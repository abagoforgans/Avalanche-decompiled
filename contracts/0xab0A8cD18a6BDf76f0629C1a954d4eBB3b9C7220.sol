contract main {




// =====================  Runtime code  =====================


#
#  - wardenCall(address arg1, uint256 arg2, uint256 arg3, bytes arg4)
#
array of uint256 sub_cedb8a81;
address stor1;

function sub_cedb8a81(?) {
    return sub_cedb8a81[0 len sub_cedb8a81.length]
}

function _fallback() payable {
    revert
}

function sub_bf9bd4bd(?) {
    require calldata.size - 4 >= 224
    require ext_code.size(arg5)
    staticcall arg5.0xe6a43905 with:
            gas gas_remaining wei
           args address(arg1), arg2
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if not ext_call.return_data[12 len 20]:
        revert with 0, 'This pool does not exist'
    require ext_code.size(address(ext_call.return_data[0]))
    call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
         gas gas_remaining wei
        args arg3, arg4, address(this.address), 128, 64, address(arg6), arg7
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
}

function joeCall(address arg1, uint256 arg2, uint256 arg3, bytes arg4) {
    require calldata.size - 4 >= 128
    require arg4 <= 4294967296
    require arg4 + 36 <= calldata.size
    require arg4.length <= 4294967296 and arg4 + arg4.length + 36 <= calldata.size
    require ext_code.size(msg.sender)
    staticcall msg.sender.token0() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_code.size(msg.sender)
    staticcall msg.sender.token1() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if not arg2:
        if not arg2:
            if arg1 != this.address:
                revert with 0, '!sender'
            mem[96] = 2
            mem[128] = address(ext_call.return_data[0])
            mem[160] = address(ext_call.return_data[0])
            require arg4.length >= 64
            require ext_code.size(address(ext_call.return_data[0]))
            call address(ext_call.return_data[0]).approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args address(cd[(arg4 + 68)]), arg3
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[192] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
            mem[196] = arg3
            mem[228] = 64
            mem[260] = 2
            mem[292 len 0] = None
            require ext_code.size(address(cd[(arg4 + 36)]))
            staticcall address(cd[(arg4 + 36)]).getAmountsIn(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args arg3, Array(len=2, data=mem[292 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[192 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(return_data.size) + 192
            require return_data.size >= 32
            if not arg2:
                if not arg2:
                    if not arg2:
                        _1813 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1909 = mem[_1813 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1813 + 192])] = mem[_1813 + 224 len floor32(mem[_1813 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3221 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1909) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1909) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1909) + ceil32(return_data.size) + 260] = _3221
                        mem[(32 * _1909) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1909) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1909) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1909) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1909) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3221, Array(len=2, data=mem[(32 * _1909) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1909) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1909) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4469 = mem[(32 * _1909) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1909) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1909) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1909) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1909) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1909) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1909) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1909) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1909) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1909) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1909) + ceil32(return_data.size) + 224]
                        mem[(32 * _1909) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4469 + (32 * _1909) + ceil32(return_data.size) + 224])] = mem[_4469 + (32 * _1909) + ceil32(return_data.size) + 256 len floor32(mem[_4469 + (32 * _1909) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1909) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1909) + (2 * ceil32(return_data.size)) + 288] <= _3221:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3221
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3221 > mem[(32 * _1909) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1909) + (2 * ceil32(return_data.size)) + 288] - _3221
                    else:
                        _1815 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1910 = mem[_1815 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1815 + 192])] = mem[_1815 + 224 len floor32(mem[_1815 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3225 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1910) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1910) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1910) + ceil32(return_data.size) + 260] = _3225
                        mem[(32 * _1910) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1910) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1910) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1910) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1910) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3225, Array(len=2, data=mem[(32 * _1910) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1910) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1910) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4471 = mem[(32 * _1910) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1910) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1910) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1910) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1910) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1910) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1910) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1910) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1910) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1910) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1910) + ceil32(return_data.size) + 224]
                        mem[(32 * _1910) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4471 + (32 * _1910) + ceil32(return_data.size) + 224])] = mem[_4471 + (32 * _1910) + ceil32(return_data.size) + 256 len floor32(mem[_4471 + (32 * _1910) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1910) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1910) + (2 * ceil32(return_data.size)) + 288] <= _3225:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3225
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3225 > mem[(32 * _1910) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1910) + (2 * ceil32(return_data.size)) + 288] - _3225
                else:
                    if not arg2:
                        _1817 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1911 = mem[_1817 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1817 + 192])] = mem[_1817 + 224 len floor32(mem[_1817 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3229 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1911) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1911) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1911) + ceil32(return_data.size) + 260] = _3229
                        mem[(32 * _1911) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1911) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1911) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1911) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1911) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3229, Array(len=2, data=mem[(32 * _1911) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1911) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1911) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4473 = mem[(32 * _1911) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1911) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1911) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1911) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1911) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1911) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1911) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1911) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1911) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1911) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1911) + ceil32(return_data.size) + 224]
                        mem[(32 * _1911) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4473 + (32 * _1911) + ceil32(return_data.size) + 224])] = mem[_4473 + (32 * _1911) + ceil32(return_data.size) + 256 len floor32(mem[_4473 + (32 * _1911) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1911) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1911) + (2 * ceil32(return_data.size)) + 288] <= _3229:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3229
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3229 > mem[(32 * _1911) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1911) + (2 * ceil32(return_data.size)) + 288] - _3229
                    else:
                        _1819 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1912 = mem[_1819 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1819 + 192])] = mem[_1819 + 224 len floor32(mem[_1819 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3233 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1912) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1912) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1912) + ceil32(return_data.size) + 260] = _3233
                        mem[(32 * _1912) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1912) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1912) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1912) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1912) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3233, Array(len=2, data=mem[(32 * _1912) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1912) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1912) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4475 = mem[(32 * _1912) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1912) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1912) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1912) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1912) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1912) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1912) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1912) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1912) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1912) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1912) + ceil32(return_data.size) + 224]
                        mem[(32 * _1912) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4475 + (32 * _1912) + ceil32(return_data.size) + 224])] = mem[_4475 + (32 * _1912) + ceil32(return_data.size) + 256 len floor32(mem[_4475 + (32 * _1912) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1912) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1912) + (2 * ceil32(return_data.size)) + 288] <= _3233:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3233
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3233 > mem[(32 * _1912) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1912) + (2 * ceil32(return_data.size)) + 288] - _3233
            else:
                if not arg2:
                    if not arg2:
                        _1821 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1913 = mem[_1821 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1821 + 192])] = mem[_1821 + 224 len floor32(mem[_1821 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3237 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1913) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1913) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1913) + ceil32(return_data.size) + 260] = _3237
                        mem[(32 * _1913) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1913) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1913) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1913) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1913) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3237, Array(len=2, data=mem[(32 * _1913) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1913) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1913) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4477 = mem[(32 * _1913) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1913) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1913) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1913) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1913) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1913) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1913) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1913) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1913) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1913) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1913) + ceil32(return_data.size) + 224]
                        mem[(32 * _1913) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4477 + (32 * _1913) + ceil32(return_data.size) + 224])] = mem[_4477 + (32 * _1913) + ceil32(return_data.size) + 256 len floor32(mem[_4477 + (32 * _1913) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1913) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1913) + (2 * ceil32(return_data.size)) + 288] <= _3237:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3237
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3237 > mem[(32 * _1913) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1913) + (2 * ceil32(return_data.size)) + 288] - _3237
                    else:
                        _1823 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1914 = mem[_1823 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1823 + 192])] = mem[_1823 + 224 len floor32(mem[_1823 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3241 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1914) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1914) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1914) + ceil32(return_data.size) + 260] = _3241
                        mem[(32 * _1914) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1914) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1914) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1914) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1914) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3241, Array(len=2, data=mem[(32 * _1914) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1914) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1914) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4479 = mem[(32 * _1914) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1914) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1914) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1914) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1914) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1914) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1914) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1914) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1914) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1914) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1914) + ceil32(return_data.size) + 224]
                        mem[(32 * _1914) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4479 + (32 * _1914) + ceil32(return_data.size) + 224])] = mem[_4479 + (32 * _1914) + ceil32(return_data.size) + 256 len floor32(mem[_4479 + (32 * _1914) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1914) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1914) + (2 * ceil32(return_data.size)) + 288] <= _3241:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3241
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3241 > mem[(32 * _1914) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1914) + (2 * ceil32(return_data.size)) + 288] - _3241
                else:
                    if not arg2:
                        _1825 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1915 = mem[_1825 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1825 + 192])] = mem[_1825 + 224 len floor32(mem[_1825 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3245 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1915) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1915) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1915) + ceil32(return_data.size) + 260] = _3245
                        mem[(32 * _1915) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1915) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1915) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1915) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1915) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3245, Array(len=2, data=mem[(32 * _1915) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1915) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1915) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4481 = mem[(32 * _1915) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1915) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1915) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1915) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1915) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1915) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1915) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1915) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1915) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1915) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1915) + ceil32(return_data.size) + 224]
                        mem[(32 * _1915) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4481 + (32 * _1915) + ceil32(return_data.size) + 224])] = mem[_4481 + (32 * _1915) + ceil32(return_data.size) + 256 len floor32(mem[_4481 + (32 * _1915) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1915) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1915) + (2 * ceil32(return_data.size)) + 288] <= _3245:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3245
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3245 > mem[(32 * _1915) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1915) + (2 * ceil32(return_data.size)) + 288] - _3245
                    else:
                        _1827 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1916 = mem[_1827 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1827 + 192])] = mem[_1827 + 224 len floor32(mem[_1827 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3249 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1916) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1916) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1916) + ceil32(return_data.size) + 260] = _3249
                        mem[(32 * _1916) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1916) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1916) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1916) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1916) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3249, Array(len=2, data=mem[(32 * _1916) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1916) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1916) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4483 = mem[(32 * _1916) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1916) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1916) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1916) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1916) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1916) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1916) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1916) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1916) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1916) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1916) + ceil32(return_data.size) + 224]
                        mem[(32 * _1916) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4483 + (32 * _1916) + ceil32(return_data.size) + 224])] = mem[_4483 + (32 * _1916) + ceil32(return_data.size) + 256 len floor32(mem[_4483 + (32 * _1916) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1916) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1916) + (2 * ceil32(return_data.size)) + 288] <= _3249:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3249
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3249 > mem[(32 * _1916) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1916) + (2 * ceil32(return_data.size)) + 288] - _3249
        else:
            require not arg3
            if arg1 != this.address:
                revert with 0, '!sender'
            mem[96] = 2
            mem[128] = address(ext_call.return_data[0])
            mem[160] = address(ext_call.return_data[0])
            require arg4.length >= 64
            require ext_code.size(address(ext_call.return_data[0]))
            call address(ext_call.return_data[0]).approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args address(cd[(arg4 + 68)]), arg3
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[192] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
            mem[196] = arg3
            mem[228] = 64
            mem[260] = 2
            mem[292 len 0] = None
            require ext_code.size(address(cd[(arg4 + 36)]))
            staticcall address(cd[(arg4 + 36)]).getAmountsIn(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args arg3, Array(len=2, data=mem[292 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[192 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(return_data.size) + 192
            require return_data.size >= 32
            if not arg2:
                if not arg2:
                    if not arg2:
                        _1829 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1917 = mem[_1829 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1829 + 192])] = mem[_1829 + 224 len floor32(mem[_1829 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3253 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1917) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1917) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1917) + ceil32(return_data.size) + 260] = _3253
                        mem[(32 * _1917) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1917) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1917) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1917) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1917) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3253, Array(len=2, data=mem[(32 * _1917) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1917) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1917) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4485 = mem[(32 * _1917) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1917) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1917) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1917) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1917) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1917) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1917) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1917) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1917) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1917) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1917) + ceil32(return_data.size) + 224]
                        mem[(32 * _1917) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4485 + (32 * _1917) + ceil32(return_data.size) + 224])] = mem[_4485 + (32 * _1917) + ceil32(return_data.size) + 256 len floor32(mem[_4485 + (32 * _1917) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1917) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1917) + (2 * ceil32(return_data.size)) + 288] <= _3253:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3253
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3253 > mem[(32 * _1917) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1917) + (2 * ceil32(return_data.size)) + 288] - _3253
                    else:
                        _1831 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1918 = mem[_1831 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1831 + 192])] = mem[_1831 + 224 len floor32(mem[_1831 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3257 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1918) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1918) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1918) + ceil32(return_data.size) + 260] = _3257
                        mem[(32 * _1918) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1918) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1918) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1918) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1918) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3257, Array(len=2, data=mem[(32 * _1918) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1918) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1918) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4487 = mem[(32 * _1918) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1918) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1918) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1918) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1918) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1918) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1918) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1918) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1918) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1918) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1918) + ceil32(return_data.size) + 224]
                        mem[(32 * _1918) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4487 + (32 * _1918) + ceil32(return_data.size) + 224])] = mem[_4487 + (32 * _1918) + ceil32(return_data.size) + 256 len floor32(mem[_4487 + (32 * _1918) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1918) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1918) + (2 * ceil32(return_data.size)) + 288] <= _3257:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3257
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3257 > mem[(32 * _1918) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1918) + (2 * ceil32(return_data.size)) + 288] - _3257
                else:
                    if not arg2:
                        _1833 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1919 = mem[_1833 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1833 + 192])] = mem[_1833 + 224 len floor32(mem[_1833 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3261 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1919) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1919) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1919) + ceil32(return_data.size) + 260] = _3261
                        mem[(32 * _1919) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1919) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1919) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1919) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1919) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3261, Array(len=2, data=mem[(32 * _1919) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1919) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1919) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4489 = mem[(32 * _1919) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1919) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1919) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1919) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1919) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1919) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1919) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1919) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1919) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1919) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1919) + ceil32(return_data.size) + 224]
                        mem[(32 * _1919) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4489 + (32 * _1919) + ceil32(return_data.size) + 224])] = mem[_4489 + (32 * _1919) + ceil32(return_data.size) + 256 len floor32(mem[_4489 + (32 * _1919) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1919) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1919) + (2 * ceil32(return_data.size)) + 288] <= _3261:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3261
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3261 > mem[(32 * _1919) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1919) + (2 * ceil32(return_data.size)) + 288] - _3261
                    else:
                        _1835 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1920 = mem[_1835 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1835 + 192])] = mem[_1835 + 224 len floor32(mem[_1835 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3265 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1920) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1920) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1920) + ceil32(return_data.size) + 260] = _3265
                        mem[(32 * _1920) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1920) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1920) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1920) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1920) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3265, Array(len=2, data=mem[(32 * _1920) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1920) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1920) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4491 = mem[(32 * _1920) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1920) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1920) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1920) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1920) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1920) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1920) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1920) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1920) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1920) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1920) + ceil32(return_data.size) + 224]
                        mem[(32 * _1920) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4491 + (32 * _1920) + ceil32(return_data.size) + 224])] = mem[_4491 + (32 * _1920) + ceil32(return_data.size) + 256 len floor32(mem[_4491 + (32 * _1920) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1920) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1920) + (2 * ceil32(return_data.size)) + 288] <= _3265:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3265
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3265 > mem[(32 * _1920) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1920) + (2 * ceil32(return_data.size)) + 288] - _3265
            else:
                if not arg2:
                    if not arg2:
                        _1837 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1921 = mem[_1837 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1837 + 192])] = mem[_1837 + 224 len floor32(mem[_1837 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3269 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1921) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1921) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1921) + ceil32(return_data.size) + 260] = _3269
                        mem[(32 * _1921) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1921) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1921) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1921) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1921) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3269, Array(len=2, data=mem[(32 * _1921) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1921) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1921) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4493 = mem[(32 * _1921) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1921) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1921) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1921) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1921) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1921) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1921) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1921) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1921) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1921) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1921) + ceil32(return_data.size) + 224]
                        mem[(32 * _1921) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4493 + (32 * _1921) + ceil32(return_data.size) + 224])] = mem[_4493 + (32 * _1921) + ceil32(return_data.size) + 256 len floor32(mem[_4493 + (32 * _1921) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1921) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1921) + (2 * ceil32(return_data.size)) + 288] <= _3269:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3269
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3269 > mem[(32 * _1921) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1921) + (2 * ceil32(return_data.size)) + 288] - _3269
                    else:
                        _1839 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1922 = mem[_1839 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1839 + 192])] = mem[_1839 + 224 len floor32(mem[_1839 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3273 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1922) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1922) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1922) + ceil32(return_data.size) + 260] = _3273
                        mem[(32 * _1922) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1922) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1922) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1922) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1922) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3273, Array(len=2, data=mem[(32 * _1922) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1922) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1922) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4495 = mem[(32 * _1922) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1922) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1922) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1922) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1922) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1922) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1922) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1922) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1922) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1922) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1922) + ceil32(return_data.size) + 224]
                        mem[(32 * _1922) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4495 + (32 * _1922) + ceil32(return_data.size) + 224])] = mem[_4495 + (32 * _1922) + ceil32(return_data.size) + 256 len floor32(mem[_4495 + (32 * _1922) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1922) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1922) + (2 * ceil32(return_data.size)) + 288] <= _3273:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3273
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3273 > mem[(32 * _1922) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1922) + (2 * ceil32(return_data.size)) + 288] - _3273
                else:
                    if not arg2:
                        _1841 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1923 = mem[_1841 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1841 + 192])] = mem[_1841 + 224 len floor32(mem[_1841 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3277 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1923) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1923) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1923) + ceil32(return_data.size) + 260] = _3277
                        mem[(32 * _1923) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1923) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1923) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1923) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1923) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3277, Array(len=2, data=mem[(32 * _1923) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1923) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1923) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4497 = mem[(32 * _1923) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1923) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1923) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1923) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1923) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1923) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1923) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1923) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1923) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1923) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1923) + ceil32(return_data.size) + 224]
                        mem[(32 * _1923) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4497 + (32 * _1923) + ceil32(return_data.size) + 224])] = mem[_4497 + (32 * _1923) + ceil32(return_data.size) + 256 len floor32(mem[_4497 + (32 * _1923) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1923) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1923) + (2 * ceil32(return_data.size)) + 288] <= _3277:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3277
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3277 > mem[(32 * _1923) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1923) + (2 * ceil32(return_data.size)) + 288] - _3277
                    else:
                        _1843 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1924 = mem[_1843 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1843 + 192])] = mem[_1843 + 224 len floor32(mem[_1843 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3281 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1924) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1924) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1924) + ceil32(return_data.size) + 260] = _3281
                        mem[(32 * _1924) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1924) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1924) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1924) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1924) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3281, Array(len=2, data=mem[(32 * _1924) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1924) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1924) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4499 = mem[(32 * _1924) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1924) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1924) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1924) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1924) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1924) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1924) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1924) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1924) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1924) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1924) + ceil32(return_data.size) + 224]
                        mem[(32 * _1924) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4499 + (32 * _1924) + ceil32(return_data.size) + 224])] = mem[_4499 + (32 * _1924) + ceil32(return_data.size) + 256 len floor32(mem[_4499 + (32 * _1924) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1924) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1924) + (2 * ceil32(return_data.size)) + 288] <= _3281:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3281
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3281 > mem[(32 * _1924) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1924) + (2 * ceil32(return_data.size)) + 288] - _3281
    else:
        if not arg2:
            if arg1 != this.address:
                revert with 0, '!sender'
            mem[96] = 2
            mem[128] = address(ext_call.return_data[0])
            mem[160] = address(ext_call.return_data[0])
            require arg4.length >= 64
            require ext_code.size(address(ext_call.return_data[0]))
            call address(ext_call.return_data[0]).approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args address(cd[(arg4 + 68)]), arg2
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[192] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
            mem[196] = arg2
            mem[228] = 64
            mem[260] = 2
            mem[292 len 0] = None
            require ext_code.size(address(cd[(arg4 + 36)]))
            staticcall address(cd[(arg4 + 36)]).getAmountsIn(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args arg2, Array(len=2, data=mem[292 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[192 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(return_data.size) + 192
            require return_data.size >= 32
            if not arg2:
                if not arg2:
                    if not arg2:
                        _1845 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1925 = mem[_1845 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1845 + 192])] = mem[_1845 + 224 len floor32(mem[_1845 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3285 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1925) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1925) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1925) + ceil32(return_data.size) + 260] = _3285
                        mem[(32 * _1925) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1925) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1925) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1925) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1925) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3285, Array(len=2, data=mem[(32 * _1925) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1925) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1925) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4501 = mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1925) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1925) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1925) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1925) + ceil32(return_data.size) + 224]
                        mem[(32 * _1925) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4501 + (32 * _1925) + ceil32(return_data.size) + 224])] = mem[_4501 + (32 * _1925) + ceil32(return_data.size) + 256 len floor32(mem[_4501 + (32 * _1925) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1925) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1925) + (2 * ceil32(return_data.size)) + 288] <= _3285:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3285
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3285 > mem[(32 * _1925) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1925) + (2 * ceil32(return_data.size)) + 288] - _3285
                    else:
                        _1847 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1926 = mem[_1847 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1847 + 192])] = mem[_1847 + 224 len floor32(mem[_1847 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3289 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1926) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1926) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1926) + ceil32(return_data.size) + 260] = _3289
                        mem[(32 * _1926) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1926) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1926) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1926) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1926) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3289, Array(len=2, data=mem[(32 * _1926) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1926) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1926) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4503 = mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1926) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1926) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1926) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1926) + ceil32(return_data.size) + 224]
                        mem[(32 * _1926) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4503 + (32 * _1926) + ceil32(return_data.size) + 224])] = mem[_4503 + (32 * _1926) + ceil32(return_data.size) + 256 len floor32(mem[_4503 + (32 * _1926) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1926) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1926) + (2 * ceil32(return_data.size)) + 288] <= _3289:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3289
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3289 > mem[(32 * _1926) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1926) + (2 * ceil32(return_data.size)) + 288] - _3289
                else:
                    if not arg2:
                        _1849 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1927 = mem[_1849 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1849 + 192])] = mem[_1849 + 224 len floor32(mem[_1849 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3293 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1927) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1927) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1927) + ceil32(return_data.size) + 260] = _3293
                        mem[(32 * _1927) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1927) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1927) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1927) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1927) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3293, Array(len=2, data=mem[(32 * _1927) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1927) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1927) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4505 = mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1927) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1927) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1927) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1927) + ceil32(return_data.size) + 224]
                        mem[(32 * _1927) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4505 + (32 * _1927) + ceil32(return_data.size) + 224])] = mem[_4505 + (32 * _1927) + ceil32(return_data.size) + 256 len floor32(mem[_4505 + (32 * _1927) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1927) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1927) + (2 * ceil32(return_data.size)) + 288] <= _3293:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3293
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3293 > mem[(32 * _1927) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1927) + (2 * ceil32(return_data.size)) + 288] - _3293
                    else:
                        _1851 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1928 = mem[_1851 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1851 + 192])] = mem[_1851 + 224 len floor32(mem[_1851 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3297 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1928) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1928) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1928) + ceil32(return_data.size) + 260] = _3297
                        mem[(32 * _1928) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1928) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1928) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1928) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1928) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3297, Array(len=2, data=mem[(32 * _1928) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1928) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1928) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4507 = mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1928) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1928) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1928) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1928) + ceil32(return_data.size) + 224]
                        mem[(32 * _1928) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4507 + (32 * _1928) + ceil32(return_data.size) + 224])] = mem[_4507 + (32 * _1928) + ceil32(return_data.size) + 256 len floor32(mem[_4507 + (32 * _1928) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1928) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1928) + (2 * ceil32(return_data.size)) + 288] <= _3297:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3297
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3297 > mem[(32 * _1928) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1928) + (2 * ceil32(return_data.size)) + 288] - _3297
            else:
                if not arg2:
                    if not arg2:
                        _1853 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1929 = mem[_1853 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1853 + 192])] = mem[_1853 + 224 len floor32(mem[_1853 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3301 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1929) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1929) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1929) + ceil32(return_data.size) + 260] = _3301
                        mem[(32 * _1929) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1929) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1929) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1929) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1929) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3301, Array(len=2, data=mem[(32 * _1929) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1929) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1929) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4509 = mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1929) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1929) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1929) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1929) + ceil32(return_data.size) + 224]
                        mem[(32 * _1929) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4509 + (32 * _1929) + ceil32(return_data.size) + 224])] = mem[_4509 + (32 * _1929) + ceil32(return_data.size) + 256 len floor32(mem[_4509 + (32 * _1929) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1929) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1929) + (2 * ceil32(return_data.size)) + 288] <= _3301:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3301
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3301 > mem[(32 * _1929) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1929) + (2 * ceil32(return_data.size)) + 288] - _3301
                    else:
                        _1855 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1930 = mem[_1855 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1855 + 192])] = mem[_1855 + 224 len floor32(mem[_1855 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3305 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1930) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1930) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1930) + ceil32(return_data.size) + 260] = _3305
                        mem[(32 * _1930) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1930) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1930) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1930) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1930) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3305, Array(len=2, data=mem[(32 * _1930) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1930) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1930) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4511 = mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1930) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1930) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1930) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1930) + ceil32(return_data.size) + 224]
                        mem[(32 * _1930) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4511 + (32 * _1930) + ceil32(return_data.size) + 224])] = mem[_4511 + (32 * _1930) + ceil32(return_data.size) + 256 len floor32(mem[_4511 + (32 * _1930) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1930) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1930) + (2 * ceil32(return_data.size)) + 288] <= _3305:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3305
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3305 > mem[(32 * _1930) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1930) + (2 * ceil32(return_data.size)) + 288] - _3305
                else:
                    if not arg2:
                        _1857 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1931 = mem[_1857 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1857 + 192])] = mem[_1857 + 224 len floor32(mem[_1857 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3309 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1931) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1931) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1931) + ceil32(return_data.size) + 260] = _3309
                        mem[(32 * _1931) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1931) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1931) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1931) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1931) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3309, Array(len=2, data=mem[(32 * _1931) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1931) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1931) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4513 = mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1931) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1931) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1931) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1931) + ceil32(return_data.size) + 224]
                        mem[(32 * _1931) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4513 + (32 * _1931) + ceil32(return_data.size) + 224])] = mem[_4513 + (32 * _1931) + ceil32(return_data.size) + 256 len floor32(mem[_4513 + (32 * _1931) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1931) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1931) + (2 * ceil32(return_data.size)) + 288] <= _3309:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3309
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3309 > mem[(32 * _1931) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1931) + (2 * ceil32(return_data.size)) + 288] - _3309
                    else:
                        _1859 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1932 = mem[_1859 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1859 + 192])] = mem[_1859 + 224 len floor32(mem[_1859 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3313 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1932) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1932) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1932) + ceil32(return_data.size) + 260] = _3313
                        mem[(32 * _1932) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1932) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1932) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1932) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1932) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3313, Array(len=2, data=mem[(32 * _1932) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1932) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1932) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4515 = mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1932) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1932) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1932) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1932) + ceil32(return_data.size) + 224]
                        mem[(32 * _1932) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4515 + (32 * _1932) + ceil32(return_data.size) + 224])] = mem[_4515 + (32 * _1932) + ceil32(return_data.size) + 256 len floor32(mem[_4515 + (32 * _1932) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1932) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1932) + (2 * ceil32(return_data.size)) + 288] <= _3313:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3313
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3313 > mem[(32 * _1932) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1932) + (2 * ceil32(return_data.size)) + 288] - _3313
        else:
            require not arg3
            if arg1 != this.address:
                revert with 0, '!sender'
            mem[96] = 2
            mem[128] = address(ext_call.return_data[0])
            mem[160] = address(ext_call.return_data[0])
            require arg4.length >= 64
            require ext_code.size(address(ext_call.return_data[0]))
            call address(ext_call.return_data[0]).approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args address(cd[(arg4 + 68)]), arg2
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[192] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
            mem[196] = arg2
            mem[228] = 64
            mem[260] = 2
            mem[292 len 0] = None
            require ext_code.size(address(cd[(arg4 + 36)]))
            staticcall address(cd[(arg4 + 36)]).getAmountsIn(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args arg2, Array(len=2, data=mem[292 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[192 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(return_data.size) + 192
            require return_data.size >= 32
            if not arg2:
                if not arg2:
                    if not arg2:
                        _1861 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1933 = mem[_1861 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1861 + 192])] = mem[_1861 + 224 len floor32(mem[_1861 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3317 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1933) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1933) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1933) + ceil32(return_data.size) + 260] = _3317
                        mem[(32 * _1933) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1933) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1933) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1933) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1933) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3317, Array(len=2, data=mem[(32 * _1933) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1933) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1933) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4517 = mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1933) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1933) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1933) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1933) + ceil32(return_data.size) + 224]
                        mem[(32 * _1933) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4517 + (32 * _1933) + ceil32(return_data.size) + 224])] = mem[_4517 + (32 * _1933) + ceil32(return_data.size) + 256 len floor32(mem[_4517 + (32 * _1933) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1933) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1933) + (2 * ceil32(return_data.size)) + 288] <= _3317:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3317
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3317 > mem[(32 * _1933) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1933) + (2 * ceil32(return_data.size)) + 288] - _3317
                    else:
                        _1863 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1934 = mem[_1863 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1863 + 192])] = mem[_1863 + 224 len floor32(mem[_1863 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3321 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1934) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1934) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1934) + ceil32(return_data.size) + 260] = _3321
                        mem[(32 * _1934) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1934) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1934) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1934) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1934) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3321, Array(len=2, data=mem[(32 * _1934) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1934) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1934) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4519 = mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1934) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1934) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1934) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1934) + ceil32(return_data.size) + 224]
                        mem[(32 * _1934) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4519 + (32 * _1934) + ceil32(return_data.size) + 224])] = mem[_4519 + (32 * _1934) + ceil32(return_data.size) + 256 len floor32(mem[_4519 + (32 * _1934) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1934) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1934) + (2 * ceil32(return_data.size)) + 288] <= _3321:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3321
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3321 > mem[(32 * _1934) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1934) + (2 * ceil32(return_data.size)) + 288] - _3321
                else:
                    if not arg2:
                        _1865 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1935 = mem[_1865 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1865 + 192])] = mem[_1865 + 224 len floor32(mem[_1865 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3325 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1935) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1935) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1935) + ceil32(return_data.size) + 260] = _3325
                        mem[(32 * _1935) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1935) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1935) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1935) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1935) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3325, Array(len=2, data=mem[(32 * _1935) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1935) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1935) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4521 = mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1935) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1935) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1935) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1935) + ceil32(return_data.size) + 224]
                        mem[(32 * _1935) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4521 + (32 * _1935) + ceil32(return_data.size) + 224])] = mem[_4521 + (32 * _1935) + ceil32(return_data.size) + 256 len floor32(mem[_4521 + (32 * _1935) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1935) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1935) + (2 * ceil32(return_data.size)) + 288] <= _3325:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3325
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3325 > mem[(32 * _1935) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1935) + (2 * ceil32(return_data.size)) + 288] - _3325
                    else:
                        _1867 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1936 = mem[_1867 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1867 + 192])] = mem[_1867 + 224 len floor32(mem[_1867 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3329 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1936) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1936) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1936) + ceil32(return_data.size) + 260] = _3329
                        mem[(32 * _1936) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1936) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1936) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1936) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1936) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3329, Array(len=2, data=mem[(32 * _1936) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1936) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1936) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4523 = mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1936) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1936) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1936) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1936) + ceil32(return_data.size) + 224]
                        mem[(32 * _1936) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4523 + (32 * _1936) + ceil32(return_data.size) + 224])] = mem[_4523 + (32 * _1936) + ceil32(return_data.size) + 256 len floor32(mem[_4523 + (32 * _1936) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1936) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1936) + (2 * ceil32(return_data.size)) + 288] <= _3329:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3329
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3329 > mem[(32 * _1936) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1936) + (2 * ceil32(return_data.size)) + 288] - _3329
            else:
                if not arg2:
                    if not arg2:
                        _1869 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1937 = mem[_1869 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1869 + 192])] = mem[_1869 + 224 len floor32(mem[_1869 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3333 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1937) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1937) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1937) + ceil32(return_data.size) + 260] = _3333
                        mem[(32 * _1937) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1937) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1937) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1937) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1937) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3333, Array(len=2, data=mem[(32 * _1937) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1937) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1937) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4525 = mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1937) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1937) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1937) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1937) + ceil32(return_data.size) + 224]
                        mem[(32 * _1937) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4525 + (32 * _1937) + ceil32(return_data.size) + 224])] = mem[_4525 + (32 * _1937) + ceil32(return_data.size) + 256 len floor32(mem[_4525 + (32 * _1937) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1937) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1937) + (2 * ceil32(return_data.size)) + 288] <= _3333:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3333
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3333 > mem[(32 * _1937) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1937) + (2 * ceil32(return_data.size)) + 288] - _3333
                    else:
                        _1871 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1938 = mem[_1871 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1871 + 192])] = mem[_1871 + 224 len floor32(mem[_1871 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3337 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1938) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1938) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1938) + ceil32(return_data.size) + 260] = _3337
                        mem[(32 * _1938) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1938) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1938) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1938) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1938) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3337, Array(len=2, data=mem[(32 * _1938) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1938) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1938) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4527 = mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1938) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1938) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1938) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1938) + ceil32(return_data.size) + 224]
                        mem[(32 * _1938) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4527 + (32 * _1938) + ceil32(return_data.size) + 224])] = mem[_4527 + (32 * _1938) + ceil32(return_data.size) + 256 len floor32(mem[_4527 + (32 * _1938) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1938) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1938) + (2 * ceil32(return_data.size)) + 288] <= _3337:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3337
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3337 > mem[(32 * _1938) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1938) + (2 * ceil32(return_data.size)) + 288] - _3337
                else:
                    if not arg2:
                        _1873 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1939 = mem[_1873 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1873 + 192])] = mem[_1873 + 224 len floor32(mem[_1873 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3341 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1939) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1939) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1939) + ceil32(return_data.size) + 260] = _3341
                        mem[(32 * _1939) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1939) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1939) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1939) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1939) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3341, Array(len=2, data=mem[(32 * _1939) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1939) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1939) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4529 = mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1939) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1939) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1939) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1939) + ceil32(return_data.size) + 224]
                        mem[(32 * _1939) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4529 + (32 * _1939) + ceil32(return_data.size) + 224])] = mem[_4529 + (32 * _1939) + ceil32(return_data.size) + 256 len floor32(mem[_4529 + (32 * _1939) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1939) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1939) + (2 * ceil32(return_data.size)) + 288] <= _3341:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3341
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3341 > mem[(32 * _1939) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1939) + (2 * ceil32(return_data.size)) + 288] - _3341
                    else:
                        _1875 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1940 = mem[_1875 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1875 + 192])] = mem[_1875 + 224 len floor32(mem[_1875 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3345 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1940) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1940) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1940) + ceil32(return_data.size) + 260] = _3345
                        mem[(32 * _1940) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1940) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1940) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1940) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1940) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3345, Array(len=2, data=mem[(32 * _1940) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1940) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1940) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4531 = mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1940) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1940) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1940) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1940) + ceil32(return_data.size) + 224]
                        mem[(32 * _1940) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4531 + (32 * _1940) + ceil32(return_data.size) + 224])] = mem[_4531 + (32 * _1940) + ceil32(return_data.size) + 256 len floor32(mem[_4531 + (32 * _1940) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1940) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1940) + (2 * ceil32(return_data.size)) + 288] <= _3345:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3345
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3345 > mem[(32 * _1940) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1940) + (2 * ceil32(return_data.size)) + 288] - _3345
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
}

function cafeCall(address arg1, uint256 arg2, uint256 arg3, bytes arg4) {
    require calldata.size - 4 >= 128
    require arg4 <= 4294967296
    require arg4 + 36 <= calldata.size
    require arg4.length <= 4294967296 and arg4 + arg4.length + 36 <= calldata.size
    require ext_code.size(msg.sender)
    staticcall msg.sender.token0() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_code.size(msg.sender)
    staticcall msg.sender.token1() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if not arg2:
        if not arg2:
            if arg1 != this.address:
                revert with 0, '!sender'
            mem[96] = 2
            mem[128] = address(ext_call.return_data[0])
            mem[160] = address(ext_call.return_data[0])
            require arg4.length >= 64
            require ext_code.size(address(ext_call.return_data[0]))
            call address(ext_call.return_data[0]).approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args address(cd[(arg4 + 68)]), arg3
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[192] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
            mem[196] = arg3
            mem[228] = 64
            mem[260] = 2
            mem[292 len 0] = None
            require ext_code.size(address(cd[(arg4 + 36)]))
            staticcall address(cd[(arg4 + 36)]).getAmountsIn(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args arg3, Array(len=2, data=mem[292 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[192 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(return_data.size) + 192
            require return_data.size >= 32
            if not arg2:
                if not arg2:
                    if not arg2:
                        _1813 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1909 = mem[_1813 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1813 + 192])] = mem[_1813 + 224 len floor32(mem[_1813 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3221 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1909) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1909) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1909) + ceil32(return_data.size) + 260] = _3221
                        mem[(32 * _1909) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1909) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1909) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1909) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1909) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3221, Array(len=2, data=mem[(32 * _1909) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1909) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1909) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4469 = mem[(32 * _1909) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1909) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1909) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1909) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1909) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1909) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1909) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1909) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1909) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1909) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1909) + ceil32(return_data.size) + 224]
                        mem[(32 * _1909) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4469 + (32 * _1909) + ceil32(return_data.size) + 224])] = mem[_4469 + (32 * _1909) + ceil32(return_data.size) + 256 len floor32(mem[_4469 + (32 * _1909) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1909) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1909) + (2 * ceil32(return_data.size)) + 288] <= _3221:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3221
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3221 > mem[(32 * _1909) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1909) + (2 * ceil32(return_data.size)) + 288] - _3221
                    else:
                        _1815 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1910 = mem[_1815 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1815 + 192])] = mem[_1815 + 224 len floor32(mem[_1815 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3225 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1910) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1910) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1910) + ceil32(return_data.size) + 260] = _3225
                        mem[(32 * _1910) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1910) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1910) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1910) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1910) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3225, Array(len=2, data=mem[(32 * _1910) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1910) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1910) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4471 = mem[(32 * _1910) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1910) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1910) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1910) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1910) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1910) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1910) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1910) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1910) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1910) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1910) + ceil32(return_data.size) + 224]
                        mem[(32 * _1910) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4471 + (32 * _1910) + ceil32(return_data.size) + 224])] = mem[_4471 + (32 * _1910) + ceil32(return_data.size) + 256 len floor32(mem[_4471 + (32 * _1910) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1910) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1910) + (2 * ceil32(return_data.size)) + 288] <= _3225:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3225
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3225 > mem[(32 * _1910) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1910) + (2 * ceil32(return_data.size)) + 288] - _3225
                else:
                    if not arg2:
                        _1817 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1911 = mem[_1817 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1817 + 192])] = mem[_1817 + 224 len floor32(mem[_1817 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3229 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1911) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1911) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1911) + ceil32(return_data.size) + 260] = _3229
                        mem[(32 * _1911) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1911) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1911) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1911) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1911) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3229, Array(len=2, data=mem[(32 * _1911) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1911) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1911) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4473 = mem[(32 * _1911) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1911) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1911) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1911) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1911) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1911) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1911) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1911) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1911) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1911) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1911) + ceil32(return_data.size) + 224]
                        mem[(32 * _1911) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4473 + (32 * _1911) + ceil32(return_data.size) + 224])] = mem[_4473 + (32 * _1911) + ceil32(return_data.size) + 256 len floor32(mem[_4473 + (32 * _1911) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1911) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1911) + (2 * ceil32(return_data.size)) + 288] <= _3229:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3229
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3229 > mem[(32 * _1911) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1911) + (2 * ceil32(return_data.size)) + 288] - _3229
                    else:
                        _1819 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1912 = mem[_1819 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1819 + 192])] = mem[_1819 + 224 len floor32(mem[_1819 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3233 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1912) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1912) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1912) + ceil32(return_data.size) + 260] = _3233
                        mem[(32 * _1912) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1912) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1912) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1912) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1912) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3233, Array(len=2, data=mem[(32 * _1912) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1912) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1912) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4475 = mem[(32 * _1912) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1912) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1912) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1912) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1912) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1912) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1912) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1912) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1912) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1912) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1912) + ceil32(return_data.size) + 224]
                        mem[(32 * _1912) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4475 + (32 * _1912) + ceil32(return_data.size) + 224])] = mem[_4475 + (32 * _1912) + ceil32(return_data.size) + 256 len floor32(mem[_4475 + (32 * _1912) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1912) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1912) + (2 * ceil32(return_data.size)) + 288] <= _3233:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3233
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3233 > mem[(32 * _1912) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1912) + (2 * ceil32(return_data.size)) + 288] - _3233
            else:
                if not arg2:
                    if not arg2:
                        _1821 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1913 = mem[_1821 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1821 + 192])] = mem[_1821 + 224 len floor32(mem[_1821 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3237 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1913) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1913) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1913) + ceil32(return_data.size) + 260] = _3237
                        mem[(32 * _1913) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1913) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1913) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1913) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1913) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3237, Array(len=2, data=mem[(32 * _1913) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1913) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1913) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4477 = mem[(32 * _1913) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1913) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1913) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1913) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1913) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1913) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1913) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1913) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1913) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1913) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1913) + ceil32(return_data.size) + 224]
                        mem[(32 * _1913) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4477 + (32 * _1913) + ceil32(return_data.size) + 224])] = mem[_4477 + (32 * _1913) + ceil32(return_data.size) + 256 len floor32(mem[_4477 + (32 * _1913) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1913) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1913) + (2 * ceil32(return_data.size)) + 288] <= _3237:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3237
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3237 > mem[(32 * _1913) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1913) + (2 * ceil32(return_data.size)) + 288] - _3237
                    else:
                        _1823 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1914 = mem[_1823 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1823 + 192])] = mem[_1823 + 224 len floor32(mem[_1823 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3241 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1914) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1914) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1914) + ceil32(return_data.size) + 260] = _3241
                        mem[(32 * _1914) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1914) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1914) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1914) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1914) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3241, Array(len=2, data=mem[(32 * _1914) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1914) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1914) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4479 = mem[(32 * _1914) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1914) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1914) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1914) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1914) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1914) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1914) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1914) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1914) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1914) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1914) + ceil32(return_data.size) + 224]
                        mem[(32 * _1914) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4479 + (32 * _1914) + ceil32(return_data.size) + 224])] = mem[_4479 + (32 * _1914) + ceil32(return_data.size) + 256 len floor32(mem[_4479 + (32 * _1914) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1914) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1914) + (2 * ceil32(return_data.size)) + 288] <= _3241:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3241
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3241 > mem[(32 * _1914) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1914) + (2 * ceil32(return_data.size)) + 288] - _3241
                else:
                    if not arg2:
                        _1825 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1915 = mem[_1825 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1825 + 192])] = mem[_1825 + 224 len floor32(mem[_1825 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3245 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1915) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1915) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1915) + ceil32(return_data.size) + 260] = _3245
                        mem[(32 * _1915) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1915) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1915) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1915) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1915) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3245, Array(len=2, data=mem[(32 * _1915) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1915) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1915) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4481 = mem[(32 * _1915) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1915) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1915) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1915) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1915) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1915) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1915) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1915) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1915) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1915) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1915) + ceil32(return_data.size) + 224]
                        mem[(32 * _1915) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4481 + (32 * _1915) + ceil32(return_data.size) + 224])] = mem[_4481 + (32 * _1915) + ceil32(return_data.size) + 256 len floor32(mem[_4481 + (32 * _1915) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1915) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1915) + (2 * ceil32(return_data.size)) + 288] <= _3245:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3245
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3245 > mem[(32 * _1915) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1915) + (2 * ceil32(return_data.size)) + 288] - _3245
                    else:
                        _1827 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1916 = mem[_1827 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1827 + 192])] = mem[_1827 + 224 len floor32(mem[_1827 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3249 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1916) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1916) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1916) + ceil32(return_data.size) + 260] = _3249
                        mem[(32 * _1916) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1916) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1916) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1916) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1916) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3249, Array(len=2, data=mem[(32 * _1916) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1916) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1916) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4483 = mem[(32 * _1916) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1916) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1916) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1916) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1916) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1916) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1916) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1916) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1916) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1916) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1916) + ceil32(return_data.size) + 224]
                        mem[(32 * _1916) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4483 + (32 * _1916) + ceil32(return_data.size) + 224])] = mem[_4483 + (32 * _1916) + ceil32(return_data.size) + 256 len floor32(mem[_4483 + (32 * _1916) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1916) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1916) + (2 * ceil32(return_data.size)) + 288] <= _3249:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3249
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3249 > mem[(32 * _1916) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1916) + (2 * ceil32(return_data.size)) + 288] - _3249
        else:
            require not arg3
            if arg1 != this.address:
                revert with 0, '!sender'
            mem[96] = 2
            mem[128] = address(ext_call.return_data[0])
            mem[160] = address(ext_call.return_data[0])
            require arg4.length >= 64
            require ext_code.size(address(ext_call.return_data[0]))
            call address(ext_call.return_data[0]).approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args address(cd[(arg4 + 68)]), arg3
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[192] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
            mem[196] = arg3
            mem[228] = 64
            mem[260] = 2
            mem[292 len 0] = None
            require ext_code.size(address(cd[(arg4 + 36)]))
            staticcall address(cd[(arg4 + 36)]).getAmountsIn(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args arg3, Array(len=2, data=mem[292 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[192 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(return_data.size) + 192
            require return_data.size >= 32
            if not arg2:
                if not arg2:
                    if not arg2:
                        _1829 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1917 = mem[_1829 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1829 + 192])] = mem[_1829 + 224 len floor32(mem[_1829 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3253 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1917) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1917) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1917) + ceil32(return_data.size) + 260] = _3253
                        mem[(32 * _1917) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1917) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1917) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1917) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1917) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3253, Array(len=2, data=mem[(32 * _1917) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1917) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1917) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4485 = mem[(32 * _1917) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1917) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1917) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1917) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1917) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1917) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1917) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1917) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1917) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1917) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1917) + ceil32(return_data.size) + 224]
                        mem[(32 * _1917) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4485 + (32 * _1917) + ceil32(return_data.size) + 224])] = mem[_4485 + (32 * _1917) + ceil32(return_data.size) + 256 len floor32(mem[_4485 + (32 * _1917) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1917) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1917) + (2 * ceil32(return_data.size)) + 288] <= _3253:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3253
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3253 > mem[(32 * _1917) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1917) + (2 * ceil32(return_data.size)) + 288] - _3253
                    else:
                        _1831 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1918 = mem[_1831 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1831 + 192])] = mem[_1831 + 224 len floor32(mem[_1831 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3257 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1918) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1918) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1918) + ceil32(return_data.size) + 260] = _3257
                        mem[(32 * _1918) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1918) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1918) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1918) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1918) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3257, Array(len=2, data=mem[(32 * _1918) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1918) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1918) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4487 = mem[(32 * _1918) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1918) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1918) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1918) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1918) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1918) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1918) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1918) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1918) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1918) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1918) + ceil32(return_data.size) + 224]
                        mem[(32 * _1918) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4487 + (32 * _1918) + ceil32(return_data.size) + 224])] = mem[_4487 + (32 * _1918) + ceil32(return_data.size) + 256 len floor32(mem[_4487 + (32 * _1918) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1918) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1918) + (2 * ceil32(return_data.size)) + 288] <= _3257:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3257
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3257 > mem[(32 * _1918) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1918) + (2 * ceil32(return_data.size)) + 288] - _3257
                else:
                    if not arg2:
                        _1833 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1919 = mem[_1833 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1833 + 192])] = mem[_1833 + 224 len floor32(mem[_1833 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3261 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1919) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1919) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1919) + ceil32(return_data.size) + 260] = _3261
                        mem[(32 * _1919) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1919) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1919) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1919) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1919) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3261, Array(len=2, data=mem[(32 * _1919) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1919) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1919) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4489 = mem[(32 * _1919) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1919) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1919) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1919) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1919) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1919) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1919) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1919) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1919) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1919) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1919) + ceil32(return_data.size) + 224]
                        mem[(32 * _1919) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4489 + (32 * _1919) + ceil32(return_data.size) + 224])] = mem[_4489 + (32 * _1919) + ceil32(return_data.size) + 256 len floor32(mem[_4489 + (32 * _1919) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1919) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1919) + (2 * ceil32(return_data.size)) + 288] <= _3261:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3261
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3261 > mem[(32 * _1919) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1919) + (2 * ceil32(return_data.size)) + 288] - _3261
                    else:
                        _1835 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1920 = mem[_1835 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1835 + 192])] = mem[_1835 + 224 len floor32(mem[_1835 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3265 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1920) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1920) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1920) + ceil32(return_data.size) + 260] = _3265
                        mem[(32 * _1920) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1920) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1920) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1920) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1920) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3265, Array(len=2, data=mem[(32 * _1920) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1920) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1920) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4491 = mem[(32 * _1920) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1920) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1920) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1920) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1920) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1920) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1920) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1920) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1920) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1920) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1920) + ceil32(return_data.size) + 224]
                        mem[(32 * _1920) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4491 + (32 * _1920) + ceil32(return_data.size) + 224])] = mem[_4491 + (32 * _1920) + ceil32(return_data.size) + 256 len floor32(mem[_4491 + (32 * _1920) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1920) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1920) + (2 * ceil32(return_data.size)) + 288] <= _3265:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3265
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3265 > mem[(32 * _1920) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1920) + (2 * ceil32(return_data.size)) + 288] - _3265
            else:
                if not arg2:
                    if not arg2:
                        _1837 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1921 = mem[_1837 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1837 + 192])] = mem[_1837 + 224 len floor32(mem[_1837 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3269 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1921) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1921) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1921) + ceil32(return_data.size) + 260] = _3269
                        mem[(32 * _1921) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1921) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1921) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1921) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1921) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3269, Array(len=2, data=mem[(32 * _1921) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1921) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1921) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4493 = mem[(32 * _1921) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1921) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1921) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1921) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1921) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1921) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1921) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1921) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1921) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1921) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1921) + ceil32(return_data.size) + 224]
                        mem[(32 * _1921) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4493 + (32 * _1921) + ceil32(return_data.size) + 224])] = mem[_4493 + (32 * _1921) + ceil32(return_data.size) + 256 len floor32(mem[_4493 + (32 * _1921) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1921) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1921) + (2 * ceil32(return_data.size)) + 288] <= _3269:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3269
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3269 > mem[(32 * _1921) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1921) + (2 * ceil32(return_data.size)) + 288] - _3269
                    else:
                        _1839 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1922 = mem[_1839 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1839 + 192])] = mem[_1839 + 224 len floor32(mem[_1839 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3273 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1922) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1922) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1922) + ceil32(return_data.size) + 260] = _3273
                        mem[(32 * _1922) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1922) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1922) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1922) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1922) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3273, Array(len=2, data=mem[(32 * _1922) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1922) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1922) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4495 = mem[(32 * _1922) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1922) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1922) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1922) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1922) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1922) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1922) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1922) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1922) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1922) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1922) + ceil32(return_data.size) + 224]
                        mem[(32 * _1922) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4495 + (32 * _1922) + ceil32(return_data.size) + 224])] = mem[_4495 + (32 * _1922) + ceil32(return_data.size) + 256 len floor32(mem[_4495 + (32 * _1922) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1922) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1922) + (2 * ceil32(return_data.size)) + 288] <= _3273:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3273
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3273 > mem[(32 * _1922) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1922) + (2 * ceil32(return_data.size)) + 288] - _3273
                else:
                    if not arg2:
                        _1841 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1923 = mem[_1841 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1841 + 192])] = mem[_1841 + 224 len floor32(mem[_1841 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3277 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1923) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1923) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1923) + ceil32(return_data.size) + 260] = _3277
                        mem[(32 * _1923) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1923) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1923) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1923) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1923) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3277, Array(len=2, data=mem[(32 * _1923) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1923) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1923) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4497 = mem[(32 * _1923) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1923) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1923) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1923) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1923) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1923) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1923) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1923) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1923) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1923) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1923) + ceil32(return_data.size) + 224]
                        mem[(32 * _1923) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4497 + (32 * _1923) + ceil32(return_data.size) + 224])] = mem[_4497 + (32 * _1923) + ceil32(return_data.size) + 256 len floor32(mem[_4497 + (32 * _1923) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1923) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1923) + (2 * ceil32(return_data.size)) + 288] <= _3277:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3277
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3277 > mem[(32 * _1923) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1923) + (2 * ceil32(return_data.size)) + 288] - _3277
                    else:
                        _1843 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1924 = mem[_1843 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1843 + 192])] = mem[_1843 + 224 len floor32(mem[_1843 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3281 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1924) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1924) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1924) + ceil32(return_data.size) + 260] = _3281
                        mem[(32 * _1924) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1924) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1924) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1924) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1924) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3281, Array(len=2, data=mem[(32 * _1924) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1924) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1924) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4499 = mem[(32 * _1924) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1924) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1924) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1924) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1924) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1924) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1924) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1924) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1924) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1924) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1924) + ceil32(return_data.size) + 224]
                        mem[(32 * _1924) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4499 + (32 * _1924) + ceil32(return_data.size) + 224])] = mem[_4499 + (32 * _1924) + ceil32(return_data.size) + 256 len floor32(mem[_4499 + (32 * _1924) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1924) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1924) + (2 * ceil32(return_data.size)) + 288] <= _3281:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3281
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3281 > mem[(32 * _1924) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1924) + (2 * ceil32(return_data.size)) + 288] - _3281
    else:
        if not arg2:
            if arg1 != this.address:
                revert with 0, '!sender'
            mem[96] = 2
            mem[128] = address(ext_call.return_data[0])
            mem[160] = address(ext_call.return_data[0])
            require arg4.length >= 64
            require ext_code.size(address(ext_call.return_data[0]))
            call address(ext_call.return_data[0]).approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args address(cd[(arg4 + 68)]), arg2
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[192] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
            mem[196] = arg2
            mem[228] = 64
            mem[260] = 2
            mem[292 len 0] = None
            require ext_code.size(address(cd[(arg4 + 36)]))
            staticcall address(cd[(arg4 + 36)]).getAmountsIn(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args arg2, Array(len=2, data=mem[292 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[192 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(return_data.size) + 192
            require return_data.size >= 32
            if not arg2:
                if not arg2:
                    if not arg2:
                        _1845 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1925 = mem[_1845 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1845 + 192])] = mem[_1845 + 224 len floor32(mem[_1845 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3285 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1925) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1925) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1925) + ceil32(return_data.size) + 260] = _3285
                        mem[(32 * _1925) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1925) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1925) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1925) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1925) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3285, Array(len=2, data=mem[(32 * _1925) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1925) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1925) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4501 = mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1925) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1925) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1925) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1925) + ceil32(return_data.size) + 224]
                        mem[(32 * _1925) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4501 + (32 * _1925) + ceil32(return_data.size) + 224])] = mem[_4501 + (32 * _1925) + ceil32(return_data.size) + 256 len floor32(mem[_4501 + (32 * _1925) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1925) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1925) + (2 * ceil32(return_data.size)) + 288] <= _3285:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3285
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3285 > mem[(32 * _1925) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1925) + (2 * ceil32(return_data.size)) + 288] - _3285
                    else:
                        _1847 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1926 = mem[_1847 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1847 + 192])] = mem[_1847 + 224 len floor32(mem[_1847 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3289 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1926) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1926) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1926) + ceil32(return_data.size) + 260] = _3289
                        mem[(32 * _1926) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1926) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1926) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1926) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1926) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3289, Array(len=2, data=mem[(32 * _1926) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1926) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1926) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4503 = mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1926) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1926) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1926) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1926) + ceil32(return_data.size) + 224]
                        mem[(32 * _1926) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4503 + (32 * _1926) + ceil32(return_data.size) + 224])] = mem[_4503 + (32 * _1926) + ceil32(return_data.size) + 256 len floor32(mem[_4503 + (32 * _1926) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1926) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1926) + (2 * ceil32(return_data.size)) + 288] <= _3289:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3289
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3289 > mem[(32 * _1926) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1926) + (2 * ceil32(return_data.size)) + 288] - _3289
                else:
                    if not arg2:
                        _1849 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1927 = mem[_1849 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1849 + 192])] = mem[_1849 + 224 len floor32(mem[_1849 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3293 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1927) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1927) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1927) + ceil32(return_data.size) + 260] = _3293
                        mem[(32 * _1927) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1927) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1927) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1927) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1927) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3293, Array(len=2, data=mem[(32 * _1927) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1927) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1927) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4505 = mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1927) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1927) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1927) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1927) + ceil32(return_data.size) + 224]
                        mem[(32 * _1927) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4505 + (32 * _1927) + ceil32(return_data.size) + 224])] = mem[_4505 + (32 * _1927) + ceil32(return_data.size) + 256 len floor32(mem[_4505 + (32 * _1927) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1927) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1927) + (2 * ceil32(return_data.size)) + 288] <= _3293:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3293
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3293 > mem[(32 * _1927) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1927) + (2 * ceil32(return_data.size)) + 288] - _3293
                    else:
                        _1851 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1928 = mem[_1851 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1851 + 192])] = mem[_1851 + 224 len floor32(mem[_1851 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3297 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1928) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1928) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1928) + ceil32(return_data.size) + 260] = _3297
                        mem[(32 * _1928) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1928) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1928) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1928) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1928) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3297, Array(len=2, data=mem[(32 * _1928) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1928) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1928) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4507 = mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1928) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1928) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1928) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1928) + ceil32(return_data.size) + 224]
                        mem[(32 * _1928) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4507 + (32 * _1928) + ceil32(return_data.size) + 224])] = mem[_4507 + (32 * _1928) + ceil32(return_data.size) + 256 len floor32(mem[_4507 + (32 * _1928) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1928) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1928) + (2 * ceil32(return_data.size)) + 288] <= _3297:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3297
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3297 > mem[(32 * _1928) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1928) + (2 * ceil32(return_data.size)) + 288] - _3297
            else:
                if not arg2:
                    if not arg2:
                        _1853 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1929 = mem[_1853 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1853 + 192])] = mem[_1853 + 224 len floor32(mem[_1853 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3301 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1929) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1929) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1929) + ceil32(return_data.size) + 260] = _3301
                        mem[(32 * _1929) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1929) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1929) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1929) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1929) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3301, Array(len=2, data=mem[(32 * _1929) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1929) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1929) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4509 = mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1929) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1929) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1929) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1929) + ceil32(return_data.size) + 224]
                        mem[(32 * _1929) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4509 + (32 * _1929) + ceil32(return_data.size) + 224])] = mem[_4509 + (32 * _1929) + ceil32(return_data.size) + 256 len floor32(mem[_4509 + (32 * _1929) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1929) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1929) + (2 * ceil32(return_data.size)) + 288] <= _3301:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3301
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3301 > mem[(32 * _1929) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1929) + (2 * ceil32(return_data.size)) + 288] - _3301
                    else:
                        _1855 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1930 = mem[_1855 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1855 + 192])] = mem[_1855 + 224 len floor32(mem[_1855 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3305 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1930) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1930) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1930) + ceil32(return_data.size) + 260] = _3305
                        mem[(32 * _1930) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1930) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1930) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1930) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1930) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3305, Array(len=2, data=mem[(32 * _1930) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1930) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1930) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4511 = mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1930) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1930) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1930) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1930) + ceil32(return_data.size) + 224]
                        mem[(32 * _1930) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4511 + (32 * _1930) + ceil32(return_data.size) + 224])] = mem[_4511 + (32 * _1930) + ceil32(return_data.size) + 256 len floor32(mem[_4511 + (32 * _1930) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1930) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1930) + (2 * ceil32(return_data.size)) + 288] <= _3305:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3305
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3305 > mem[(32 * _1930) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1930) + (2 * ceil32(return_data.size)) + 288] - _3305
                else:
                    if not arg2:
                        _1857 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1931 = mem[_1857 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1857 + 192])] = mem[_1857 + 224 len floor32(mem[_1857 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3309 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1931) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1931) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1931) + ceil32(return_data.size) + 260] = _3309
                        mem[(32 * _1931) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1931) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1931) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1931) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1931) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3309, Array(len=2, data=mem[(32 * _1931) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1931) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1931) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4513 = mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1931) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1931) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1931) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1931) + ceil32(return_data.size) + 224]
                        mem[(32 * _1931) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4513 + (32 * _1931) + ceil32(return_data.size) + 224])] = mem[_4513 + (32 * _1931) + ceil32(return_data.size) + 256 len floor32(mem[_4513 + (32 * _1931) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1931) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1931) + (2 * ceil32(return_data.size)) + 288] <= _3309:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3309
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3309 > mem[(32 * _1931) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1931) + (2 * ceil32(return_data.size)) + 288] - _3309
                    else:
                        _1859 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1932 = mem[_1859 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1859 + 192])] = mem[_1859 + 224 len floor32(mem[_1859 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3313 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1932) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1932) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1932) + ceil32(return_data.size) + 260] = _3313
                        mem[(32 * _1932) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1932) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1932) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1932) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1932) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3313, Array(len=2, data=mem[(32 * _1932) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1932) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1932) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4515 = mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1932) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1932) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1932) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1932) + ceil32(return_data.size) + 224]
                        mem[(32 * _1932) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4515 + (32 * _1932) + ceil32(return_data.size) + 224])] = mem[_4515 + (32 * _1932) + ceil32(return_data.size) + 256 len floor32(mem[_4515 + (32 * _1932) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1932) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1932) + (2 * ceil32(return_data.size)) + 288] <= _3313:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3313
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3313 > mem[(32 * _1932) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1932) + (2 * ceil32(return_data.size)) + 288] - _3313
        else:
            require not arg3
            if arg1 != this.address:
                revert with 0, '!sender'
            mem[96] = 2
            mem[128] = address(ext_call.return_data[0])
            mem[160] = address(ext_call.return_data[0])
            require arg4.length >= 64
            require ext_code.size(address(ext_call.return_data[0]))
            call address(ext_call.return_data[0]).approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args address(cd[(arg4 + 68)]), arg2
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[192] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
            mem[196] = arg2
            mem[228] = 64
            mem[260] = 2
            mem[292 len 0] = None
            require ext_code.size(address(cd[(arg4 + 36)]))
            staticcall address(cd[(arg4 + 36)]).getAmountsIn(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args arg2, Array(len=2, data=mem[292 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[192 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(return_data.size) + 192
            require return_data.size >= 32
            if not arg2:
                if not arg2:
                    if not arg2:
                        _1861 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1933 = mem[_1861 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1861 + 192])] = mem[_1861 + 224 len floor32(mem[_1861 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3317 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1933) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1933) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1933) + ceil32(return_data.size) + 260] = _3317
                        mem[(32 * _1933) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1933) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1933) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1933) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1933) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3317, Array(len=2, data=mem[(32 * _1933) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1933) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1933) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4517 = mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1933) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1933) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1933) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1933) + ceil32(return_data.size) + 224]
                        mem[(32 * _1933) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4517 + (32 * _1933) + ceil32(return_data.size) + 224])] = mem[_4517 + (32 * _1933) + ceil32(return_data.size) + 256 len floor32(mem[_4517 + (32 * _1933) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1933) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1933) + (2 * ceil32(return_data.size)) + 288] <= _3317:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3317
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3317 > mem[(32 * _1933) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1933) + (2 * ceil32(return_data.size)) + 288] - _3317
                    else:
                        _1863 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1934 = mem[_1863 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1863 + 192])] = mem[_1863 + 224 len floor32(mem[_1863 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3321 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1934) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1934) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1934) + ceil32(return_data.size) + 260] = _3321
                        mem[(32 * _1934) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1934) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1934) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1934) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1934) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3321, Array(len=2, data=mem[(32 * _1934) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1934) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1934) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4519 = mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1934) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1934) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1934) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1934) + ceil32(return_data.size) + 224]
                        mem[(32 * _1934) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4519 + (32 * _1934) + ceil32(return_data.size) + 224])] = mem[_4519 + (32 * _1934) + ceil32(return_data.size) + 256 len floor32(mem[_4519 + (32 * _1934) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1934) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1934) + (2 * ceil32(return_data.size)) + 288] <= _3321:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3321
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3321 > mem[(32 * _1934) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1934) + (2 * ceil32(return_data.size)) + 288] - _3321
                else:
                    if not arg2:
                        _1865 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1935 = mem[_1865 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1865 + 192])] = mem[_1865 + 224 len floor32(mem[_1865 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3325 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1935) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1935) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1935) + ceil32(return_data.size) + 260] = _3325
                        mem[(32 * _1935) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1935) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1935) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1935) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1935) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3325, Array(len=2, data=mem[(32 * _1935) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1935) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1935) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4521 = mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1935) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1935) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1935) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1935) + ceil32(return_data.size) + 224]
                        mem[(32 * _1935) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4521 + (32 * _1935) + ceil32(return_data.size) + 224])] = mem[_4521 + (32 * _1935) + ceil32(return_data.size) + 256 len floor32(mem[_4521 + (32 * _1935) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1935) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1935) + (2 * ceil32(return_data.size)) + 288] <= _3325:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3325
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3325 > mem[(32 * _1935) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1935) + (2 * ceil32(return_data.size)) + 288] - _3325
                    else:
                        _1867 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1936 = mem[_1867 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1867 + 192])] = mem[_1867 + 224 len floor32(mem[_1867 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3329 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1936) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1936) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1936) + ceil32(return_data.size) + 260] = _3329
                        mem[(32 * _1936) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1936) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1936) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1936) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1936) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3329, Array(len=2, data=mem[(32 * _1936) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1936) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1936) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4523 = mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1936) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1936) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1936) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1936) + ceil32(return_data.size) + 224]
                        mem[(32 * _1936) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4523 + (32 * _1936) + ceil32(return_data.size) + 224])] = mem[_4523 + (32 * _1936) + ceil32(return_data.size) + 256 len floor32(mem[_4523 + (32 * _1936) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1936) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1936) + (2 * ceil32(return_data.size)) + 288] <= _3329:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3329
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3329 > mem[(32 * _1936) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1936) + (2 * ceil32(return_data.size)) + 288] - _3329
            else:
                if not arg2:
                    if not arg2:
                        _1869 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1937 = mem[_1869 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1869 + 192])] = mem[_1869 + 224 len floor32(mem[_1869 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3333 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1937) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1937) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1937) + ceil32(return_data.size) + 260] = _3333
                        mem[(32 * _1937) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1937) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1937) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1937) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1937) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3333, Array(len=2, data=mem[(32 * _1937) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1937) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1937) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4525 = mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1937) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1937) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1937) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1937) + ceil32(return_data.size) + 224]
                        mem[(32 * _1937) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4525 + (32 * _1937) + ceil32(return_data.size) + 224])] = mem[_4525 + (32 * _1937) + ceil32(return_data.size) + 256 len floor32(mem[_4525 + (32 * _1937) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1937) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1937) + (2 * ceil32(return_data.size)) + 288] <= _3333:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3333
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3333 > mem[(32 * _1937) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1937) + (2 * ceil32(return_data.size)) + 288] - _3333
                    else:
                        _1871 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1938 = mem[_1871 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1871 + 192])] = mem[_1871 + 224 len floor32(mem[_1871 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3337 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1938) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1938) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1938) + ceil32(return_data.size) + 260] = _3337
                        mem[(32 * _1938) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1938) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1938) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1938) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1938) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3337, Array(len=2, data=mem[(32 * _1938) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1938) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1938) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4527 = mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1938) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1938) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1938) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1938) + ceil32(return_data.size) + 224]
                        mem[(32 * _1938) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4527 + (32 * _1938) + ceil32(return_data.size) + 224])] = mem[_4527 + (32 * _1938) + ceil32(return_data.size) + 256 len floor32(mem[_4527 + (32 * _1938) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1938) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1938) + (2 * ceil32(return_data.size)) + 288] <= _3337:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3337
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3337 > mem[(32 * _1938) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1938) + (2 * ceil32(return_data.size)) + 288] - _3337
                else:
                    if not arg2:
                        _1873 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1939 = mem[_1873 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1873 + 192])] = mem[_1873 + 224 len floor32(mem[_1873 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3341 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1939) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1939) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1939) + ceil32(return_data.size) + 260] = _3341
                        mem[(32 * _1939) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1939) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1939) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1939) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1939) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3341, Array(len=2, data=mem[(32 * _1939) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1939) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1939) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4529 = mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1939) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1939) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1939) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1939) + ceil32(return_data.size) + 224]
                        mem[(32 * _1939) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4529 + (32 * _1939) + ceil32(return_data.size) + 224])] = mem[_4529 + (32 * _1939) + ceil32(return_data.size) + 256 len floor32(mem[_4529 + (32 * _1939) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1939) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1939) + (2 * ceil32(return_data.size)) + 288] <= _3341:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3341
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3341 > mem[(32 * _1939) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1939) + (2 * ceil32(return_data.size)) + 288] - _3341
                    else:
                        _1875 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1940 = mem[_1875 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1875 + 192])] = mem[_1875 + 224 len floor32(mem[_1875 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3345 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1940) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1940) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1940) + ceil32(return_data.size) + 260] = _3345
                        mem[(32 * _1940) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1940) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1940) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1940) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1940) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3345, Array(len=2, data=mem[(32 * _1940) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1940) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1940) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4531 = mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1940) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1940) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1940) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1940) + ceil32(return_data.size) + 224]
                        mem[(32 * _1940) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4531 + (32 * _1940) + ceil32(return_data.size) + 224])] = mem[_4531 + (32 * _1940) + ceil32(return_data.size) + 256 len floor32(mem[_4531 + (32 * _1940) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1940) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1940) + (2 * ceil32(return_data.size)) + 288] <= _3345:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3345
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3345 > mem[(32 * _1940) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1940) + (2 * ceil32(return_data.size)) + 288] - _3345
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
}

function BiswapCall(address arg1, uint256 arg2, uint256 arg3, bytes arg4) {
    require calldata.size - 4 >= 128
    require arg4 <= 4294967296
    require arg4 + 36 <= calldata.size
    require arg4.length <= 4294967296 and arg4 + arg4.length + 36 <= calldata.size
    require ext_code.size(msg.sender)
    staticcall msg.sender.token0() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_code.size(msg.sender)
    staticcall msg.sender.token1() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if not arg2:
        if not arg2:
            if arg1 != this.address:
                revert with 0, '!sender'
            mem[96] = 2
            mem[128] = address(ext_call.return_data[0])
            mem[160] = address(ext_call.return_data[0])
            require arg4.length >= 64
            require ext_code.size(address(ext_call.return_data[0]))
            call address(ext_call.return_data[0]).approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args address(cd[(arg4 + 68)]), arg3
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[192] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
            mem[196] = arg3
            mem[228] = 64
            mem[260] = 2
            mem[292 len 0] = None
            require ext_code.size(address(cd[(arg4 + 36)]))
            staticcall address(cd[(arg4 + 36)]).getAmountsIn(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args arg3, Array(len=2, data=mem[292 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[192 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(return_data.size) + 192
            require return_data.size >= 32
            if not arg2:
                if not arg2:
                    if not arg2:
                        _1813 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1909 = mem[_1813 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1813 + 192])] = mem[_1813 + 224 len floor32(mem[_1813 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3221 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1909) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1909) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1909) + ceil32(return_data.size) + 260] = _3221
                        mem[(32 * _1909) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1909) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1909) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1909) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1909) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3221, Array(len=2, data=mem[(32 * _1909) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1909) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1909) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4469 = mem[(32 * _1909) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1909) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1909) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1909) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1909) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1909) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1909) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1909) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1909) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1909) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1909) + ceil32(return_data.size) + 224]
                        mem[(32 * _1909) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4469 + (32 * _1909) + ceil32(return_data.size) + 224])] = mem[_4469 + (32 * _1909) + ceil32(return_data.size) + 256 len floor32(mem[_4469 + (32 * _1909) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1909) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1909) + (2 * ceil32(return_data.size)) + 288] <= _3221:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3221
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3221 > mem[(32 * _1909) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1909) + (2 * ceil32(return_data.size)) + 288] - _3221
                    else:
                        _1815 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1910 = mem[_1815 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1815 + 192])] = mem[_1815 + 224 len floor32(mem[_1815 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3225 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1910) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1910) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1910) + ceil32(return_data.size) + 260] = _3225
                        mem[(32 * _1910) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1910) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1910) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1910) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1910) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3225, Array(len=2, data=mem[(32 * _1910) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1910) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1910) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4471 = mem[(32 * _1910) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1910) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1910) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1910) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1910) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1910) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1910) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1910) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1910) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1910) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1910) + ceil32(return_data.size) + 224]
                        mem[(32 * _1910) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4471 + (32 * _1910) + ceil32(return_data.size) + 224])] = mem[_4471 + (32 * _1910) + ceil32(return_data.size) + 256 len floor32(mem[_4471 + (32 * _1910) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1910) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1910) + (2 * ceil32(return_data.size)) + 288] <= _3225:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3225
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3225 > mem[(32 * _1910) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1910) + (2 * ceil32(return_data.size)) + 288] - _3225
                else:
                    if not arg2:
                        _1817 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1911 = mem[_1817 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1817 + 192])] = mem[_1817 + 224 len floor32(mem[_1817 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3229 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1911) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1911) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1911) + ceil32(return_data.size) + 260] = _3229
                        mem[(32 * _1911) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1911) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1911) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1911) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1911) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3229, Array(len=2, data=mem[(32 * _1911) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1911) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1911) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4473 = mem[(32 * _1911) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1911) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1911) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1911) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1911) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1911) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1911) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1911) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1911) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1911) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1911) + ceil32(return_data.size) + 224]
                        mem[(32 * _1911) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4473 + (32 * _1911) + ceil32(return_data.size) + 224])] = mem[_4473 + (32 * _1911) + ceil32(return_data.size) + 256 len floor32(mem[_4473 + (32 * _1911) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1911) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1911) + (2 * ceil32(return_data.size)) + 288] <= _3229:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3229
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3229 > mem[(32 * _1911) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1911) + (2 * ceil32(return_data.size)) + 288] - _3229
                    else:
                        _1819 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1912 = mem[_1819 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1819 + 192])] = mem[_1819 + 224 len floor32(mem[_1819 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3233 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1912) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1912) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1912) + ceil32(return_data.size) + 260] = _3233
                        mem[(32 * _1912) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1912) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1912) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1912) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1912) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3233, Array(len=2, data=mem[(32 * _1912) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1912) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1912) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4475 = mem[(32 * _1912) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1912) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1912) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1912) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1912) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1912) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1912) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1912) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1912) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1912) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1912) + ceil32(return_data.size) + 224]
                        mem[(32 * _1912) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4475 + (32 * _1912) + ceil32(return_data.size) + 224])] = mem[_4475 + (32 * _1912) + ceil32(return_data.size) + 256 len floor32(mem[_4475 + (32 * _1912) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1912) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1912) + (2 * ceil32(return_data.size)) + 288] <= _3233:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3233
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3233 > mem[(32 * _1912) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1912) + (2 * ceil32(return_data.size)) + 288] - _3233
            else:
                if not arg2:
                    if not arg2:
                        _1821 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1913 = mem[_1821 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1821 + 192])] = mem[_1821 + 224 len floor32(mem[_1821 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3237 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1913) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1913) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1913) + ceil32(return_data.size) + 260] = _3237
                        mem[(32 * _1913) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1913) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1913) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1913) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1913) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3237, Array(len=2, data=mem[(32 * _1913) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1913) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1913) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4477 = mem[(32 * _1913) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1913) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1913) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1913) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1913) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1913) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1913) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1913) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1913) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1913) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1913) + ceil32(return_data.size) + 224]
                        mem[(32 * _1913) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4477 + (32 * _1913) + ceil32(return_data.size) + 224])] = mem[_4477 + (32 * _1913) + ceil32(return_data.size) + 256 len floor32(mem[_4477 + (32 * _1913) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1913) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1913) + (2 * ceil32(return_data.size)) + 288] <= _3237:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3237
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3237 > mem[(32 * _1913) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1913) + (2 * ceil32(return_data.size)) + 288] - _3237
                    else:
                        _1823 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1914 = mem[_1823 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1823 + 192])] = mem[_1823 + 224 len floor32(mem[_1823 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3241 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1914) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1914) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1914) + ceil32(return_data.size) + 260] = _3241
                        mem[(32 * _1914) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1914) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1914) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1914) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1914) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3241, Array(len=2, data=mem[(32 * _1914) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1914) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1914) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4479 = mem[(32 * _1914) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1914) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1914) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1914) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1914) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1914) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1914) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1914) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1914) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1914) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1914) + ceil32(return_data.size) + 224]
                        mem[(32 * _1914) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4479 + (32 * _1914) + ceil32(return_data.size) + 224])] = mem[_4479 + (32 * _1914) + ceil32(return_data.size) + 256 len floor32(mem[_4479 + (32 * _1914) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1914) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1914) + (2 * ceil32(return_data.size)) + 288] <= _3241:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3241
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3241 > mem[(32 * _1914) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1914) + (2 * ceil32(return_data.size)) + 288] - _3241
                else:
                    if not arg2:
                        _1825 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1915 = mem[_1825 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1825 + 192])] = mem[_1825 + 224 len floor32(mem[_1825 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3245 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1915) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1915) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1915) + ceil32(return_data.size) + 260] = _3245
                        mem[(32 * _1915) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1915) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1915) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1915) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1915) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3245, Array(len=2, data=mem[(32 * _1915) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1915) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1915) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4481 = mem[(32 * _1915) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1915) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1915) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1915) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1915) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1915) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1915) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1915) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1915) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1915) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1915) + ceil32(return_data.size) + 224]
                        mem[(32 * _1915) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4481 + (32 * _1915) + ceil32(return_data.size) + 224])] = mem[_4481 + (32 * _1915) + ceil32(return_data.size) + 256 len floor32(mem[_4481 + (32 * _1915) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1915) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1915) + (2 * ceil32(return_data.size)) + 288] <= _3245:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3245
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3245 > mem[(32 * _1915) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1915) + (2 * ceil32(return_data.size)) + 288] - _3245
                    else:
                        _1827 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1916 = mem[_1827 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1827 + 192])] = mem[_1827 + 224 len floor32(mem[_1827 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3249 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1916) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1916) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1916) + ceil32(return_data.size) + 260] = _3249
                        mem[(32 * _1916) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1916) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1916) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1916) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1916) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3249, Array(len=2, data=mem[(32 * _1916) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1916) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1916) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4483 = mem[(32 * _1916) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1916) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1916) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1916) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1916) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1916) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1916) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1916) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1916) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1916) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1916) + ceil32(return_data.size) + 224]
                        mem[(32 * _1916) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4483 + (32 * _1916) + ceil32(return_data.size) + 224])] = mem[_4483 + (32 * _1916) + ceil32(return_data.size) + 256 len floor32(mem[_4483 + (32 * _1916) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1916) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1916) + (2 * ceil32(return_data.size)) + 288] <= _3249:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3249
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3249 > mem[(32 * _1916) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1916) + (2 * ceil32(return_data.size)) + 288] - _3249
        else:
            require not arg3
            if arg1 != this.address:
                revert with 0, '!sender'
            mem[96] = 2
            mem[128] = address(ext_call.return_data[0])
            mem[160] = address(ext_call.return_data[0])
            require arg4.length >= 64
            require ext_code.size(address(ext_call.return_data[0]))
            call address(ext_call.return_data[0]).approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args address(cd[(arg4 + 68)]), arg3
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[192] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
            mem[196] = arg3
            mem[228] = 64
            mem[260] = 2
            mem[292 len 0] = None
            require ext_code.size(address(cd[(arg4 + 36)]))
            staticcall address(cd[(arg4 + 36)]).getAmountsIn(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args arg3, Array(len=2, data=mem[292 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[192 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(return_data.size) + 192
            require return_data.size >= 32
            if not arg2:
                if not arg2:
                    if not arg2:
                        _1829 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1917 = mem[_1829 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1829 + 192])] = mem[_1829 + 224 len floor32(mem[_1829 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3253 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1917) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1917) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1917) + ceil32(return_data.size) + 260] = _3253
                        mem[(32 * _1917) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1917) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1917) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1917) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1917) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3253, Array(len=2, data=mem[(32 * _1917) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1917) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1917) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4485 = mem[(32 * _1917) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1917) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1917) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1917) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1917) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1917) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1917) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1917) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1917) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1917) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1917) + ceil32(return_data.size) + 224]
                        mem[(32 * _1917) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4485 + (32 * _1917) + ceil32(return_data.size) + 224])] = mem[_4485 + (32 * _1917) + ceil32(return_data.size) + 256 len floor32(mem[_4485 + (32 * _1917) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1917) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1917) + (2 * ceil32(return_data.size)) + 288] <= _3253:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3253
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3253 > mem[(32 * _1917) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1917) + (2 * ceil32(return_data.size)) + 288] - _3253
                    else:
                        _1831 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1918 = mem[_1831 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1831 + 192])] = mem[_1831 + 224 len floor32(mem[_1831 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3257 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1918) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1918) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1918) + ceil32(return_data.size) + 260] = _3257
                        mem[(32 * _1918) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1918) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1918) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1918) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1918) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3257, Array(len=2, data=mem[(32 * _1918) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1918) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1918) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4487 = mem[(32 * _1918) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1918) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1918) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1918) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1918) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1918) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1918) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1918) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1918) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1918) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1918) + ceil32(return_data.size) + 224]
                        mem[(32 * _1918) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4487 + (32 * _1918) + ceil32(return_data.size) + 224])] = mem[_4487 + (32 * _1918) + ceil32(return_data.size) + 256 len floor32(mem[_4487 + (32 * _1918) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1918) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1918) + (2 * ceil32(return_data.size)) + 288] <= _3257:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3257
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3257 > mem[(32 * _1918) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1918) + (2 * ceil32(return_data.size)) + 288] - _3257
                else:
                    if not arg2:
                        _1833 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1919 = mem[_1833 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1833 + 192])] = mem[_1833 + 224 len floor32(mem[_1833 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3261 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1919) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1919) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1919) + ceil32(return_data.size) + 260] = _3261
                        mem[(32 * _1919) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1919) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1919) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1919) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1919) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3261, Array(len=2, data=mem[(32 * _1919) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1919) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1919) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4489 = mem[(32 * _1919) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1919) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1919) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1919) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1919) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1919) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1919) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1919) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1919) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1919) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1919) + ceil32(return_data.size) + 224]
                        mem[(32 * _1919) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4489 + (32 * _1919) + ceil32(return_data.size) + 224])] = mem[_4489 + (32 * _1919) + ceil32(return_data.size) + 256 len floor32(mem[_4489 + (32 * _1919) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1919) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1919) + (2 * ceil32(return_data.size)) + 288] <= _3261:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3261
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3261 > mem[(32 * _1919) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1919) + (2 * ceil32(return_data.size)) + 288] - _3261
                    else:
                        _1835 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1920 = mem[_1835 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1835 + 192])] = mem[_1835 + 224 len floor32(mem[_1835 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3265 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1920) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1920) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1920) + ceil32(return_data.size) + 260] = _3265
                        mem[(32 * _1920) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1920) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1920) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1920) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1920) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3265, Array(len=2, data=mem[(32 * _1920) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1920) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1920) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4491 = mem[(32 * _1920) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1920) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1920) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1920) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1920) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1920) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1920) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1920) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1920) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1920) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1920) + ceil32(return_data.size) + 224]
                        mem[(32 * _1920) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4491 + (32 * _1920) + ceil32(return_data.size) + 224])] = mem[_4491 + (32 * _1920) + ceil32(return_data.size) + 256 len floor32(mem[_4491 + (32 * _1920) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1920) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1920) + (2 * ceil32(return_data.size)) + 288] <= _3265:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3265
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3265 > mem[(32 * _1920) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1920) + (2 * ceil32(return_data.size)) + 288] - _3265
            else:
                if not arg2:
                    if not arg2:
                        _1837 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1921 = mem[_1837 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1837 + 192])] = mem[_1837 + 224 len floor32(mem[_1837 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3269 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1921) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1921) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1921) + ceil32(return_data.size) + 260] = _3269
                        mem[(32 * _1921) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1921) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1921) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1921) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1921) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3269, Array(len=2, data=mem[(32 * _1921) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1921) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1921) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4493 = mem[(32 * _1921) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1921) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1921) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1921) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1921) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1921) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1921) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1921) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1921) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1921) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1921) + ceil32(return_data.size) + 224]
                        mem[(32 * _1921) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4493 + (32 * _1921) + ceil32(return_data.size) + 224])] = mem[_4493 + (32 * _1921) + ceil32(return_data.size) + 256 len floor32(mem[_4493 + (32 * _1921) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1921) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1921) + (2 * ceil32(return_data.size)) + 288] <= _3269:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3269
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3269 > mem[(32 * _1921) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1921) + (2 * ceil32(return_data.size)) + 288] - _3269
                    else:
                        _1839 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1922 = mem[_1839 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1839 + 192])] = mem[_1839 + 224 len floor32(mem[_1839 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3273 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1922) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1922) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1922) + ceil32(return_data.size) + 260] = _3273
                        mem[(32 * _1922) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1922) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1922) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1922) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1922) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3273, Array(len=2, data=mem[(32 * _1922) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1922) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1922) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4495 = mem[(32 * _1922) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1922) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1922) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1922) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1922) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1922) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1922) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1922) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1922) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1922) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1922) + ceil32(return_data.size) + 224]
                        mem[(32 * _1922) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4495 + (32 * _1922) + ceil32(return_data.size) + 224])] = mem[_4495 + (32 * _1922) + ceil32(return_data.size) + 256 len floor32(mem[_4495 + (32 * _1922) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1922) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1922) + (2 * ceil32(return_data.size)) + 288] <= _3273:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3273
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3273 > mem[(32 * _1922) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1922) + (2 * ceil32(return_data.size)) + 288] - _3273
                else:
                    if not arg2:
                        _1841 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1923 = mem[_1841 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1841 + 192])] = mem[_1841 + 224 len floor32(mem[_1841 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3277 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1923) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1923) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1923) + ceil32(return_data.size) + 260] = _3277
                        mem[(32 * _1923) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1923) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1923) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1923) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1923) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3277, Array(len=2, data=mem[(32 * _1923) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1923) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1923) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4497 = mem[(32 * _1923) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1923) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1923) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1923) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1923) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1923) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1923) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1923) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1923) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1923) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1923) + ceil32(return_data.size) + 224]
                        mem[(32 * _1923) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4497 + (32 * _1923) + ceil32(return_data.size) + 224])] = mem[_4497 + (32 * _1923) + ceil32(return_data.size) + 256 len floor32(mem[_4497 + (32 * _1923) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1923) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1923) + (2 * ceil32(return_data.size)) + 288] <= _3277:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3277
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3277 > mem[(32 * _1923) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1923) + (2 * ceil32(return_data.size)) + 288] - _3277
                    else:
                        _1843 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1924 = mem[_1843 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1843 + 192])] = mem[_1843 + 224 len floor32(mem[_1843 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3281 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1924) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1924) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1924) + ceil32(return_data.size) + 260] = _3281
                        mem[(32 * _1924) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1924) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1924) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1924) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1924) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3281, Array(len=2, data=mem[(32 * _1924) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1924) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1924) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4499 = mem[(32 * _1924) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1924) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1924) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1924) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1924) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1924) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1924) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1924) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1924) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1924) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1924) + ceil32(return_data.size) + 224]
                        mem[(32 * _1924) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4499 + (32 * _1924) + ceil32(return_data.size) + 224])] = mem[_4499 + (32 * _1924) + ceil32(return_data.size) + 256 len floor32(mem[_4499 + (32 * _1924) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1924) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1924) + (2 * ceil32(return_data.size)) + 288] <= _3281:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3281
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3281 > mem[(32 * _1924) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1924) + (2 * ceil32(return_data.size)) + 288] - _3281
    else:
        if not arg2:
            if arg1 != this.address:
                revert with 0, '!sender'
            mem[96] = 2
            mem[128] = address(ext_call.return_data[0])
            mem[160] = address(ext_call.return_data[0])
            require arg4.length >= 64
            require ext_code.size(address(ext_call.return_data[0]))
            call address(ext_call.return_data[0]).approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args address(cd[(arg4 + 68)]), arg2
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[192] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
            mem[196] = arg2
            mem[228] = 64
            mem[260] = 2
            mem[292 len 0] = None
            require ext_code.size(address(cd[(arg4 + 36)]))
            staticcall address(cd[(arg4 + 36)]).getAmountsIn(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args arg2, Array(len=2, data=mem[292 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[192 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(return_data.size) + 192
            require return_data.size >= 32
            if not arg2:
                if not arg2:
                    if not arg2:
                        _1845 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1925 = mem[_1845 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1845 + 192])] = mem[_1845 + 224 len floor32(mem[_1845 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3285 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1925) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1925) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1925) + ceil32(return_data.size) + 260] = _3285
                        mem[(32 * _1925) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1925) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1925) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1925) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1925) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3285, Array(len=2, data=mem[(32 * _1925) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1925) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1925) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4501 = mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1925) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1925) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1925) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1925) + ceil32(return_data.size) + 224]
                        mem[(32 * _1925) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4501 + (32 * _1925) + ceil32(return_data.size) + 224])] = mem[_4501 + (32 * _1925) + ceil32(return_data.size) + 256 len floor32(mem[_4501 + (32 * _1925) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1925) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1925) + (2 * ceil32(return_data.size)) + 288] <= _3285:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3285
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3285 > mem[(32 * _1925) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1925) + (2 * ceil32(return_data.size)) + 288] - _3285
                    else:
                        _1847 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1926 = mem[_1847 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1847 + 192])] = mem[_1847 + 224 len floor32(mem[_1847 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3289 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1926) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1926) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1926) + ceil32(return_data.size) + 260] = _3289
                        mem[(32 * _1926) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1926) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1926) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1926) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1926) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3289, Array(len=2, data=mem[(32 * _1926) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1926) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1926) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4503 = mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1926) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1926) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1926) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1926) + ceil32(return_data.size) + 224]
                        mem[(32 * _1926) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4503 + (32 * _1926) + ceil32(return_data.size) + 224])] = mem[_4503 + (32 * _1926) + ceil32(return_data.size) + 256 len floor32(mem[_4503 + (32 * _1926) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1926) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1926) + (2 * ceil32(return_data.size)) + 288] <= _3289:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3289
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3289 > mem[(32 * _1926) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1926) + (2 * ceil32(return_data.size)) + 288] - _3289
                else:
                    if not arg2:
                        _1849 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1927 = mem[_1849 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1849 + 192])] = mem[_1849 + 224 len floor32(mem[_1849 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3293 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1927) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1927) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1927) + ceil32(return_data.size) + 260] = _3293
                        mem[(32 * _1927) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1927) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1927) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1927) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1927) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3293, Array(len=2, data=mem[(32 * _1927) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1927) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1927) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4505 = mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1927) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1927) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1927) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1927) + ceil32(return_data.size) + 224]
                        mem[(32 * _1927) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4505 + (32 * _1927) + ceil32(return_data.size) + 224])] = mem[_4505 + (32 * _1927) + ceil32(return_data.size) + 256 len floor32(mem[_4505 + (32 * _1927) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1927) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1927) + (2 * ceil32(return_data.size)) + 288] <= _3293:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3293
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3293 > mem[(32 * _1927) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1927) + (2 * ceil32(return_data.size)) + 288] - _3293
                    else:
                        _1851 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1928 = mem[_1851 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1851 + 192])] = mem[_1851 + 224 len floor32(mem[_1851 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3297 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1928) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1928) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1928) + ceil32(return_data.size) + 260] = _3297
                        mem[(32 * _1928) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1928) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1928) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1928) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1928) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3297, Array(len=2, data=mem[(32 * _1928) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1928) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1928) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4507 = mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1928) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1928) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1928) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1928) + ceil32(return_data.size) + 224]
                        mem[(32 * _1928) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4507 + (32 * _1928) + ceil32(return_data.size) + 224])] = mem[_4507 + (32 * _1928) + ceil32(return_data.size) + 256 len floor32(mem[_4507 + (32 * _1928) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1928) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1928) + (2 * ceil32(return_data.size)) + 288] <= _3297:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3297
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3297 > mem[(32 * _1928) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1928) + (2 * ceil32(return_data.size)) + 288] - _3297
            else:
                if not arg2:
                    if not arg2:
                        _1853 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1929 = mem[_1853 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1853 + 192])] = mem[_1853 + 224 len floor32(mem[_1853 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3301 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1929) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1929) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1929) + ceil32(return_data.size) + 260] = _3301
                        mem[(32 * _1929) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1929) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1929) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1929) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1929) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3301, Array(len=2, data=mem[(32 * _1929) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1929) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1929) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4509 = mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1929) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1929) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1929) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1929) + ceil32(return_data.size) + 224]
                        mem[(32 * _1929) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4509 + (32 * _1929) + ceil32(return_data.size) + 224])] = mem[_4509 + (32 * _1929) + ceil32(return_data.size) + 256 len floor32(mem[_4509 + (32 * _1929) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1929) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1929) + (2 * ceil32(return_data.size)) + 288] <= _3301:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3301
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3301 > mem[(32 * _1929) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1929) + (2 * ceil32(return_data.size)) + 288] - _3301
                    else:
                        _1855 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1930 = mem[_1855 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1855 + 192])] = mem[_1855 + 224 len floor32(mem[_1855 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3305 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1930) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1930) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1930) + ceil32(return_data.size) + 260] = _3305
                        mem[(32 * _1930) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1930) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1930) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1930) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1930) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3305, Array(len=2, data=mem[(32 * _1930) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1930) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1930) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4511 = mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1930) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1930) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1930) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1930) + ceil32(return_data.size) + 224]
                        mem[(32 * _1930) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4511 + (32 * _1930) + ceil32(return_data.size) + 224])] = mem[_4511 + (32 * _1930) + ceil32(return_data.size) + 256 len floor32(mem[_4511 + (32 * _1930) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1930) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1930) + (2 * ceil32(return_data.size)) + 288] <= _3305:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3305
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3305 > mem[(32 * _1930) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1930) + (2 * ceil32(return_data.size)) + 288] - _3305
                else:
                    if not arg2:
                        _1857 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1931 = mem[_1857 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1857 + 192])] = mem[_1857 + 224 len floor32(mem[_1857 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3309 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1931) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1931) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1931) + ceil32(return_data.size) + 260] = _3309
                        mem[(32 * _1931) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1931) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1931) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1931) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1931) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3309, Array(len=2, data=mem[(32 * _1931) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1931) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1931) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4513 = mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1931) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1931) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1931) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1931) + ceil32(return_data.size) + 224]
                        mem[(32 * _1931) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4513 + (32 * _1931) + ceil32(return_data.size) + 224])] = mem[_4513 + (32 * _1931) + ceil32(return_data.size) + 256 len floor32(mem[_4513 + (32 * _1931) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1931) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1931) + (2 * ceil32(return_data.size)) + 288] <= _3309:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3309
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3309 > mem[(32 * _1931) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1931) + (2 * ceil32(return_data.size)) + 288] - _3309
                    else:
                        _1859 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1932 = mem[_1859 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1859 + 192])] = mem[_1859 + 224 len floor32(mem[_1859 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3313 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1932) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1932) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1932) + ceil32(return_data.size) + 260] = _3313
                        mem[(32 * _1932) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1932) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1932) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1932) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1932) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3313, Array(len=2, data=mem[(32 * _1932) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1932) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1932) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4515 = mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1932) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1932) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1932) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1932) + ceil32(return_data.size) + 224]
                        mem[(32 * _1932) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4515 + (32 * _1932) + ceil32(return_data.size) + 224])] = mem[_4515 + (32 * _1932) + ceil32(return_data.size) + 256 len floor32(mem[_4515 + (32 * _1932) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1932) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1932) + (2 * ceil32(return_data.size)) + 288] <= _3313:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3313
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3313 > mem[(32 * _1932) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1932) + (2 * ceil32(return_data.size)) + 288] - _3313
        else:
            require not arg3
            if arg1 != this.address:
                revert with 0, '!sender'
            mem[96] = 2
            mem[128] = address(ext_call.return_data[0])
            mem[160] = address(ext_call.return_data[0])
            require arg4.length >= 64
            require ext_code.size(address(ext_call.return_data[0]))
            call address(ext_call.return_data[0]).approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args address(cd[(arg4 + 68)]), arg2
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[192] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
            mem[196] = arg2
            mem[228] = 64
            mem[260] = 2
            mem[292 len 0] = None
            require ext_code.size(address(cd[(arg4 + 36)]))
            staticcall address(cd[(arg4 + 36)]).getAmountsIn(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args arg2, Array(len=2, data=mem[292 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[192 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(return_data.size) + 192
            require return_data.size >= 32
            if not arg2:
                if not arg2:
                    if not arg2:
                        _1861 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1933 = mem[_1861 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1861 + 192])] = mem[_1861 + 224 len floor32(mem[_1861 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3317 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1933) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1933) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1933) + ceil32(return_data.size) + 260] = _3317
                        mem[(32 * _1933) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1933) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1933) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1933) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1933) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3317, Array(len=2, data=mem[(32 * _1933) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1933) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1933) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4517 = mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1933) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1933) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1933) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1933) + ceil32(return_data.size) + 224]
                        mem[(32 * _1933) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4517 + (32 * _1933) + ceil32(return_data.size) + 224])] = mem[_4517 + (32 * _1933) + ceil32(return_data.size) + 256 len floor32(mem[_4517 + (32 * _1933) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1933) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1933) + (2 * ceil32(return_data.size)) + 288] <= _3317:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3317
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3317 > mem[(32 * _1933) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1933) + (2 * ceil32(return_data.size)) + 288] - _3317
                    else:
                        _1863 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1934 = mem[_1863 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1863 + 192])] = mem[_1863 + 224 len floor32(mem[_1863 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3321 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1934) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1934) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1934) + ceil32(return_data.size) + 260] = _3321
                        mem[(32 * _1934) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1934) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1934) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1934) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1934) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3321, Array(len=2, data=mem[(32 * _1934) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1934) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1934) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4519 = mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1934) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1934) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1934) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1934) + ceil32(return_data.size) + 224]
                        mem[(32 * _1934) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4519 + (32 * _1934) + ceil32(return_data.size) + 224])] = mem[_4519 + (32 * _1934) + ceil32(return_data.size) + 256 len floor32(mem[_4519 + (32 * _1934) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1934) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1934) + (2 * ceil32(return_data.size)) + 288] <= _3321:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3321
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3321 > mem[(32 * _1934) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1934) + (2 * ceil32(return_data.size)) + 288] - _3321
                else:
                    if not arg2:
                        _1865 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1935 = mem[_1865 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1865 + 192])] = mem[_1865 + 224 len floor32(mem[_1865 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3325 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1935) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1935) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1935) + ceil32(return_data.size) + 260] = _3325
                        mem[(32 * _1935) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1935) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1935) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1935) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1935) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3325, Array(len=2, data=mem[(32 * _1935) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1935) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1935) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4521 = mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1935) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1935) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1935) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1935) + ceil32(return_data.size) + 224]
                        mem[(32 * _1935) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4521 + (32 * _1935) + ceil32(return_data.size) + 224])] = mem[_4521 + (32 * _1935) + ceil32(return_data.size) + 256 len floor32(mem[_4521 + (32 * _1935) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1935) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1935) + (2 * ceil32(return_data.size)) + 288] <= _3325:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3325
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3325 > mem[(32 * _1935) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1935) + (2 * ceil32(return_data.size)) + 288] - _3325
                    else:
                        _1867 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1936 = mem[_1867 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1867 + 192])] = mem[_1867 + 224 len floor32(mem[_1867 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3329 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1936) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1936) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1936) + ceil32(return_data.size) + 260] = _3329
                        mem[(32 * _1936) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1936) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1936) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1936) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1936) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3329, Array(len=2, data=mem[(32 * _1936) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1936) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1936) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4523 = mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1936) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1936) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1936) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1936) + ceil32(return_data.size) + 224]
                        mem[(32 * _1936) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4523 + (32 * _1936) + ceil32(return_data.size) + 224])] = mem[_4523 + (32 * _1936) + ceil32(return_data.size) + 256 len floor32(mem[_4523 + (32 * _1936) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1936) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1936) + (2 * ceil32(return_data.size)) + 288] <= _3329:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3329
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3329 > mem[(32 * _1936) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1936) + (2 * ceil32(return_data.size)) + 288] - _3329
            else:
                if not arg2:
                    if not arg2:
                        _1869 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1937 = mem[_1869 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1869 + 192])] = mem[_1869 + 224 len floor32(mem[_1869 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3333 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1937) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1937) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1937) + ceil32(return_data.size) + 260] = _3333
                        mem[(32 * _1937) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1937) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1937) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1937) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1937) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3333, Array(len=2, data=mem[(32 * _1937) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1937) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1937) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4525 = mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1937) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1937) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1937) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1937) + ceil32(return_data.size) + 224]
                        mem[(32 * _1937) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4525 + (32 * _1937) + ceil32(return_data.size) + 224])] = mem[_4525 + (32 * _1937) + ceil32(return_data.size) + 256 len floor32(mem[_4525 + (32 * _1937) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1937) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1937) + (2 * ceil32(return_data.size)) + 288] <= _3333:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3333
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3333 > mem[(32 * _1937) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1937) + (2 * ceil32(return_data.size)) + 288] - _3333
                    else:
                        _1871 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1938 = mem[_1871 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1871 + 192])] = mem[_1871 + 224 len floor32(mem[_1871 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3337 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1938) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1938) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1938) + ceil32(return_data.size) + 260] = _3337
                        mem[(32 * _1938) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1938) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1938) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1938) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1938) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3337, Array(len=2, data=mem[(32 * _1938) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1938) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1938) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4527 = mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1938) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1938) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1938) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1938) + ceil32(return_data.size) + 224]
                        mem[(32 * _1938) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4527 + (32 * _1938) + ceil32(return_data.size) + 224])] = mem[_4527 + (32 * _1938) + ceil32(return_data.size) + 256 len floor32(mem[_4527 + (32 * _1938) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1938) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1938) + (2 * ceil32(return_data.size)) + 288] <= _3337:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3337
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3337 > mem[(32 * _1938) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1938) + (2 * ceil32(return_data.size)) + 288] - _3337
                else:
                    if not arg2:
                        _1873 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1939 = mem[_1873 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1873 + 192])] = mem[_1873 + 224 len floor32(mem[_1873 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3341 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1939) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1939) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1939) + ceil32(return_data.size) + 260] = _3341
                        mem[(32 * _1939) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1939) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1939) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1939) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1939) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3341, Array(len=2, data=mem[(32 * _1939) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1939) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1939) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4529 = mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1939) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1939) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1939) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1939) + ceil32(return_data.size) + 224]
                        mem[(32 * _1939) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4529 + (32 * _1939) + ceil32(return_data.size) + 224])] = mem[_4529 + (32 * _1939) + ceil32(return_data.size) + 256 len floor32(mem[_4529 + (32 * _1939) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1939) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1939) + (2 * ceil32(return_data.size)) + 288] <= _3341:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3341
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3341 > mem[(32 * _1939) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1939) + (2 * ceil32(return_data.size)) + 288] - _3341
                    else:
                        _1875 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1940 = mem[_1875 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1875 + 192])] = mem[_1875 + 224 len floor32(mem[_1875 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3345 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1940) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1940) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1940) + ceil32(return_data.size) + 260] = _3345
                        mem[(32 * _1940) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1940) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1940) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1940) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1940) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3345, Array(len=2, data=mem[(32 * _1940) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1940) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1940) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4531 = mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1940) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1940) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1940) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1940) + ceil32(return_data.size) + 224]
                        mem[(32 * _1940) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4531 + (32 * _1940) + ceil32(return_data.size) + 224])] = mem[_4531 + (32 * _1940) + ceil32(return_data.size) + 256 len floor32(mem[_4531 + (32 * _1940) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1940) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1940) + (2 * ceil32(return_data.size)) + 288] <= _3345:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3345
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3345 > mem[(32 * _1940) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1940) + (2 * ceil32(return_data.size)) + 288] - _3345
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
}

function swapV2Call(address arg1, uint256 arg2, uint256 arg3, bytes arg4) {
    require calldata.size - 4 >= 128
    require arg4 <= 4294967296
    require arg4 + 36 <= calldata.size
    require arg4.length <= 4294967296 and arg4 + arg4.length + 36 <= calldata.size
    require ext_code.size(msg.sender)
    staticcall msg.sender.token0() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_code.size(msg.sender)
    staticcall msg.sender.token1() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if not arg2:
        if not arg2:
            if arg1 != this.address:
                revert with 0, '!sender'
            mem[96] = 2
            mem[128] = address(ext_call.return_data[0])
            mem[160] = address(ext_call.return_data[0])
            require arg4.length >= 64
            require ext_code.size(address(ext_call.return_data[0]))
            call address(ext_call.return_data[0]).approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args address(cd[(arg4 + 68)]), arg3
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[192] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
            mem[196] = arg3
            mem[228] = 64
            mem[260] = 2
            mem[292 len 0] = None
            require ext_code.size(address(cd[(arg4 + 36)]))
            staticcall address(cd[(arg4 + 36)]).getAmountsIn(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args arg3, Array(len=2, data=mem[292 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[192 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(return_data.size) + 192
            require return_data.size >= 32
            if not arg2:
                if not arg2:
                    if not arg2:
                        _1813 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1909 = mem[_1813 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1813 + 192])] = mem[_1813 + 224 len floor32(mem[_1813 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3221 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1909) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1909) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1909) + ceil32(return_data.size) + 260] = _3221
                        mem[(32 * _1909) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1909) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1909) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1909) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1909) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3221, Array(len=2, data=mem[(32 * _1909) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1909) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1909) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4469 = mem[(32 * _1909) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1909) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1909) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1909) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1909) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1909) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1909) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1909) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1909) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1909) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1909) + ceil32(return_data.size) + 224]
                        mem[(32 * _1909) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4469 + (32 * _1909) + ceil32(return_data.size) + 224])] = mem[_4469 + (32 * _1909) + ceil32(return_data.size) + 256 len floor32(mem[_4469 + (32 * _1909) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1909) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1909) + (2 * ceil32(return_data.size)) + 288] <= _3221:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3221
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3221 > mem[(32 * _1909) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1909) + (2 * ceil32(return_data.size)) + 288] - _3221
                    else:
                        _1815 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1910 = mem[_1815 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1815 + 192])] = mem[_1815 + 224 len floor32(mem[_1815 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3225 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1910) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1910) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1910) + ceil32(return_data.size) + 260] = _3225
                        mem[(32 * _1910) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1910) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1910) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1910) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1910) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3225, Array(len=2, data=mem[(32 * _1910) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1910) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1910) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4471 = mem[(32 * _1910) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1910) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1910) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1910) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1910) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1910) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1910) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1910) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1910) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1910) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1910) + ceil32(return_data.size) + 224]
                        mem[(32 * _1910) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4471 + (32 * _1910) + ceil32(return_data.size) + 224])] = mem[_4471 + (32 * _1910) + ceil32(return_data.size) + 256 len floor32(mem[_4471 + (32 * _1910) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1910) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1910) + (2 * ceil32(return_data.size)) + 288] <= _3225:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3225
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3225 > mem[(32 * _1910) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1910) + (2 * ceil32(return_data.size)) + 288] - _3225
                else:
                    if not arg2:
                        _1817 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1911 = mem[_1817 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1817 + 192])] = mem[_1817 + 224 len floor32(mem[_1817 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3229 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1911) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1911) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1911) + ceil32(return_data.size) + 260] = _3229
                        mem[(32 * _1911) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1911) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1911) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1911) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1911) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3229, Array(len=2, data=mem[(32 * _1911) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1911) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1911) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4473 = mem[(32 * _1911) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1911) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1911) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1911) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1911) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1911) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1911) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1911) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1911) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1911) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1911) + ceil32(return_data.size) + 224]
                        mem[(32 * _1911) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4473 + (32 * _1911) + ceil32(return_data.size) + 224])] = mem[_4473 + (32 * _1911) + ceil32(return_data.size) + 256 len floor32(mem[_4473 + (32 * _1911) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1911) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1911) + (2 * ceil32(return_data.size)) + 288] <= _3229:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3229
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3229 > mem[(32 * _1911) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1911) + (2 * ceil32(return_data.size)) + 288] - _3229
                    else:
                        _1819 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1912 = mem[_1819 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1819 + 192])] = mem[_1819 + 224 len floor32(mem[_1819 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3233 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1912) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1912) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1912) + ceil32(return_data.size) + 260] = _3233
                        mem[(32 * _1912) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1912) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1912) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1912) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1912) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3233, Array(len=2, data=mem[(32 * _1912) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1912) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1912) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4475 = mem[(32 * _1912) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1912) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1912) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1912) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1912) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1912) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1912) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1912) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1912) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1912) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1912) + ceil32(return_data.size) + 224]
                        mem[(32 * _1912) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4475 + (32 * _1912) + ceil32(return_data.size) + 224])] = mem[_4475 + (32 * _1912) + ceil32(return_data.size) + 256 len floor32(mem[_4475 + (32 * _1912) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1912) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1912) + (2 * ceil32(return_data.size)) + 288] <= _3233:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3233
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3233 > mem[(32 * _1912) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1912) + (2 * ceil32(return_data.size)) + 288] - _3233
            else:
                if not arg2:
                    if not arg2:
                        _1821 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1913 = mem[_1821 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1821 + 192])] = mem[_1821 + 224 len floor32(mem[_1821 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3237 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1913) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1913) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1913) + ceil32(return_data.size) + 260] = _3237
                        mem[(32 * _1913) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1913) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1913) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1913) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1913) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3237, Array(len=2, data=mem[(32 * _1913) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1913) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1913) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4477 = mem[(32 * _1913) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1913) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1913) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1913) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1913) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1913) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1913) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1913) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1913) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1913) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1913) + ceil32(return_data.size) + 224]
                        mem[(32 * _1913) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4477 + (32 * _1913) + ceil32(return_data.size) + 224])] = mem[_4477 + (32 * _1913) + ceil32(return_data.size) + 256 len floor32(mem[_4477 + (32 * _1913) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1913) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1913) + (2 * ceil32(return_data.size)) + 288] <= _3237:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3237
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3237 > mem[(32 * _1913) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1913) + (2 * ceil32(return_data.size)) + 288] - _3237
                    else:
                        _1823 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1914 = mem[_1823 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1823 + 192])] = mem[_1823 + 224 len floor32(mem[_1823 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3241 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1914) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1914) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1914) + ceil32(return_data.size) + 260] = _3241
                        mem[(32 * _1914) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1914) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1914) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1914) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1914) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3241, Array(len=2, data=mem[(32 * _1914) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1914) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1914) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4479 = mem[(32 * _1914) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1914) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1914) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1914) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1914) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1914) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1914) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1914) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1914) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1914) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1914) + ceil32(return_data.size) + 224]
                        mem[(32 * _1914) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4479 + (32 * _1914) + ceil32(return_data.size) + 224])] = mem[_4479 + (32 * _1914) + ceil32(return_data.size) + 256 len floor32(mem[_4479 + (32 * _1914) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1914) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1914) + (2 * ceil32(return_data.size)) + 288] <= _3241:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3241
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3241 > mem[(32 * _1914) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1914) + (2 * ceil32(return_data.size)) + 288] - _3241
                else:
                    if not arg2:
                        _1825 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1915 = mem[_1825 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1825 + 192])] = mem[_1825 + 224 len floor32(mem[_1825 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3245 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1915) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1915) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1915) + ceil32(return_data.size) + 260] = _3245
                        mem[(32 * _1915) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1915) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1915) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1915) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1915) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3245, Array(len=2, data=mem[(32 * _1915) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1915) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1915) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4481 = mem[(32 * _1915) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1915) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1915) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1915) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1915) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1915) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1915) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1915) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1915) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1915) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1915) + ceil32(return_data.size) + 224]
                        mem[(32 * _1915) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4481 + (32 * _1915) + ceil32(return_data.size) + 224])] = mem[_4481 + (32 * _1915) + ceil32(return_data.size) + 256 len floor32(mem[_4481 + (32 * _1915) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1915) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1915) + (2 * ceil32(return_data.size)) + 288] <= _3245:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3245
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3245 > mem[(32 * _1915) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1915) + (2 * ceil32(return_data.size)) + 288] - _3245
                    else:
                        _1827 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1916 = mem[_1827 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1827 + 192])] = mem[_1827 + 224 len floor32(mem[_1827 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3249 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1916) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1916) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1916) + ceil32(return_data.size) + 260] = _3249
                        mem[(32 * _1916) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1916) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1916) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1916) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1916) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3249, Array(len=2, data=mem[(32 * _1916) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1916) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1916) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4483 = mem[(32 * _1916) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1916) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1916) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1916) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1916) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1916) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1916) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1916) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1916) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1916) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1916) + ceil32(return_data.size) + 224]
                        mem[(32 * _1916) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4483 + (32 * _1916) + ceil32(return_data.size) + 224])] = mem[_4483 + (32 * _1916) + ceil32(return_data.size) + 256 len floor32(mem[_4483 + (32 * _1916) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1916) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1916) + (2 * ceil32(return_data.size)) + 288] <= _3249:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3249
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3249 > mem[(32 * _1916) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1916) + (2 * ceil32(return_data.size)) + 288] - _3249
        else:
            require not arg3
            if arg1 != this.address:
                revert with 0, '!sender'
            mem[96] = 2
            mem[128] = address(ext_call.return_data[0])
            mem[160] = address(ext_call.return_data[0])
            require arg4.length >= 64
            require ext_code.size(address(ext_call.return_data[0]))
            call address(ext_call.return_data[0]).approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args address(cd[(arg4 + 68)]), arg3
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[192] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
            mem[196] = arg3
            mem[228] = 64
            mem[260] = 2
            mem[292 len 0] = None
            require ext_code.size(address(cd[(arg4 + 36)]))
            staticcall address(cd[(arg4 + 36)]).getAmountsIn(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args arg3, Array(len=2, data=mem[292 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[192 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(return_data.size) + 192
            require return_data.size >= 32
            if not arg2:
                if not arg2:
                    if not arg2:
                        _1829 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1917 = mem[_1829 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1829 + 192])] = mem[_1829 + 224 len floor32(mem[_1829 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3253 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1917) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1917) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1917) + ceil32(return_data.size) + 260] = _3253
                        mem[(32 * _1917) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1917) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1917) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1917) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1917) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3253, Array(len=2, data=mem[(32 * _1917) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1917) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1917) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4485 = mem[(32 * _1917) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1917) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1917) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1917) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1917) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1917) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1917) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1917) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1917) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1917) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1917) + ceil32(return_data.size) + 224]
                        mem[(32 * _1917) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4485 + (32 * _1917) + ceil32(return_data.size) + 224])] = mem[_4485 + (32 * _1917) + ceil32(return_data.size) + 256 len floor32(mem[_4485 + (32 * _1917) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1917) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1917) + (2 * ceil32(return_data.size)) + 288] <= _3253:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3253
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3253 > mem[(32 * _1917) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1917) + (2 * ceil32(return_data.size)) + 288] - _3253
                    else:
                        _1831 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1918 = mem[_1831 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1831 + 192])] = mem[_1831 + 224 len floor32(mem[_1831 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3257 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1918) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1918) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1918) + ceil32(return_data.size) + 260] = _3257
                        mem[(32 * _1918) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1918) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1918) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1918) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1918) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3257, Array(len=2, data=mem[(32 * _1918) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1918) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1918) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4487 = mem[(32 * _1918) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1918) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1918) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1918) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1918) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1918) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1918) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1918) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1918) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1918) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1918) + ceil32(return_data.size) + 224]
                        mem[(32 * _1918) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4487 + (32 * _1918) + ceil32(return_data.size) + 224])] = mem[_4487 + (32 * _1918) + ceil32(return_data.size) + 256 len floor32(mem[_4487 + (32 * _1918) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1918) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1918) + (2 * ceil32(return_data.size)) + 288] <= _3257:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3257
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3257 > mem[(32 * _1918) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1918) + (2 * ceil32(return_data.size)) + 288] - _3257
                else:
                    if not arg2:
                        _1833 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1919 = mem[_1833 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1833 + 192])] = mem[_1833 + 224 len floor32(mem[_1833 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3261 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1919) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1919) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1919) + ceil32(return_data.size) + 260] = _3261
                        mem[(32 * _1919) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1919) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1919) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1919) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1919) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3261, Array(len=2, data=mem[(32 * _1919) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1919) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1919) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4489 = mem[(32 * _1919) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1919) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1919) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1919) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1919) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1919) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1919) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1919) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1919) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1919) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1919) + ceil32(return_data.size) + 224]
                        mem[(32 * _1919) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4489 + (32 * _1919) + ceil32(return_data.size) + 224])] = mem[_4489 + (32 * _1919) + ceil32(return_data.size) + 256 len floor32(mem[_4489 + (32 * _1919) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1919) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1919) + (2 * ceil32(return_data.size)) + 288] <= _3261:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3261
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3261 > mem[(32 * _1919) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1919) + (2 * ceil32(return_data.size)) + 288] - _3261
                    else:
                        _1835 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1920 = mem[_1835 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1835 + 192])] = mem[_1835 + 224 len floor32(mem[_1835 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3265 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1920) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1920) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1920) + ceil32(return_data.size) + 260] = _3265
                        mem[(32 * _1920) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1920) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1920) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1920) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1920) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3265, Array(len=2, data=mem[(32 * _1920) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1920) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1920) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4491 = mem[(32 * _1920) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1920) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1920) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1920) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1920) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1920) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1920) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1920) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1920) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1920) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1920) + ceil32(return_data.size) + 224]
                        mem[(32 * _1920) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4491 + (32 * _1920) + ceil32(return_data.size) + 224])] = mem[_4491 + (32 * _1920) + ceil32(return_data.size) + 256 len floor32(mem[_4491 + (32 * _1920) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1920) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1920) + (2 * ceil32(return_data.size)) + 288] <= _3265:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3265
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3265 > mem[(32 * _1920) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1920) + (2 * ceil32(return_data.size)) + 288] - _3265
            else:
                if not arg2:
                    if not arg2:
                        _1837 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1921 = mem[_1837 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1837 + 192])] = mem[_1837 + 224 len floor32(mem[_1837 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3269 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1921) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1921) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1921) + ceil32(return_data.size) + 260] = _3269
                        mem[(32 * _1921) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1921) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1921) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1921) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1921) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3269, Array(len=2, data=mem[(32 * _1921) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1921) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1921) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4493 = mem[(32 * _1921) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1921) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1921) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1921) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1921) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1921) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1921) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1921) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1921) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1921) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1921) + ceil32(return_data.size) + 224]
                        mem[(32 * _1921) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4493 + (32 * _1921) + ceil32(return_data.size) + 224])] = mem[_4493 + (32 * _1921) + ceil32(return_data.size) + 256 len floor32(mem[_4493 + (32 * _1921) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1921) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1921) + (2 * ceil32(return_data.size)) + 288] <= _3269:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3269
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3269 > mem[(32 * _1921) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1921) + (2 * ceil32(return_data.size)) + 288] - _3269
                    else:
                        _1839 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1922 = mem[_1839 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1839 + 192])] = mem[_1839 + 224 len floor32(mem[_1839 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3273 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1922) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1922) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1922) + ceil32(return_data.size) + 260] = _3273
                        mem[(32 * _1922) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1922) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1922) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1922) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1922) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3273, Array(len=2, data=mem[(32 * _1922) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1922) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1922) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4495 = mem[(32 * _1922) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1922) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1922) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1922) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1922) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1922) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1922) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1922) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1922) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1922) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1922) + ceil32(return_data.size) + 224]
                        mem[(32 * _1922) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4495 + (32 * _1922) + ceil32(return_data.size) + 224])] = mem[_4495 + (32 * _1922) + ceil32(return_data.size) + 256 len floor32(mem[_4495 + (32 * _1922) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1922) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1922) + (2 * ceil32(return_data.size)) + 288] <= _3273:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3273
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3273 > mem[(32 * _1922) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1922) + (2 * ceil32(return_data.size)) + 288] - _3273
                else:
                    if not arg2:
                        _1841 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1923 = mem[_1841 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1841 + 192])] = mem[_1841 + 224 len floor32(mem[_1841 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3277 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1923) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1923) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1923) + ceil32(return_data.size) + 260] = _3277
                        mem[(32 * _1923) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1923) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1923) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1923) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1923) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3277, Array(len=2, data=mem[(32 * _1923) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1923) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1923) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4497 = mem[(32 * _1923) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1923) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1923) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1923) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1923) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1923) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1923) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1923) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1923) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1923) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1923) + ceil32(return_data.size) + 224]
                        mem[(32 * _1923) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4497 + (32 * _1923) + ceil32(return_data.size) + 224])] = mem[_4497 + (32 * _1923) + ceil32(return_data.size) + 256 len floor32(mem[_4497 + (32 * _1923) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1923) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1923) + (2 * ceil32(return_data.size)) + 288] <= _3277:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3277
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3277 > mem[(32 * _1923) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1923) + (2 * ceil32(return_data.size)) + 288] - _3277
                    else:
                        _1843 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1924 = mem[_1843 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1843 + 192])] = mem[_1843 + 224 len floor32(mem[_1843 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3281 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1924) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1924) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1924) + ceil32(return_data.size) + 260] = _3281
                        mem[(32 * _1924) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1924) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1924) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1924) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1924) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3281, Array(len=2, data=mem[(32 * _1924) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1924) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1924) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4499 = mem[(32 * _1924) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1924) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1924) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1924) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1924) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1924) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1924) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1924) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1924) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1924) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1924) + ceil32(return_data.size) + 224]
                        mem[(32 * _1924) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4499 + (32 * _1924) + ceil32(return_data.size) + 224])] = mem[_4499 + (32 * _1924) + ceil32(return_data.size) + 256 len floor32(mem[_4499 + (32 * _1924) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1924) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1924) + (2 * ceil32(return_data.size)) + 288] <= _3281:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3281
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3281 > mem[(32 * _1924) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1924) + (2 * ceil32(return_data.size)) + 288] - _3281
    else:
        if not arg2:
            if arg1 != this.address:
                revert with 0, '!sender'
            mem[96] = 2
            mem[128] = address(ext_call.return_data[0])
            mem[160] = address(ext_call.return_data[0])
            require arg4.length >= 64
            require ext_code.size(address(ext_call.return_data[0]))
            call address(ext_call.return_data[0]).approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args address(cd[(arg4 + 68)]), arg2
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[192] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
            mem[196] = arg2
            mem[228] = 64
            mem[260] = 2
            mem[292 len 0] = None
            require ext_code.size(address(cd[(arg4 + 36)]))
            staticcall address(cd[(arg4 + 36)]).getAmountsIn(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args arg2, Array(len=2, data=mem[292 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[192 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(return_data.size) + 192
            require return_data.size >= 32
            if not arg2:
                if not arg2:
                    if not arg2:
                        _1845 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1925 = mem[_1845 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1845 + 192])] = mem[_1845 + 224 len floor32(mem[_1845 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3285 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1925) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1925) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1925) + ceil32(return_data.size) + 260] = _3285
                        mem[(32 * _1925) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1925) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1925) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1925) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1925) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3285, Array(len=2, data=mem[(32 * _1925) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1925) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1925) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4501 = mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1925) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1925) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1925) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1925) + ceil32(return_data.size) + 224]
                        mem[(32 * _1925) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4501 + (32 * _1925) + ceil32(return_data.size) + 224])] = mem[_4501 + (32 * _1925) + ceil32(return_data.size) + 256 len floor32(mem[_4501 + (32 * _1925) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1925) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1925) + (2 * ceil32(return_data.size)) + 288] <= _3285:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3285
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3285 > mem[(32 * _1925) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1925) + (2 * ceil32(return_data.size)) + 288] - _3285
                    else:
                        _1847 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1926 = mem[_1847 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1847 + 192])] = mem[_1847 + 224 len floor32(mem[_1847 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3289 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1926) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1926) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1926) + ceil32(return_data.size) + 260] = _3289
                        mem[(32 * _1926) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1926) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1926) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1926) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1926) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3289, Array(len=2, data=mem[(32 * _1926) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1926) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1926) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4503 = mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1926) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1926) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1926) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1926) + ceil32(return_data.size) + 224]
                        mem[(32 * _1926) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4503 + (32 * _1926) + ceil32(return_data.size) + 224])] = mem[_4503 + (32 * _1926) + ceil32(return_data.size) + 256 len floor32(mem[_4503 + (32 * _1926) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1926) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1926) + (2 * ceil32(return_data.size)) + 288] <= _3289:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3289
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3289 > mem[(32 * _1926) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1926) + (2 * ceil32(return_data.size)) + 288] - _3289
                else:
                    if not arg2:
                        _1849 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1927 = mem[_1849 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1849 + 192])] = mem[_1849 + 224 len floor32(mem[_1849 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3293 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1927) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1927) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1927) + ceil32(return_data.size) + 260] = _3293
                        mem[(32 * _1927) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1927) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1927) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1927) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1927) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3293, Array(len=2, data=mem[(32 * _1927) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1927) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1927) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4505 = mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1927) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1927) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1927) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1927) + ceil32(return_data.size) + 224]
                        mem[(32 * _1927) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4505 + (32 * _1927) + ceil32(return_data.size) + 224])] = mem[_4505 + (32 * _1927) + ceil32(return_data.size) + 256 len floor32(mem[_4505 + (32 * _1927) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1927) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1927) + (2 * ceil32(return_data.size)) + 288] <= _3293:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3293
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3293 > mem[(32 * _1927) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1927) + (2 * ceil32(return_data.size)) + 288] - _3293
                    else:
                        _1851 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1928 = mem[_1851 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1851 + 192])] = mem[_1851 + 224 len floor32(mem[_1851 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3297 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1928) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1928) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1928) + ceil32(return_data.size) + 260] = _3297
                        mem[(32 * _1928) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1928) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1928) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1928) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1928) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3297, Array(len=2, data=mem[(32 * _1928) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1928) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1928) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4507 = mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1928) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1928) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1928) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1928) + ceil32(return_data.size) + 224]
                        mem[(32 * _1928) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4507 + (32 * _1928) + ceil32(return_data.size) + 224])] = mem[_4507 + (32 * _1928) + ceil32(return_data.size) + 256 len floor32(mem[_4507 + (32 * _1928) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1928) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1928) + (2 * ceil32(return_data.size)) + 288] <= _3297:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3297
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3297 > mem[(32 * _1928) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1928) + (2 * ceil32(return_data.size)) + 288] - _3297
            else:
                if not arg2:
                    if not arg2:
                        _1853 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1929 = mem[_1853 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1853 + 192])] = mem[_1853 + 224 len floor32(mem[_1853 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3301 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1929) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1929) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1929) + ceil32(return_data.size) + 260] = _3301
                        mem[(32 * _1929) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1929) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1929) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1929) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1929) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3301, Array(len=2, data=mem[(32 * _1929) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1929) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1929) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4509 = mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1929) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1929) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1929) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1929) + ceil32(return_data.size) + 224]
                        mem[(32 * _1929) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4509 + (32 * _1929) + ceil32(return_data.size) + 224])] = mem[_4509 + (32 * _1929) + ceil32(return_data.size) + 256 len floor32(mem[_4509 + (32 * _1929) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1929) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1929) + (2 * ceil32(return_data.size)) + 288] <= _3301:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3301
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3301 > mem[(32 * _1929) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1929) + (2 * ceil32(return_data.size)) + 288] - _3301
                    else:
                        _1855 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1930 = mem[_1855 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1855 + 192])] = mem[_1855 + 224 len floor32(mem[_1855 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3305 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1930) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1930) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1930) + ceil32(return_data.size) + 260] = _3305
                        mem[(32 * _1930) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1930) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1930) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1930) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1930) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3305, Array(len=2, data=mem[(32 * _1930) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1930) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1930) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4511 = mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1930) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1930) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1930) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1930) + ceil32(return_data.size) + 224]
                        mem[(32 * _1930) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4511 + (32 * _1930) + ceil32(return_data.size) + 224])] = mem[_4511 + (32 * _1930) + ceil32(return_data.size) + 256 len floor32(mem[_4511 + (32 * _1930) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1930) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1930) + (2 * ceil32(return_data.size)) + 288] <= _3305:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3305
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3305 > mem[(32 * _1930) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1930) + (2 * ceil32(return_data.size)) + 288] - _3305
                else:
                    if not arg2:
                        _1857 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1931 = mem[_1857 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1857 + 192])] = mem[_1857 + 224 len floor32(mem[_1857 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3309 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1931) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1931) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1931) + ceil32(return_data.size) + 260] = _3309
                        mem[(32 * _1931) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1931) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1931) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1931) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1931) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3309, Array(len=2, data=mem[(32 * _1931) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1931) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1931) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4513 = mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1931) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1931) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1931) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1931) + ceil32(return_data.size) + 224]
                        mem[(32 * _1931) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4513 + (32 * _1931) + ceil32(return_data.size) + 224])] = mem[_4513 + (32 * _1931) + ceil32(return_data.size) + 256 len floor32(mem[_4513 + (32 * _1931) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1931) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1931) + (2 * ceil32(return_data.size)) + 288] <= _3309:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3309
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3309 > mem[(32 * _1931) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1931) + (2 * ceil32(return_data.size)) + 288] - _3309
                    else:
                        _1859 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1932 = mem[_1859 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1859 + 192])] = mem[_1859 + 224 len floor32(mem[_1859 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3313 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1932) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1932) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1932) + ceil32(return_data.size) + 260] = _3313
                        mem[(32 * _1932) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1932) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1932) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1932) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1932) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3313, Array(len=2, data=mem[(32 * _1932) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1932) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1932) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4515 = mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1932) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1932) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1932) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1932) + ceil32(return_data.size) + 224]
                        mem[(32 * _1932) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4515 + (32 * _1932) + ceil32(return_data.size) + 224])] = mem[_4515 + (32 * _1932) + ceil32(return_data.size) + 256 len floor32(mem[_4515 + (32 * _1932) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1932) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1932) + (2 * ceil32(return_data.size)) + 288] <= _3313:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3313
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3313 > mem[(32 * _1932) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1932) + (2 * ceil32(return_data.size)) + 288] - _3313
        else:
            require not arg3
            if arg1 != this.address:
                revert with 0, '!sender'
            mem[96] = 2
            mem[128] = address(ext_call.return_data[0])
            mem[160] = address(ext_call.return_data[0])
            require arg4.length >= 64
            require ext_code.size(address(ext_call.return_data[0]))
            call address(ext_call.return_data[0]).approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args address(cd[(arg4 + 68)]), arg2
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[192] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
            mem[196] = arg2
            mem[228] = 64
            mem[260] = 2
            mem[292 len 0] = None
            require ext_code.size(address(cd[(arg4 + 36)]))
            staticcall address(cd[(arg4 + 36)]).getAmountsIn(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args arg2, Array(len=2, data=mem[292 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[192 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(return_data.size) + 192
            require return_data.size >= 32
            if not arg2:
                if not arg2:
                    if not arg2:
                        _1861 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1933 = mem[_1861 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1861 + 192])] = mem[_1861 + 224 len floor32(mem[_1861 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3317 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1933) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1933) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1933) + ceil32(return_data.size) + 260] = _3317
                        mem[(32 * _1933) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1933) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1933) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1933) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1933) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3317, Array(len=2, data=mem[(32 * _1933) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1933) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1933) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4517 = mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1933) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1933) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1933) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1933) + ceil32(return_data.size) + 224]
                        mem[(32 * _1933) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4517 + (32 * _1933) + ceil32(return_data.size) + 224])] = mem[_4517 + (32 * _1933) + ceil32(return_data.size) + 256 len floor32(mem[_4517 + (32 * _1933) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1933) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1933) + (2 * ceil32(return_data.size)) + 288] <= _3317:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3317
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3317 > mem[(32 * _1933) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1933) + (2 * ceil32(return_data.size)) + 288] - _3317
                    else:
                        _1863 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1934 = mem[_1863 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1863 + 192])] = mem[_1863 + 224 len floor32(mem[_1863 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3321 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1934) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1934) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1934) + ceil32(return_data.size) + 260] = _3321
                        mem[(32 * _1934) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1934) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1934) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1934) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1934) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3321, Array(len=2, data=mem[(32 * _1934) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1934) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1934) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4519 = mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1934) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1934) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1934) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1934) + ceil32(return_data.size) + 224]
                        mem[(32 * _1934) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4519 + (32 * _1934) + ceil32(return_data.size) + 224])] = mem[_4519 + (32 * _1934) + ceil32(return_data.size) + 256 len floor32(mem[_4519 + (32 * _1934) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1934) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1934) + (2 * ceil32(return_data.size)) + 288] <= _3321:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3321
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3321 > mem[(32 * _1934) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1934) + (2 * ceil32(return_data.size)) + 288] - _3321
                else:
                    if not arg2:
                        _1865 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1935 = mem[_1865 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1865 + 192])] = mem[_1865 + 224 len floor32(mem[_1865 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3325 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1935) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1935) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1935) + ceil32(return_data.size) + 260] = _3325
                        mem[(32 * _1935) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1935) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1935) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1935) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1935) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3325, Array(len=2, data=mem[(32 * _1935) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1935) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1935) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4521 = mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1935) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1935) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1935) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1935) + ceil32(return_data.size) + 224]
                        mem[(32 * _1935) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4521 + (32 * _1935) + ceil32(return_data.size) + 224])] = mem[_4521 + (32 * _1935) + ceil32(return_data.size) + 256 len floor32(mem[_4521 + (32 * _1935) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1935) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1935) + (2 * ceil32(return_data.size)) + 288] <= _3325:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3325
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3325 > mem[(32 * _1935) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1935) + (2 * ceil32(return_data.size)) + 288] - _3325
                    else:
                        _1867 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1936 = mem[_1867 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1867 + 192])] = mem[_1867 + 224 len floor32(mem[_1867 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3329 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1936) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1936) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1936) + ceil32(return_data.size) + 260] = _3329
                        mem[(32 * _1936) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1936) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1936) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1936) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1936) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3329, Array(len=2, data=mem[(32 * _1936) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1936) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1936) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4523 = mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1936) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1936) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1936) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1936) + ceil32(return_data.size) + 224]
                        mem[(32 * _1936) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4523 + (32 * _1936) + ceil32(return_data.size) + 224])] = mem[_4523 + (32 * _1936) + ceil32(return_data.size) + 256 len floor32(mem[_4523 + (32 * _1936) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1936) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1936) + (2 * ceil32(return_data.size)) + 288] <= _3329:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3329
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3329 > mem[(32 * _1936) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1936) + (2 * ceil32(return_data.size)) + 288] - _3329
            else:
                if not arg2:
                    if not arg2:
                        _1869 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1937 = mem[_1869 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1869 + 192])] = mem[_1869 + 224 len floor32(mem[_1869 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3333 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1937) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1937) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1937) + ceil32(return_data.size) + 260] = _3333
                        mem[(32 * _1937) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1937) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1937) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1937) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1937) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3333, Array(len=2, data=mem[(32 * _1937) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1937) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1937) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4525 = mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1937) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1937) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1937) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1937) + ceil32(return_data.size) + 224]
                        mem[(32 * _1937) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4525 + (32 * _1937) + ceil32(return_data.size) + 224])] = mem[_4525 + (32 * _1937) + ceil32(return_data.size) + 256 len floor32(mem[_4525 + (32 * _1937) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1937) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1937) + (2 * ceil32(return_data.size)) + 288] <= _3333:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3333
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3333 > mem[(32 * _1937) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1937) + (2 * ceil32(return_data.size)) + 288] - _3333
                    else:
                        _1871 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1938 = mem[_1871 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1871 + 192])] = mem[_1871 + 224 len floor32(mem[_1871 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3337 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1938) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1938) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1938) + ceil32(return_data.size) + 260] = _3337
                        mem[(32 * _1938) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1938) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1938) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1938) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1938) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3337, Array(len=2, data=mem[(32 * _1938) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1938) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1938) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4527 = mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1938) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1938) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1938) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1938) + ceil32(return_data.size) + 224]
                        mem[(32 * _1938) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4527 + (32 * _1938) + ceil32(return_data.size) + 224])] = mem[_4527 + (32 * _1938) + ceil32(return_data.size) + 256 len floor32(mem[_4527 + (32 * _1938) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1938) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1938) + (2 * ceil32(return_data.size)) + 288] <= _3337:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3337
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3337 > mem[(32 * _1938) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1938) + (2 * ceil32(return_data.size)) + 288] - _3337
                else:
                    if not arg2:
                        _1873 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1939 = mem[_1873 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1873 + 192])] = mem[_1873 + 224 len floor32(mem[_1873 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3341 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1939) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1939) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1939) + ceil32(return_data.size) + 260] = _3341
                        mem[(32 * _1939) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1939) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1939) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1939) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1939) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3341, Array(len=2, data=mem[(32 * _1939) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1939) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1939) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4529 = mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1939) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1939) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1939) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1939) + ceil32(return_data.size) + 224]
                        mem[(32 * _1939) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4529 + (32 * _1939) + ceil32(return_data.size) + 224])] = mem[_4529 + (32 * _1939) + ceil32(return_data.size) + 256 len floor32(mem[_4529 + (32 * _1939) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1939) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1939) + (2 * ceil32(return_data.size)) + 288] <= _3341:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3341
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3341 > mem[(32 * _1939) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1939) + (2 * ceil32(return_data.size)) + 288] - _3341
                    else:
                        _1875 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1940 = mem[_1875 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1875 + 192])] = mem[_1875 + 224 len floor32(mem[_1875 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3345 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1940) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1940) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1940) + ceil32(return_data.size) + 260] = _3345
                        mem[(32 * _1940) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1940) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1940) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1940) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1940) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3345, Array(len=2, data=mem[(32 * _1940) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1940) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1940) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4531 = mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1940) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1940) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1940) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1940) + ceil32(return_data.size) + 224]
                        mem[(32 * _1940) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4531 + (32 * _1940) + ceil32(return_data.size) + 224])] = mem[_4531 + (32 * _1940) + ceil32(return_data.size) + 256 len floor32(mem[_4531 + (32 * _1940) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1940) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1940) + (2 * ceil32(return_data.size)) + 288] <= _3345:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3345
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3345 > mem[(32 * _1940) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1940) + (2 * ceil32(return_data.size)) + 288] - _3345
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
}

function pantherCall(address arg1, uint256 arg2, uint256 arg3, bytes arg4) {
    require calldata.size - 4 >= 128
    require arg4 <= 4294967296
    require arg4 + 36 <= calldata.size
    require arg4.length <= 4294967296 and arg4 + arg4.length + 36 <= calldata.size
    require ext_code.size(msg.sender)
    staticcall msg.sender.token0() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_code.size(msg.sender)
    staticcall msg.sender.token1() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if not arg2:
        if not arg2:
            if arg1 != this.address:
                revert with 0, '!sender'
            mem[96] = 2
            mem[128] = address(ext_call.return_data[0])
            mem[160] = address(ext_call.return_data[0])
            require arg4.length >= 64
            require ext_code.size(address(ext_call.return_data[0]))
            call address(ext_call.return_data[0]).approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args address(cd[(arg4 + 68)]), arg3
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[192] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
            mem[196] = arg3
            mem[228] = 64
            mem[260] = 2
            mem[292 len 0] = None
            require ext_code.size(address(cd[(arg4 + 36)]))
            staticcall address(cd[(arg4 + 36)]).getAmountsIn(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args arg3, Array(len=2, data=mem[292 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[192 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(return_data.size) + 192
            require return_data.size >= 32
            if not arg2:
                if not arg2:
                    if not arg2:
                        _1813 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1909 = mem[_1813 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1813 + 192])] = mem[_1813 + 224 len floor32(mem[_1813 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3221 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1909) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1909) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1909) + ceil32(return_data.size) + 260] = _3221
                        mem[(32 * _1909) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1909) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1909) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1909) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1909) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3221, Array(len=2, data=mem[(32 * _1909) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1909) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1909) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4469 = mem[(32 * _1909) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1909) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1909) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1909) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1909) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1909) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1909) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1909) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1909) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1909) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1909) + ceil32(return_data.size) + 224]
                        mem[(32 * _1909) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4469 + (32 * _1909) + ceil32(return_data.size) + 224])] = mem[_4469 + (32 * _1909) + ceil32(return_data.size) + 256 len floor32(mem[_4469 + (32 * _1909) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1909) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1909) + (2 * ceil32(return_data.size)) + 288] <= _3221:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3221
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3221 > mem[(32 * _1909) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1909) + (2 * ceil32(return_data.size)) + 288] - _3221
                    else:
                        _1815 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1910 = mem[_1815 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1815 + 192])] = mem[_1815 + 224 len floor32(mem[_1815 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3225 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1910) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1910) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1910) + ceil32(return_data.size) + 260] = _3225
                        mem[(32 * _1910) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1910) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1910) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1910) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1910) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3225, Array(len=2, data=mem[(32 * _1910) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1910) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1910) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4471 = mem[(32 * _1910) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1910) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1910) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1910) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1910) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1910) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1910) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1910) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1910) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1910) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1910) + ceil32(return_data.size) + 224]
                        mem[(32 * _1910) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4471 + (32 * _1910) + ceil32(return_data.size) + 224])] = mem[_4471 + (32 * _1910) + ceil32(return_data.size) + 256 len floor32(mem[_4471 + (32 * _1910) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1910) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1910) + (2 * ceil32(return_data.size)) + 288] <= _3225:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3225
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3225 > mem[(32 * _1910) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1910) + (2 * ceil32(return_data.size)) + 288] - _3225
                else:
                    if not arg2:
                        _1817 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1911 = mem[_1817 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1817 + 192])] = mem[_1817 + 224 len floor32(mem[_1817 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3229 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1911) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1911) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1911) + ceil32(return_data.size) + 260] = _3229
                        mem[(32 * _1911) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1911) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1911) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1911) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1911) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3229, Array(len=2, data=mem[(32 * _1911) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1911) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1911) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4473 = mem[(32 * _1911) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1911) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1911) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1911) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1911) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1911) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1911) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1911) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1911) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1911) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1911) + ceil32(return_data.size) + 224]
                        mem[(32 * _1911) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4473 + (32 * _1911) + ceil32(return_data.size) + 224])] = mem[_4473 + (32 * _1911) + ceil32(return_data.size) + 256 len floor32(mem[_4473 + (32 * _1911) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1911) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1911) + (2 * ceil32(return_data.size)) + 288] <= _3229:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3229
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3229 > mem[(32 * _1911) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1911) + (2 * ceil32(return_data.size)) + 288] - _3229
                    else:
                        _1819 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1912 = mem[_1819 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1819 + 192])] = mem[_1819 + 224 len floor32(mem[_1819 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3233 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1912) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1912) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1912) + ceil32(return_data.size) + 260] = _3233
                        mem[(32 * _1912) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1912) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1912) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1912) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1912) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3233, Array(len=2, data=mem[(32 * _1912) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1912) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1912) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4475 = mem[(32 * _1912) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1912) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1912) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1912) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1912) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1912) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1912) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1912) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1912) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1912) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1912) + ceil32(return_data.size) + 224]
                        mem[(32 * _1912) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4475 + (32 * _1912) + ceil32(return_data.size) + 224])] = mem[_4475 + (32 * _1912) + ceil32(return_data.size) + 256 len floor32(mem[_4475 + (32 * _1912) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1912) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1912) + (2 * ceil32(return_data.size)) + 288] <= _3233:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3233
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3233 > mem[(32 * _1912) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1912) + (2 * ceil32(return_data.size)) + 288] - _3233
            else:
                if not arg2:
                    if not arg2:
                        _1821 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1913 = mem[_1821 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1821 + 192])] = mem[_1821 + 224 len floor32(mem[_1821 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3237 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1913) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1913) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1913) + ceil32(return_data.size) + 260] = _3237
                        mem[(32 * _1913) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1913) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1913) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1913) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1913) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3237, Array(len=2, data=mem[(32 * _1913) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1913) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1913) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4477 = mem[(32 * _1913) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1913) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1913) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1913) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1913) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1913) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1913) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1913) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1913) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1913) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1913) + ceil32(return_data.size) + 224]
                        mem[(32 * _1913) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4477 + (32 * _1913) + ceil32(return_data.size) + 224])] = mem[_4477 + (32 * _1913) + ceil32(return_data.size) + 256 len floor32(mem[_4477 + (32 * _1913) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1913) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1913) + (2 * ceil32(return_data.size)) + 288] <= _3237:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3237
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3237 > mem[(32 * _1913) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1913) + (2 * ceil32(return_data.size)) + 288] - _3237
                    else:
                        _1823 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1914 = mem[_1823 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1823 + 192])] = mem[_1823 + 224 len floor32(mem[_1823 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3241 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1914) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1914) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1914) + ceil32(return_data.size) + 260] = _3241
                        mem[(32 * _1914) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1914) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1914) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1914) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1914) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3241, Array(len=2, data=mem[(32 * _1914) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1914) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1914) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4479 = mem[(32 * _1914) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1914) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1914) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1914) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1914) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1914) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1914) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1914) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1914) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1914) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1914) + ceil32(return_data.size) + 224]
                        mem[(32 * _1914) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4479 + (32 * _1914) + ceil32(return_data.size) + 224])] = mem[_4479 + (32 * _1914) + ceil32(return_data.size) + 256 len floor32(mem[_4479 + (32 * _1914) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1914) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1914) + (2 * ceil32(return_data.size)) + 288] <= _3241:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3241
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3241 > mem[(32 * _1914) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1914) + (2 * ceil32(return_data.size)) + 288] - _3241
                else:
                    if not arg2:
                        _1825 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1915 = mem[_1825 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1825 + 192])] = mem[_1825 + 224 len floor32(mem[_1825 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3245 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1915) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1915) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1915) + ceil32(return_data.size) + 260] = _3245
                        mem[(32 * _1915) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1915) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1915) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1915) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1915) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3245, Array(len=2, data=mem[(32 * _1915) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1915) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1915) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4481 = mem[(32 * _1915) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1915) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1915) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1915) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1915) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1915) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1915) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1915) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1915) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1915) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1915) + ceil32(return_data.size) + 224]
                        mem[(32 * _1915) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4481 + (32 * _1915) + ceil32(return_data.size) + 224])] = mem[_4481 + (32 * _1915) + ceil32(return_data.size) + 256 len floor32(mem[_4481 + (32 * _1915) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1915) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1915) + (2 * ceil32(return_data.size)) + 288] <= _3245:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3245
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3245 > mem[(32 * _1915) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1915) + (2 * ceil32(return_data.size)) + 288] - _3245
                    else:
                        _1827 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1916 = mem[_1827 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1827 + 192])] = mem[_1827 + 224 len floor32(mem[_1827 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3249 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1916) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1916) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1916) + ceil32(return_data.size) + 260] = _3249
                        mem[(32 * _1916) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1916) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1916) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1916) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1916) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3249, Array(len=2, data=mem[(32 * _1916) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1916) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1916) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4483 = mem[(32 * _1916) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1916) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1916) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1916) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1916) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1916) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1916) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1916) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1916) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1916) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1916) + ceil32(return_data.size) + 224]
                        mem[(32 * _1916) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4483 + (32 * _1916) + ceil32(return_data.size) + 224])] = mem[_4483 + (32 * _1916) + ceil32(return_data.size) + 256 len floor32(mem[_4483 + (32 * _1916) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1916) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1916) + (2 * ceil32(return_data.size)) + 288] <= _3249:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3249
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3249 > mem[(32 * _1916) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1916) + (2 * ceil32(return_data.size)) + 288] - _3249
        else:
            require not arg3
            if arg1 != this.address:
                revert with 0, '!sender'
            mem[96] = 2
            mem[128] = address(ext_call.return_data[0])
            mem[160] = address(ext_call.return_data[0])
            require arg4.length >= 64
            require ext_code.size(address(ext_call.return_data[0]))
            call address(ext_call.return_data[0]).approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args address(cd[(arg4 + 68)]), arg3
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[192] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
            mem[196] = arg3
            mem[228] = 64
            mem[260] = 2
            mem[292 len 0] = None
            require ext_code.size(address(cd[(arg4 + 36)]))
            staticcall address(cd[(arg4 + 36)]).getAmountsIn(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args arg3, Array(len=2, data=mem[292 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[192 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(return_data.size) + 192
            require return_data.size >= 32
            if not arg2:
                if not arg2:
                    if not arg2:
                        _1829 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1917 = mem[_1829 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1829 + 192])] = mem[_1829 + 224 len floor32(mem[_1829 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3253 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1917) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1917) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1917) + ceil32(return_data.size) + 260] = _3253
                        mem[(32 * _1917) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1917) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1917) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1917) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1917) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3253, Array(len=2, data=mem[(32 * _1917) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1917) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1917) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4485 = mem[(32 * _1917) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1917) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1917) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1917) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1917) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1917) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1917) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1917) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1917) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1917) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1917) + ceil32(return_data.size) + 224]
                        mem[(32 * _1917) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4485 + (32 * _1917) + ceil32(return_data.size) + 224])] = mem[_4485 + (32 * _1917) + ceil32(return_data.size) + 256 len floor32(mem[_4485 + (32 * _1917) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1917) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1917) + (2 * ceil32(return_data.size)) + 288] <= _3253:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3253
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3253 > mem[(32 * _1917) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1917) + (2 * ceil32(return_data.size)) + 288] - _3253
                    else:
                        _1831 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1918 = mem[_1831 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1831 + 192])] = mem[_1831 + 224 len floor32(mem[_1831 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3257 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1918) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1918) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1918) + ceil32(return_data.size) + 260] = _3257
                        mem[(32 * _1918) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1918) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1918) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1918) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1918) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3257, Array(len=2, data=mem[(32 * _1918) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1918) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1918) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4487 = mem[(32 * _1918) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1918) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1918) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1918) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1918) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1918) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1918) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1918) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1918) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1918) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1918) + ceil32(return_data.size) + 224]
                        mem[(32 * _1918) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4487 + (32 * _1918) + ceil32(return_data.size) + 224])] = mem[_4487 + (32 * _1918) + ceil32(return_data.size) + 256 len floor32(mem[_4487 + (32 * _1918) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1918) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1918) + (2 * ceil32(return_data.size)) + 288] <= _3257:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3257
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3257 > mem[(32 * _1918) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1918) + (2 * ceil32(return_data.size)) + 288] - _3257
                else:
                    if not arg2:
                        _1833 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1919 = mem[_1833 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1833 + 192])] = mem[_1833 + 224 len floor32(mem[_1833 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3261 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1919) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1919) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1919) + ceil32(return_data.size) + 260] = _3261
                        mem[(32 * _1919) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1919) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1919) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1919) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1919) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3261, Array(len=2, data=mem[(32 * _1919) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1919) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1919) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4489 = mem[(32 * _1919) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1919) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1919) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1919) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1919) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1919) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1919) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1919) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1919) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1919) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1919) + ceil32(return_data.size) + 224]
                        mem[(32 * _1919) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4489 + (32 * _1919) + ceil32(return_data.size) + 224])] = mem[_4489 + (32 * _1919) + ceil32(return_data.size) + 256 len floor32(mem[_4489 + (32 * _1919) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1919) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1919) + (2 * ceil32(return_data.size)) + 288] <= _3261:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3261
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3261 > mem[(32 * _1919) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1919) + (2 * ceil32(return_data.size)) + 288] - _3261
                    else:
                        _1835 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1920 = mem[_1835 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1835 + 192])] = mem[_1835 + 224 len floor32(mem[_1835 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3265 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1920) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1920) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1920) + ceil32(return_data.size) + 260] = _3265
                        mem[(32 * _1920) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1920) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1920) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1920) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1920) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3265, Array(len=2, data=mem[(32 * _1920) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1920) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1920) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4491 = mem[(32 * _1920) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1920) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1920) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1920) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1920) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1920) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1920) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1920) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1920) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1920) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1920) + ceil32(return_data.size) + 224]
                        mem[(32 * _1920) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4491 + (32 * _1920) + ceil32(return_data.size) + 224])] = mem[_4491 + (32 * _1920) + ceil32(return_data.size) + 256 len floor32(mem[_4491 + (32 * _1920) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1920) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1920) + (2 * ceil32(return_data.size)) + 288] <= _3265:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3265
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3265 > mem[(32 * _1920) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1920) + (2 * ceil32(return_data.size)) + 288] - _3265
            else:
                if not arg2:
                    if not arg2:
                        _1837 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1921 = mem[_1837 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1837 + 192])] = mem[_1837 + 224 len floor32(mem[_1837 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3269 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1921) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1921) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1921) + ceil32(return_data.size) + 260] = _3269
                        mem[(32 * _1921) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1921) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1921) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1921) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1921) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3269, Array(len=2, data=mem[(32 * _1921) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1921) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1921) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4493 = mem[(32 * _1921) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1921) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1921) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1921) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1921) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1921) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1921) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1921) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1921) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1921) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1921) + ceil32(return_data.size) + 224]
                        mem[(32 * _1921) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4493 + (32 * _1921) + ceil32(return_data.size) + 224])] = mem[_4493 + (32 * _1921) + ceil32(return_data.size) + 256 len floor32(mem[_4493 + (32 * _1921) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1921) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1921) + (2 * ceil32(return_data.size)) + 288] <= _3269:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3269
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3269 > mem[(32 * _1921) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1921) + (2 * ceil32(return_data.size)) + 288] - _3269
                    else:
                        _1839 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1922 = mem[_1839 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1839 + 192])] = mem[_1839 + 224 len floor32(mem[_1839 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3273 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1922) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1922) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1922) + ceil32(return_data.size) + 260] = _3273
                        mem[(32 * _1922) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1922) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1922) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1922) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1922) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3273, Array(len=2, data=mem[(32 * _1922) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1922) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1922) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4495 = mem[(32 * _1922) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1922) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1922) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1922) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1922) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1922) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1922) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1922) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1922) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1922) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1922) + ceil32(return_data.size) + 224]
                        mem[(32 * _1922) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4495 + (32 * _1922) + ceil32(return_data.size) + 224])] = mem[_4495 + (32 * _1922) + ceil32(return_data.size) + 256 len floor32(mem[_4495 + (32 * _1922) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1922) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1922) + (2 * ceil32(return_data.size)) + 288] <= _3273:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3273
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3273 > mem[(32 * _1922) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1922) + (2 * ceil32(return_data.size)) + 288] - _3273
                else:
                    if not arg2:
                        _1841 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1923 = mem[_1841 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1841 + 192])] = mem[_1841 + 224 len floor32(mem[_1841 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3277 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1923) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1923) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1923) + ceil32(return_data.size) + 260] = _3277
                        mem[(32 * _1923) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1923) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1923) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1923) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1923) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3277, Array(len=2, data=mem[(32 * _1923) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1923) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1923) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4497 = mem[(32 * _1923) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1923) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1923) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1923) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1923) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1923) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1923) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1923) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1923) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1923) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1923) + ceil32(return_data.size) + 224]
                        mem[(32 * _1923) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4497 + (32 * _1923) + ceil32(return_data.size) + 224])] = mem[_4497 + (32 * _1923) + ceil32(return_data.size) + 256 len floor32(mem[_4497 + (32 * _1923) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1923) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1923) + (2 * ceil32(return_data.size)) + 288] <= _3277:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3277
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3277 > mem[(32 * _1923) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1923) + (2 * ceil32(return_data.size)) + 288] - _3277
                    else:
                        _1843 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1924 = mem[_1843 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1843 + 192])] = mem[_1843 + 224 len floor32(mem[_1843 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3281 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1924) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1924) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1924) + ceil32(return_data.size) + 260] = _3281
                        mem[(32 * _1924) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1924) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1924) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1924) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1924) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3281, Array(len=2, data=mem[(32 * _1924) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1924) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1924) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4499 = mem[(32 * _1924) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1924) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1924) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1924) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1924) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1924) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1924) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1924) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1924) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1924) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1924) + ceil32(return_data.size) + 224]
                        mem[(32 * _1924) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4499 + (32 * _1924) + ceil32(return_data.size) + 224])] = mem[_4499 + (32 * _1924) + ceil32(return_data.size) + 256 len floor32(mem[_4499 + (32 * _1924) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1924) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1924) + (2 * ceil32(return_data.size)) + 288] <= _3281:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3281
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3281 > mem[(32 * _1924) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1924) + (2 * ceil32(return_data.size)) + 288] - _3281
    else:
        if not arg2:
            if arg1 != this.address:
                revert with 0, '!sender'
            mem[96] = 2
            mem[128] = address(ext_call.return_data[0])
            mem[160] = address(ext_call.return_data[0])
            require arg4.length >= 64
            require ext_code.size(address(ext_call.return_data[0]))
            call address(ext_call.return_data[0]).approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args address(cd[(arg4 + 68)]), arg2
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[192] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
            mem[196] = arg2
            mem[228] = 64
            mem[260] = 2
            mem[292 len 0] = None
            require ext_code.size(address(cd[(arg4 + 36)]))
            staticcall address(cd[(arg4 + 36)]).getAmountsIn(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args arg2, Array(len=2, data=mem[292 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[192 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(return_data.size) + 192
            require return_data.size >= 32
            if not arg2:
                if not arg2:
                    if not arg2:
                        _1845 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1925 = mem[_1845 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1845 + 192])] = mem[_1845 + 224 len floor32(mem[_1845 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3285 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1925) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1925) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1925) + ceil32(return_data.size) + 260] = _3285
                        mem[(32 * _1925) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1925) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1925) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1925) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1925) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3285, Array(len=2, data=mem[(32 * _1925) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1925) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1925) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4501 = mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1925) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1925) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1925) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1925) + ceil32(return_data.size) + 224]
                        mem[(32 * _1925) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4501 + (32 * _1925) + ceil32(return_data.size) + 224])] = mem[_4501 + (32 * _1925) + ceil32(return_data.size) + 256 len floor32(mem[_4501 + (32 * _1925) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1925) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1925) + (2 * ceil32(return_data.size)) + 288] <= _3285:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3285
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3285 > mem[(32 * _1925) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1925) + (2 * ceil32(return_data.size)) + 288] - _3285
                    else:
                        _1847 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1926 = mem[_1847 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1847 + 192])] = mem[_1847 + 224 len floor32(mem[_1847 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3289 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1926) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1926) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1926) + ceil32(return_data.size) + 260] = _3289
                        mem[(32 * _1926) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1926) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1926) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1926) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1926) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3289, Array(len=2, data=mem[(32 * _1926) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1926) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1926) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4503 = mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1926) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1926) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1926) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1926) + ceil32(return_data.size) + 224]
                        mem[(32 * _1926) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4503 + (32 * _1926) + ceil32(return_data.size) + 224])] = mem[_4503 + (32 * _1926) + ceil32(return_data.size) + 256 len floor32(mem[_4503 + (32 * _1926) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1926) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1926) + (2 * ceil32(return_data.size)) + 288] <= _3289:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3289
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3289 > mem[(32 * _1926) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1926) + (2 * ceil32(return_data.size)) + 288] - _3289
                else:
                    if not arg2:
                        _1849 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1927 = mem[_1849 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1849 + 192])] = mem[_1849 + 224 len floor32(mem[_1849 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3293 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1927) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1927) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1927) + ceil32(return_data.size) + 260] = _3293
                        mem[(32 * _1927) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1927) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1927) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1927) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1927) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3293, Array(len=2, data=mem[(32 * _1927) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1927) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1927) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4505 = mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1927) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1927) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1927) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1927) + ceil32(return_data.size) + 224]
                        mem[(32 * _1927) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4505 + (32 * _1927) + ceil32(return_data.size) + 224])] = mem[_4505 + (32 * _1927) + ceil32(return_data.size) + 256 len floor32(mem[_4505 + (32 * _1927) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1927) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1927) + (2 * ceil32(return_data.size)) + 288] <= _3293:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3293
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3293 > mem[(32 * _1927) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1927) + (2 * ceil32(return_data.size)) + 288] - _3293
                    else:
                        _1851 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1928 = mem[_1851 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1851 + 192])] = mem[_1851 + 224 len floor32(mem[_1851 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3297 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1928) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1928) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1928) + ceil32(return_data.size) + 260] = _3297
                        mem[(32 * _1928) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1928) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1928) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1928) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1928) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3297, Array(len=2, data=mem[(32 * _1928) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1928) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1928) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4507 = mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1928) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1928) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1928) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1928) + ceil32(return_data.size) + 224]
                        mem[(32 * _1928) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4507 + (32 * _1928) + ceil32(return_data.size) + 224])] = mem[_4507 + (32 * _1928) + ceil32(return_data.size) + 256 len floor32(mem[_4507 + (32 * _1928) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1928) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1928) + (2 * ceil32(return_data.size)) + 288] <= _3297:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3297
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3297 > mem[(32 * _1928) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1928) + (2 * ceil32(return_data.size)) + 288] - _3297
            else:
                if not arg2:
                    if not arg2:
                        _1853 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1929 = mem[_1853 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1853 + 192])] = mem[_1853 + 224 len floor32(mem[_1853 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3301 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1929) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1929) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1929) + ceil32(return_data.size) + 260] = _3301
                        mem[(32 * _1929) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1929) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1929) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1929) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1929) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3301, Array(len=2, data=mem[(32 * _1929) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1929) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1929) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4509 = mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1929) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1929) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1929) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1929) + ceil32(return_data.size) + 224]
                        mem[(32 * _1929) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4509 + (32 * _1929) + ceil32(return_data.size) + 224])] = mem[_4509 + (32 * _1929) + ceil32(return_data.size) + 256 len floor32(mem[_4509 + (32 * _1929) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1929) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1929) + (2 * ceil32(return_data.size)) + 288] <= _3301:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3301
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3301 > mem[(32 * _1929) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1929) + (2 * ceil32(return_data.size)) + 288] - _3301
                    else:
                        _1855 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1930 = mem[_1855 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1855 + 192])] = mem[_1855 + 224 len floor32(mem[_1855 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3305 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1930) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1930) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1930) + ceil32(return_data.size) + 260] = _3305
                        mem[(32 * _1930) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1930) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1930) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1930) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1930) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3305, Array(len=2, data=mem[(32 * _1930) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1930) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1930) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4511 = mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1930) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1930) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1930) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1930) + ceil32(return_data.size) + 224]
                        mem[(32 * _1930) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4511 + (32 * _1930) + ceil32(return_data.size) + 224])] = mem[_4511 + (32 * _1930) + ceil32(return_data.size) + 256 len floor32(mem[_4511 + (32 * _1930) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1930) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1930) + (2 * ceil32(return_data.size)) + 288] <= _3305:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3305
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3305 > mem[(32 * _1930) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1930) + (2 * ceil32(return_data.size)) + 288] - _3305
                else:
                    if not arg2:
                        _1857 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1931 = mem[_1857 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1857 + 192])] = mem[_1857 + 224 len floor32(mem[_1857 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3309 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1931) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1931) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1931) + ceil32(return_data.size) + 260] = _3309
                        mem[(32 * _1931) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1931) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1931) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1931) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1931) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3309, Array(len=2, data=mem[(32 * _1931) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1931) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1931) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4513 = mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1931) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1931) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1931) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1931) + ceil32(return_data.size) + 224]
                        mem[(32 * _1931) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4513 + (32 * _1931) + ceil32(return_data.size) + 224])] = mem[_4513 + (32 * _1931) + ceil32(return_data.size) + 256 len floor32(mem[_4513 + (32 * _1931) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1931) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1931) + (2 * ceil32(return_data.size)) + 288] <= _3309:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3309
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3309 > mem[(32 * _1931) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1931) + (2 * ceil32(return_data.size)) + 288] - _3309
                    else:
                        _1859 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1932 = mem[_1859 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1859 + 192])] = mem[_1859 + 224 len floor32(mem[_1859 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3313 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1932) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1932) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1932) + ceil32(return_data.size) + 260] = _3313
                        mem[(32 * _1932) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1932) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1932) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1932) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1932) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3313, Array(len=2, data=mem[(32 * _1932) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1932) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1932) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4515 = mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1932) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1932) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1932) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1932) + ceil32(return_data.size) + 224]
                        mem[(32 * _1932) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4515 + (32 * _1932) + ceil32(return_data.size) + 224])] = mem[_4515 + (32 * _1932) + ceil32(return_data.size) + 256 len floor32(mem[_4515 + (32 * _1932) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1932) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1932) + (2 * ceil32(return_data.size)) + 288] <= _3313:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3313
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3313 > mem[(32 * _1932) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1932) + (2 * ceil32(return_data.size)) + 288] - _3313
        else:
            require not arg3
            if arg1 != this.address:
                revert with 0, '!sender'
            mem[96] = 2
            mem[128] = address(ext_call.return_data[0])
            mem[160] = address(ext_call.return_data[0])
            require arg4.length >= 64
            require ext_code.size(address(ext_call.return_data[0]))
            call address(ext_call.return_data[0]).approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args address(cd[(arg4 + 68)]), arg2
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[192] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
            mem[196] = arg2
            mem[228] = 64
            mem[260] = 2
            mem[292 len 0] = None
            require ext_code.size(address(cd[(arg4 + 36)]))
            staticcall address(cd[(arg4 + 36)]).getAmountsIn(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args arg2, Array(len=2, data=mem[292 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[192 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(return_data.size) + 192
            require return_data.size >= 32
            if not arg2:
                if not arg2:
                    if not arg2:
                        _1861 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1933 = mem[_1861 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1861 + 192])] = mem[_1861 + 224 len floor32(mem[_1861 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3317 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1933) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1933) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1933) + ceil32(return_data.size) + 260] = _3317
                        mem[(32 * _1933) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1933) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1933) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1933) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1933) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3317, Array(len=2, data=mem[(32 * _1933) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1933) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1933) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4517 = mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1933) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1933) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1933) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1933) + ceil32(return_data.size) + 224]
                        mem[(32 * _1933) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4517 + (32 * _1933) + ceil32(return_data.size) + 224])] = mem[_4517 + (32 * _1933) + ceil32(return_data.size) + 256 len floor32(mem[_4517 + (32 * _1933) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1933) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1933) + (2 * ceil32(return_data.size)) + 288] <= _3317:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3317
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3317 > mem[(32 * _1933) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1933) + (2 * ceil32(return_data.size)) + 288] - _3317
                    else:
                        _1863 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1934 = mem[_1863 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1863 + 192])] = mem[_1863 + 224 len floor32(mem[_1863 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3321 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1934) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1934) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1934) + ceil32(return_data.size) + 260] = _3321
                        mem[(32 * _1934) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1934) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1934) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1934) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1934) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3321, Array(len=2, data=mem[(32 * _1934) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1934) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1934) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4519 = mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1934) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1934) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1934) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1934) + ceil32(return_data.size) + 224]
                        mem[(32 * _1934) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4519 + (32 * _1934) + ceil32(return_data.size) + 224])] = mem[_4519 + (32 * _1934) + ceil32(return_data.size) + 256 len floor32(mem[_4519 + (32 * _1934) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1934) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1934) + (2 * ceil32(return_data.size)) + 288] <= _3321:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3321
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3321 > mem[(32 * _1934) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1934) + (2 * ceil32(return_data.size)) + 288] - _3321
                else:
                    if not arg2:
                        _1865 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1935 = mem[_1865 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1865 + 192])] = mem[_1865 + 224 len floor32(mem[_1865 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3325 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1935) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1935) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1935) + ceil32(return_data.size) + 260] = _3325
                        mem[(32 * _1935) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1935) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1935) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1935) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1935) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3325, Array(len=2, data=mem[(32 * _1935) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1935) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1935) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4521 = mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1935) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1935) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1935) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1935) + ceil32(return_data.size) + 224]
                        mem[(32 * _1935) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4521 + (32 * _1935) + ceil32(return_data.size) + 224])] = mem[_4521 + (32 * _1935) + ceil32(return_data.size) + 256 len floor32(mem[_4521 + (32 * _1935) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1935) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1935) + (2 * ceil32(return_data.size)) + 288] <= _3325:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3325
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3325 > mem[(32 * _1935) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1935) + (2 * ceil32(return_data.size)) + 288] - _3325
                    else:
                        _1867 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1936 = mem[_1867 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1867 + 192])] = mem[_1867 + 224 len floor32(mem[_1867 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3329 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1936) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1936) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1936) + ceil32(return_data.size) + 260] = _3329
                        mem[(32 * _1936) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1936) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1936) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1936) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1936) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3329, Array(len=2, data=mem[(32 * _1936) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1936) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1936) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4523 = mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1936) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1936) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1936) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1936) + ceil32(return_data.size) + 224]
                        mem[(32 * _1936) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4523 + (32 * _1936) + ceil32(return_data.size) + 224])] = mem[_4523 + (32 * _1936) + ceil32(return_data.size) + 256 len floor32(mem[_4523 + (32 * _1936) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1936) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1936) + (2 * ceil32(return_data.size)) + 288] <= _3329:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3329
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3329 > mem[(32 * _1936) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1936) + (2 * ceil32(return_data.size)) + 288] - _3329
            else:
                if not arg2:
                    if not arg2:
                        _1869 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1937 = mem[_1869 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1869 + 192])] = mem[_1869 + 224 len floor32(mem[_1869 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3333 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1937) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1937) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1937) + ceil32(return_data.size) + 260] = _3333
                        mem[(32 * _1937) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1937) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1937) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1937) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1937) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3333, Array(len=2, data=mem[(32 * _1937) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1937) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1937) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4525 = mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1937) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1937) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1937) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1937) + ceil32(return_data.size) + 224]
                        mem[(32 * _1937) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4525 + (32 * _1937) + ceil32(return_data.size) + 224])] = mem[_4525 + (32 * _1937) + ceil32(return_data.size) + 256 len floor32(mem[_4525 + (32 * _1937) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1937) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1937) + (2 * ceil32(return_data.size)) + 288] <= _3333:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3333
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3333 > mem[(32 * _1937) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1937) + (2 * ceil32(return_data.size)) + 288] - _3333
                    else:
                        _1871 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1938 = mem[_1871 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1871 + 192])] = mem[_1871 + 224 len floor32(mem[_1871 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3337 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1938) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1938) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1938) + ceil32(return_data.size) + 260] = _3337
                        mem[(32 * _1938) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1938) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1938) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1938) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1938) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3337, Array(len=2, data=mem[(32 * _1938) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1938) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1938) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4527 = mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1938) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1938) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1938) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1938) + ceil32(return_data.size) + 224]
                        mem[(32 * _1938) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4527 + (32 * _1938) + ceil32(return_data.size) + 224])] = mem[_4527 + (32 * _1938) + ceil32(return_data.size) + 256 len floor32(mem[_4527 + (32 * _1938) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1938) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1938) + (2 * ceil32(return_data.size)) + 288] <= _3337:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3337
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3337 > mem[(32 * _1938) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1938) + (2 * ceil32(return_data.size)) + 288] - _3337
                else:
                    if not arg2:
                        _1873 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1939 = mem[_1873 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1873 + 192])] = mem[_1873 + 224 len floor32(mem[_1873 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3341 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1939) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1939) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1939) + ceil32(return_data.size) + 260] = _3341
                        mem[(32 * _1939) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1939) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1939) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1939) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1939) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3341, Array(len=2, data=mem[(32 * _1939) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1939) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1939) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4529 = mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1939) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1939) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1939) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1939) + ceil32(return_data.size) + 224]
                        mem[(32 * _1939) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4529 + (32 * _1939) + ceil32(return_data.size) + 224])] = mem[_4529 + (32 * _1939) + ceil32(return_data.size) + 256 len floor32(mem[_4529 + (32 * _1939) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1939) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1939) + (2 * ceil32(return_data.size)) + 288] <= _3341:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3341
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3341 > mem[(32 * _1939) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1939) + (2 * ceil32(return_data.size)) + 288] - _3341
                    else:
                        _1875 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1940 = mem[_1875 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1875 + 192])] = mem[_1875 + 224 len floor32(mem[_1875 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3345 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1940) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1940) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1940) + ceil32(return_data.size) + 260] = _3345
                        mem[(32 * _1940) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1940) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1940) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1940) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1940) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3345, Array(len=2, data=mem[(32 * _1940) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1940) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1940) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4531 = mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1940) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1940) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1940) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1940) + ceil32(return_data.size) + 224]
                        mem[(32 * _1940) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4531 + (32 * _1940) + ceil32(return_data.size) + 224])] = mem[_4531 + (32 * _1940) + ceil32(return_data.size) + 256 len floor32(mem[_4531 + (32 * _1940) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1940) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1940) + (2 * ceil32(return_data.size)) + 288] <= _3345:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3345
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3345 > mem[(32 * _1940) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1940) + (2 * ceil32(return_data.size)) + 288] - _3345
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
}

function jetswapCall(address arg1, uint256 arg2, uint256 arg3, bytes arg4) {
    require calldata.size - 4 >= 128
    require arg4 <= 4294967296
    require arg4 + 36 <= calldata.size
    require arg4.length <= 4294967296 and arg4 + arg4.length + 36 <= calldata.size
    require ext_code.size(msg.sender)
    staticcall msg.sender.token0() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_code.size(msg.sender)
    staticcall msg.sender.token1() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if not arg2:
        if not arg2:
            if arg1 != this.address:
                revert with 0, '!sender'
            mem[96] = 2
            mem[128] = address(ext_call.return_data[0])
            mem[160] = address(ext_call.return_data[0])
            require arg4.length >= 64
            require ext_code.size(address(ext_call.return_data[0]))
            call address(ext_call.return_data[0]).approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args address(cd[(arg4 + 68)]), arg3
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[192] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
            mem[196] = arg3
            mem[228] = 64
            mem[260] = 2
            mem[292 len 0] = None
            require ext_code.size(address(cd[(arg4 + 36)]))
            staticcall address(cd[(arg4 + 36)]).getAmountsIn(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args arg3, Array(len=2, data=mem[292 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[192 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(return_data.size) + 192
            require return_data.size >= 32
            if not arg2:
                if not arg2:
                    if not arg2:
                        _1813 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1909 = mem[_1813 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1813 + 192])] = mem[_1813 + 224 len floor32(mem[_1813 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3221 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1909) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1909) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1909) + ceil32(return_data.size) + 260] = _3221
                        mem[(32 * _1909) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1909) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1909) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1909) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1909) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3221, Array(len=2, data=mem[(32 * _1909) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1909) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1909) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4469 = mem[(32 * _1909) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1909) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1909) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1909) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1909) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1909) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1909) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1909) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1909) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1909) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1909) + ceil32(return_data.size) + 224]
                        mem[(32 * _1909) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4469 + (32 * _1909) + ceil32(return_data.size) + 224])] = mem[_4469 + (32 * _1909) + ceil32(return_data.size) + 256 len floor32(mem[_4469 + (32 * _1909) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1909) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1909) + (2 * ceil32(return_data.size)) + 288] <= _3221:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3221
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3221 > mem[(32 * _1909) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1909) + (2 * ceil32(return_data.size)) + 288] - _3221
                    else:
                        _1815 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1910 = mem[_1815 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1815 + 192])] = mem[_1815 + 224 len floor32(mem[_1815 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3225 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1910) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1910) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1910) + ceil32(return_data.size) + 260] = _3225
                        mem[(32 * _1910) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1910) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1910) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1910) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1910) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3225, Array(len=2, data=mem[(32 * _1910) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1910) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1910) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4471 = mem[(32 * _1910) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1910) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1910) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1910) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1910) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1910) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1910) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1910) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1910) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1910) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1910) + ceil32(return_data.size) + 224]
                        mem[(32 * _1910) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4471 + (32 * _1910) + ceil32(return_data.size) + 224])] = mem[_4471 + (32 * _1910) + ceil32(return_data.size) + 256 len floor32(mem[_4471 + (32 * _1910) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1910) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1910) + (2 * ceil32(return_data.size)) + 288] <= _3225:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3225
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3225 > mem[(32 * _1910) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1910) + (2 * ceil32(return_data.size)) + 288] - _3225
                else:
                    if not arg2:
                        _1817 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1911 = mem[_1817 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1817 + 192])] = mem[_1817 + 224 len floor32(mem[_1817 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3229 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1911) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1911) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1911) + ceil32(return_data.size) + 260] = _3229
                        mem[(32 * _1911) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1911) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1911) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1911) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1911) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3229, Array(len=2, data=mem[(32 * _1911) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1911) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1911) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4473 = mem[(32 * _1911) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1911) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1911) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1911) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1911) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1911) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1911) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1911) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1911) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1911) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1911) + ceil32(return_data.size) + 224]
                        mem[(32 * _1911) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4473 + (32 * _1911) + ceil32(return_data.size) + 224])] = mem[_4473 + (32 * _1911) + ceil32(return_data.size) + 256 len floor32(mem[_4473 + (32 * _1911) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1911) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1911) + (2 * ceil32(return_data.size)) + 288] <= _3229:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3229
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3229 > mem[(32 * _1911) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1911) + (2 * ceil32(return_data.size)) + 288] - _3229
                    else:
                        _1819 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1912 = mem[_1819 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1819 + 192])] = mem[_1819 + 224 len floor32(mem[_1819 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3233 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1912) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1912) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1912) + ceil32(return_data.size) + 260] = _3233
                        mem[(32 * _1912) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1912) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1912) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1912) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1912) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3233, Array(len=2, data=mem[(32 * _1912) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1912) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1912) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4475 = mem[(32 * _1912) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1912) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1912) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1912) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1912) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1912) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1912) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1912) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1912) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1912) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1912) + ceil32(return_data.size) + 224]
                        mem[(32 * _1912) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4475 + (32 * _1912) + ceil32(return_data.size) + 224])] = mem[_4475 + (32 * _1912) + ceil32(return_data.size) + 256 len floor32(mem[_4475 + (32 * _1912) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1912) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1912) + (2 * ceil32(return_data.size)) + 288] <= _3233:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3233
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3233 > mem[(32 * _1912) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1912) + (2 * ceil32(return_data.size)) + 288] - _3233
            else:
                if not arg2:
                    if not arg2:
                        _1821 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1913 = mem[_1821 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1821 + 192])] = mem[_1821 + 224 len floor32(mem[_1821 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3237 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1913) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1913) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1913) + ceil32(return_data.size) + 260] = _3237
                        mem[(32 * _1913) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1913) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1913) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1913) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1913) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3237, Array(len=2, data=mem[(32 * _1913) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1913) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1913) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4477 = mem[(32 * _1913) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1913) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1913) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1913) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1913) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1913) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1913) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1913) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1913) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1913) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1913) + ceil32(return_data.size) + 224]
                        mem[(32 * _1913) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4477 + (32 * _1913) + ceil32(return_data.size) + 224])] = mem[_4477 + (32 * _1913) + ceil32(return_data.size) + 256 len floor32(mem[_4477 + (32 * _1913) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1913) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1913) + (2 * ceil32(return_data.size)) + 288] <= _3237:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3237
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3237 > mem[(32 * _1913) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1913) + (2 * ceil32(return_data.size)) + 288] - _3237
                    else:
                        _1823 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1914 = mem[_1823 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1823 + 192])] = mem[_1823 + 224 len floor32(mem[_1823 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3241 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1914) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1914) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1914) + ceil32(return_data.size) + 260] = _3241
                        mem[(32 * _1914) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1914) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1914) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1914) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1914) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3241, Array(len=2, data=mem[(32 * _1914) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1914) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1914) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4479 = mem[(32 * _1914) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1914) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1914) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1914) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1914) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1914) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1914) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1914) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1914) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1914) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1914) + ceil32(return_data.size) + 224]
                        mem[(32 * _1914) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4479 + (32 * _1914) + ceil32(return_data.size) + 224])] = mem[_4479 + (32 * _1914) + ceil32(return_data.size) + 256 len floor32(mem[_4479 + (32 * _1914) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1914) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1914) + (2 * ceil32(return_data.size)) + 288] <= _3241:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3241
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3241 > mem[(32 * _1914) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1914) + (2 * ceil32(return_data.size)) + 288] - _3241
                else:
                    if not arg2:
                        _1825 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1915 = mem[_1825 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1825 + 192])] = mem[_1825 + 224 len floor32(mem[_1825 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3245 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1915) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1915) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1915) + ceil32(return_data.size) + 260] = _3245
                        mem[(32 * _1915) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1915) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1915) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1915) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1915) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3245, Array(len=2, data=mem[(32 * _1915) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1915) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1915) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4481 = mem[(32 * _1915) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1915) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1915) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1915) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1915) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1915) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1915) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1915) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1915) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1915) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1915) + ceil32(return_data.size) + 224]
                        mem[(32 * _1915) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4481 + (32 * _1915) + ceil32(return_data.size) + 224])] = mem[_4481 + (32 * _1915) + ceil32(return_data.size) + 256 len floor32(mem[_4481 + (32 * _1915) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1915) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1915) + (2 * ceil32(return_data.size)) + 288] <= _3245:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3245
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3245 > mem[(32 * _1915) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1915) + (2 * ceil32(return_data.size)) + 288] - _3245
                    else:
                        _1827 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1916 = mem[_1827 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1827 + 192])] = mem[_1827 + 224 len floor32(mem[_1827 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3249 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1916) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1916) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1916) + ceil32(return_data.size) + 260] = _3249
                        mem[(32 * _1916) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1916) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1916) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1916) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1916) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3249, Array(len=2, data=mem[(32 * _1916) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1916) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1916) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4483 = mem[(32 * _1916) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1916) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1916) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1916) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1916) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1916) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1916) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1916) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1916) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1916) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1916) + ceil32(return_data.size) + 224]
                        mem[(32 * _1916) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4483 + (32 * _1916) + ceil32(return_data.size) + 224])] = mem[_4483 + (32 * _1916) + ceil32(return_data.size) + 256 len floor32(mem[_4483 + (32 * _1916) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1916) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1916) + (2 * ceil32(return_data.size)) + 288] <= _3249:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3249
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3249 > mem[(32 * _1916) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1916) + (2 * ceil32(return_data.size)) + 288] - _3249
        else:
            require not arg3
            if arg1 != this.address:
                revert with 0, '!sender'
            mem[96] = 2
            mem[128] = address(ext_call.return_data[0])
            mem[160] = address(ext_call.return_data[0])
            require arg4.length >= 64
            require ext_code.size(address(ext_call.return_data[0]))
            call address(ext_call.return_data[0]).approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args address(cd[(arg4 + 68)]), arg3
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[192] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
            mem[196] = arg3
            mem[228] = 64
            mem[260] = 2
            mem[292 len 0] = None
            require ext_code.size(address(cd[(arg4 + 36)]))
            staticcall address(cd[(arg4 + 36)]).getAmountsIn(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args arg3, Array(len=2, data=mem[292 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[192 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(return_data.size) + 192
            require return_data.size >= 32
            if not arg2:
                if not arg2:
                    if not arg2:
                        _1829 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1917 = mem[_1829 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1829 + 192])] = mem[_1829 + 224 len floor32(mem[_1829 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3253 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1917) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1917) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1917) + ceil32(return_data.size) + 260] = _3253
                        mem[(32 * _1917) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1917) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1917) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1917) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1917) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3253, Array(len=2, data=mem[(32 * _1917) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1917) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1917) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4485 = mem[(32 * _1917) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1917) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1917) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1917) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1917) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1917) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1917) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1917) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1917) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1917) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1917) + ceil32(return_data.size) + 224]
                        mem[(32 * _1917) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4485 + (32 * _1917) + ceil32(return_data.size) + 224])] = mem[_4485 + (32 * _1917) + ceil32(return_data.size) + 256 len floor32(mem[_4485 + (32 * _1917) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1917) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1917) + (2 * ceil32(return_data.size)) + 288] <= _3253:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3253
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3253 > mem[(32 * _1917) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1917) + (2 * ceil32(return_data.size)) + 288] - _3253
                    else:
                        _1831 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1918 = mem[_1831 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1831 + 192])] = mem[_1831 + 224 len floor32(mem[_1831 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3257 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1918) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1918) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1918) + ceil32(return_data.size) + 260] = _3257
                        mem[(32 * _1918) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1918) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1918) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1918) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1918) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3257, Array(len=2, data=mem[(32 * _1918) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1918) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1918) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4487 = mem[(32 * _1918) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1918) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1918) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1918) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1918) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1918) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1918) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1918) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1918) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1918) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1918) + ceil32(return_data.size) + 224]
                        mem[(32 * _1918) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4487 + (32 * _1918) + ceil32(return_data.size) + 224])] = mem[_4487 + (32 * _1918) + ceil32(return_data.size) + 256 len floor32(mem[_4487 + (32 * _1918) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1918) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1918) + (2 * ceil32(return_data.size)) + 288] <= _3257:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3257
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3257 > mem[(32 * _1918) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1918) + (2 * ceil32(return_data.size)) + 288] - _3257
                else:
                    if not arg2:
                        _1833 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1919 = mem[_1833 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1833 + 192])] = mem[_1833 + 224 len floor32(mem[_1833 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3261 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1919) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1919) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1919) + ceil32(return_data.size) + 260] = _3261
                        mem[(32 * _1919) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1919) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1919) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1919) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1919) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3261, Array(len=2, data=mem[(32 * _1919) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1919) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1919) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4489 = mem[(32 * _1919) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1919) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1919) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1919) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1919) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1919) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1919) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1919) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1919) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1919) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1919) + ceil32(return_data.size) + 224]
                        mem[(32 * _1919) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4489 + (32 * _1919) + ceil32(return_data.size) + 224])] = mem[_4489 + (32 * _1919) + ceil32(return_data.size) + 256 len floor32(mem[_4489 + (32 * _1919) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1919) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1919) + (2 * ceil32(return_data.size)) + 288] <= _3261:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3261
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3261 > mem[(32 * _1919) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1919) + (2 * ceil32(return_data.size)) + 288] - _3261
                    else:
                        _1835 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1920 = mem[_1835 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1835 + 192])] = mem[_1835 + 224 len floor32(mem[_1835 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3265 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1920) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1920) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1920) + ceil32(return_data.size) + 260] = _3265
                        mem[(32 * _1920) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1920) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1920) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1920) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1920) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3265, Array(len=2, data=mem[(32 * _1920) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1920) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1920) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4491 = mem[(32 * _1920) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1920) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1920) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1920) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1920) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1920) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1920) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1920) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1920) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1920) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1920) + ceil32(return_data.size) + 224]
                        mem[(32 * _1920) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4491 + (32 * _1920) + ceil32(return_data.size) + 224])] = mem[_4491 + (32 * _1920) + ceil32(return_data.size) + 256 len floor32(mem[_4491 + (32 * _1920) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1920) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1920) + (2 * ceil32(return_data.size)) + 288] <= _3265:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3265
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3265 > mem[(32 * _1920) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1920) + (2 * ceil32(return_data.size)) + 288] - _3265
            else:
                if not arg2:
                    if not arg2:
                        _1837 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1921 = mem[_1837 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1837 + 192])] = mem[_1837 + 224 len floor32(mem[_1837 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3269 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1921) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1921) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1921) + ceil32(return_data.size) + 260] = _3269
                        mem[(32 * _1921) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1921) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1921) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1921) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1921) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3269, Array(len=2, data=mem[(32 * _1921) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1921) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1921) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4493 = mem[(32 * _1921) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1921) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1921) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1921) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1921) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1921) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1921) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1921) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1921) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1921) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1921) + ceil32(return_data.size) + 224]
                        mem[(32 * _1921) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4493 + (32 * _1921) + ceil32(return_data.size) + 224])] = mem[_4493 + (32 * _1921) + ceil32(return_data.size) + 256 len floor32(mem[_4493 + (32 * _1921) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1921) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1921) + (2 * ceil32(return_data.size)) + 288] <= _3269:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3269
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3269 > mem[(32 * _1921) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1921) + (2 * ceil32(return_data.size)) + 288] - _3269
                    else:
                        _1839 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1922 = mem[_1839 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1839 + 192])] = mem[_1839 + 224 len floor32(mem[_1839 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3273 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1922) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1922) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1922) + ceil32(return_data.size) + 260] = _3273
                        mem[(32 * _1922) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1922) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1922) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1922) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1922) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3273, Array(len=2, data=mem[(32 * _1922) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1922) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1922) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4495 = mem[(32 * _1922) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1922) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1922) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1922) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1922) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1922) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1922) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1922) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1922) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1922) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1922) + ceil32(return_data.size) + 224]
                        mem[(32 * _1922) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4495 + (32 * _1922) + ceil32(return_data.size) + 224])] = mem[_4495 + (32 * _1922) + ceil32(return_data.size) + 256 len floor32(mem[_4495 + (32 * _1922) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1922) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1922) + (2 * ceil32(return_data.size)) + 288] <= _3273:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3273
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3273 > mem[(32 * _1922) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1922) + (2 * ceil32(return_data.size)) + 288] - _3273
                else:
                    if not arg2:
                        _1841 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1923 = mem[_1841 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1841 + 192])] = mem[_1841 + 224 len floor32(mem[_1841 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3277 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1923) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1923) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1923) + ceil32(return_data.size) + 260] = _3277
                        mem[(32 * _1923) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1923) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1923) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1923) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1923) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3277, Array(len=2, data=mem[(32 * _1923) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1923) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1923) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4497 = mem[(32 * _1923) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1923) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1923) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1923) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1923) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1923) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1923) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1923) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1923) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1923) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1923) + ceil32(return_data.size) + 224]
                        mem[(32 * _1923) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4497 + (32 * _1923) + ceil32(return_data.size) + 224])] = mem[_4497 + (32 * _1923) + ceil32(return_data.size) + 256 len floor32(mem[_4497 + (32 * _1923) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1923) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1923) + (2 * ceil32(return_data.size)) + 288] <= _3277:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3277
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3277 > mem[(32 * _1923) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1923) + (2 * ceil32(return_data.size)) + 288] - _3277
                    else:
                        _1843 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1924 = mem[_1843 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1843 + 192])] = mem[_1843 + 224 len floor32(mem[_1843 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3281 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1924) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1924) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1924) + ceil32(return_data.size) + 260] = _3281
                        mem[(32 * _1924) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1924) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1924) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1924) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1924) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3281, Array(len=2, data=mem[(32 * _1924) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1924) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1924) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4499 = mem[(32 * _1924) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1924) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1924) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1924) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1924) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1924) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1924) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1924) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1924) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1924) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1924) + ceil32(return_data.size) + 224]
                        mem[(32 * _1924) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4499 + (32 * _1924) + ceil32(return_data.size) + 224])] = mem[_4499 + (32 * _1924) + ceil32(return_data.size) + 256 len floor32(mem[_4499 + (32 * _1924) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1924) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1924) + (2 * ceil32(return_data.size)) + 288] <= _3281:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3281
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3281 > mem[(32 * _1924) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1924) + (2 * ceil32(return_data.size)) + 288] - _3281
    else:
        if not arg2:
            if arg1 != this.address:
                revert with 0, '!sender'
            mem[96] = 2
            mem[128] = address(ext_call.return_data[0])
            mem[160] = address(ext_call.return_data[0])
            require arg4.length >= 64
            require ext_code.size(address(ext_call.return_data[0]))
            call address(ext_call.return_data[0]).approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args address(cd[(arg4 + 68)]), arg2
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[192] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
            mem[196] = arg2
            mem[228] = 64
            mem[260] = 2
            mem[292 len 0] = None
            require ext_code.size(address(cd[(arg4 + 36)]))
            staticcall address(cd[(arg4 + 36)]).getAmountsIn(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args arg2, Array(len=2, data=mem[292 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[192 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(return_data.size) + 192
            require return_data.size >= 32
            if not arg2:
                if not arg2:
                    if not arg2:
                        _1845 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1925 = mem[_1845 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1845 + 192])] = mem[_1845 + 224 len floor32(mem[_1845 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3285 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1925) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1925) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1925) + ceil32(return_data.size) + 260] = _3285
                        mem[(32 * _1925) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1925) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1925) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1925) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1925) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3285, Array(len=2, data=mem[(32 * _1925) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1925) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1925) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4501 = mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1925) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1925) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1925) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1925) + ceil32(return_data.size) + 224]
                        mem[(32 * _1925) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4501 + (32 * _1925) + ceil32(return_data.size) + 224])] = mem[_4501 + (32 * _1925) + ceil32(return_data.size) + 256 len floor32(mem[_4501 + (32 * _1925) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1925) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1925) + (2 * ceil32(return_data.size)) + 288] <= _3285:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3285
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3285 > mem[(32 * _1925) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1925) + (2 * ceil32(return_data.size)) + 288] - _3285
                    else:
                        _1847 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1926 = mem[_1847 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1847 + 192])] = mem[_1847 + 224 len floor32(mem[_1847 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3289 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1926) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1926) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1926) + ceil32(return_data.size) + 260] = _3289
                        mem[(32 * _1926) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1926) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1926) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1926) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1926) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3289, Array(len=2, data=mem[(32 * _1926) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1926) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1926) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4503 = mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1926) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1926) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1926) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1926) + ceil32(return_data.size) + 224]
                        mem[(32 * _1926) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4503 + (32 * _1926) + ceil32(return_data.size) + 224])] = mem[_4503 + (32 * _1926) + ceil32(return_data.size) + 256 len floor32(mem[_4503 + (32 * _1926) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1926) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1926) + (2 * ceil32(return_data.size)) + 288] <= _3289:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3289
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3289 > mem[(32 * _1926) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1926) + (2 * ceil32(return_data.size)) + 288] - _3289
                else:
                    if not arg2:
                        _1849 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1927 = mem[_1849 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1849 + 192])] = mem[_1849 + 224 len floor32(mem[_1849 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3293 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1927) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1927) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1927) + ceil32(return_data.size) + 260] = _3293
                        mem[(32 * _1927) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1927) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1927) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1927) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1927) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3293, Array(len=2, data=mem[(32 * _1927) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1927) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1927) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4505 = mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1927) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1927) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1927) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1927) + ceil32(return_data.size) + 224]
                        mem[(32 * _1927) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4505 + (32 * _1927) + ceil32(return_data.size) + 224])] = mem[_4505 + (32 * _1927) + ceil32(return_data.size) + 256 len floor32(mem[_4505 + (32 * _1927) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1927) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1927) + (2 * ceil32(return_data.size)) + 288] <= _3293:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3293
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3293 > mem[(32 * _1927) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1927) + (2 * ceil32(return_data.size)) + 288] - _3293
                    else:
                        _1851 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1928 = mem[_1851 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1851 + 192])] = mem[_1851 + 224 len floor32(mem[_1851 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3297 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1928) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1928) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1928) + ceil32(return_data.size) + 260] = _3297
                        mem[(32 * _1928) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1928) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1928) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1928) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1928) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3297, Array(len=2, data=mem[(32 * _1928) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1928) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1928) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4507 = mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1928) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1928) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1928) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1928) + ceil32(return_data.size) + 224]
                        mem[(32 * _1928) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4507 + (32 * _1928) + ceil32(return_data.size) + 224])] = mem[_4507 + (32 * _1928) + ceil32(return_data.size) + 256 len floor32(mem[_4507 + (32 * _1928) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1928) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1928) + (2 * ceil32(return_data.size)) + 288] <= _3297:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3297
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3297 > mem[(32 * _1928) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1928) + (2 * ceil32(return_data.size)) + 288] - _3297
            else:
                if not arg2:
                    if not arg2:
                        _1853 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1929 = mem[_1853 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1853 + 192])] = mem[_1853 + 224 len floor32(mem[_1853 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3301 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1929) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1929) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1929) + ceil32(return_data.size) + 260] = _3301
                        mem[(32 * _1929) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1929) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1929) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1929) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1929) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3301, Array(len=2, data=mem[(32 * _1929) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1929) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1929) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4509 = mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1929) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1929) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1929) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1929) + ceil32(return_data.size) + 224]
                        mem[(32 * _1929) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4509 + (32 * _1929) + ceil32(return_data.size) + 224])] = mem[_4509 + (32 * _1929) + ceil32(return_data.size) + 256 len floor32(mem[_4509 + (32 * _1929) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1929) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1929) + (2 * ceil32(return_data.size)) + 288] <= _3301:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3301
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3301 > mem[(32 * _1929) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1929) + (2 * ceil32(return_data.size)) + 288] - _3301
                    else:
                        _1855 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1930 = mem[_1855 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1855 + 192])] = mem[_1855 + 224 len floor32(mem[_1855 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3305 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1930) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1930) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1930) + ceil32(return_data.size) + 260] = _3305
                        mem[(32 * _1930) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1930) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1930) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1930) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1930) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3305, Array(len=2, data=mem[(32 * _1930) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1930) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1930) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4511 = mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1930) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1930) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1930) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1930) + ceil32(return_data.size) + 224]
                        mem[(32 * _1930) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4511 + (32 * _1930) + ceil32(return_data.size) + 224])] = mem[_4511 + (32 * _1930) + ceil32(return_data.size) + 256 len floor32(mem[_4511 + (32 * _1930) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1930) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1930) + (2 * ceil32(return_data.size)) + 288] <= _3305:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3305
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3305 > mem[(32 * _1930) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1930) + (2 * ceil32(return_data.size)) + 288] - _3305
                else:
                    if not arg2:
                        _1857 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1931 = mem[_1857 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1857 + 192])] = mem[_1857 + 224 len floor32(mem[_1857 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3309 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1931) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1931) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1931) + ceil32(return_data.size) + 260] = _3309
                        mem[(32 * _1931) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1931) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1931) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1931) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1931) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3309, Array(len=2, data=mem[(32 * _1931) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1931) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1931) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4513 = mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1931) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1931) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1931) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1931) + ceil32(return_data.size) + 224]
                        mem[(32 * _1931) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4513 + (32 * _1931) + ceil32(return_data.size) + 224])] = mem[_4513 + (32 * _1931) + ceil32(return_data.size) + 256 len floor32(mem[_4513 + (32 * _1931) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1931) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1931) + (2 * ceil32(return_data.size)) + 288] <= _3309:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3309
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3309 > mem[(32 * _1931) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1931) + (2 * ceil32(return_data.size)) + 288] - _3309
                    else:
                        _1859 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1932 = mem[_1859 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1859 + 192])] = mem[_1859 + 224 len floor32(mem[_1859 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3313 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1932) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1932) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1932) + ceil32(return_data.size) + 260] = _3313
                        mem[(32 * _1932) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1932) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1932) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1932) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1932) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3313, Array(len=2, data=mem[(32 * _1932) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1932) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1932) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4515 = mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1932) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1932) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1932) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1932) + ceil32(return_data.size) + 224]
                        mem[(32 * _1932) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4515 + (32 * _1932) + ceil32(return_data.size) + 224])] = mem[_4515 + (32 * _1932) + ceil32(return_data.size) + 256 len floor32(mem[_4515 + (32 * _1932) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1932) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1932) + (2 * ceil32(return_data.size)) + 288] <= _3313:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3313
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3313 > mem[(32 * _1932) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1932) + (2 * ceil32(return_data.size)) + 288] - _3313
        else:
            require not arg3
            if arg1 != this.address:
                revert with 0, '!sender'
            mem[96] = 2
            mem[128] = address(ext_call.return_data[0])
            mem[160] = address(ext_call.return_data[0])
            require arg4.length >= 64
            require ext_code.size(address(ext_call.return_data[0]))
            call address(ext_call.return_data[0]).approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args address(cd[(arg4 + 68)]), arg2
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[192] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
            mem[196] = arg2
            mem[228] = 64
            mem[260] = 2
            mem[292 len 0] = None
            require ext_code.size(address(cd[(arg4 + 36)]))
            staticcall address(cd[(arg4 + 36)]).getAmountsIn(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args arg2, Array(len=2, data=mem[292 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[192 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(return_data.size) + 192
            require return_data.size >= 32
            if not arg2:
                if not arg2:
                    if not arg2:
                        _1861 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1933 = mem[_1861 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1861 + 192])] = mem[_1861 + 224 len floor32(mem[_1861 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3317 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1933) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1933) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1933) + ceil32(return_data.size) + 260] = _3317
                        mem[(32 * _1933) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1933) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1933) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1933) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1933) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3317, Array(len=2, data=mem[(32 * _1933) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1933) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1933) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4517 = mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1933) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1933) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1933) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1933) + ceil32(return_data.size) + 224]
                        mem[(32 * _1933) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4517 + (32 * _1933) + ceil32(return_data.size) + 224])] = mem[_4517 + (32 * _1933) + ceil32(return_data.size) + 256 len floor32(mem[_4517 + (32 * _1933) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1933) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1933) + (2 * ceil32(return_data.size)) + 288] <= _3317:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3317
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3317 > mem[(32 * _1933) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1933) + (2 * ceil32(return_data.size)) + 288] - _3317
                    else:
                        _1863 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1934 = mem[_1863 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1863 + 192])] = mem[_1863 + 224 len floor32(mem[_1863 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3321 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1934) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1934) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1934) + ceil32(return_data.size) + 260] = _3321
                        mem[(32 * _1934) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1934) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1934) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1934) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1934) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3321, Array(len=2, data=mem[(32 * _1934) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1934) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1934) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4519 = mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1934) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1934) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1934) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1934) + ceil32(return_data.size) + 224]
                        mem[(32 * _1934) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4519 + (32 * _1934) + ceil32(return_data.size) + 224])] = mem[_4519 + (32 * _1934) + ceil32(return_data.size) + 256 len floor32(mem[_4519 + (32 * _1934) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1934) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1934) + (2 * ceil32(return_data.size)) + 288] <= _3321:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3321
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3321 > mem[(32 * _1934) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1934) + (2 * ceil32(return_data.size)) + 288] - _3321
                else:
                    if not arg2:
                        _1865 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1935 = mem[_1865 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1865 + 192])] = mem[_1865 + 224 len floor32(mem[_1865 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3325 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1935) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1935) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1935) + ceil32(return_data.size) + 260] = _3325
                        mem[(32 * _1935) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1935) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1935) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1935) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1935) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3325, Array(len=2, data=mem[(32 * _1935) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1935) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1935) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4521 = mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1935) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1935) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1935) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1935) + ceil32(return_data.size) + 224]
                        mem[(32 * _1935) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4521 + (32 * _1935) + ceil32(return_data.size) + 224])] = mem[_4521 + (32 * _1935) + ceil32(return_data.size) + 256 len floor32(mem[_4521 + (32 * _1935) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1935) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1935) + (2 * ceil32(return_data.size)) + 288] <= _3325:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3325
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3325 > mem[(32 * _1935) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1935) + (2 * ceil32(return_data.size)) + 288] - _3325
                    else:
                        _1867 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1936 = mem[_1867 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1867 + 192])] = mem[_1867 + 224 len floor32(mem[_1867 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3329 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1936) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1936) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1936) + ceil32(return_data.size) + 260] = _3329
                        mem[(32 * _1936) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1936) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1936) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1936) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1936) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3329, Array(len=2, data=mem[(32 * _1936) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1936) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1936) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4523 = mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1936) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1936) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1936) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1936) + ceil32(return_data.size) + 224]
                        mem[(32 * _1936) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4523 + (32 * _1936) + ceil32(return_data.size) + 224])] = mem[_4523 + (32 * _1936) + ceil32(return_data.size) + 256 len floor32(mem[_4523 + (32 * _1936) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1936) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1936) + (2 * ceil32(return_data.size)) + 288] <= _3329:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3329
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3329 > mem[(32 * _1936) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1936) + (2 * ceil32(return_data.size)) + 288] - _3329
            else:
                if not arg2:
                    if not arg2:
                        _1869 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1937 = mem[_1869 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1869 + 192])] = mem[_1869 + 224 len floor32(mem[_1869 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3333 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1937) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1937) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1937) + ceil32(return_data.size) + 260] = _3333
                        mem[(32 * _1937) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1937) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1937) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1937) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1937) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3333, Array(len=2, data=mem[(32 * _1937) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1937) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1937) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4525 = mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1937) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1937) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1937) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1937) + ceil32(return_data.size) + 224]
                        mem[(32 * _1937) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4525 + (32 * _1937) + ceil32(return_data.size) + 224])] = mem[_4525 + (32 * _1937) + ceil32(return_data.size) + 256 len floor32(mem[_4525 + (32 * _1937) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1937) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1937) + (2 * ceil32(return_data.size)) + 288] <= _3333:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3333
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3333 > mem[(32 * _1937) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1937) + (2 * ceil32(return_data.size)) + 288] - _3333
                    else:
                        _1871 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1938 = mem[_1871 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1871 + 192])] = mem[_1871 + 224 len floor32(mem[_1871 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3337 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1938) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1938) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1938) + ceil32(return_data.size) + 260] = _3337
                        mem[(32 * _1938) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1938) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1938) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1938) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1938) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3337, Array(len=2, data=mem[(32 * _1938) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1938) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1938) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4527 = mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1938) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1938) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1938) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1938) + ceil32(return_data.size) + 224]
                        mem[(32 * _1938) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4527 + (32 * _1938) + ceil32(return_data.size) + 224])] = mem[_4527 + (32 * _1938) + ceil32(return_data.size) + 256 len floor32(mem[_4527 + (32 * _1938) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1938) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1938) + (2 * ceil32(return_data.size)) + 288] <= _3337:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3337
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3337 > mem[(32 * _1938) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1938) + (2 * ceil32(return_data.size)) + 288] - _3337
                else:
                    if not arg2:
                        _1873 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1939 = mem[_1873 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1873 + 192])] = mem[_1873 + 224 len floor32(mem[_1873 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3341 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1939) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1939) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1939) + ceil32(return_data.size) + 260] = _3341
                        mem[(32 * _1939) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1939) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1939) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1939) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1939) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3341, Array(len=2, data=mem[(32 * _1939) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1939) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1939) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4529 = mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1939) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1939) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1939) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1939) + ceil32(return_data.size) + 224]
                        mem[(32 * _1939) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4529 + (32 * _1939) + ceil32(return_data.size) + 224])] = mem[_4529 + (32 * _1939) + ceil32(return_data.size) + 256 len floor32(mem[_4529 + (32 * _1939) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1939) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1939) + (2 * ceil32(return_data.size)) + 288] <= _3341:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3341
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3341 > mem[(32 * _1939) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1939) + (2 * ceil32(return_data.size)) + 288] - _3341
                    else:
                        _1875 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1940 = mem[_1875 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1875 + 192])] = mem[_1875 + 224 len floor32(mem[_1875 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3345 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1940) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1940) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1940) + ceil32(return_data.size) + 260] = _3345
                        mem[(32 * _1940) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1940) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1940) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1940) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1940) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3345, Array(len=2, data=mem[(32 * _1940) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1940) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1940) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4531 = mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1940) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1940) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1940) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1940) + ceil32(return_data.size) + 224]
                        mem[(32 * _1940) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4531 + (32 * _1940) + ceil32(return_data.size) + 224])] = mem[_4531 + (32 * _1940) + ceil32(return_data.size) + 256 len floor32(mem[_4531 + (32 * _1940) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1940) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1940) + (2 * ceil32(return_data.size)) + 288] <= _3345:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3345
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3345 > mem[(32 * _1940) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1940) + (2 * ceil32(return_data.size)) + 288] - _3345
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
}

function pancakeCall(address arg1, uint256 arg2, uint256 arg3, bytes arg4) {
    require calldata.size - 4 >= 128
    require arg4 <= 4294967296
    require arg4 + 36 <= calldata.size
    require arg4.length <= 4294967296 and arg4 + arg4.length + 36 <= calldata.size
    require ext_code.size(msg.sender)
    staticcall msg.sender.token0() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_code.size(msg.sender)
    staticcall msg.sender.token1() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if not arg2:
        if not arg2:
            if arg1 != this.address:
                revert with 0, '!sender'
            mem[96] = 2
            mem[128] = address(ext_call.return_data[0])
            mem[160] = address(ext_call.return_data[0])
            require arg4.length >= 64
            require ext_code.size(address(ext_call.return_data[0]))
            call address(ext_call.return_data[0]).approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args address(cd[(arg4 + 68)]), arg3
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[192] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
            mem[196] = arg3
            mem[228] = 64
            mem[260] = 2
            mem[292 len 0] = None
            require ext_code.size(address(cd[(arg4 + 36)]))
            staticcall address(cd[(arg4 + 36)]).getAmountsIn(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args arg3, Array(len=2, data=mem[292 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[192 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(return_data.size) + 192
            require return_data.size >= 32
            if not arg2:
                if not arg2:
                    if not arg2:
                        _1813 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1909 = mem[_1813 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1813 + 192])] = mem[_1813 + 224 len floor32(mem[_1813 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3221 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1909) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1909) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1909) + ceil32(return_data.size) + 260] = _3221
                        mem[(32 * _1909) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1909) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1909) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1909) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1909) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3221, Array(len=2, data=mem[(32 * _1909) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1909) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1909) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4469 = mem[(32 * _1909) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1909) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1909) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1909) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1909) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1909) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1909) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1909) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1909) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1909) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1909) + ceil32(return_data.size) + 224]
                        mem[(32 * _1909) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4469 + (32 * _1909) + ceil32(return_data.size) + 224])] = mem[_4469 + (32 * _1909) + ceil32(return_data.size) + 256 len floor32(mem[_4469 + (32 * _1909) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1909) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1909) + (2 * ceil32(return_data.size)) + 288] <= _3221:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3221
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3221 > mem[(32 * _1909) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1909) + (2 * ceil32(return_data.size)) + 288] - _3221
                    else:
                        _1815 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1910 = mem[_1815 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1815 + 192])] = mem[_1815 + 224 len floor32(mem[_1815 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3225 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1910) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1910) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1910) + ceil32(return_data.size) + 260] = _3225
                        mem[(32 * _1910) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1910) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1910) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1910) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1910) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3225, Array(len=2, data=mem[(32 * _1910) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1910) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1910) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4471 = mem[(32 * _1910) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1910) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1910) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1910) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1910) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1910) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1910) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1910) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1910) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1910) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1910) + ceil32(return_data.size) + 224]
                        mem[(32 * _1910) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4471 + (32 * _1910) + ceil32(return_data.size) + 224])] = mem[_4471 + (32 * _1910) + ceil32(return_data.size) + 256 len floor32(mem[_4471 + (32 * _1910) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1910) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1910) + (2 * ceil32(return_data.size)) + 288] <= _3225:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3225
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3225 > mem[(32 * _1910) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1910) + (2 * ceil32(return_data.size)) + 288] - _3225
                else:
                    if not arg2:
                        _1817 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1911 = mem[_1817 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1817 + 192])] = mem[_1817 + 224 len floor32(mem[_1817 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3229 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1911) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1911) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1911) + ceil32(return_data.size) + 260] = _3229
                        mem[(32 * _1911) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1911) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1911) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1911) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1911) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3229, Array(len=2, data=mem[(32 * _1911) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1911) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1911) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4473 = mem[(32 * _1911) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1911) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1911) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1911) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1911) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1911) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1911) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1911) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1911) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1911) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1911) + ceil32(return_data.size) + 224]
                        mem[(32 * _1911) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4473 + (32 * _1911) + ceil32(return_data.size) + 224])] = mem[_4473 + (32 * _1911) + ceil32(return_data.size) + 256 len floor32(mem[_4473 + (32 * _1911) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1911) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1911) + (2 * ceil32(return_data.size)) + 288] <= _3229:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3229
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3229 > mem[(32 * _1911) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1911) + (2 * ceil32(return_data.size)) + 288] - _3229
                    else:
                        _1819 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1912 = mem[_1819 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1819 + 192])] = mem[_1819 + 224 len floor32(mem[_1819 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3233 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1912) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1912) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1912) + ceil32(return_data.size) + 260] = _3233
                        mem[(32 * _1912) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1912) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1912) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1912) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1912) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3233, Array(len=2, data=mem[(32 * _1912) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1912) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1912) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4475 = mem[(32 * _1912) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1912) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1912) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1912) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1912) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1912) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1912) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1912) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1912) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1912) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1912) + ceil32(return_data.size) + 224]
                        mem[(32 * _1912) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4475 + (32 * _1912) + ceil32(return_data.size) + 224])] = mem[_4475 + (32 * _1912) + ceil32(return_data.size) + 256 len floor32(mem[_4475 + (32 * _1912) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1912) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1912) + (2 * ceil32(return_data.size)) + 288] <= _3233:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3233
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3233 > mem[(32 * _1912) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1912) + (2 * ceil32(return_data.size)) + 288] - _3233
            else:
                if not arg2:
                    if not arg2:
                        _1821 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1913 = mem[_1821 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1821 + 192])] = mem[_1821 + 224 len floor32(mem[_1821 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3237 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1913) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1913) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1913) + ceil32(return_data.size) + 260] = _3237
                        mem[(32 * _1913) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1913) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1913) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1913) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1913) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3237, Array(len=2, data=mem[(32 * _1913) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1913) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1913) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4477 = mem[(32 * _1913) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1913) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1913) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1913) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1913) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1913) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1913) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1913) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1913) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1913) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1913) + ceil32(return_data.size) + 224]
                        mem[(32 * _1913) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4477 + (32 * _1913) + ceil32(return_data.size) + 224])] = mem[_4477 + (32 * _1913) + ceil32(return_data.size) + 256 len floor32(mem[_4477 + (32 * _1913) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1913) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1913) + (2 * ceil32(return_data.size)) + 288] <= _3237:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3237
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3237 > mem[(32 * _1913) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1913) + (2 * ceil32(return_data.size)) + 288] - _3237
                    else:
                        _1823 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1914 = mem[_1823 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1823 + 192])] = mem[_1823 + 224 len floor32(mem[_1823 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3241 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1914) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1914) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1914) + ceil32(return_data.size) + 260] = _3241
                        mem[(32 * _1914) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1914) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1914) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1914) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1914) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3241, Array(len=2, data=mem[(32 * _1914) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1914) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1914) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4479 = mem[(32 * _1914) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1914) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1914) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1914) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1914) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1914) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1914) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1914) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1914) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1914) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1914) + ceil32(return_data.size) + 224]
                        mem[(32 * _1914) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4479 + (32 * _1914) + ceil32(return_data.size) + 224])] = mem[_4479 + (32 * _1914) + ceil32(return_data.size) + 256 len floor32(mem[_4479 + (32 * _1914) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1914) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1914) + (2 * ceil32(return_data.size)) + 288] <= _3241:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3241
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3241 > mem[(32 * _1914) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1914) + (2 * ceil32(return_data.size)) + 288] - _3241
                else:
                    if not arg2:
                        _1825 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1915 = mem[_1825 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1825 + 192])] = mem[_1825 + 224 len floor32(mem[_1825 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3245 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1915) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1915) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1915) + ceil32(return_data.size) + 260] = _3245
                        mem[(32 * _1915) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1915) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1915) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1915) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1915) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3245, Array(len=2, data=mem[(32 * _1915) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1915) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1915) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4481 = mem[(32 * _1915) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1915) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1915) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1915) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1915) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1915) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1915) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1915) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1915) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1915) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1915) + ceil32(return_data.size) + 224]
                        mem[(32 * _1915) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4481 + (32 * _1915) + ceil32(return_data.size) + 224])] = mem[_4481 + (32 * _1915) + ceil32(return_data.size) + 256 len floor32(mem[_4481 + (32 * _1915) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1915) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1915) + (2 * ceil32(return_data.size)) + 288] <= _3245:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3245
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3245 > mem[(32 * _1915) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1915) + (2 * ceil32(return_data.size)) + 288] - _3245
                    else:
                        _1827 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1916 = mem[_1827 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1827 + 192])] = mem[_1827 + 224 len floor32(mem[_1827 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3249 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1916) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1916) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1916) + ceil32(return_data.size) + 260] = _3249
                        mem[(32 * _1916) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1916) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1916) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1916) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1916) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3249, Array(len=2, data=mem[(32 * _1916) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1916) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1916) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4483 = mem[(32 * _1916) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1916) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1916) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1916) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1916) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1916) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1916) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1916) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1916) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1916) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1916) + ceil32(return_data.size) + 224]
                        mem[(32 * _1916) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4483 + (32 * _1916) + ceil32(return_data.size) + 224])] = mem[_4483 + (32 * _1916) + ceil32(return_data.size) + 256 len floor32(mem[_4483 + (32 * _1916) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1916) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1916) + (2 * ceil32(return_data.size)) + 288] <= _3249:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3249
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3249 > mem[(32 * _1916) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1916) + (2 * ceil32(return_data.size)) + 288] - _3249
        else:
            require not arg3
            if arg1 != this.address:
                revert with 0, '!sender'
            mem[96] = 2
            mem[128] = address(ext_call.return_data[0])
            mem[160] = address(ext_call.return_data[0])
            require arg4.length >= 64
            require ext_code.size(address(ext_call.return_data[0]))
            call address(ext_call.return_data[0]).approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args address(cd[(arg4 + 68)]), arg3
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[192] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
            mem[196] = arg3
            mem[228] = 64
            mem[260] = 2
            mem[292 len 0] = None
            require ext_code.size(address(cd[(arg4 + 36)]))
            staticcall address(cd[(arg4 + 36)]).getAmountsIn(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args arg3, Array(len=2, data=mem[292 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[192 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(return_data.size) + 192
            require return_data.size >= 32
            if not arg2:
                if not arg2:
                    if not arg2:
                        _1829 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1917 = mem[_1829 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1829 + 192])] = mem[_1829 + 224 len floor32(mem[_1829 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3253 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1917) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1917) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1917) + ceil32(return_data.size) + 260] = _3253
                        mem[(32 * _1917) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1917) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1917) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1917) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1917) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3253, Array(len=2, data=mem[(32 * _1917) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1917) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1917) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4485 = mem[(32 * _1917) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1917) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1917) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1917) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1917) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1917) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1917) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1917) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1917) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1917) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1917) + ceil32(return_data.size) + 224]
                        mem[(32 * _1917) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4485 + (32 * _1917) + ceil32(return_data.size) + 224])] = mem[_4485 + (32 * _1917) + ceil32(return_data.size) + 256 len floor32(mem[_4485 + (32 * _1917) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1917) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1917) + (2 * ceil32(return_data.size)) + 288] <= _3253:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3253
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3253 > mem[(32 * _1917) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1917) + (2 * ceil32(return_data.size)) + 288] - _3253
                    else:
                        _1831 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1918 = mem[_1831 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1831 + 192])] = mem[_1831 + 224 len floor32(mem[_1831 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3257 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1918) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1918) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1918) + ceil32(return_data.size) + 260] = _3257
                        mem[(32 * _1918) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1918) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1918) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1918) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1918) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3257, Array(len=2, data=mem[(32 * _1918) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1918) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1918) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4487 = mem[(32 * _1918) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1918) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1918) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1918) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1918) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1918) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1918) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1918) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1918) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1918) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1918) + ceil32(return_data.size) + 224]
                        mem[(32 * _1918) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4487 + (32 * _1918) + ceil32(return_data.size) + 224])] = mem[_4487 + (32 * _1918) + ceil32(return_data.size) + 256 len floor32(mem[_4487 + (32 * _1918) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1918) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1918) + (2 * ceil32(return_data.size)) + 288] <= _3257:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3257
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3257 > mem[(32 * _1918) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1918) + (2 * ceil32(return_data.size)) + 288] - _3257
                else:
                    if not arg2:
                        _1833 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1919 = mem[_1833 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1833 + 192])] = mem[_1833 + 224 len floor32(mem[_1833 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3261 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1919) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1919) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1919) + ceil32(return_data.size) + 260] = _3261
                        mem[(32 * _1919) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1919) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1919) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1919) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1919) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3261, Array(len=2, data=mem[(32 * _1919) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1919) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1919) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4489 = mem[(32 * _1919) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1919) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1919) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1919) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1919) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1919) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1919) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1919) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1919) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1919) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1919) + ceil32(return_data.size) + 224]
                        mem[(32 * _1919) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4489 + (32 * _1919) + ceil32(return_data.size) + 224])] = mem[_4489 + (32 * _1919) + ceil32(return_data.size) + 256 len floor32(mem[_4489 + (32 * _1919) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1919) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1919) + (2 * ceil32(return_data.size)) + 288] <= _3261:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3261
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3261 > mem[(32 * _1919) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1919) + (2 * ceil32(return_data.size)) + 288] - _3261
                    else:
                        _1835 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1920 = mem[_1835 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1835 + 192])] = mem[_1835 + 224 len floor32(mem[_1835 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3265 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1920) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1920) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1920) + ceil32(return_data.size) + 260] = _3265
                        mem[(32 * _1920) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1920) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1920) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1920) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1920) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3265, Array(len=2, data=mem[(32 * _1920) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1920) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1920) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4491 = mem[(32 * _1920) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1920) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1920) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1920) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1920) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1920) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1920) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1920) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1920) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1920) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1920) + ceil32(return_data.size) + 224]
                        mem[(32 * _1920) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4491 + (32 * _1920) + ceil32(return_data.size) + 224])] = mem[_4491 + (32 * _1920) + ceil32(return_data.size) + 256 len floor32(mem[_4491 + (32 * _1920) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1920) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1920) + (2 * ceil32(return_data.size)) + 288] <= _3265:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3265
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3265 > mem[(32 * _1920) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1920) + (2 * ceil32(return_data.size)) + 288] - _3265
            else:
                if not arg2:
                    if not arg2:
                        _1837 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1921 = mem[_1837 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1837 + 192])] = mem[_1837 + 224 len floor32(mem[_1837 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3269 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1921) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1921) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1921) + ceil32(return_data.size) + 260] = _3269
                        mem[(32 * _1921) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1921) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1921) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1921) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1921) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3269, Array(len=2, data=mem[(32 * _1921) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1921) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1921) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4493 = mem[(32 * _1921) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1921) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1921) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1921) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1921) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1921) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1921) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1921) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1921) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1921) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1921) + ceil32(return_data.size) + 224]
                        mem[(32 * _1921) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4493 + (32 * _1921) + ceil32(return_data.size) + 224])] = mem[_4493 + (32 * _1921) + ceil32(return_data.size) + 256 len floor32(mem[_4493 + (32 * _1921) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1921) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1921) + (2 * ceil32(return_data.size)) + 288] <= _3269:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3269
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3269 > mem[(32 * _1921) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1921) + (2 * ceil32(return_data.size)) + 288] - _3269
                    else:
                        _1839 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1922 = mem[_1839 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1839 + 192])] = mem[_1839 + 224 len floor32(mem[_1839 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3273 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1922) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1922) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1922) + ceil32(return_data.size) + 260] = _3273
                        mem[(32 * _1922) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1922) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1922) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1922) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1922) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3273, Array(len=2, data=mem[(32 * _1922) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1922) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1922) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4495 = mem[(32 * _1922) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1922) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1922) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1922) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1922) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1922) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1922) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1922) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1922) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1922) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1922) + ceil32(return_data.size) + 224]
                        mem[(32 * _1922) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4495 + (32 * _1922) + ceil32(return_data.size) + 224])] = mem[_4495 + (32 * _1922) + ceil32(return_data.size) + 256 len floor32(mem[_4495 + (32 * _1922) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1922) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1922) + (2 * ceil32(return_data.size)) + 288] <= _3273:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3273
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3273 > mem[(32 * _1922) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1922) + (2 * ceil32(return_data.size)) + 288] - _3273
                else:
                    if not arg2:
                        _1841 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1923 = mem[_1841 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1841 + 192])] = mem[_1841 + 224 len floor32(mem[_1841 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3277 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1923) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1923) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1923) + ceil32(return_data.size) + 260] = _3277
                        mem[(32 * _1923) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1923) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1923) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1923) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1923) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3277, Array(len=2, data=mem[(32 * _1923) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1923) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1923) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4497 = mem[(32 * _1923) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1923) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1923) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1923) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1923) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1923) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1923) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1923) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1923) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1923) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1923) + ceil32(return_data.size) + 224]
                        mem[(32 * _1923) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4497 + (32 * _1923) + ceil32(return_data.size) + 224])] = mem[_4497 + (32 * _1923) + ceil32(return_data.size) + 256 len floor32(mem[_4497 + (32 * _1923) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1923) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1923) + (2 * ceil32(return_data.size)) + 288] <= _3277:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3277
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3277 > mem[(32 * _1923) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1923) + (2 * ceil32(return_data.size)) + 288] - _3277
                    else:
                        _1843 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1924 = mem[_1843 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1843 + 192])] = mem[_1843 + 224 len floor32(mem[_1843 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3281 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1924) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1924) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1924) + ceil32(return_data.size) + 260] = _3281
                        mem[(32 * _1924) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1924) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1924) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1924) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1924) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3281, Array(len=2, data=mem[(32 * _1924) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1924) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1924) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4499 = mem[(32 * _1924) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1924) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1924) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1924) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1924) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1924) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1924) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1924) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1924) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1924) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1924) + ceil32(return_data.size) + 224]
                        mem[(32 * _1924) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4499 + (32 * _1924) + ceil32(return_data.size) + 224])] = mem[_4499 + (32 * _1924) + ceil32(return_data.size) + 256 len floor32(mem[_4499 + (32 * _1924) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1924) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1924) + (2 * ceil32(return_data.size)) + 288] <= _3281:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3281
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3281 > mem[(32 * _1924) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1924) + (2 * ceil32(return_data.size)) + 288] - _3281
    else:
        if not arg2:
            if arg1 != this.address:
                revert with 0, '!sender'
            mem[96] = 2
            mem[128] = address(ext_call.return_data[0])
            mem[160] = address(ext_call.return_data[0])
            require arg4.length >= 64
            require ext_code.size(address(ext_call.return_data[0]))
            call address(ext_call.return_data[0]).approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args address(cd[(arg4 + 68)]), arg2
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[192] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
            mem[196] = arg2
            mem[228] = 64
            mem[260] = 2
            mem[292 len 0] = None
            require ext_code.size(address(cd[(arg4 + 36)]))
            staticcall address(cd[(arg4 + 36)]).getAmountsIn(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args arg2, Array(len=2, data=mem[292 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[192 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(return_data.size) + 192
            require return_data.size >= 32
            if not arg2:
                if not arg2:
                    if not arg2:
                        _1845 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1925 = mem[_1845 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1845 + 192])] = mem[_1845 + 224 len floor32(mem[_1845 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3285 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1925) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1925) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1925) + ceil32(return_data.size) + 260] = _3285
                        mem[(32 * _1925) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1925) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1925) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1925) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1925) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3285, Array(len=2, data=mem[(32 * _1925) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1925) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1925) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4501 = mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1925) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1925) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1925) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1925) + ceil32(return_data.size) + 224]
                        mem[(32 * _1925) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4501 + (32 * _1925) + ceil32(return_data.size) + 224])] = mem[_4501 + (32 * _1925) + ceil32(return_data.size) + 256 len floor32(mem[_4501 + (32 * _1925) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1925) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1925) + (2 * ceil32(return_data.size)) + 288] <= _3285:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3285
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3285 > mem[(32 * _1925) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1925) + (2 * ceil32(return_data.size)) + 288] - _3285
                    else:
                        _1847 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1926 = mem[_1847 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1847 + 192])] = mem[_1847 + 224 len floor32(mem[_1847 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3289 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1926) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1926) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1926) + ceil32(return_data.size) + 260] = _3289
                        mem[(32 * _1926) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1926) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1926) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1926) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1926) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3289, Array(len=2, data=mem[(32 * _1926) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1926) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1926) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4503 = mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1926) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1926) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1926) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1926) + ceil32(return_data.size) + 224]
                        mem[(32 * _1926) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4503 + (32 * _1926) + ceil32(return_data.size) + 224])] = mem[_4503 + (32 * _1926) + ceil32(return_data.size) + 256 len floor32(mem[_4503 + (32 * _1926) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1926) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1926) + (2 * ceil32(return_data.size)) + 288] <= _3289:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3289
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3289 > mem[(32 * _1926) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1926) + (2 * ceil32(return_data.size)) + 288] - _3289
                else:
                    if not arg2:
                        _1849 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1927 = mem[_1849 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1849 + 192])] = mem[_1849 + 224 len floor32(mem[_1849 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3293 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1927) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1927) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1927) + ceil32(return_data.size) + 260] = _3293
                        mem[(32 * _1927) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1927) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1927) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1927) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1927) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3293, Array(len=2, data=mem[(32 * _1927) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1927) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1927) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4505 = mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1927) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1927) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1927) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1927) + ceil32(return_data.size) + 224]
                        mem[(32 * _1927) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4505 + (32 * _1927) + ceil32(return_data.size) + 224])] = mem[_4505 + (32 * _1927) + ceil32(return_data.size) + 256 len floor32(mem[_4505 + (32 * _1927) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1927) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1927) + (2 * ceil32(return_data.size)) + 288] <= _3293:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3293
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3293 > mem[(32 * _1927) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1927) + (2 * ceil32(return_data.size)) + 288] - _3293
                    else:
                        _1851 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1928 = mem[_1851 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1851 + 192])] = mem[_1851 + 224 len floor32(mem[_1851 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3297 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1928) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1928) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1928) + ceil32(return_data.size) + 260] = _3297
                        mem[(32 * _1928) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1928) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1928) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1928) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1928) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3297, Array(len=2, data=mem[(32 * _1928) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1928) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1928) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4507 = mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1928) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1928) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1928) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1928) + ceil32(return_data.size) + 224]
                        mem[(32 * _1928) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4507 + (32 * _1928) + ceil32(return_data.size) + 224])] = mem[_4507 + (32 * _1928) + ceil32(return_data.size) + 256 len floor32(mem[_4507 + (32 * _1928) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1928) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1928) + (2 * ceil32(return_data.size)) + 288] <= _3297:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3297
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3297 > mem[(32 * _1928) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1928) + (2 * ceil32(return_data.size)) + 288] - _3297
            else:
                if not arg2:
                    if not arg2:
                        _1853 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1929 = mem[_1853 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1853 + 192])] = mem[_1853 + 224 len floor32(mem[_1853 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3301 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1929) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1929) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1929) + ceil32(return_data.size) + 260] = _3301
                        mem[(32 * _1929) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1929) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1929) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1929) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1929) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3301, Array(len=2, data=mem[(32 * _1929) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1929) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1929) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4509 = mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1929) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1929) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1929) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1929) + ceil32(return_data.size) + 224]
                        mem[(32 * _1929) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4509 + (32 * _1929) + ceil32(return_data.size) + 224])] = mem[_4509 + (32 * _1929) + ceil32(return_data.size) + 256 len floor32(mem[_4509 + (32 * _1929) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1929) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1929) + (2 * ceil32(return_data.size)) + 288] <= _3301:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3301
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3301 > mem[(32 * _1929) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1929) + (2 * ceil32(return_data.size)) + 288] - _3301
                    else:
                        _1855 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1930 = mem[_1855 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1855 + 192])] = mem[_1855 + 224 len floor32(mem[_1855 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3305 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1930) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1930) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1930) + ceil32(return_data.size) + 260] = _3305
                        mem[(32 * _1930) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1930) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1930) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1930) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1930) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3305, Array(len=2, data=mem[(32 * _1930) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1930) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1930) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4511 = mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1930) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1930) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1930) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1930) + ceil32(return_data.size) + 224]
                        mem[(32 * _1930) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4511 + (32 * _1930) + ceil32(return_data.size) + 224])] = mem[_4511 + (32 * _1930) + ceil32(return_data.size) + 256 len floor32(mem[_4511 + (32 * _1930) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1930) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1930) + (2 * ceil32(return_data.size)) + 288] <= _3305:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3305
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3305 > mem[(32 * _1930) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1930) + (2 * ceil32(return_data.size)) + 288] - _3305
                else:
                    if not arg2:
                        _1857 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1931 = mem[_1857 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1857 + 192])] = mem[_1857 + 224 len floor32(mem[_1857 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3309 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1931) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1931) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1931) + ceil32(return_data.size) + 260] = _3309
                        mem[(32 * _1931) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1931) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1931) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1931) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1931) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3309, Array(len=2, data=mem[(32 * _1931) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1931) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1931) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4513 = mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1931) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1931) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1931) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1931) + ceil32(return_data.size) + 224]
                        mem[(32 * _1931) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4513 + (32 * _1931) + ceil32(return_data.size) + 224])] = mem[_4513 + (32 * _1931) + ceil32(return_data.size) + 256 len floor32(mem[_4513 + (32 * _1931) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1931) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1931) + (2 * ceil32(return_data.size)) + 288] <= _3309:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3309
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3309 > mem[(32 * _1931) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1931) + (2 * ceil32(return_data.size)) + 288] - _3309
                    else:
                        _1859 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1932 = mem[_1859 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1859 + 192])] = mem[_1859 + 224 len floor32(mem[_1859 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3313 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1932) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1932) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1932) + ceil32(return_data.size) + 260] = _3313
                        mem[(32 * _1932) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1932) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1932) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1932) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1932) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3313, Array(len=2, data=mem[(32 * _1932) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1932) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1932) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4515 = mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1932) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1932) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1932) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1932) + ceil32(return_data.size) + 224]
                        mem[(32 * _1932) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4515 + (32 * _1932) + ceil32(return_data.size) + 224])] = mem[_4515 + (32 * _1932) + ceil32(return_data.size) + 256 len floor32(mem[_4515 + (32 * _1932) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1932) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1932) + (2 * ceil32(return_data.size)) + 288] <= _3313:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3313
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3313 > mem[(32 * _1932) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1932) + (2 * ceil32(return_data.size)) + 288] - _3313
        else:
            require not arg3
            if arg1 != this.address:
                revert with 0, '!sender'
            mem[96] = 2
            mem[128] = address(ext_call.return_data[0])
            mem[160] = address(ext_call.return_data[0])
            require arg4.length >= 64
            require ext_code.size(address(ext_call.return_data[0]))
            call address(ext_call.return_data[0]).approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args address(cd[(arg4 + 68)]), arg2
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[192] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
            mem[196] = arg2
            mem[228] = 64
            mem[260] = 2
            mem[292 len 0] = None
            require ext_code.size(address(cd[(arg4 + 36)]))
            staticcall address(cd[(arg4 + 36)]).getAmountsIn(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args arg2, Array(len=2, data=mem[292 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[192 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(return_data.size) + 192
            require return_data.size >= 32
            if not arg2:
                if not arg2:
                    if not arg2:
                        _1861 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1933 = mem[_1861 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1861 + 192])] = mem[_1861 + 224 len floor32(mem[_1861 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3317 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1933) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1933) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1933) + ceil32(return_data.size) + 260] = _3317
                        mem[(32 * _1933) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1933) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1933) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1933) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1933) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3317, Array(len=2, data=mem[(32 * _1933) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1933) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1933) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4517 = mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1933) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1933) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1933) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1933) + ceil32(return_data.size) + 224]
                        mem[(32 * _1933) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4517 + (32 * _1933) + ceil32(return_data.size) + 224])] = mem[_4517 + (32 * _1933) + ceil32(return_data.size) + 256 len floor32(mem[_4517 + (32 * _1933) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1933) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1933) + (2 * ceil32(return_data.size)) + 288] <= _3317:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3317
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3317 > mem[(32 * _1933) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1933) + (2 * ceil32(return_data.size)) + 288] - _3317
                    else:
                        _1863 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1934 = mem[_1863 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1863 + 192])] = mem[_1863 + 224 len floor32(mem[_1863 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3321 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1934) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1934) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1934) + ceil32(return_data.size) + 260] = _3321
                        mem[(32 * _1934) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1934) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1934) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1934) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1934) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3321, Array(len=2, data=mem[(32 * _1934) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1934) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1934) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4519 = mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1934) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1934) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1934) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1934) + ceil32(return_data.size) + 224]
                        mem[(32 * _1934) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4519 + (32 * _1934) + ceil32(return_data.size) + 224])] = mem[_4519 + (32 * _1934) + ceil32(return_data.size) + 256 len floor32(mem[_4519 + (32 * _1934) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1934) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1934) + (2 * ceil32(return_data.size)) + 288] <= _3321:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3321
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3321 > mem[(32 * _1934) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1934) + (2 * ceil32(return_data.size)) + 288] - _3321
                else:
                    if not arg2:
                        _1865 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1935 = mem[_1865 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1865 + 192])] = mem[_1865 + 224 len floor32(mem[_1865 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3325 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1935) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1935) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1935) + ceil32(return_data.size) + 260] = _3325
                        mem[(32 * _1935) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1935) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1935) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1935) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1935) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3325, Array(len=2, data=mem[(32 * _1935) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1935) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1935) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4521 = mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1935) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1935) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1935) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1935) + ceil32(return_data.size) + 224]
                        mem[(32 * _1935) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4521 + (32 * _1935) + ceil32(return_data.size) + 224])] = mem[_4521 + (32 * _1935) + ceil32(return_data.size) + 256 len floor32(mem[_4521 + (32 * _1935) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1935) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1935) + (2 * ceil32(return_data.size)) + 288] <= _3325:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3325
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3325 > mem[(32 * _1935) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1935) + (2 * ceil32(return_data.size)) + 288] - _3325
                    else:
                        _1867 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1936 = mem[_1867 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1867 + 192])] = mem[_1867 + 224 len floor32(mem[_1867 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3329 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1936) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1936) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1936) + ceil32(return_data.size) + 260] = _3329
                        mem[(32 * _1936) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1936) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1936) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1936) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1936) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3329, Array(len=2, data=mem[(32 * _1936) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1936) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1936) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4523 = mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1936) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1936) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1936) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1936) + ceil32(return_data.size) + 224]
                        mem[(32 * _1936) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4523 + (32 * _1936) + ceil32(return_data.size) + 224])] = mem[_4523 + (32 * _1936) + ceil32(return_data.size) + 256 len floor32(mem[_4523 + (32 * _1936) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1936) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1936) + (2 * ceil32(return_data.size)) + 288] <= _3329:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3329
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3329 > mem[(32 * _1936) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1936) + (2 * ceil32(return_data.size)) + 288] - _3329
            else:
                if not arg2:
                    if not arg2:
                        _1869 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1937 = mem[_1869 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1869 + 192])] = mem[_1869 + 224 len floor32(mem[_1869 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3333 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1937) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1937) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1937) + ceil32(return_data.size) + 260] = _3333
                        mem[(32 * _1937) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1937) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1937) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1937) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1937) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3333, Array(len=2, data=mem[(32 * _1937) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1937) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1937) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4525 = mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1937) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1937) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1937) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1937) + ceil32(return_data.size) + 224]
                        mem[(32 * _1937) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4525 + (32 * _1937) + ceil32(return_data.size) + 224])] = mem[_4525 + (32 * _1937) + ceil32(return_data.size) + 256 len floor32(mem[_4525 + (32 * _1937) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1937) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1937) + (2 * ceil32(return_data.size)) + 288] <= _3333:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3333
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3333 > mem[(32 * _1937) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1937) + (2 * ceil32(return_data.size)) + 288] - _3333
                    else:
                        _1871 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1938 = mem[_1871 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1871 + 192])] = mem[_1871 + 224 len floor32(mem[_1871 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3337 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1938) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1938) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1938) + ceil32(return_data.size) + 260] = _3337
                        mem[(32 * _1938) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1938) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1938) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1938) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1938) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3337, Array(len=2, data=mem[(32 * _1938) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1938) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1938) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4527 = mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1938) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1938) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1938) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1938) + ceil32(return_data.size) + 224]
                        mem[(32 * _1938) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4527 + (32 * _1938) + ceil32(return_data.size) + 224])] = mem[_4527 + (32 * _1938) + ceil32(return_data.size) + 256 len floor32(mem[_4527 + (32 * _1938) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1938) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1938) + (2 * ceil32(return_data.size)) + 288] <= _3337:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3337
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3337 > mem[(32 * _1938) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1938) + (2 * ceil32(return_data.size)) + 288] - _3337
                else:
                    if not arg2:
                        _1873 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1939 = mem[_1873 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1873 + 192])] = mem[_1873 + 224 len floor32(mem[_1873 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3341 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1939) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1939) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1939) + ceil32(return_data.size) + 260] = _3341
                        mem[(32 * _1939) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1939) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1939) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1939) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1939) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3341, Array(len=2, data=mem[(32 * _1939) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1939) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1939) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4529 = mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1939) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1939) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1939) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1939) + ceil32(return_data.size) + 224]
                        mem[(32 * _1939) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4529 + (32 * _1939) + ceil32(return_data.size) + 224])] = mem[_4529 + (32 * _1939) + ceil32(return_data.size) + 256 len floor32(mem[_4529 + (32 * _1939) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1939) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1939) + (2 * ceil32(return_data.size)) + 288] <= _3341:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3341
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3341 > mem[(32 * _1939) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1939) + (2 * ceil32(return_data.size)) + 288] - _3341
                    else:
                        _1875 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1940 = mem[_1875 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1875 + 192])] = mem[_1875 + 224 len floor32(mem[_1875 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3345 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1940) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1940) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1940) + ceil32(return_data.size) + 260] = _3345
                        mem[(32 * _1940) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1940) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1940) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1940) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1940) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3345, Array(len=2, data=mem[(32 * _1940) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1940) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1940) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4531 = mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1940) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1940) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1940) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1940) + ceil32(return_data.size) + 224]
                        mem[(32 * _1940) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4531 + (32 * _1940) + ceil32(return_data.size) + 224])] = mem[_4531 + (32 * _1940) + ceil32(return_data.size) + 256 len floor32(mem[_4531 + (32 * _1940) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1940) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1940) + (2 * ceil32(return_data.size)) + 288] <= _3345:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3345
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3345 > mem[(32 * _1940) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1940) + (2 * ceil32(return_data.size)) + 288] - _3345
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
}

function uniswapV2Call(address arg1, uint256 arg2, uint256 arg3, bytes arg4) {
    require calldata.size - 4 >= 128
    require arg4 <= 4294967296
    require arg4 + 36 <= calldata.size
    require arg4.length <= 4294967296 and arg4 + arg4.length + 36 <= calldata.size
    require ext_code.size(msg.sender)
    staticcall msg.sender.token0() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_code.size(msg.sender)
    staticcall msg.sender.token1() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if not arg2:
        if not arg2:
            if arg1 != this.address:
                revert with 0, '!sender'
            mem[96] = 2
            mem[128] = address(ext_call.return_data[0])
            mem[160] = address(ext_call.return_data[0])
            require arg4.length >= 64
            require ext_code.size(address(ext_call.return_data[0]))
            call address(ext_call.return_data[0]).approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args address(cd[(arg4 + 68)]), arg3
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[192] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
            mem[196] = arg3
            mem[228] = 64
            mem[260] = 2
            mem[292 len 0] = None
            require ext_code.size(address(cd[(arg4 + 36)]))
            staticcall address(cd[(arg4 + 36)]).getAmountsIn(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args arg3, Array(len=2, data=mem[292 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[192 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(return_data.size) + 192
            require return_data.size >= 32
            if not arg2:
                if not arg2:
                    if not arg2:
                        _1813 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1909 = mem[_1813 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1813 + 192])] = mem[_1813 + 224 len floor32(mem[_1813 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3221 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1909) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1909) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1909) + ceil32(return_data.size) + 260] = _3221
                        mem[(32 * _1909) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1909) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1909) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1909) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1909) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3221, Array(len=2, data=mem[(32 * _1909) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1909) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1909) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4469 = mem[(32 * _1909) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1909) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1909) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1909) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1909) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1909) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1909) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1909) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1909) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1909) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1909) + ceil32(return_data.size) + 224]
                        mem[(32 * _1909) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4469 + (32 * _1909) + ceil32(return_data.size) + 224])] = mem[_4469 + (32 * _1909) + ceil32(return_data.size) + 256 len floor32(mem[_4469 + (32 * _1909) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1909) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1909) + (2 * ceil32(return_data.size)) + 288] <= _3221:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3221
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3221 > mem[(32 * _1909) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1909) + (2 * ceil32(return_data.size)) + 288] - _3221
                    else:
                        _1815 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1910 = mem[_1815 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1815 + 192])] = mem[_1815 + 224 len floor32(mem[_1815 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3225 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1910) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1910) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1910) + ceil32(return_data.size) + 260] = _3225
                        mem[(32 * _1910) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1910) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1910) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1910) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1910) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3225, Array(len=2, data=mem[(32 * _1910) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1910) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1910) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4471 = mem[(32 * _1910) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1910) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1910) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1910) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1910) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1910) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1910) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1910) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1910) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1910) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1910) + ceil32(return_data.size) + 224]
                        mem[(32 * _1910) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4471 + (32 * _1910) + ceil32(return_data.size) + 224])] = mem[_4471 + (32 * _1910) + ceil32(return_data.size) + 256 len floor32(mem[_4471 + (32 * _1910) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1910) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1910) + (2 * ceil32(return_data.size)) + 288] <= _3225:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3225
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3225 > mem[(32 * _1910) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1910) + (2 * ceil32(return_data.size)) + 288] - _3225
                else:
                    if not arg2:
                        _1817 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1911 = mem[_1817 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1817 + 192])] = mem[_1817 + 224 len floor32(mem[_1817 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3229 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1911) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1911) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1911) + ceil32(return_data.size) + 260] = _3229
                        mem[(32 * _1911) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1911) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1911) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1911) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1911) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3229, Array(len=2, data=mem[(32 * _1911) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1911) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1911) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4473 = mem[(32 * _1911) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1911) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1911) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1911) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1911) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1911) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1911) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1911) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1911) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1911) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1911) + ceil32(return_data.size) + 224]
                        mem[(32 * _1911) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4473 + (32 * _1911) + ceil32(return_data.size) + 224])] = mem[_4473 + (32 * _1911) + ceil32(return_data.size) + 256 len floor32(mem[_4473 + (32 * _1911) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1911) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1911) + (2 * ceil32(return_data.size)) + 288] <= _3229:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3229
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3229 > mem[(32 * _1911) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1911) + (2 * ceil32(return_data.size)) + 288] - _3229
                    else:
                        _1819 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1912 = mem[_1819 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1819 + 192])] = mem[_1819 + 224 len floor32(mem[_1819 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3233 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1912) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1912) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1912) + ceil32(return_data.size) + 260] = _3233
                        mem[(32 * _1912) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1912) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1912) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1912) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1912) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3233, Array(len=2, data=mem[(32 * _1912) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1912) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1912) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4475 = mem[(32 * _1912) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1912) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1912) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1912) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1912) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1912) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1912) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1912) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1912) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1912) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1912) + ceil32(return_data.size) + 224]
                        mem[(32 * _1912) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4475 + (32 * _1912) + ceil32(return_data.size) + 224])] = mem[_4475 + (32 * _1912) + ceil32(return_data.size) + 256 len floor32(mem[_4475 + (32 * _1912) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1912) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1912) + (2 * ceil32(return_data.size)) + 288] <= _3233:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3233
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3233 > mem[(32 * _1912) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1912) + (2 * ceil32(return_data.size)) + 288] - _3233
            else:
                if not arg2:
                    if not arg2:
                        _1821 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1913 = mem[_1821 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1821 + 192])] = mem[_1821 + 224 len floor32(mem[_1821 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3237 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1913) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1913) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1913) + ceil32(return_data.size) + 260] = _3237
                        mem[(32 * _1913) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1913) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1913) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1913) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1913) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3237, Array(len=2, data=mem[(32 * _1913) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1913) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1913) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4477 = mem[(32 * _1913) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1913) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1913) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1913) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1913) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1913) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1913) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1913) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1913) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1913) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1913) + ceil32(return_data.size) + 224]
                        mem[(32 * _1913) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4477 + (32 * _1913) + ceil32(return_data.size) + 224])] = mem[_4477 + (32 * _1913) + ceil32(return_data.size) + 256 len floor32(mem[_4477 + (32 * _1913) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1913) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1913) + (2 * ceil32(return_data.size)) + 288] <= _3237:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3237
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3237 > mem[(32 * _1913) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1913) + (2 * ceil32(return_data.size)) + 288] - _3237
                    else:
                        _1823 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1914 = mem[_1823 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1823 + 192])] = mem[_1823 + 224 len floor32(mem[_1823 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3241 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1914) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1914) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1914) + ceil32(return_data.size) + 260] = _3241
                        mem[(32 * _1914) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1914) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1914) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1914) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1914) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3241, Array(len=2, data=mem[(32 * _1914) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1914) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1914) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4479 = mem[(32 * _1914) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1914) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1914) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1914) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1914) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1914) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1914) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1914) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1914) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1914) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1914) + ceil32(return_data.size) + 224]
                        mem[(32 * _1914) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4479 + (32 * _1914) + ceil32(return_data.size) + 224])] = mem[_4479 + (32 * _1914) + ceil32(return_data.size) + 256 len floor32(mem[_4479 + (32 * _1914) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1914) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1914) + (2 * ceil32(return_data.size)) + 288] <= _3241:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3241
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3241 > mem[(32 * _1914) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1914) + (2 * ceil32(return_data.size)) + 288] - _3241
                else:
                    if not arg2:
                        _1825 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1915 = mem[_1825 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1825 + 192])] = mem[_1825 + 224 len floor32(mem[_1825 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3245 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1915) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1915) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1915) + ceil32(return_data.size) + 260] = _3245
                        mem[(32 * _1915) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1915) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1915) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1915) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1915) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3245, Array(len=2, data=mem[(32 * _1915) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1915) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1915) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4481 = mem[(32 * _1915) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1915) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1915) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1915) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1915) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1915) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1915) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1915) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1915) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1915) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1915) + ceil32(return_data.size) + 224]
                        mem[(32 * _1915) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4481 + (32 * _1915) + ceil32(return_data.size) + 224])] = mem[_4481 + (32 * _1915) + ceil32(return_data.size) + 256 len floor32(mem[_4481 + (32 * _1915) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1915) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1915) + (2 * ceil32(return_data.size)) + 288] <= _3245:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3245
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3245 > mem[(32 * _1915) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1915) + (2 * ceil32(return_data.size)) + 288] - _3245
                    else:
                        _1827 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1916 = mem[_1827 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1827 + 192])] = mem[_1827 + 224 len floor32(mem[_1827 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3249 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1916) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1916) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1916) + ceil32(return_data.size) + 260] = _3249
                        mem[(32 * _1916) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1916) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1916) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1916) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1916) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3249, Array(len=2, data=mem[(32 * _1916) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1916) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1916) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4483 = mem[(32 * _1916) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1916) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1916) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1916) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1916) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1916) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1916) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1916) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1916) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1916) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1916) + ceil32(return_data.size) + 224]
                        mem[(32 * _1916) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4483 + (32 * _1916) + ceil32(return_data.size) + 224])] = mem[_4483 + (32 * _1916) + ceil32(return_data.size) + 256 len floor32(mem[_4483 + (32 * _1916) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1916) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1916) + (2 * ceil32(return_data.size)) + 288] <= _3249:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3249
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3249 > mem[(32 * _1916) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1916) + (2 * ceil32(return_data.size)) + 288] - _3249
        else:
            require not arg3
            if arg1 != this.address:
                revert with 0, '!sender'
            mem[96] = 2
            mem[128] = address(ext_call.return_data[0])
            mem[160] = address(ext_call.return_data[0])
            require arg4.length >= 64
            require ext_code.size(address(ext_call.return_data[0]))
            call address(ext_call.return_data[0]).approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args address(cd[(arg4 + 68)]), arg3
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[192] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
            mem[196] = arg3
            mem[228] = 64
            mem[260] = 2
            mem[292 len 0] = None
            require ext_code.size(address(cd[(arg4 + 36)]))
            staticcall address(cd[(arg4 + 36)]).getAmountsIn(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args arg3, Array(len=2, data=mem[292 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[192 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(return_data.size) + 192
            require return_data.size >= 32
            if not arg2:
                if not arg2:
                    if not arg2:
                        _1829 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1917 = mem[_1829 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1829 + 192])] = mem[_1829 + 224 len floor32(mem[_1829 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3253 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1917) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1917) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1917) + ceil32(return_data.size) + 260] = _3253
                        mem[(32 * _1917) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1917) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1917) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1917) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1917) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3253, Array(len=2, data=mem[(32 * _1917) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1917) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1917) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4485 = mem[(32 * _1917) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1917) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1917) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1917) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1917) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1917) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1917) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1917) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1917) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1917) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1917) + ceil32(return_data.size) + 224]
                        mem[(32 * _1917) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4485 + (32 * _1917) + ceil32(return_data.size) + 224])] = mem[_4485 + (32 * _1917) + ceil32(return_data.size) + 256 len floor32(mem[_4485 + (32 * _1917) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1917) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1917) + (2 * ceil32(return_data.size)) + 288] <= _3253:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3253
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3253 > mem[(32 * _1917) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1917) + (2 * ceil32(return_data.size)) + 288] - _3253
                    else:
                        _1831 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1918 = mem[_1831 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1831 + 192])] = mem[_1831 + 224 len floor32(mem[_1831 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3257 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1918) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1918) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1918) + ceil32(return_data.size) + 260] = _3257
                        mem[(32 * _1918) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1918) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1918) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1918) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1918) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3257, Array(len=2, data=mem[(32 * _1918) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1918) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1918) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4487 = mem[(32 * _1918) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1918) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1918) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1918) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1918) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1918) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1918) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1918) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1918) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1918) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1918) + ceil32(return_data.size) + 224]
                        mem[(32 * _1918) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4487 + (32 * _1918) + ceil32(return_data.size) + 224])] = mem[_4487 + (32 * _1918) + ceil32(return_data.size) + 256 len floor32(mem[_4487 + (32 * _1918) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1918) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1918) + (2 * ceil32(return_data.size)) + 288] <= _3257:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3257
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3257 > mem[(32 * _1918) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1918) + (2 * ceil32(return_data.size)) + 288] - _3257
                else:
                    if not arg2:
                        _1833 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1919 = mem[_1833 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1833 + 192])] = mem[_1833 + 224 len floor32(mem[_1833 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3261 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1919) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1919) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1919) + ceil32(return_data.size) + 260] = _3261
                        mem[(32 * _1919) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1919) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1919) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1919) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1919) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3261, Array(len=2, data=mem[(32 * _1919) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1919) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1919) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4489 = mem[(32 * _1919) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1919) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1919) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1919) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1919) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1919) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1919) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1919) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1919) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1919) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1919) + ceil32(return_data.size) + 224]
                        mem[(32 * _1919) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4489 + (32 * _1919) + ceil32(return_data.size) + 224])] = mem[_4489 + (32 * _1919) + ceil32(return_data.size) + 256 len floor32(mem[_4489 + (32 * _1919) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1919) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1919) + (2 * ceil32(return_data.size)) + 288] <= _3261:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3261
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3261 > mem[(32 * _1919) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1919) + (2 * ceil32(return_data.size)) + 288] - _3261
                    else:
                        _1835 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1920 = mem[_1835 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1835 + 192])] = mem[_1835 + 224 len floor32(mem[_1835 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3265 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1920) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1920) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1920) + ceil32(return_data.size) + 260] = _3265
                        mem[(32 * _1920) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1920) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1920) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1920) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1920) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3265, Array(len=2, data=mem[(32 * _1920) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1920) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1920) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4491 = mem[(32 * _1920) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1920) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1920) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1920) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1920) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1920) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1920) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1920) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1920) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1920) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1920) + ceil32(return_data.size) + 224]
                        mem[(32 * _1920) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4491 + (32 * _1920) + ceil32(return_data.size) + 224])] = mem[_4491 + (32 * _1920) + ceil32(return_data.size) + 256 len floor32(mem[_4491 + (32 * _1920) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1920) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1920) + (2 * ceil32(return_data.size)) + 288] <= _3265:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3265
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3265 > mem[(32 * _1920) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1920) + (2 * ceil32(return_data.size)) + 288] - _3265
            else:
                if not arg2:
                    if not arg2:
                        _1837 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1921 = mem[_1837 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1837 + 192])] = mem[_1837 + 224 len floor32(mem[_1837 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3269 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1921) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1921) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1921) + ceil32(return_data.size) + 260] = _3269
                        mem[(32 * _1921) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1921) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1921) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1921) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1921) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3269, Array(len=2, data=mem[(32 * _1921) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1921) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1921) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4493 = mem[(32 * _1921) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1921) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1921) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1921) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1921) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1921) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1921) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1921) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1921) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1921) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1921) + ceil32(return_data.size) + 224]
                        mem[(32 * _1921) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4493 + (32 * _1921) + ceil32(return_data.size) + 224])] = mem[_4493 + (32 * _1921) + ceil32(return_data.size) + 256 len floor32(mem[_4493 + (32 * _1921) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1921) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1921) + (2 * ceil32(return_data.size)) + 288] <= _3269:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3269
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3269 > mem[(32 * _1921) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1921) + (2 * ceil32(return_data.size)) + 288] - _3269
                    else:
                        _1839 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1922 = mem[_1839 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1839 + 192])] = mem[_1839 + 224 len floor32(mem[_1839 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3273 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1922) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1922) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1922) + ceil32(return_data.size) + 260] = _3273
                        mem[(32 * _1922) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1922) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1922) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1922) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1922) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3273, Array(len=2, data=mem[(32 * _1922) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1922) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1922) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4495 = mem[(32 * _1922) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1922) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1922) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1922) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1922) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1922) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1922) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1922) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1922) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1922) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1922) + ceil32(return_data.size) + 224]
                        mem[(32 * _1922) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4495 + (32 * _1922) + ceil32(return_data.size) + 224])] = mem[_4495 + (32 * _1922) + ceil32(return_data.size) + 256 len floor32(mem[_4495 + (32 * _1922) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1922) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1922) + (2 * ceil32(return_data.size)) + 288] <= _3273:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3273
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3273 > mem[(32 * _1922) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1922) + (2 * ceil32(return_data.size)) + 288] - _3273
                else:
                    if not arg2:
                        _1841 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1923 = mem[_1841 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1841 + 192])] = mem[_1841 + 224 len floor32(mem[_1841 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3277 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1923) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1923) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1923) + ceil32(return_data.size) + 260] = _3277
                        mem[(32 * _1923) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1923) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1923) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1923) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1923) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3277, Array(len=2, data=mem[(32 * _1923) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1923) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1923) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4497 = mem[(32 * _1923) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1923) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1923) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1923) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1923) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1923) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1923) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1923) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1923) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1923) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1923) + ceil32(return_data.size) + 224]
                        mem[(32 * _1923) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4497 + (32 * _1923) + ceil32(return_data.size) + 224])] = mem[_4497 + (32 * _1923) + ceil32(return_data.size) + 256 len floor32(mem[_4497 + (32 * _1923) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1923) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1923) + (2 * ceil32(return_data.size)) + 288] <= _3277:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3277
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3277 > mem[(32 * _1923) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1923) + (2 * ceil32(return_data.size)) + 288] - _3277
                    else:
                        _1843 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1924 = mem[_1843 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1843 + 192])] = mem[_1843 + 224 len floor32(mem[_1843 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3281 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1924) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1924) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1924) + ceil32(return_data.size) + 260] = _3281
                        mem[(32 * _1924) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1924) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1924) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1924) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1924) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3281, Array(len=2, data=mem[(32 * _1924) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1924) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1924) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4499 = mem[(32 * _1924) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1924) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1924) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1924) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1924) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1924) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1924) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1924) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1924) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1924) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1924) + ceil32(return_data.size) + 224]
                        mem[(32 * _1924) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4499 + (32 * _1924) + ceil32(return_data.size) + 224])] = mem[_4499 + (32 * _1924) + ceil32(return_data.size) + 256 len floor32(mem[_4499 + (32 * _1924) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1924) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1924) + (2 * ceil32(return_data.size)) + 288] <= _3281:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3281
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3281 > mem[(32 * _1924) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1924) + (2 * ceil32(return_data.size)) + 288] - _3281
    else:
        if not arg2:
            if arg1 != this.address:
                revert with 0, '!sender'
            mem[96] = 2
            mem[128] = address(ext_call.return_data[0])
            mem[160] = address(ext_call.return_data[0])
            require arg4.length >= 64
            require ext_code.size(address(ext_call.return_data[0]))
            call address(ext_call.return_data[0]).approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args address(cd[(arg4 + 68)]), arg2
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[192] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
            mem[196] = arg2
            mem[228] = 64
            mem[260] = 2
            mem[292 len 0] = None
            require ext_code.size(address(cd[(arg4 + 36)]))
            staticcall address(cd[(arg4 + 36)]).getAmountsIn(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args arg2, Array(len=2, data=mem[292 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[192 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(return_data.size) + 192
            require return_data.size >= 32
            if not arg2:
                if not arg2:
                    if not arg2:
                        _1845 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1925 = mem[_1845 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1845 + 192])] = mem[_1845 + 224 len floor32(mem[_1845 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3285 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1925) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1925) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1925) + ceil32(return_data.size) + 260] = _3285
                        mem[(32 * _1925) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1925) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1925) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1925) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1925) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3285, Array(len=2, data=mem[(32 * _1925) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1925) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1925) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4501 = mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1925) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1925) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1925) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1925) + ceil32(return_data.size) + 224]
                        mem[(32 * _1925) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4501 + (32 * _1925) + ceil32(return_data.size) + 224])] = mem[_4501 + (32 * _1925) + ceil32(return_data.size) + 256 len floor32(mem[_4501 + (32 * _1925) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1925) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1925) + (2 * ceil32(return_data.size)) + 288] <= _3285:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3285
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3285 > mem[(32 * _1925) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1925) + (2 * ceil32(return_data.size)) + 288] - _3285
                    else:
                        _1847 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1926 = mem[_1847 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1847 + 192])] = mem[_1847 + 224 len floor32(mem[_1847 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3289 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1926) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1926) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1926) + ceil32(return_data.size) + 260] = _3289
                        mem[(32 * _1926) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1926) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1926) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1926) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1926) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3289, Array(len=2, data=mem[(32 * _1926) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1926) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1926) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4503 = mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1926) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1926) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1926) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1926) + ceil32(return_data.size) + 224]
                        mem[(32 * _1926) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4503 + (32 * _1926) + ceil32(return_data.size) + 224])] = mem[_4503 + (32 * _1926) + ceil32(return_data.size) + 256 len floor32(mem[_4503 + (32 * _1926) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1926) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1926) + (2 * ceil32(return_data.size)) + 288] <= _3289:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3289
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3289 > mem[(32 * _1926) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1926) + (2 * ceil32(return_data.size)) + 288] - _3289
                else:
                    if not arg2:
                        _1849 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1927 = mem[_1849 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1849 + 192])] = mem[_1849 + 224 len floor32(mem[_1849 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3293 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1927) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1927) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1927) + ceil32(return_data.size) + 260] = _3293
                        mem[(32 * _1927) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1927) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1927) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1927) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1927) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3293, Array(len=2, data=mem[(32 * _1927) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1927) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1927) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4505 = mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1927) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1927) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1927) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1927) + ceil32(return_data.size) + 224]
                        mem[(32 * _1927) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4505 + (32 * _1927) + ceil32(return_data.size) + 224])] = mem[_4505 + (32 * _1927) + ceil32(return_data.size) + 256 len floor32(mem[_4505 + (32 * _1927) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1927) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1927) + (2 * ceil32(return_data.size)) + 288] <= _3293:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3293
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3293 > mem[(32 * _1927) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1927) + (2 * ceil32(return_data.size)) + 288] - _3293
                    else:
                        _1851 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1928 = mem[_1851 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1851 + 192])] = mem[_1851 + 224 len floor32(mem[_1851 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3297 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1928) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1928) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1928) + ceil32(return_data.size) + 260] = _3297
                        mem[(32 * _1928) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1928) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1928) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1928) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1928) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3297, Array(len=2, data=mem[(32 * _1928) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1928) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1928) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4507 = mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1928) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1928) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1928) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1928) + ceil32(return_data.size) + 224]
                        mem[(32 * _1928) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4507 + (32 * _1928) + ceil32(return_data.size) + 224])] = mem[_4507 + (32 * _1928) + ceil32(return_data.size) + 256 len floor32(mem[_4507 + (32 * _1928) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1928) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1928) + (2 * ceil32(return_data.size)) + 288] <= _3297:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3297
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3297 > mem[(32 * _1928) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1928) + (2 * ceil32(return_data.size)) + 288] - _3297
            else:
                if not arg2:
                    if not arg2:
                        _1853 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1929 = mem[_1853 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1853 + 192])] = mem[_1853 + 224 len floor32(mem[_1853 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3301 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1929) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1929) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1929) + ceil32(return_data.size) + 260] = _3301
                        mem[(32 * _1929) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1929) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1929) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1929) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1929) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3301, Array(len=2, data=mem[(32 * _1929) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1929) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1929) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4509 = mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1929) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1929) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1929) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1929) + ceil32(return_data.size) + 224]
                        mem[(32 * _1929) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4509 + (32 * _1929) + ceil32(return_data.size) + 224])] = mem[_4509 + (32 * _1929) + ceil32(return_data.size) + 256 len floor32(mem[_4509 + (32 * _1929) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1929) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1929) + (2 * ceil32(return_data.size)) + 288] <= _3301:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3301
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3301 > mem[(32 * _1929) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1929) + (2 * ceil32(return_data.size)) + 288] - _3301
                    else:
                        _1855 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1930 = mem[_1855 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1855 + 192])] = mem[_1855 + 224 len floor32(mem[_1855 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3305 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1930) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1930) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1930) + ceil32(return_data.size) + 260] = _3305
                        mem[(32 * _1930) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1930) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1930) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1930) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1930) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3305, Array(len=2, data=mem[(32 * _1930) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1930) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1930) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4511 = mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1930) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1930) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1930) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1930) + ceil32(return_data.size) + 224]
                        mem[(32 * _1930) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4511 + (32 * _1930) + ceil32(return_data.size) + 224])] = mem[_4511 + (32 * _1930) + ceil32(return_data.size) + 256 len floor32(mem[_4511 + (32 * _1930) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1930) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1930) + (2 * ceil32(return_data.size)) + 288] <= _3305:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3305
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3305 > mem[(32 * _1930) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1930) + (2 * ceil32(return_data.size)) + 288] - _3305
                else:
                    if not arg2:
                        _1857 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1931 = mem[_1857 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1857 + 192])] = mem[_1857 + 224 len floor32(mem[_1857 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3309 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1931) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1931) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1931) + ceil32(return_data.size) + 260] = _3309
                        mem[(32 * _1931) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1931) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1931) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1931) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1931) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3309, Array(len=2, data=mem[(32 * _1931) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1931) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1931) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4513 = mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1931) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1931) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1931) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1931) + ceil32(return_data.size) + 224]
                        mem[(32 * _1931) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4513 + (32 * _1931) + ceil32(return_data.size) + 224])] = mem[_4513 + (32 * _1931) + ceil32(return_data.size) + 256 len floor32(mem[_4513 + (32 * _1931) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1931) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1931) + (2 * ceil32(return_data.size)) + 288] <= _3309:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3309
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3309 > mem[(32 * _1931) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1931) + (2 * ceil32(return_data.size)) + 288] - _3309
                    else:
                        _1859 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1932 = mem[_1859 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1859 + 192])] = mem[_1859 + 224 len floor32(mem[_1859 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3313 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1932) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1932) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1932) + ceil32(return_data.size) + 260] = _3313
                        mem[(32 * _1932) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1932) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1932) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1932) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1932) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3313, Array(len=2, data=mem[(32 * _1932) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1932) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1932) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4515 = mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1932) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1932) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1932) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1932) + ceil32(return_data.size) + 224]
                        mem[(32 * _1932) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4515 + (32 * _1932) + ceil32(return_data.size) + 224])] = mem[_4515 + (32 * _1932) + ceil32(return_data.size) + 256 len floor32(mem[_4515 + (32 * _1932) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1932) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1932) + (2 * ceil32(return_data.size)) + 288] <= _3313:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3313
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3313 > mem[(32 * _1932) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1932) + (2 * ceil32(return_data.size)) + 288] - _3313
        else:
            require not arg3
            if arg1 != this.address:
                revert with 0, '!sender'
            mem[96] = 2
            mem[128] = address(ext_call.return_data[0])
            mem[160] = address(ext_call.return_data[0])
            require arg4.length >= 64
            require ext_code.size(address(ext_call.return_data[0]))
            call address(ext_call.return_data[0]).approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args address(cd[(arg4 + 68)]), arg2
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[192] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
            mem[196] = arg2
            mem[228] = 64
            mem[260] = 2
            mem[292 len 0] = None
            require ext_code.size(address(cd[(arg4 + 36)]))
            staticcall address(cd[(arg4 + 36)]).getAmountsIn(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args arg2, Array(len=2, data=mem[292 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[192 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(return_data.size) + 192
            require return_data.size >= 32
            if not arg2:
                if not arg2:
                    if not arg2:
                        _1861 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1933 = mem[_1861 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1861 + 192])] = mem[_1861 + 224 len floor32(mem[_1861 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3317 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1933) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1933) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1933) + ceil32(return_data.size) + 260] = _3317
                        mem[(32 * _1933) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1933) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1933) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1933) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1933) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3317, Array(len=2, data=mem[(32 * _1933) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1933) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1933) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4517 = mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1933) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1933) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1933) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1933) + ceil32(return_data.size) + 224]
                        mem[(32 * _1933) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4517 + (32 * _1933) + ceil32(return_data.size) + 224])] = mem[_4517 + (32 * _1933) + ceil32(return_data.size) + 256 len floor32(mem[_4517 + (32 * _1933) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1933) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1933) + (2 * ceil32(return_data.size)) + 288] <= _3317:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3317
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3317 > mem[(32 * _1933) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1933) + (2 * ceil32(return_data.size)) + 288] - _3317
                    else:
                        _1863 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1934 = mem[_1863 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1863 + 192])] = mem[_1863 + 224 len floor32(mem[_1863 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3321 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1934) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1934) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1934) + ceil32(return_data.size) + 260] = _3321
                        mem[(32 * _1934) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1934) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1934) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1934) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1934) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3321, Array(len=2, data=mem[(32 * _1934) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1934) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1934) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4519 = mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1934) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1934) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1934) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1934) + ceil32(return_data.size) + 224]
                        mem[(32 * _1934) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4519 + (32 * _1934) + ceil32(return_data.size) + 224])] = mem[_4519 + (32 * _1934) + ceil32(return_data.size) + 256 len floor32(mem[_4519 + (32 * _1934) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1934) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1934) + (2 * ceil32(return_data.size)) + 288] <= _3321:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3321
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3321 > mem[(32 * _1934) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1934) + (2 * ceil32(return_data.size)) + 288] - _3321
                else:
                    if not arg2:
                        _1865 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1935 = mem[_1865 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1865 + 192])] = mem[_1865 + 224 len floor32(mem[_1865 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3325 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1935) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1935) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1935) + ceil32(return_data.size) + 260] = _3325
                        mem[(32 * _1935) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1935) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1935) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1935) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1935) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3325, Array(len=2, data=mem[(32 * _1935) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1935) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1935) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4521 = mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1935) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1935) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1935) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1935) + ceil32(return_data.size) + 224]
                        mem[(32 * _1935) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4521 + (32 * _1935) + ceil32(return_data.size) + 224])] = mem[_4521 + (32 * _1935) + ceil32(return_data.size) + 256 len floor32(mem[_4521 + (32 * _1935) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1935) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1935) + (2 * ceil32(return_data.size)) + 288] <= _3325:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3325
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3325 > mem[(32 * _1935) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1935) + (2 * ceil32(return_data.size)) + 288] - _3325
                    else:
                        _1867 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1936 = mem[_1867 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1867 + 192])] = mem[_1867 + 224 len floor32(mem[_1867 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3329 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1936) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1936) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1936) + ceil32(return_data.size) + 260] = _3329
                        mem[(32 * _1936) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1936) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1936) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1936) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1936) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3329, Array(len=2, data=mem[(32 * _1936) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1936) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1936) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4523 = mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1936) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1936) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1936) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1936) + ceil32(return_data.size) + 224]
                        mem[(32 * _1936) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4523 + (32 * _1936) + ceil32(return_data.size) + 224])] = mem[_4523 + (32 * _1936) + ceil32(return_data.size) + 256 len floor32(mem[_4523 + (32 * _1936) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1936) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1936) + (2 * ceil32(return_data.size)) + 288] <= _3329:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3329
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3329 > mem[(32 * _1936) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1936) + (2 * ceil32(return_data.size)) + 288] - _3329
            else:
                if not arg2:
                    if not arg2:
                        _1869 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1937 = mem[_1869 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1869 + 192])] = mem[_1869 + 224 len floor32(mem[_1869 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3333 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1937) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1937) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1937) + ceil32(return_data.size) + 260] = _3333
                        mem[(32 * _1937) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1937) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1937) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1937) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1937) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3333, Array(len=2, data=mem[(32 * _1937) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1937) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1937) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4525 = mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1937) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1937) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1937) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1937) + ceil32(return_data.size) + 224]
                        mem[(32 * _1937) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4525 + (32 * _1937) + ceil32(return_data.size) + 224])] = mem[_4525 + (32 * _1937) + ceil32(return_data.size) + 256 len floor32(mem[_4525 + (32 * _1937) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1937) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1937) + (2 * ceil32(return_data.size)) + 288] <= _3333:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3333
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3333 > mem[(32 * _1937) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1937) + (2 * ceil32(return_data.size)) + 288] - _3333
                    else:
                        _1871 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1938 = mem[_1871 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1871 + 192])] = mem[_1871 + 224 len floor32(mem[_1871 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3337 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1938) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1938) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1938) + ceil32(return_data.size) + 260] = _3337
                        mem[(32 * _1938) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1938) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1938) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1938) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1938) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3337, Array(len=2, data=mem[(32 * _1938) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1938) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1938) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4527 = mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1938) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1938) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1938) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1938) + ceil32(return_data.size) + 224]
                        mem[(32 * _1938) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4527 + (32 * _1938) + ceil32(return_data.size) + 224])] = mem[_4527 + (32 * _1938) + ceil32(return_data.size) + 256 len floor32(mem[_4527 + (32 * _1938) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1938) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1938) + (2 * ceil32(return_data.size)) + 288] <= _3337:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3337
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3337 > mem[(32 * _1938) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1938) + (2 * ceil32(return_data.size)) + 288] - _3337
                else:
                    if not arg2:
                        _1873 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1939 = mem[_1873 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1873 + 192])] = mem[_1873 + 224 len floor32(mem[_1873 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3341 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1939) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1939) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1939) + ceil32(return_data.size) + 260] = _3341
                        mem[(32 * _1939) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1939) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1939) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1939) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1939) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3341, Array(len=2, data=mem[(32 * _1939) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1939) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1939) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4529 = mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1939) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1939) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1939) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1939) + ceil32(return_data.size) + 224]
                        mem[(32 * _1939) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4529 + (32 * _1939) + ceil32(return_data.size) + 224])] = mem[_4529 + (32 * _1939) + ceil32(return_data.size) + 256 len floor32(mem[_4529 + (32 * _1939) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1939) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1939) + (2 * ceil32(return_data.size)) + 288] <= _3341:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3341
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3341 > mem[(32 * _1939) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1939) + (2 * ceil32(return_data.size)) + 288] - _3341
                    else:
                        _1875 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1940 = mem[_1875 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1875 + 192])] = mem[_1875 + 224 len floor32(mem[_1875 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3345 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1940) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1940) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1940) + ceil32(return_data.size) + 260] = _3345
                        mem[(32 * _1940) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1940) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1940) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1940) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1940) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3345, Array(len=2, data=mem[(32 * _1940) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1940) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1940) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4531 = mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1940) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1940) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1940) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1940) + ceil32(return_data.size) + 224]
                        mem[(32 * _1940) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4531 + (32 * _1940) + ceil32(return_data.size) + 224])] = mem[_4531 + (32 * _1940) + ceil32(return_data.size) + 256 len floor32(mem[_4531 + (32 * _1940) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1940) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1940) + (2 * ceil32(return_data.size)) + 288] <= _3345:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3345
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3345 > mem[(32 * _1940) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1940) + (2 * ceil32(return_data.size)) + 288] - _3345
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
}

function waultSwapCall(address arg1, uint256 arg2, uint256 arg3, bytes arg4) {
    require calldata.size - 4 >= 128
    require arg4 <= 4294967296
    require arg4 + 36 <= calldata.size
    require arg4.length <= 4294967296 and arg4 + arg4.length + 36 <= calldata.size
    require ext_code.size(msg.sender)
    staticcall msg.sender.token0() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_code.size(msg.sender)
    staticcall msg.sender.token1() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if not arg2:
        if not arg2:
            if arg1 != this.address:
                revert with 0, '!sender'
            mem[96] = 2
            mem[128] = address(ext_call.return_data[0])
            mem[160] = address(ext_call.return_data[0])
            require arg4.length >= 64
            require ext_code.size(address(ext_call.return_data[0]))
            call address(ext_call.return_data[0]).approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args address(cd[(arg4 + 68)]), arg3
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[192] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
            mem[196] = arg3
            mem[228] = 64
            mem[260] = 2
            mem[292 len 0] = None
            require ext_code.size(address(cd[(arg4 + 36)]))
            staticcall address(cd[(arg4 + 36)]).getAmountsIn(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args arg3, Array(len=2, data=mem[292 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[192 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(return_data.size) + 192
            require return_data.size >= 32
            if not arg2:
                if not arg2:
                    if not arg2:
                        _1813 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1909 = mem[_1813 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1813 + 192])] = mem[_1813 + 224 len floor32(mem[_1813 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3221 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1909) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1909) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1909) + ceil32(return_data.size) + 260] = _3221
                        mem[(32 * _1909) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1909) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1909) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1909) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1909) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3221, Array(len=2, data=mem[(32 * _1909) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1909) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1909) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4469 = mem[(32 * _1909) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1909) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1909) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1909) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1909) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1909) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1909) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1909) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1909) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1909) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1909) + ceil32(return_data.size) + 224]
                        mem[(32 * _1909) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4469 + (32 * _1909) + ceil32(return_data.size) + 224])] = mem[_4469 + (32 * _1909) + ceil32(return_data.size) + 256 len floor32(mem[_4469 + (32 * _1909) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1909) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1909) + (2 * ceil32(return_data.size)) + 288] <= _3221:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3221
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3221 > mem[(32 * _1909) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1909) + (2 * ceil32(return_data.size)) + 288] - _3221
                    else:
                        _1815 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1910 = mem[_1815 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1815 + 192])] = mem[_1815 + 224 len floor32(mem[_1815 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3225 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1910) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1910) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1910) + ceil32(return_data.size) + 260] = _3225
                        mem[(32 * _1910) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1910) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1910) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1910) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1910) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3225, Array(len=2, data=mem[(32 * _1910) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1910) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1910) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4471 = mem[(32 * _1910) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1910) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1910) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1910) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1910) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1910) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1910) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1910) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1910) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1910) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1910) + ceil32(return_data.size) + 224]
                        mem[(32 * _1910) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4471 + (32 * _1910) + ceil32(return_data.size) + 224])] = mem[_4471 + (32 * _1910) + ceil32(return_data.size) + 256 len floor32(mem[_4471 + (32 * _1910) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1910) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1910) + (2 * ceil32(return_data.size)) + 288] <= _3225:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3225
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3225 > mem[(32 * _1910) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1910) + (2 * ceil32(return_data.size)) + 288] - _3225
                else:
                    if not arg2:
                        _1817 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1911 = mem[_1817 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1817 + 192])] = mem[_1817 + 224 len floor32(mem[_1817 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3229 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1911) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1911) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1911) + ceil32(return_data.size) + 260] = _3229
                        mem[(32 * _1911) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1911) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1911) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1911) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1911) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3229, Array(len=2, data=mem[(32 * _1911) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1911) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1911) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4473 = mem[(32 * _1911) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1911) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1911) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1911) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1911) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1911) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1911) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1911) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1911) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1911) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1911) + ceil32(return_data.size) + 224]
                        mem[(32 * _1911) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4473 + (32 * _1911) + ceil32(return_data.size) + 224])] = mem[_4473 + (32 * _1911) + ceil32(return_data.size) + 256 len floor32(mem[_4473 + (32 * _1911) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1911) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1911) + (2 * ceil32(return_data.size)) + 288] <= _3229:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3229
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3229 > mem[(32 * _1911) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1911) + (2 * ceil32(return_data.size)) + 288] - _3229
                    else:
                        _1819 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1912 = mem[_1819 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1819 + 192])] = mem[_1819 + 224 len floor32(mem[_1819 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3233 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1912) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1912) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1912) + ceil32(return_data.size) + 260] = _3233
                        mem[(32 * _1912) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1912) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1912) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1912) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1912) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3233, Array(len=2, data=mem[(32 * _1912) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1912) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1912) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4475 = mem[(32 * _1912) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1912) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1912) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1912) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1912) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1912) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1912) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1912) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1912) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1912) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1912) + ceil32(return_data.size) + 224]
                        mem[(32 * _1912) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4475 + (32 * _1912) + ceil32(return_data.size) + 224])] = mem[_4475 + (32 * _1912) + ceil32(return_data.size) + 256 len floor32(mem[_4475 + (32 * _1912) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1912) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1912) + (2 * ceil32(return_data.size)) + 288] <= _3233:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3233
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3233 > mem[(32 * _1912) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1912) + (2 * ceil32(return_data.size)) + 288] - _3233
            else:
                if not arg2:
                    if not arg2:
                        _1821 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1913 = mem[_1821 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1821 + 192])] = mem[_1821 + 224 len floor32(mem[_1821 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3237 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1913) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1913) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1913) + ceil32(return_data.size) + 260] = _3237
                        mem[(32 * _1913) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1913) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1913) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1913) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1913) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3237, Array(len=2, data=mem[(32 * _1913) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1913) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1913) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4477 = mem[(32 * _1913) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1913) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1913) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1913) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1913) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1913) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1913) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1913) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1913) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1913) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1913) + ceil32(return_data.size) + 224]
                        mem[(32 * _1913) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4477 + (32 * _1913) + ceil32(return_data.size) + 224])] = mem[_4477 + (32 * _1913) + ceil32(return_data.size) + 256 len floor32(mem[_4477 + (32 * _1913) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1913) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1913) + (2 * ceil32(return_data.size)) + 288] <= _3237:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3237
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3237 > mem[(32 * _1913) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1913) + (2 * ceil32(return_data.size)) + 288] - _3237
                    else:
                        _1823 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1914 = mem[_1823 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1823 + 192])] = mem[_1823 + 224 len floor32(mem[_1823 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3241 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1914) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1914) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1914) + ceil32(return_data.size) + 260] = _3241
                        mem[(32 * _1914) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1914) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1914) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1914) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1914) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3241, Array(len=2, data=mem[(32 * _1914) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1914) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1914) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4479 = mem[(32 * _1914) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1914) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1914) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1914) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1914) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1914) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1914) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1914) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1914) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1914) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1914) + ceil32(return_data.size) + 224]
                        mem[(32 * _1914) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4479 + (32 * _1914) + ceil32(return_data.size) + 224])] = mem[_4479 + (32 * _1914) + ceil32(return_data.size) + 256 len floor32(mem[_4479 + (32 * _1914) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1914) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1914) + (2 * ceil32(return_data.size)) + 288] <= _3241:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3241
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3241 > mem[(32 * _1914) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1914) + (2 * ceil32(return_data.size)) + 288] - _3241
                else:
                    if not arg2:
                        _1825 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1915 = mem[_1825 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1825 + 192])] = mem[_1825 + 224 len floor32(mem[_1825 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3245 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1915) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1915) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1915) + ceil32(return_data.size) + 260] = _3245
                        mem[(32 * _1915) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1915) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1915) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1915) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1915) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3245, Array(len=2, data=mem[(32 * _1915) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1915) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1915) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4481 = mem[(32 * _1915) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1915) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1915) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1915) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1915) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1915) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1915) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1915) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1915) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1915) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1915) + ceil32(return_data.size) + 224]
                        mem[(32 * _1915) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4481 + (32 * _1915) + ceil32(return_data.size) + 224])] = mem[_4481 + (32 * _1915) + ceil32(return_data.size) + 256 len floor32(mem[_4481 + (32 * _1915) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1915) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1915) + (2 * ceil32(return_data.size)) + 288] <= _3245:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3245
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3245 > mem[(32 * _1915) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1915) + (2 * ceil32(return_data.size)) + 288] - _3245
                    else:
                        _1827 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1916 = mem[_1827 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1827 + 192])] = mem[_1827 + 224 len floor32(mem[_1827 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3249 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1916) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1916) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1916) + ceil32(return_data.size) + 260] = _3249
                        mem[(32 * _1916) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1916) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1916) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1916) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1916) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3249, Array(len=2, data=mem[(32 * _1916) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1916) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1916) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4483 = mem[(32 * _1916) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1916) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1916) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1916) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1916) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1916) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1916) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1916) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1916) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1916) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1916) + ceil32(return_data.size) + 224]
                        mem[(32 * _1916) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4483 + (32 * _1916) + ceil32(return_data.size) + 224])] = mem[_4483 + (32 * _1916) + ceil32(return_data.size) + 256 len floor32(mem[_4483 + (32 * _1916) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1916) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1916) + (2 * ceil32(return_data.size)) + 288] <= _3249:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3249
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3249 > mem[(32 * _1916) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1916) + (2 * ceil32(return_data.size)) + 288] - _3249
        else:
            require not arg3
            if arg1 != this.address:
                revert with 0, '!sender'
            mem[96] = 2
            mem[128] = address(ext_call.return_data[0])
            mem[160] = address(ext_call.return_data[0])
            require arg4.length >= 64
            require ext_code.size(address(ext_call.return_data[0]))
            call address(ext_call.return_data[0]).approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args address(cd[(arg4 + 68)]), arg3
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[192] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
            mem[196] = arg3
            mem[228] = 64
            mem[260] = 2
            mem[292 len 0] = None
            require ext_code.size(address(cd[(arg4 + 36)]))
            staticcall address(cd[(arg4 + 36)]).getAmountsIn(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args arg3, Array(len=2, data=mem[292 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[192 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(return_data.size) + 192
            require return_data.size >= 32
            if not arg2:
                if not arg2:
                    if not arg2:
                        _1829 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1917 = mem[_1829 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1829 + 192])] = mem[_1829 + 224 len floor32(mem[_1829 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3253 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1917) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1917) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1917) + ceil32(return_data.size) + 260] = _3253
                        mem[(32 * _1917) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1917) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1917) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1917) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1917) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3253, Array(len=2, data=mem[(32 * _1917) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1917) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1917) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4485 = mem[(32 * _1917) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1917) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1917) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1917) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1917) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1917) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1917) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1917) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1917) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1917) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1917) + ceil32(return_data.size) + 224]
                        mem[(32 * _1917) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4485 + (32 * _1917) + ceil32(return_data.size) + 224])] = mem[_4485 + (32 * _1917) + ceil32(return_data.size) + 256 len floor32(mem[_4485 + (32 * _1917) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1917) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1917) + (2 * ceil32(return_data.size)) + 288] <= _3253:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3253
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3253 > mem[(32 * _1917) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1917) + (2 * ceil32(return_data.size)) + 288] - _3253
                    else:
                        _1831 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1918 = mem[_1831 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1831 + 192])] = mem[_1831 + 224 len floor32(mem[_1831 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3257 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1918) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1918) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1918) + ceil32(return_data.size) + 260] = _3257
                        mem[(32 * _1918) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1918) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1918) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1918) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1918) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3257, Array(len=2, data=mem[(32 * _1918) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1918) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1918) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4487 = mem[(32 * _1918) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1918) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1918) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1918) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1918) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1918) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1918) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1918) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1918) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1918) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1918) + ceil32(return_data.size) + 224]
                        mem[(32 * _1918) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4487 + (32 * _1918) + ceil32(return_data.size) + 224])] = mem[_4487 + (32 * _1918) + ceil32(return_data.size) + 256 len floor32(mem[_4487 + (32 * _1918) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1918) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1918) + (2 * ceil32(return_data.size)) + 288] <= _3257:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3257
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3257 > mem[(32 * _1918) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1918) + (2 * ceil32(return_data.size)) + 288] - _3257
                else:
                    if not arg2:
                        _1833 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1919 = mem[_1833 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1833 + 192])] = mem[_1833 + 224 len floor32(mem[_1833 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3261 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1919) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1919) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1919) + ceil32(return_data.size) + 260] = _3261
                        mem[(32 * _1919) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1919) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1919) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1919) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1919) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3261, Array(len=2, data=mem[(32 * _1919) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1919) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1919) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4489 = mem[(32 * _1919) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1919) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1919) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1919) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1919) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1919) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1919) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1919) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1919) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1919) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1919) + ceil32(return_data.size) + 224]
                        mem[(32 * _1919) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4489 + (32 * _1919) + ceil32(return_data.size) + 224])] = mem[_4489 + (32 * _1919) + ceil32(return_data.size) + 256 len floor32(mem[_4489 + (32 * _1919) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1919) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1919) + (2 * ceil32(return_data.size)) + 288] <= _3261:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3261
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3261 > mem[(32 * _1919) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1919) + (2 * ceil32(return_data.size)) + 288] - _3261
                    else:
                        _1835 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1920 = mem[_1835 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1835 + 192])] = mem[_1835 + 224 len floor32(mem[_1835 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3265 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1920) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1920) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1920) + ceil32(return_data.size) + 260] = _3265
                        mem[(32 * _1920) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1920) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1920) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1920) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1920) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3265, Array(len=2, data=mem[(32 * _1920) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1920) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1920) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4491 = mem[(32 * _1920) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1920) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1920) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1920) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1920) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1920) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1920) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1920) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1920) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1920) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1920) + ceil32(return_data.size) + 224]
                        mem[(32 * _1920) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4491 + (32 * _1920) + ceil32(return_data.size) + 224])] = mem[_4491 + (32 * _1920) + ceil32(return_data.size) + 256 len floor32(mem[_4491 + (32 * _1920) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1920) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1920) + (2 * ceil32(return_data.size)) + 288] <= _3265:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3265
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3265 > mem[(32 * _1920) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1920) + (2 * ceil32(return_data.size)) + 288] - _3265
            else:
                if not arg2:
                    if not arg2:
                        _1837 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1921 = mem[_1837 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1837 + 192])] = mem[_1837 + 224 len floor32(mem[_1837 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3269 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1921) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1921) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1921) + ceil32(return_data.size) + 260] = _3269
                        mem[(32 * _1921) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1921) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1921) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1921) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1921) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3269, Array(len=2, data=mem[(32 * _1921) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1921) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1921) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4493 = mem[(32 * _1921) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1921) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1921) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1921) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1921) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1921) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1921) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1921) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1921) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1921) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1921) + ceil32(return_data.size) + 224]
                        mem[(32 * _1921) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4493 + (32 * _1921) + ceil32(return_data.size) + 224])] = mem[_4493 + (32 * _1921) + ceil32(return_data.size) + 256 len floor32(mem[_4493 + (32 * _1921) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1921) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1921) + (2 * ceil32(return_data.size)) + 288] <= _3269:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3269
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3269 > mem[(32 * _1921) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1921) + (2 * ceil32(return_data.size)) + 288] - _3269
                    else:
                        _1839 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1922 = mem[_1839 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1839 + 192])] = mem[_1839 + 224 len floor32(mem[_1839 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3273 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1922) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1922) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1922) + ceil32(return_data.size) + 260] = _3273
                        mem[(32 * _1922) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1922) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1922) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1922) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1922) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3273, Array(len=2, data=mem[(32 * _1922) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1922) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1922) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4495 = mem[(32 * _1922) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1922) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1922) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1922) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1922) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1922) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1922) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1922) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1922) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1922) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1922) + ceil32(return_data.size) + 224]
                        mem[(32 * _1922) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4495 + (32 * _1922) + ceil32(return_data.size) + 224])] = mem[_4495 + (32 * _1922) + ceil32(return_data.size) + 256 len floor32(mem[_4495 + (32 * _1922) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1922) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1922) + (2 * ceil32(return_data.size)) + 288] <= _3273:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3273
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3273 > mem[(32 * _1922) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1922) + (2 * ceil32(return_data.size)) + 288] - _3273
                else:
                    if not arg2:
                        _1841 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1923 = mem[_1841 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1841 + 192])] = mem[_1841 + 224 len floor32(mem[_1841 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3277 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1923) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1923) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1923) + ceil32(return_data.size) + 260] = _3277
                        mem[(32 * _1923) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1923) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1923) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1923) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1923) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3277, Array(len=2, data=mem[(32 * _1923) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1923) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1923) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4497 = mem[(32 * _1923) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1923) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1923) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1923) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1923) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1923) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1923) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1923) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1923) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1923) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1923) + ceil32(return_data.size) + 224]
                        mem[(32 * _1923) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4497 + (32 * _1923) + ceil32(return_data.size) + 224])] = mem[_4497 + (32 * _1923) + ceil32(return_data.size) + 256 len floor32(mem[_4497 + (32 * _1923) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1923) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1923) + (2 * ceil32(return_data.size)) + 288] <= _3277:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3277
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3277 > mem[(32 * _1923) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1923) + (2 * ceil32(return_data.size)) + 288] - _3277
                    else:
                        _1843 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1924 = mem[_1843 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1843 + 192])] = mem[_1843 + 224 len floor32(mem[_1843 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3281 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1924) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1924) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1924) + ceil32(return_data.size) + 260] = _3281
                        mem[(32 * _1924) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1924) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1924) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1924) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1924) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3281, Array(len=2, data=mem[(32 * _1924) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1924) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1924) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4499 = mem[(32 * _1924) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1924) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1924) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1924) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1924) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1924) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1924) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1924) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1924) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1924) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1924) + ceil32(return_data.size) + 224]
                        mem[(32 * _1924) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4499 + (32 * _1924) + ceil32(return_data.size) + 224])] = mem[_4499 + (32 * _1924) + ceil32(return_data.size) + 256 len floor32(mem[_4499 + (32 * _1924) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1924) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1924) + (2 * ceil32(return_data.size)) + 288] <= _3281:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3281
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3281 > mem[(32 * _1924) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1924) + (2 * ceil32(return_data.size)) + 288] - _3281
    else:
        if not arg2:
            if arg1 != this.address:
                revert with 0, '!sender'
            mem[96] = 2
            mem[128] = address(ext_call.return_data[0])
            mem[160] = address(ext_call.return_data[0])
            require arg4.length >= 64
            require ext_code.size(address(ext_call.return_data[0]))
            call address(ext_call.return_data[0]).approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args address(cd[(arg4 + 68)]), arg2
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[192] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
            mem[196] = arg2
            mem[228] = 64
            mem[260] = 2
            mem[292 len 0] = None
            require ext_code.size(address(cd[(arg4 + 36)]))
            staticcall address(cd[(arg4 + 36)]).getAmountsIn(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args arg2, Array(len=2, data=mem[292 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[192 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(return_data.size) + 192
            require return_data.size >= 32
            if not arg2:
                if not arg2:
                    if not arg2:
                        _1845 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1925 = mem[_1845 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1845 + 192])] = mem[_1845 + 224 len floor32(mem[_1845 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3285 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1925) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1925) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1925) + ceil32(return_data.size) + 260] = _3285
                        mem[(32 * _1925) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1925) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1925) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1925) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1925) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3285, Array(len=2, data=mem[(32 * _1925) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1925) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1925) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4501 = mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1925) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1925) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1925) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1925) + ceil32(return_data.size) + 224]
                        mem[(32 * _1925) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4501 + (32 * _1925) + ceil32(return_data.size) + 224])] = mem[_4501 + (32 * _1925) + ceil32(return_data.size) + 256 len floor32(mem[_4501 + (32 * _1925) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1925) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1925) + (2 * ceil32(return_data.size)) + 288] <= _3285:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3285
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3285 > mem[(32 * _1925) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1925) + (2 * ceil32(return_data.size)) + 288] - _3285
                    else:
                        _1847 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1926 = mem[_1847 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1847 + 192])] = mem[_1847 + 224 len floor32(mem[_1847 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3289 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1926) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1926) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1926) + ceil32(return_data.size) + 260] = _3289
                        mem[(32 * _1926) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1926) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1926) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1926) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1926) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3289, Array(len=2, data=mem[(32 * _1926) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1926) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1926) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4503 = mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1926) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1926) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1926) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1926) + ceil32(return_data.size) + 224]
                        mem[(32 * _1926) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4503 + (32 * _1926) + ceil32(return_data.size) + 224])] = mem[_4503 + (32 * _1926) + ceil32(return_data.size) + 256 len floor32(mem[_4503 + (32 * _1926) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1926) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1926) + (2 * ceil32(return_data.size)) + 288] <= _3289:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3289
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3289 > mem[(32 * _1926) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1926) + (2 * ceil32(return_data.size)) + 288] - _3289
                else:
                    if not arg2:
                        _1849 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1927 = mem[_1849 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1849 + 192])] = mem[_1849 + 224 len floor32(mem[_1849 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3293 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1927) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1927) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1927) + ceil32(return_data.size) + 260] = _3293
                        mem[(32 * _1927) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1927) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1927) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1927) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1927) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3293, Array(len=2, data=mem[(32 * _1927) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1927) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1927) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4505 = mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1927) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1927) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1927) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1927) + ceil32(return_data.size) + 224]
                        mem[(32 * _1927) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4505 + (32 * _1927) + ceil32(return_data.size) + 224])] = mem[_4505 + (32 * _1927) + ceil32(return_data.size) + 256 len floor32(mem[_4505 + (32 * _1927) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1927) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1927) + (2 * ceil32(return_data.size)) + 288] <= _3293:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3293
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3293 > mem[(32 * _1927) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1927) + (2 * ceil32(return_data.size)) + 288] - _3293
                    else:
                        _1851 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1928 = mem[_1851 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1851 + 192])] = mem[_1851 + 224 len floor32(mem[_1851 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3297 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1928) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1928) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1928) + ceil32(return_data.size) + 260] = _3297
                        mem[(32 * _1928) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1928) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1928) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1928) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1928) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3297, Array(len=2, data=mem[(32 * _1928) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1928) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1928) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4507 = mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1928) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1928) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1928) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1928) + ceil32(return_data.size) + 224]
                        mem[(32 * _1928) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4507 + (32 * _1928) + ceil32(return_data.size) + 224])] = mem[_4507 + (32 * _1928) + ceil32(return_data.size) + 256 len floor32(mem[_4507 + (32 * _1928) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1928) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1928) + (2 * ceil32(return_data.size)) + 288] <= _3297:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3297
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3297 > mem[(32 * _1928) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1928) + (2 * ceil32(return_data.size)) + 288] - _3297
            else:
                if not arg2:
                    if not arg2:
                        _1853 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1929 = mem[_1853 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1853 + 192])] = mem[_1853 + 224 len floor32(mem[_1853 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3301 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1929) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1929) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1929) + ceil32(return_data.size) + 260] = _3301
                        mem[(32 * _1929) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1929) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1929) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1929) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1929) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3301, Array(len=2, data=mem[(32 * _1929) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1929) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1929) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4509 = mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1929) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1929) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1929) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1929) + ceil32(return_data.size) + 224]
                        mem[(32 * _1929) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4509 + (32 * _1929) + ceil32(return_data.size) + 224])] = mem[_4509 + (32 * _1929) + ceil32(return_data.size) + 256 len floor32(mem[_4509 + (32 * _1929) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1929) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1929) + (2 * ceil32(return_data.size)) + 288] <= _3301:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3301
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3301 > mem[(32 * _1929) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1929) + (2 * ceil32(return_data.size)) + 288] - _3301
                    else:
                        _1855 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1930 = mem[_1855 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1855 + 192])] = mem[_1855 + 224 len floor32(mem[_1855 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3305 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1930) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1930) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1930) + ceil32(return_data.size) + 260] = _3305
                        mem[(32 * _1930) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1930) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1930) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1930) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1930) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3305, Array(len=2, data=mem[(32 * _1930) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1930) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1930) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4511 = mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1930) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1930) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1930) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1930) + ceil32(return_data.size) + 224]
                        mem[(32 * _1930) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4511 + (32 * _1930) + ceil32(return_data.size) + 224])] = mem[_4511 + (32 * _1930) + ceil32(return_data.size) + 256 len floor32(mem[_4511 + (32 * _1930) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1930) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1930) + (2 * ceil32(return_data.size)) + 288] <= _3305:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3305
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3305 > mem[(32 * _1930) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1930) + (2 * ceil32(return_data.size)) + 288] - _3305
                else:
                    if not arg2:
                        _1857 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1931 = mem[_1857 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1857 + 192])] = mem[_1857 + 224 len floor32(mem[_1857 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3309 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1931) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1931) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1931) + ceil32(return_data.size) + 260] = _3309
                        mem[(32 * _1931) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1931) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1931) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1931) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1931) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3309, Array(len=2, data=mem[(32 * _1931) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1931) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1931) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4513 = mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1931) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1931) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1931) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1931) + ceil32(return_data.size) + 224]
                        mem[(32 * _1931) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4513 + (32 * _1931) + ceil32(return_data.size) + 224])] = mem[_4513 + (32 * _1931) + ceil32(return_data.size) + 256 len floor32(mem[_4513 + (32 * _1931) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1931) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1931) + (2 * ceil32(return_data.size)) + 288] <= _3309:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3309
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3309 > mem[(32 * _1931) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1931) + (2 * ceil32(return_data.size)) + 288] - _3309
                    else:
                        _1859 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1932 = mem[_1859 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1859 + 192])] = mem[_1859 + 224 len floor32(mem[_1859 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3313 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1932) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1932) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1932) + ceil32(return_data.size) + 260] = _3313
                        mem[(32 * _1932) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1932) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1932) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1932) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1932) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3313, Array(len=2, data=mem[(32 * _1932) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1932) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1932) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4515 = mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1932) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1932) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1932) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1932) + ceil32(return_data.size) + 224]
                        mem[(32 * _1932) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4515 + (32 * _1932) + ceil32(return_data.size) + 224])] = mem[_4515 + (32 * _1932) + ceil32(return_data.size) + 256 len floor32(mem[_4515 + (32 * _1932) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1932) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1932) + (2 * ceil32(return_data.size)) + 288] <= _3313:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3313
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3313 > mem[(32 * _1932) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1932) + (2 * ceil32(return_data.size)) + 288] - _3313
        else:
            require not arg3
            if arg1 != this.address:
                revert with 0, '!sender'
            mem[96] = 2
            mem[128] = address(ext_call.return_data[0])
            mem[160] = address(ext_call.return_data[0])
            require arg4.length >= 64
            require ext_code.size(address(ext_call.return_data[0]))
            call address(ext_call.return_data[0]).approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args address(cd[(arg4 + 68)]), arg2
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[192] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
            mem[196] = arg2
            mem[228] = 64
            mem[260] = 2
            mem[292 len 0] = None
            require ext_code.size(address(cd[(arg4 + 36)]))
            staticcall address(cd[(arg4 + 36)]).getAmountsIn(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args arg2, Array(len=2, data=mem[292 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[192 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(return_data.size) + 192
            require return_data.size >= 32
            if not arg2:
                if not arg2:
                    if not arg2:
                        _1861 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1933 = mem[_1861 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1861 + 192])] = mem[_1861 + 224 len floor32(mem[_1861 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3317 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1933) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1933) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1933) + ceil32(return_data.size) + 260] = _3317
                        mem[(32 * _1933) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1933) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1933) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1933) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1933) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3317, Array(len=2, data=mem[(32 * _1933) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1933) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1933) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4517 = mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1933) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1933) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1933) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1933) + ceil32(return_data.size) + 224]
                        mem[(32 * _1933) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4517 + (32 * _1933) + ceil32(return_data.size) + 224])] = mem[_4517 + (32 * _1933) + ceil32(return_data.size) + 256 len floor32(mem[_4517 + (32 * _1933) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1933) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1933) + (2 * ceil32(return_data.size)) + 288] <= _3317:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3317
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3317 > mem[(32 * _1933) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1933) + (2 * ceil32(return_data.size)) + 288] - _3317
                    else:
                        _1863 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1934 = mem[_1863 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1863 + 192])] = mem[_1863 + 224 len floor32(mem[_1863 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3321 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1934) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1934) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1934) + ceil32(return_data.size) + 260] = _3321
                        mem[(32 * _1934) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1934) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1934) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1934) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1934) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3321, Array(len=2, data=mem[(32 * _1934) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1934) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1934) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4519 = mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1934) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1934) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1934) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1934) + ceil32(return_data.size) + 224]
                        mem[(32 * _1934) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4519 + (32 * _1934) + ceil32(return_data.size) + 224])] = mem[_4519 + (32 * _1934) + ceil32(return_data.size) + 256 len floor32(mem[_4519 + (32 * _1934) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1934) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1934) + (2 * ceil32(return_data.size)) + 288] <= _3321:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3321
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3321 > mem[(32 * _1934) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1934) + (2 * ceil32(return_data.size)) + 288] - _3321
                else:
                    if not arg2:
                        _1865 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1935 = mem[_1865 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1865 + 192])] = mem[_1865 + 224 len floor32(mem[_1865 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3325 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1935) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1935) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1935) + ceil32(return_data.size) + 260] = _3325
                        mem[(32 * _1935) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1935) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1935) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1935) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1935) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3325, Array(len=2, data=mem[(32 * _1935) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1935) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1935) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4521 = mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1935) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1935) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1935) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1935) + ceil32(return_data.size) + 224]
                        mem[(32 * _1935) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4521 + (32 * _1935) + ceil32(return_data.size) + 224])] = mem[_4521 + (32 * _1935) + ceil32(return_data.size) + 256 len floor32(mem[_4521 + (32 * _1935) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1935) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1935) + (2 * ceil32(return_data.size)) + 288] <= _3325:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3325
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3325 > mem[(32 * _1935) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1935) + (2 * ceil32(return_data.size)) + 288] - _3325
                    else:
                        _1867 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1936 = mem[_1867 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1867 + 192])] = mem[_1867 + 224 len floor32(mem[_1867 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3329 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1936) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1936) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1936) + ceil32(return_data.size) + 260] = _3329
                        mem[(32 * _1936) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1936) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1936) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1936) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1936) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3329, Array(len=2, data=mem[(32 * _1936) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1936) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1936) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4523 = mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1936) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1936) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1936) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1936) + ceil32(return_data.size) + 224]
                        mem[(32 * _1936) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4523 + (32 * _1936) + ceil32(return_data.size) + 224])] = mem[_4523 + (32 * _1936) + ceil32(return_data.size) + 256 len floor32(mem[_4523 + (32 * _1936) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1936) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1936) + (2 * ceil32(return_data.size)) + 288] <= _3329:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3329
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3329 > mem[(32 * _1936) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1936) + (2 * ceil32(return_data.size)) + 288] - _3329
            else:
                if not arg2:
                    if not arg2:
                        _1869 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1937 = mem[_1869 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1869 + 192])] = mem[_1869 + 224 len floor32(mem[_1869 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3333 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1937) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1937) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1937) + ceil32(return_data.size) + 260] = _3333
                        mem[(32 * _1937) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1937) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1937) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1937) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1937) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3333, Array(len=2, data=mem[(32 * _1937) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1937) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1937) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4525 = mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1937) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1937) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1937) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1937) + ceil32(return_data.size) + 224]
                        mem[(32 * _1937) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4525 + (32 * _1937) + ceil32(return_data.size) + 224])] = mem[_4525 + (32 * _1937) + ceil32(return_data.size) + 256 len floor32(mem[_4525 + (32 * _1937) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1937) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1937) + (2 * ceil32(return_data.size)) + 288] <= _3333:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3333
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3333 > mem[(32 * _1937) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1937) + (2 * ceil32(return_data.size)) + 288] - _3333
                    else:
                        _1871 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1938 = mem[_1871 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1871 + 192])] = mem[_1871 + 224 len floor32(mem[_1871 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3337 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1938) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1938) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1938) + ceil32(return_data.size) + 260] = _3337
                        mem[(32 * _1938) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1938) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1938) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1938) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1938) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3337, Array(len=2, data=mem[(32 * _1938) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1938) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1938) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4527 = mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1938) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1938) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1938) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1938) + ceil32(return_data.size) + 224]
                        mem[(32 * _1938) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4527 + (32 * _1938) + ceil32(return_data.size) + 224])] = mem[_4527 + (32 * _1938) + ceil32(return_data.size) + 256 len floor32(mem[_4527 + (32 * _1938) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1938) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1938) + (2 * ceil32(return_data.size)) + 288] <= _3337:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3337
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3337 > mem[(32 * _1938) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1938) + (2 * ceil32(return_data.size)) + 288] - _3337
                else:
                    if not arg2:
                        _1873 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1939 = mem[_1873 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1873 + 192])] = mem[_1873 + 224 len floor32(mem[_1873 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3341 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1939) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1939) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1939) + ceil32(return_data.size) + 260] = _3341
                        mem[(32 * _1939) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1939) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1939) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1939) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1939) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3341, Array(len=2, data=mem[(32 * _1939) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1939) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1939) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4529 = mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1939) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1939) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1939) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1939) + ceil32(return_data.size) + 224]
                        mem[(32 * _1939) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4529 + (32 * _1939) + ceil32(return_data.size) + 224])] = mem[_4529 + (32 * _1939) + ceil32(return_data.size) + 256 len floor32(mem[_4529 + (32 * _1939) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1939) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1939) + (2 * ceil32(return_data.size)) + 288] <= _3341:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3341
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3341 > mem[(32 * _1939) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1939) + (2 * ceil32(return_data.size)) + 288] - _3341
                    else:
                        _1875 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1940 = mem[_1875 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1875 + 192])] = mem[_1875 + 224 len floor32(mem[_1875 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3345 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1940) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1940) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1940) + ceil32(return_data.size) + 260] = _3345
                        mem[(32 * _1940) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1940) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1940) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1940) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1940) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(address(cd[(arg4 + 68)]))
                        call address(cd[(arg4 + 68)]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3345, Array(len=2, data=mem[(32 * _1940) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1940) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1940) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4531 = mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1940) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1940) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1940) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1940) + ceil32(return_data.size) + 224]
                        mem[(32 * _1940) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4531 + (32 * _1940) + ceil32(return_data.size) + 224])] = mem[_4531 + (32 * _1940) + ceil32(return_data.size) + 256 len floor32(mem[_4531 + (32 * _1940) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1940) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1940) + (2 * ceil32(return_data.size)) + 288] <= _3345:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3345
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3345 > mem[(32 * _1940) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor1, mem[(32 * _1940) + (2 * ceil32(return_data.size)) + 288] - _3345
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
}



}

contract main {




// =====================  Runtime code  =====================


#
#  - withdraw(uint256 arg1, uint256 arg2)
#  - sub_4f00a93e(?)
#  - emergencyWithdraw(uint256 arg1)
#  - deposit(uint256 arg1, uint256 arg2)
#  - pendingTokens(uint256 arg1, address arg2)
#
uint8 stor0;
uint8 stor0; offset 8
uint256 stor0; offset 8
address owner;
uint32 stor151;
address MASTER_CHEF_V2Address;
address JOEAddress;
address sub_e76fdb7eAddress;
uint256 MASTER_PID;
array of struct poolInfo;
mapping of uint8 stor156;
mapping of struct userInfo;
uint256 totalAllocPoint;
uint256 stor159;
mapping of uint256 sub_d00ffa8e;

function poolLength() payable {
    return poolInfo.length
}

function poolInfo(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 < poolInfo.length
    return poolInfo[arg1].field_0, 
           poolInfo[arg1].field_0,
           poolInfo[arg1].field_256,
           poolInfo[arg1].field_512,
           poolInfo[arg1].field_768,
           poolInfo[arg1].field_768,
           poolInfo[arg1].field_768,
           poolInfo[arg1].field_1024,
           poolInfo[arg1].field_1280
}

function totalAllocPoint() payable {
    return totalAllocPoint
}

function MASTER_CHEF_V2() payable {
    return address(MASTER_CHEF_V2Address)
}

function MASTER_PID() payable {
    return MASTER_PID
}

function owner() payable {
    return owner
}

function userInfo(uint256 arg1, address arg2) payable {
    require calldata.size - 4 >= 64
    require arg2 == arg2
    return userInfo[arg1][arg2].field_0, userInfo[arg1][arg2].field_256, userInfo[arg1][arg2].field_512
}

function sub_d00ffa8e(?) payable {
    require calldata.size - 4 >= 64
    require arg2 == address(arg2)
    return sub_d00ffa8e[arg1][arg2]
}

function sub_e76fdb7e(?) payable {
    return sub_e76fdb7eAddress
}

function JOE() payable {
    return JOEAddress
}

function _fallback() payable {
    revert
}

function renounceOwnership() payable {
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    emit OwnershipTransferred(owner, 0);
    owner = 0
}

function harvestFromMasterChef() payable {
    require ext_code.size(address(MASTER_CHEF_V2Address))
    call address(MASTER_CHEF_V2Address).0xe2bbb158 with:
         gas gas_remaining wei
        args MASTER_PID, 0
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
}

function transferOwnership(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Ownable: new owner is the zero address'
    emit OwnershipTransferred(owner, arg1);
    owner = arg1
}

function init(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    mem[100] = address(MASTER_CHEF_V2Address)
    require ext_code.size(arg1)
    staticcall arg1.0x70a08231 with:
            gas gas_remaining wei
           args address(MASTER_CHEF_V2Address)
    mem[96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if ext_call.return_data[0]:
        revert with 0, 'BoostedMasterChefJoe: Already has a balance of dummy token'
    mem[ceil32(return_data.size) + 100] = msg.sender
    require ext_code.size(arg1)
    staticcall arg1.0x70a08231 with:
            gas gas_remaining wei
           args msg.sender
    mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if not ext_call.return_data[0]:
        revert with 0, 'BoostedMasterChefJoe: Balance must exceed 0'
    mem[(2 * ceil32(return_data.size)) + 96] = 100
    mem[(2 * ceil32(return_data.size)) + 132 len 28] = Mask(224, 32, msg.sender) >> 32
    mem[(2 * ceil32(return_data.size)) + 128 len 4] = unknown_0x23b872dd(?????)
    mem[(2 * ceil32(return_data.size)) + 228 len 128] = unknown_0x23b872dd(?????), msg.sender, address(this.address), ext_call.return_data[0], mem[(2 * ceil32(return_data.size)) + 228 len 28]
    call arg1.mem[(2 * ceil32(return_data.size)) + 228 len 4] with:
         gas gas_remaining wei
        args mem[(2 * ceil32(return_data.size)) + 232 len 96]
    if not return_data.size:
        if not ext_call.success:
            revert with 0, 'BoringERC20: TransferFrom failed'
        if ext_call.return_data[0]:
            require ext_call.return_data[0] >= 32
            require uint32(stor151), mem[132 len 28] == bool(uint32(stor151), mem[132 len 28])
            if not uint32(stor151), mem[132 len 28]:
                revert with 0, 'BoringERC20: TransferFrom failed'
    else:
        mem[(2 * ceil32(return_data.size)) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
        if not ext_call.success:
            revert with 0, 'BoringERC20: TransferFrom failed'
        if return_data.size:
            require return_data.size >= 32
            require mem[(2 * ceil32(return_data.size)) + 260] == bool(mem[(2 * ceil32(return_data.size)) + 260])
            if not mem[(2 * ceil32(return_data.size)) + 260]:
                revert with 0, 'BoringERC20: TransferFrom failed'
    require ext_code.size(arg1)
    call arg1.approve(address arg1, uint256 arg2) with:
         gas gas_remaining wei
        args address(MASTER_CHEF_V2Address), ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    require ext_code.size(address(MASTER_CHEF_V2Address))
    call address(MASTER_CHEF_V2Address).0xe2bbb158 with:
         gas gas_remaining wei
        args MASTER_PID, ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    emit 0x387d06ac: ext_call.return_data[0]
}

function initialize(address arg1, address arg2, address arg3, uint256 arg4) payable {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg2 == arg2
    require arg3 == arg3
    if uint8(stor0.field_8):
        owner = msg.sender
        emit OwnershipTransferred(0, msg.sender);
        address(MASTER_CHEF_V2Address) = arg1
        JOEAddress = arg2
        sub_e76fdb7eAddress = arg3
        MASTER_PID = arg4
        stor159 = 10^18
    else:
        if ext_code.size(this.address):
            if uint8(stor0.field_0):
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Initializable: contract is already initialized'
        if uint8(stor0.field_8):
            owner = msg.sender
            emit OwnershipTransferred(0, msg.sender);
            address(MASTER_CHEF_V2Address) = arg1
            JOEAddress = arg2
            sub_e76fdb7eAddress = arg3
            MASTER_PID = arg4
            stor159 = 10^18
        else:
            uint8(stor0.field_0) = 1
            uint8(stor0.field_8) = 1
            Mask(248, 0, stor0.field_8) = 0
            if ext_code.size(this.address):
                if uint8(stor0.field_0):
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Initializable: contract is already initialized'
            if uint8(stor0.field_8):
                owner = msg.sender
                emit OwnershipTransferred(0, msg.sender);
                address(MASTER_CHEF_V2Address) = arg1
                JOEAddress = arg2
                sub_e76fdb7eAddress = arg3
                MASTER_PID = arg4
                stor159 = 10^18
            else:
                uint8(stor0.field_0) = 1
                uint8(stor0.field_8) = 1
                Mask(248, 0, stor0.field_8) = 0
                if ext_code.size(this.address):
                    if uint8(stor0.field_0):
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Initializable: contract is already initialized'
                if uint8(stor0.field_8):
                    owner = msg.sender
                    emit OwnershipTransferred(0, msg.sender);
                    address(MASTER_CHEF_V2Address) = arg1
                    JOEAddress = arg2
                    sub_e76fdb7eAddress = arg3
                    MASTER_PID = arg4
                    stor159 = 10^18
                else:
                    uint8(stor0.field_0) = 1
                    uint8(stor0.field_8) = 1
                    Mask(248, 0, stor0.field_8) = 0
                    uint8(stor0.field_8) = 0
                    if ext_code.size(this.address):
                        if uint8(stor0.field_0):
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Initializable: contract is already initialized'
                    if uint8(stor0.field_8):
                        owner = msg.sender
                        emit OwnershipTransferred(0, msg.sender);
                        address(MASTER_CHEF_V2Address) = arg1
                        JOEAddress = arg2
                        sub_e76fdb7eAddress = arg3
                        MASTER_PID = arg4
                        stor159 = 10^18
                    else:
                        uint8(stor0.field_0) = 1
                        uint8(stor0.field_8) = 1
                        Mask(248, 0, stor0.field_8) = 0
                        owner = msg.sender
                        emit OwnershipTransferred(0, msg.sender);
                        uint8(stor0.field_8) = 0
                        uint8(stor0.field_8) = 0
                        address(MASTER_CHEF_V2Address) = arg1
                        JOEAddress = arg2
                        sub_e76fdb7eAddress = arg3
                        MASTER_PID = arg4
                        stor159 = 10^18
                        uint8(stor0.field_8) = 0
}

function joePerSec() payable {
    require ext_code.size(address(MASTER_CHEF_V2Address))
    staticcall address(MASTER_CHEF_V2Address).investorPercent() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_code.size(address(MASTER_CHEF_V2Address))
    staticcall address(MASTER_CHEF_V2Address).treasuryPercent() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_code.size(address(MASTER_CHEF_V2Address))
    staticcall address(MASTER_CHEF_V2Address).devPercent() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if ext_call.return_data[0] > 1000:
        revert with 0, 'SafeMath: subtraction overflow', 0
    if ext_call.return_data[0] > -ext_call.return_data[0] + 1000:
        revert with 0, 'SafeMath: subtraction overflow', 0
    if ext_call.return_data[0] > (-2 * ext_call.return_data[0]) + 1000:
        revert with 0, 'SafeMath: subtraction overflow', 0
    require ext_code.size(address(MASTER_CHEF_V2Address))
    staticcall address(MASTER_CHEF_V2Address).0xca418d23 with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if not ext_call.return_data[0]:
        require ext_code.size(address(MASTER_CHEF_V2Address))
        staticcall address(MASTER_CHEF_V2Address).0x17caf6f1 with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_code.size(address(MASTER_CHEF_V2Address))
        staticcall address(MASTER_CHEF_V2Address).0x1526fe27 with:
                gas gas_remaining wei
               args MASTER_PID
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 128
        require bool((8 * ceil32(return_data.size)) + 480 <= test266151307())
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        if not ext_call.return_data[0]:
            revert with 0, 'SafeMath: division by zero', 0
        return (0 / ext_call.return_data[0])
    if (1000 * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) / ext_call.return_data[0] != (-3 * ext_call.return_data[0]) + 1000:
        revert with 0, 'SafeMath: multiplication overflow'
    require ext_code.size(address(MASTER_CHEF_V2Address))
    staticcall address(MASTER_CHEF_V2Address).0x17caf6f1 with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_code.size(address(MASTER_CHEF_V2Address))
    staticcall address(MASTER_CHEF_V2Address).0x1526fe27 with:
            gas gas_remaining wei
           args MASTER_PID
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 128
    require bool((8 * ceil32(return_data.size)) + 480 <= test266151307())
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    if not (1000 * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) / 1000:
        if not ext_call.return_data[0]:
            revert with 0, 'SafeMath: division by zero', 0
        return (0 / ext_call.return_data[0])
    if ext_call.return_data[32] * (1000 * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) / 1000 / (1000 * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) / 1000 != ext_call.return_data[32]:
        revert with 0, 'SafeMath: multiplication overflow'
    if not ext_call.return_data[0]:
        revert with 0, 'SafeMath: division by zero', 0
    return (ext_call.return_data[32] * (1000 * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) / 1000 / ext_call.return_data[0])
}

function updatePool(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 < poolInfo.length
    if poolInfo[arg1].field_768 < block.timestamp:
        if poolInfo[arg1].field_1280:
            if poolInfo[arg1].field_160:
                require ext_code.size(address(MASTER_CHEF_V2Address))
                staticcall address(MASTER_CHEF_V2Address).investorPercent() with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_code.size(address(MASTER_CHEF_V2Address))
                staticcall address(MASTER_CHEF_V2Address).treasuryPercent() with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_code.size(address(MASTER_CHEF_V2Address))
                staticcall address(MASTER_CHEF_V2Address).devPercent() with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if ext_call.return_data[0] > 1000:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if ext_call.return_data[0] > -ext_call.return_data[0] + 1000:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if ext_call.return_data[0] > (-2 * ext_call.return_data[0]) + 1000:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                require ext_code.size(address(MASTER_CHEF_V2Address))
                staticcall address(MASTER_CHEF_V2Address).0xca418d23 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if not ext_call.return_data[0]:
                    require ext_code.size(address(MASTER_CHEF_V2Address))
                    staticcall address(MASTER_CHEF_V2Address).0x17caf6f1 with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_code.size(address(MASTER_CHEF_V2Address))
                    staticcall address(MASTER_CHEF_V2Address).0x1526fe27 with:
                            gas gas_remaining wei
                           args MASTER_PID
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 128
                    require bool((8 * ceil32(return_data.size)) + 480 <= test266151307())
                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                    if not ext_call.return_data[0]:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not block.timestamp - poolInfo[arg1].field_768:
                        if not totalAllocPoint:
                            revert with 0, 'SafeMath: division by zero', 0
                        if not poolInfo[arg1].field_1280:
                            if 0 / totalAllocPoint:
                                if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if stor159 * 0 / totalAllocPoint:
                                    if (10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[arg1].field_992 * stor159 * 0 / totalAllocPoint) / stor159 * 0 / totalAllocPoint != -poolInfo[arg1].field_992 + 10000:
                                        revert with 0, 'SafeMath: multiplication overflow'
                            revert with 0, 'SafeMath: division by zero', 0
                        if 10000 * poolInfo[arg1].field_1280 / poolInfo[arg1].field_1280 != 10000:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / totalAllocPoint:
                            if not 10000 * poolInfo[arg1].field_1280:
                                revert with 0, 'SafeMath: division by zero', 0
                            if (0 / 10000 * poolInfo[arg1].field_1280) + poolInfo[arg1].field_256 < poolInfo[arg1].field_256:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[arg1].field_256 += 0 / 10000 * poolInfo[arg1].field_1280
                        else:
                            if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not stor159 * 0 / totalAllocPoint:
                                if not 10000 * poolInfo[arg1].field_1280:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if (0 / 10000 * poolInfo[arg1].field_1280) + poolInfo[arg1].field_256 < poolInfo[arg1].field_256:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[arg1].field_256 += 0 / 10000 * poolInfo[arg1].field_1280
                            else:
                                if (10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[arg1].field_992 * stor159 * 0 / totalAllocPoint) / stor159 * 0 / totalAllocPoint != -poolInfo[arg1].field_992 + 10000:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 10000 * poolInfo[arg1].field_1280:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if ((10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[arg1].field_992 * stor159 * 0 / totalAllocPoint) / 10000 * poolInfo[arg1].field_1280) + poolInfo[arg1].field_256 < poolInfo[arg1].field_256:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[arg1].field_256 += (10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[arg1].field_992 * stor159 * 0 / totalAllocPoint) / 10000 * poolInfo[arg1].field_1280
                        if poolInfo[arg1].field_992:
                            if poolInfo[arg1].field_1024:
                                if not poolInfo[arg1].field_1024:
                                    if 0 / totalAllocPoint:
                                        if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if stor159 * 0 / totalAllocPoint:
                                            if poolInfo[arg1].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[arg1].field_992:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                    revert with 0, 'SafeMath: division by zero', 0
                                if 10000 * poolInfo[arg1].field_1024 / poolInfo[arg1].field_1024 != 10000:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 0 / totalAllocPoint:
                                    if not 10000 * poolInfo[arg1].field_1024:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if (0 / 10000 * poolInfo[arg1].field_1024) + poolInfo[arg1].field_512 < poolInfo[arg1].field_512:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_512 += 0 / 10000 * poolInfo[arg1].field_1024
                                else:
                                    if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not stor159 * 0 / totalAllocPoint:
                                        if not 10000 * poolInfo[arg1].field_1024:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if (0 / 10000 * poolInfo[arg1].field_1024) + poolInfo[arg1].field_512 < poolInfo[arg1].field_512:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_512 += 0 / 10000 * poolInfo[arg1].field_1024
                                    else:
                                        if poolInfo[arg1].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[arg1].field_992:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not 10000 * poolInfo[arg1].field_1024:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if (poolInfo[arg1].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[arg1].field_1024) + poolInfo[arg1].field_512 < poolInfo[arg1].field_512:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_512 += poolInfo[arg1].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[arg1].field_1024
                    else:
                        if (block.timestamp * 0 / ext_call.return_data[0]) - (poolInfo[arg1].field_768 * 0 / ext_call.return_data[0]) / block.timestamp - poolInfo[arg1].field_768 != 0 / ext_call.return_data[0]:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not (block.timestamp * 0 / ext_call.return_data[0]) - (poolInfo[arg1].field_768 * 0 / ext_call.return_data[0]):
                            if not totalAllocPoint:
                                revert with 0, 'SafeMath: division by zero', 0
                            if not poolInfo[arg1].field_1280:
                                if 0 / totalAllocPoint:
                                    if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if stor159 * 0 / totalAllocPoint:
                                        if (10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[arg1].field_992 * stor159 * 0 / totalAllocPoint) / stor159 * 0 / totalAllocPoint != -poolInfo[arg1].field_992 + 10000:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                revert with 0, 'SafeMath: division by zero', 0
                            if 10000 * poolInfo[arg1].field_1280 / poolInfo[arg1].field_1280 != 10000:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / totalAllocPoint:
                                if not 10000 * poolInfo[arg1].field_1280:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if (0 / 10000 * poolInfo[arg1].field_1280) + poolInfo[arg1].field_256 < poolInfo[arg1].field_256:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[arg1].field_256 += 0 / 10000 * poolInfo[arg1].field_1280
                            else:
                                if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not stor159 * 0 / totalAllocPoint:
                                    if not 10000 * poolInfo[arg1].field_1280:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if (0 / 10000 * poolInfo[arg1].field_1280) + poolInfo[arg1].field_256 < poolInfo[arg1].field_256:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_256 += 0 / 10000 * poolInfo[arg1].field_1280
                                else:
                                    if (10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[arg1].field_992 * stor159 * 0 / totalAllocPoint) / stor159 * 0 / totalAllocPoint != -poolInfo[arg1].field_992 + 10000:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not 10000 * poolInfo[arg1].field_1280:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if ((10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[arg1].field_992 * stor159 * 0 / totalAllocPoint) / 10000 * poolInfo[arg1].field_1280) + poolInfo[arg1].field_256 < poolInfo[arg1].field_256:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_256 += (10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[arg1].field_992 * stor159 * 0 / totalAllocPoint) / 10000 * poolInfo[arg1].field_1280
                            if poolInfo[arg1].field_992:
                                if poolInfo[arg1].field_1024:
                                    if not poolInfo[arg1].field_1024:
                                        if 0 / totalAllocPoint:
                                            if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if stor159 * 0 / totalAllocPoint:
                                                if poolInfo[arg1].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[arg1].field_992:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if 10000 * poolInfo[arg1].field_1024 / poolInfo[arg1].field_1024 != 10000:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not 0 / totalAllocPoint:
                                        if not 10000 * poolInfo[arg1].field_1024:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if (0 / 10000 * poolInfo[arg1].field_1024) + poolInfo[arg1].field_512 < poolInfo[arg1].field_512:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_512 += 0 / 10000 * poolInfo[arg1].field_1024
                                    else:
                                        if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not stor159 * 0 / totalAllocPoint:
                                            if not 10000 * poolInfo[arg1].field_1024:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if (0 / 10000 * poolInfo[arg1].field_1024) + poolInfo[arg1].field_512 < poolInfo[arg1].field_512:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_512 += 0 / 10000 * poolInfo[arg1].field_1024
                                        else:
                                            if poolInfo[arg1].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[arg1].field_992:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if not 10000 * poolInfo[arg1].field_1024:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if (poolInfo[arg1].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[arg1].field_1024) + poolInfo[arg1].field_512 < poolInfo[arg1].field_512:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_512 += poolInfo[arg1].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[arg1].field_1024
                        else:
                            if (block.timestamp * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) - (poolInfo[arg1].field_768 * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) / (block.timestamp * 0 / ext_call.return_data[0]) - (poolInfo[arg1].field_768 * 0 / ext_call.return_data[0]) != poolInfo[arg1].field_160:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not totalAllocPoint:
                                revert with 0, 'SafeMath: division by zero', 0
                            if not poolInfo[arg1].field_1280:
                                if (block.timestamp * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) - (poolInfo[arg1].field_768 * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) / totalAllocPoint:
                                    if stor159 * (block.timestamp * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) - (poolInfo[arg1].field_768 * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) / totalAllocPoint / (block.timestamp * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) - (poolInfo[arg1].field_768 * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) / totalAllocPoint != stor159:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if stor159 * (block.timestamp * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) - (poolInfo[arg1].field_768 * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) / totalAllocPoint:
                                        if (10000 * stor159 * (block.timestamp * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) - (poolInfo[arg1].field_768 * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) / totalAllocPoint) - (poolInfo[arg1].field_992 * stor159 * (block.timestamp * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) - (poolInfo[arg1].field_768 * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) / totalAllocPoint) / stor159 * (block.timestamp * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) - (poolInfo[arg1].field_768 * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) / totalAllocPoint != -poolInfo[arg1].field_992 + 10000:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                revert with 0, 'SafeMath: division by zero', 0
                            if 10000 * poolInfo[arg1].field_1280 / poolInfo[arg1].field_1280 != 10000:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not (block.timestamp * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) - (poolInfo[arg1].field_768 * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) / totalAllocPoint:
                                if not 10000 * poolInfo[arg1].field_1280:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if (0 / 10000 * poolInfo[arg1].field_1280) + poolInfo[arg1].field_256 < poolInfo[arg1].field_256:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[arg1].field_256 += 0 / 10000 * poolInfo[arg1].field_1280
                            else:
                                if stor159 * (block.timestamp * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) - (poolInfo[arg1].field_768 * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) / totalAllocPoint / (block.timestamp * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) - (poolInfo[arg1].field_768 * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) / totalAllocPoint != stor159:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not stor159 * (block.timestamp * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) - (poolInfo[arg1].field_768 * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) / totalAllocPoint:
                                    if not 10000 * poolInfo[arg1].field_1280:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if (0 / 10000 * poolInfo[arg1].field_1280) + poolInfo[arg1].field_256 < poolInfo[arg1].field_256:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_256 += 0 / 10000 * poolInfo[arg1].field_1280
                                else:
                                    if (10000 * stor159 * (block.timestamp * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) - (poolInfo[arg1].field_768 * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) / totalAllocPoint) - (poolInfo[arg1].field_992 * stor159 * (block.timestamp * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) - (poolInfo[arg1].field_768 * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) / totalAllocPoint) / stor159 * (block.timestamp * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) - (poolInfo[arg1].field_768 * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) / totalAllocPoint != -poolInfo[arg1].field_992 + 10000:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not 10000 * poolInfo[arg1].field_1280:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if ((10000 * stor159 * (block.timestamp * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) - (poolInfo[arg1].field_768 * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) / totalAllocPoint) - (poolInfo[arg1].field_992 * stor159 * (block.timestamp * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) - (poolInfo[arg1].field_768 * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) / totalAllocPoint) / 10000 * poolInfo[arg1].field_1280) + poolInfo[arg1].field_256 < poolInfo[arg1].field_256:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_256 += (10000 * stor159 * (block.timestamp * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) - (poolInfo[arg1].field_768 * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) / totalAllocPoint) - (poolInfo[arg1].field_992 * stor159 * (block.timestamp * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) - (poolInfo[arg1].field_768 * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) / totalAllocPoint) / 10000 * poolInfo[arg1].field_1280
                            if poolInfo[arg1].field_992:
                                if poolInfo[arg1].field_1024:
                                    if not poolInfo[arg1].field_1024:
                                        if (block.timestamp * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) - (poolInfo[arg1].field_768 * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) / totalAllocPoint:
                                            if stor159 * (block.timestamp * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) - (poolInfo[arg1].field_768 * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) / totalAllocPoint / (block.timestamp * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) - (poolInfo[arg1].field_768 * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) / totalAllocPoint != stor159:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if stor159 * (block.timestamp * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) - (poolInfo[arg1].field_768 * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) / totalAllocPoint:
                                                if poolInfo[arg1].field_992 * stor159 * (block.timestamp * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) - (poolInfo[arg1].field_768 * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) / totalAllocPoint / stor159 * (block.timestamp * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) - (poolInfo[arg1].field_768 * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) / totalAllocPoint != poolInfo[arg1].field_992:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if 10000 * poolInfo[arg1].field_1024 / poolInfo[arg1].field_1024 != 10000:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not (block.timestamp * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) - (poolInfo[arg1].field_768 * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) / totalAllocPoint:
                                        if not 10000 * poolInfo[arg1].field_1024:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if (0 / 10000 * poolInfo[arg1].field_1024) + poolInfo[arg1].field_512 < poolInfo[arg1].field_512:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_512 += 0 / 10000 * poolInfo[arg1].field_1024
                                    else:
                                        if stor159 * (block.timestamp * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) - (poolInfo[arg1].field_768 * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) / totalAllocPoint / (block.timestamp * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) - (poolInfo[arg1].field_768 * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) / totalAllocPoint != stor159:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not stor159 * (block.timestamp * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) - (poolInfo[arg1].field_768 * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) / totalAllocPoint:
                                            if not 10000 * poolInfo[arg1].field_1024:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if (0 / 10000 * poolInfo[arg1].field_1024) + poolInfo[arg1].field_512 < poolInfo[arg1].field_512:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_512 += 0 / 10000 * poolInfo[arg1].field_1024
                                        else:
                                            if poolInfo[arg1].field_992 * stor159 * (block.timestamp * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) - (poolInfo[arg1].field_768 * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) / totalAllocPoint / stor159 * (block.timestamp * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) - (poolInfo[arg1].field_768 * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) / totalAllocPoint != poolInfo[arg1].field_992:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if not 10000 * poolInfo[arg1].field_1024:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if (poolInfo[arg1].field_992 * stor159 * (block.timestamp * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) - (poolInfo[arg1].field_768 * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) / totalAllocPoint / 10000 * poolInfo[arg1].field_1024) + poolInfo[arg1].field_512 < poolInfo[arg1].field_512:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_512 += poolInfo[arg1].field_992 * stor159 * (block.timestamp * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) - (poolInfo[arg1].field_768 * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) / totalAllocPoint / 10000 * poolInfo[arg1].field_1024
                else:
                    if (1000 * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) / ext_call.return_data[0] != (-3 * ext_call.return_data[0]) + 1000:
                        revert with 0, 'SafeMath: multiplication overflow'
                    require ext_code.size(address(MASTER_CHEF_V2Address))
                    staticcall address(MASTER_CHEF_V2Address).0x17caf6f1 with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_code.size(address(MASTER_CHEF_V2Address))
                    staticcall address(MASTER_CHEF_V2Address).0x1526fe27 with:
                            gas gas_remaining wei
                           args MASTER_PID
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 128
                    require bool((8 * ceil32(return_data.size)) + 480 <= test266151307())
                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                    if not (1000 * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) / 1000:
                        if not ext_call.return_data[0]:
                            revert with 0, 'SafeMath: division by zero', 0
                        if not block.timestamp - poolInfo[arg1].field_768:
                            if not totalAllocPoint:
                                revert with 0, 'SafeMath: division by zero', 0
                            if not poolInfo[arg1].field_1280:
                                if 0 / totalAllocPoint:
                                    if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if stor159 * 0 / totalAllocPoint:
                                        if (10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[arg1].field_992 * stor159 * 0 / totalAllocPoint) / stor159 * 0 / totalAllocPoint != -poolInfo[arg1].field_992 + 10000:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                revert with 0, 'SafeMath: division by zero', 0
                            if 10000 * poolInfo[arg1].field_1280 / poolInfo[arg1].field_1280 != 10000:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / totalAllocPoint:
                                if not 10000 * poolInfo[arg1].field_1280:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if (0 / 10000 * poolInfo[arg1].field_1280) + poolInfo[arg1].field_256 < poolInfo[arg1].field_256:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[arg1].field_256 += 0 / 10000 * poolInfo[arg1].field_1280
                            else:
                                if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not stor159 * 0 / totalAllocPoint:
                                    if not 10000 * poolInfo[arg1].field_1280:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if (0 / 10000 * poolInfo[arg1].field_1280) + poolInfo[arg1].field_256 < poolInfo[arg1].field_256:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_256 += 0 / 10000 * poolInfo[arg1].field_1280
                                else:
                                    if (10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[arg1].field_992 * stor159 * 0 / totalAllocPoint) / stor159 * 0 / totalAllocPoint != -poolInfo[arg1].field_992 + 10000:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not 10000 * poolInfo[arg1].field_1280:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if ((10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[arg1].field_992 * stor159 * 0 / totalAllocPoint) / 10000 * poolInfo[arg1].field_1280) + poolInfo[arg1].field_256 < poolInfo[arg1].field_256:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_256 += (10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[arg1].field_992 * stor159 * 0 / totalAllocPoint) / 10000 * poolInfo[arg1].field_1280
                            if poolInfo[arg1].field_992:
                                if poolInfo[arg1].field_1024:
                                    if not poolInfo[arg1].field_1024:
                                        if 0 / totalAllocPoint:
                                            if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if stor159 * 0 / totalAllocPoint:
                                                if poolInfo[arg1].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[arg1].field_992:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if 10000 * poolInfo[arg1].field_1024 / poolInfo[arg1].field_1024 != 10000:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not 0 / totalAllocPoint:
                                        if not 10000 * poolInfo[arg1].field_1024:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if (0 / 10000 * poolInfo[arg1].field_1024) + poolInfo[arg1].field_512 < poolInfo[arg1].field_512:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_512 += 0 / 10000 * poolInfo[arg1].field_1024
                                    else:
                                        if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not stor159 * 0 / totalAllocPoint:
                                            if not 10000 * poolInfo[arg1].field_1024:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if (0 / 10000 * poolInfo[arg1].field_1024) + poolInfo[arg1].field_512 < poolInfo[arg1].field_512:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_512 += 0 / 10000 * poolInfo[arg1].field_1024
                                        else:
                                            if poolInfo[arg1].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[arg1].field_992:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if not 10000 * poolInfo[arg1].field_1024:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if (poolInfo[arg1].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[arg1].field_1024) + poolInfo[arg1].field_512 < poolInfo[arg1].field_512:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_512 += poolInfo[arg1].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[arg1].field_1024
                        else:
                            if (block.timestamp * 0 / ext_call.return_data[0]) - (poolInfo[arg1].field_768 * 0 / ext_call.return_data[0]) / block.timestamp - poolInfo[arg1].field_768 != 0 / ext_call.return_data[0]:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not (block.timestamp * 0 / ext_call.return_data[0]) - (poolInfo[arg1].field_768 * 0 / ext_call.return_data[0]):
                                if not totalAllocPoint:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not poolInfo[arg1].field_1280:
                                    if 0 / totalAllocPoint:
                                        if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if stor159 * 0 / totalAllocPoint:
                                            if (10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[arg1].field_992 * stor159 * 0 / totalAllocPoint) / stor159 * 0 / totalAllocPoint != -poolInfo[arg1].field_992 + 10000:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                    revert with 0, 'SafeMath: division by zero', 0
                                if 10000 * poolInfo[arg1].field_1280 / poolInfo[arg1].field_1280 != 10000:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 0 / totalAllocPoint:
                                    if not 10000 * poolInfo[arg1].field_1280:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if (0 / 10000 * poolInfo[arg1].field_1280) + poolInfo[arg1].field_256 < poolInfo[arg1].field_256:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_256 += 0 / 10000 * poolInfo[arg1].field_1280
                                else:
                                    if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not stor159 * 0 / totalAllocPoint:
                                        if not 10000 * poolInfo[arg1].field_1280:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if (0 / 10000 * poolInfo[arg1].field_1280) + poolInfo[arg1].field_256 < poolInfo[arg1].field_256:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_256 += 0 / 10000 * poolInfo[arg1].field_1280
                                    else:
                                        if (10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[arg1].field_992 * stor159 * 0 / totalAllocPoint) / stor159 * 0 / totalAllocPoint != -poolInfo[arg1].field_992 + 10000:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not 10000 * poolInfo[arg1].field_1280:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if ((10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[arg1].field_992 * stor159 * 0 / totalAllocPoint) / 10000 * poolInfo[arg1].field_1280) + poolInfo[arg1].field_256 < poolInfo[arg1].field_256:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_256 += (10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[arg1].field_992 * stor159 * 0 / totalAllocPoint) / 10000 * poolInfo[arg1].field_1280
                                if poolInfo[arg1].field_992:
                                    if poolInfo[arg1].field_1024:
                                        if not poolInfo[arg1].field_1024:
                                            if 0 / totalAllocPoint:
                                                if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if stor159 * 0 / totalAllocPoint:
                                                    if poolInfo[arg1].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[arg1].field_992:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if 10000 * poolInfo[arg1].field_1024 / poolInfo[arg1].field_1024 != 10000:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not 0 / totalAllocPoint:
                                            if not 10000 * poolInfo[arg1].field_1024:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if (0 / 10000 * poolInfo[arg1].field_1024) + poolInfo[arg1].field_512 < poolInfo[arg1].field_512:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_512 += 0 / 10000 * poolInfo[arg1].field_1024
                                        else:
                                            if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if not stor159 * 0 / totalAllocPoint:
                                                if not 10000 * poolInfo[arg1].field_1024:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                if (0 / 10000 * poolInfo[arg1].field_1024) + poolInfo[arg1].field_512 < poolInfo[arg1].field_512:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_512 += 0 / 10000 * poolInfo[arg1].field_1024
                                            else:
                                                if poolInfo[arg1].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[arg1].field_992:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not 10000 * poolInfo[arg1].field_1024:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                if (poolInfo[arg1].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[arg1].field_1024) + poolInfo[arg1].field_512 < poolInfo[arg1].field_512:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_512 += poolInfo[arg1].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[arg1].field_1024
                            else:
                                if (block.timestamp * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) - (poolInfo[arg1].field_768 * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) / (block.timestamp * 0 / ext_call.return_data[0]) - (poolInfo[arg1].field_768 * 0 / ext_call.return_data[0]) != poolInfo[arg1].field_160:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not totalAllocPoint:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not poolInfo[arg1].field_1280:
                                    if (block.timestamp * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) - (poolInfo[arg1].field_768 * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) / totalAllocPoint:
                                        if stor159 * (block.timestamp * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) - (poolInfo[arg1].field_768 * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) / totalAllocPoint / (block.timestamp * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) - (poolInfo[arg1].field_768 * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) / totalAllocPoint != stor159:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if stor159 * (block.timestamp * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) - (poolInfo[arg1].field_768 * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) / totalAllocPoint:
                                            if (10000 * stor159 * (block.timestamp * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) - (poolInfo[arg1].field_768 * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) / totalAllocPoint) - (poolInfo[arg1].field_992 * stor159 * (block.timestamp * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) - (poolInfo[arg1].field_768 * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) / totalAllocPoint) / stor159 * (block.timestamp * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) - (poolInfo[arg1].field_768 * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) / totalAllocPoint != -poolInfo[arg1].field_992 + 10000:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                    revert with 0, 'SafeMath: division by zero', 0
                                if 10000 * poolInfo[arg1].field_1280 / poolInfo[arg1].field_1280 != 10000:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not (block.timestamp * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) - (poolInfo[arg1].field_768 * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) / totalAllocPoint:
                                    if not 10000 * poolInfo[arg1].field_1280:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if (0 / 10000 * poolInfo[arg1].field_1280) + poolInfo[arg1].field_256 < poolInfo[arg1].field_256:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_256 += 0 / 10000 * poolInfo[arg1].field_1280
                                else:
                                    if stor159 * (block.timestamp * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) - (poolInfo[arg1].field_768 * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) / totalAllocPoint / (block.timestamp * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) - (poolInfo[arg1].field_768 * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) / totalAllocPoint != stor159:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not stor159 * (block.timestamp * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) - (poolInfo[arg1].field_768 * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) / totalAllocPoint:
                                        if not 10000 * poolInfo[arg1].field_1280:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if (0 / 10000 * poolInfo[arg1].field_1280) + poolInfo[arg1].field_256 < poolInfo[arg1].field_256:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_256 += 0 / 10000 * poolInfo[arg1].field_1280
                                    else:
                                        if (10000 * stor159 * (block.timestamp * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) - (poolInfo[arg1].field_768 * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) / totalAllocPoint) - (poolInfo[arg1].field_992 * stor159 * (block.timestamp * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) - (poolInfo[arg1].field_768 * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) / totalAllocPoint) / stor159 * (block.timestamp * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) - (poolInfo[arg1].field_768 * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) / totalAllocPoint != -poolInfo[arg1].field_992 + 10000:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not 10000 * poolInfo[arg1].field_1280:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if ((10000 * stor159 * (block.timestamp * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) - (poolInfo[arg1].field_768 * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) / totalAllocPoint) - (poolInfo[arg1].field_992 * stor159 * (block.timestamp * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) - (poolInfo[arg1].field_768 * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) / totalAllocPoint) / 10000 * poolInfo[arg1].field_1280) + poolInfo[arg1].field_256 < poolInfo[arg1].field_256:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_256 += (10000 * stor159 * (block.timestamp * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) - (poolInfo[arg1].field_768 * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) / totalAllocPoint) - (poolInfo[arg1].field_992 * stor159 * (block.timestamp * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) - (poolInfo[arg1].field_768 * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) / totalAllocPoint) / 10000 * poolInfo[arg1].field_1280
                                if poolInfo[arg1].field_992:
                                    if poolInfo[arg1].field_1024:
                                        if not poolInfo[arg1].field_1024:
                                            if (block.timestamp * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) - (poolInfo[arg1].field_768 * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) / totalAllocPoint:
                                                if stor159 * (block.timestamp * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) - (poolInfo[arg1].field_768 * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) / totalAllocPoint / (block.timestamp * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) - (poolInfo[arg1].field_768 * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) / totalAllocPoint != stor159:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if stor159 * (block.timestamp * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) - (poolInfo[arg1].field_768 * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) / totalAllocPoint:
                                                    if poolInfo[arg1].field_992 * stor159 * (block.timestamp * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) - (poolInfo[arg1].field_768 * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) / totalAllocPoint / stor159 * (block.timestamp * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) - (poolInfo[arg1].field_768 * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) / totalAllocPoint != poolInfo[arg1].field_992:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if 10000 * poolInfo[arg1].field_1024 / poolInfo[arg1].field_1024 != 10000:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not (block.timestamp * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) - (poolInfo[arg1].field_768 * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) / totalAllocPoint:
                                            if not 10000 * poolInfo[arg1].field_1024:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if (0 / 10000 * poolInfo[arg1].field_1024) + poolInfo[arg1].field_512 < poolInfo[arg1].field_512:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_512 += 0 / 10000 * poolInfo[arg1].field_1024
                                        else:
                                            if stor159 * (block.timestamp * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) - (poolInfo[arg1].field_768 * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) / totalAllocPoint / (block.timestamp * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) - (poolInfo[arg1].field_768 * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) / totalAllocPoint != stor159:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if not stor159 * (block.timestamp * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) - (poolInfo[arg1].field_768 * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) / totalAllocPoint:
                                                if not 10000 * poolInfo[arg1].field_1024:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                if (0 / 10000 * poolInfo[arg1].field_1024) + poolInfo[arg1].field_512 < poolInfo[arg1].field_512:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_512 += 0 / 10000 * poolInfo[arg1].field_1024
                                            else:
                                                if poolInfo[arg1].field_992 * stor159 * (block.timestamp * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) - (poolInfo[arg1].field_768 * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) / totalAllocPoint / stor159 * (block.timestamp * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) - (poolInfo[arg1].field_768 * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) / totalAllocPoint != poolInfo[arg1].field_992:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not 10000 * poolInfo[arg1].field_1024:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                if (poolInfo[arg1].field_992 * stor159 * (block.timestamp * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) - (poolInfo[arg1].field_768 * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) / totalAllocPoint / 10000 * poolInfo[arg1].field_1024) + poolInfo[arg1].field_512 < poolInfo[arg1].field_512:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_512 += poolInfo[arg1].field_992 * stor159 * (block.timestamp * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) - (poolInfo[arg1].field_768 * 0 / ext_call.return_data[0] * poolInfo[arg1].field_160) / totalAllocPoint / 10000 * poolInfo[arg1].field_1024
                    else:
                        if ext_call.return_data[32] * (1000 * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) / 1000 / (1000 * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) / 1000 != ext_call.return_data[32]:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not ext_call.return_data[0]:
                            revert with 0, 'SafeMath: division by zero', 0
                        if not block.timestamp - poolInfo[arg1].field_768:
                            if not totalAllocPoint:
                                revert with 0, 'SafeMath: division by zero', 0
                            if not poolInfo[arg1].field_1280:
                                if 0 / totalAllocPoint:
                                    if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if stor159 * 0 / totalAllocPoint:
                                        if (10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[arg1].field_992 * stor159 * 0 / totalAllocPoint) / stor159 * 0 / totalAllocPoint != -poolInfo[arg1].field_992 + 10000:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                revert with 0, 'SafeMath: division by zero', 0
                            if 10000 * poolInfo[arg1].field_1280 / poolInfo[arg1].field_1280 != 10000:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / totalAllocPoint:
                                if not 10000 * poolInfo[arg1].field_1280:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if (0 / 10000 * poolInfo[arg1].field_1280) + poolInfo[arg1].field_256 < poolInfo[arg1].field_256:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[arg1].field_256 += 0 / 10000 * poolInfo[arg1].field_1280
                            else:
                                if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not stor159 * 0 / totalAllocPoint:
                                    if not 10000 * poolInfo[arg1].field_1280:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if (0 / 10000 * poolInfo[arg1].field_1280) + poolInfo[arg1].field_256 < poolInfo[arg1].field_256:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_256 += 0 / 10000 * poolInfo[arg1].field_1280
                                else:
                                    if (10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[arg1].field_992 * stor159 * 0 / totalAllocPoint) / stor159 * 0 / totalAllocPoint != -poolInfo[arg1].field_992 + 10000:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not 10000 * poolInfo[arg1].field_1280:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if ((10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[arg1].field_992 * stor159 * 0 / totalAllocPoint) / 10000 * poolInfo[arg1].field_1280) + poolInfo[arg1].field_256 < poolInfo[arg1].field_256:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_256 += (10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[arg1].field_992 * stor159 * 0 / totalAllocPoint) / 10000 * poolInfo[arg1].field_1280
                            if poolInfo[arg1].field_992:
                                if poolInfo[arg1].field_1024:
                                    if not poolInfo[arg1].field_1024:
                                        if 0 / totalAllocPoint:
                                            if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if stor159 * 0 / totalAllocPoint:
                                                if poolInfo[arg1].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[arg1].field_992:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if 10000 * poolInfo[arg1].field_1024 / poolInfo[arg1].field_1024 != 10000:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not 0 / totalAllocPoint:
                                        if not 10000 * poolInfo[arg1].field_1024:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if (0 / 10000 * poolInfo[arg1].field_1024) + poolInfo[arg1].field_512 < poolInfo[arg1].field_512:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_512 += 0 / 10000 * poolInfo[arg1].field_1024
                                    else:
                                        if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not stor159 * 0 / totalAllocPoint:
                                            if not 10000 * poolInfo[arg1].field_1024:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if (0 / 10000 * poolInfo[arg1].field_1024) + poolInfo[arg1].field_512 < poolInfo[arg1].field_512:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_512 += 0 / 10000 * poolInfo[arg1].field_1024
                                        else:
                                            if poolInfo[arg1].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[arg1].field_992:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if not 10000 * poolInfo[arg1].field_1024:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if (poolInfo[arg1].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[arg1].field_1024) + poolInfo[arg1].field_512 < poolInfo[arg1].field_512:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_512 += poolInfo[arg1].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[arg1].field_1024
                        else:
                            if (block.timestamp * ext_call.return_data[32] * (1000 * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) / 1000 / ext_call.return_data[0]) - (poolInfo[arg1].field_768 * ext_call.return_data[32] * (1000 * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) / 1000 / ext_call.return_data[0]) / block.timestamp - poolInfo[arg1].field_768 != ext_call.return_data[32] * (1000 * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) / 1000 / ext_call.return_data[0]:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not (block.timestamp * ext_call.return_data[32] * (1000 * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) / 1000 / ext_call.return_data[0]) - (poolInfo[arg1].field_768 * ext_call.return_data[32] * (1000 * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) / 1000 / ext_call.return_data[0]):
                                if not totalAllocPoint:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not poolInfo[arg1].field_1280:
                                    if 0 / totalAllocPoint:
                                        if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if stor159 * 0 / totalAllocPoint:
                                            if (10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[arg1].field_992 * stor159 * 0 / totalAllocPoint) / stor159 * 0 / totalAllocPoint != -poolInfo[arg1].field_992 + 10000:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                    revert with 0, 'SafeMath: division by zero', 0
                                if 10000 * poolInfo[arg1].field_1280 / poolInfo[arg1].field_1280 != 10000:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 0 / totalAllocPoint:
                                    if not 10000 * poolInfo[arg1].field_1280:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if (0 / 10000 * poolInfo[arg1].field_1280) + poolInfo[arg1].field_256 < poolInfo[arg1].field_256:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_256 += 0 / 10000 * poolInfo[arg1].field_1280
                                else:
                                    if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not stor159 * 0 / totalAllocPoint:
                                        if not 10000 * poolInfo[arg1].field_1280:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if (0 / 10000 * poolInfo[arg1].field_1280) + poolInfo[arg1].field_256 < poolInfo[arg1].field_256:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_256 += 0 / 10000 * poolInfo[arg1].field_1280
                                    else:
                                        if (10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[arg1].field_992 * stor159 * 0 / totalAllocPoint) / stor159 * 0 / totalAllocPoint != -poolInfo[arg1].field_992 + 10000:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not 10000 * poolInfo[arg1].field_1280:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if ((10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[arg1].field_992 * stor159 * 0 / totalAllocPoint) / 10000 * poolInfo[arg1].field_1280) + poolInfo[arg1].field_256 < poolInfo[arg1].field_256:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_256 += (10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[arg1].field_992 * stor159 * 0 / totalAllocPoint) / 10000 * poolInfo[arg1].field_1280
                                if poolInfo[arg1].field_992:
                                    if poolInfo[arg1].field_1024:
                                        if not poolInfo[arg1].field_1024:
                                            if 0 / totalAllocPoint:
                                                if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if stor159 * 0 / totalAllocPoint:
                                                    if poolInfo[arg1].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[arg1].field_992:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if 10000 * poolInfo[arg1].field_1024 / poolInfo[arg1].field_1024 != 10000:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not 0 / totalAllocPoint:
                                            if not 10000 * poolInfo[arg1].field_1024:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if (0 / 10000 * poolInfo[arg1].field_1024) + poolInfo[arg1].field_512 < poolInfo[arg1].field_512:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_512 += 0 / 10000 * poolInfo[arg1].field_1024
                                        else:
                                            if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if not stor159 * 0 / totalAllocPoint:
                                                if not 10000 * poolInfo[arg1].field_1024:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                if (0 / 10000 * poolInfo[arg1].field_1024) + poolInfo[arg1].field_512 < poolInfo[arg1].field_512:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_512 += 0 / 10000 * poolInfo[arg1].field_1024
                                            else:
                                                if poolInfo[arg1].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[arg1].field_992:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not 10000 * poolInfo[arg1].field_1024:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                if (poolInfo[arg1].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[arg1].field_1024) + poolInfo[arg1].field_512 < poolInfo[arg1].field_512:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_512 += poolInfo[arg1].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[arg1].field_1024
                            else:
                                if (block.timestamp * ext_call.return_data[32] * (1000 * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) / 1000 / ext_call.return_data[0] * poolInfo[arg1].field_160) - (poolInfo[arg1].field_768 * ext_call.return_data[32] * (1000 * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) / 1000 / ext_call.return_data[0] * poolInfo[arg1].field_160) / (block.timestamp * ext_call.return_data[32] * (1000 * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) / 1000 / ext_call.return_data[0]) - (poolInfo[arg1].field_768 * ext_call.return_data[32] * (1000 * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) / 1000 / ext_call.return_data[0]) != poolInfo[arg1].field_160:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not totalAllocPoint:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not poolInfo[arg1].field_1280:
                                    if (block.timestamp * ext_call.return_data[32] * (1000 * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) / 1000 / ext_call.return_data[0] * poolInfo[arg1].field_160) - (poolInfo[arg1].field_768 * ext_call.return_data[32] * (1000 * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) / 1000 / ext_call.return_data[0] * poolInfo[arg1].field_160) / totalAllocPoint:
                                        if stor159 * (block.timestamp * ext_call.return_data[32] * (1000 * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) / 1000 / ext_call.return_data[0] * poolInfo[arg1].field_160) - (poolInfo[arg1].field_768 * ext_call.return_data[32] * (1000 * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) / 1000 / ext_call.return_data[0] * poolInfo[arg1].field_160) / totalAllocPoint / (block.timestamp * ext_call.return_data[32] * (1000 * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) / 1000 / ext_call.return_data[0] * poolInfo[arg1].field_160) - (poolInfo[arg1].field_768 * ext_call.return_data[32] * (1000 * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) / 1000 / ext_call.return_data[0] * poolInfo[arg1].field_160) / totalAllocPoint != stor159:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if stor159 * (block.timestamp * ext_call.return_data[32] * (1000 * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) / 1000 / ext_call.return_data[0] * poolInfo[arg1].field_160) - (poolInfo[arg1].field_768 * ext_call.return_data[32] * (1000 * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) / 1000 / ext_call.return_data[0] * poolInfo[arg1].field_160) / totalAllocPoint:
                                            if (10000 * stor159 * (block.timestamp * ext_call.return_data[32] * (1000 * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) / 1000 / ext_call.return_data[0] * poolInfo[arg1].field_160) - (poolInfo[arg1].field_768 * ext_call.return_data[32] * (1000 * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) / 1000 / ext_call.return_data[0] * poolInfo[arg1].field_160) / totalAllocPoint) - (poolInfo[arg1].field_992 * stor159 * (block.timestamp * ext_call.return_data[32] * (1000 * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) / 1000 / ext_call.return_data[0] * poolInfo[arg1].field_160) - (poolInfo[arg1].field_768 * ext_call.return_data[32] * (1000 * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) / 1000 / ext_call.return_data[0] * poolInfo[arg1].field_160) / totalAllocPoint) / stor159 * (block.timestamp * ext_call.return_data[32] * (1000 * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) / 1000 / ext_call.return_data[0] * poolInfo[arg1].field_160) - (poolInfo[arg1].field_768 * ext_call.return_data[32] * (1000 * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) / 1000 / ext_call.return_data[0] * poolInfo[arg1].field_160) / totalAllocPoint != -poolInfo[arg1].field_992 + 10000:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                    revert with 0, 'SafeMath: division by zero', 0
                                if 10000 * poolInfo[arg1].field_1280 / poolInfo[arg1].field_1280 != 10000:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not (block.timestamp * ext_call.return_data[32] * (1000 * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) / 1000 / ext_call.return_data[0] * poolInfo[arg1].field_160) - (poolInfo[arg1].field_768 * ext_call.return_data[32] * (1000 * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) / 1000 / ext_call.return_data[0] * poolInfo[arg1].field_160) / totalAllocPoint:
                                    if not 10000 * poolInfo[arg1].field_1280:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if (0 / 10000 * poolInfo[arg1].field_1280) + poolInfo[arg1].field_256 < poolInfo[arg1].field_256:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_256 += 0 / 10000 * poolInfo[arg1].field_1280
                                else:
                                    if stor159 * (block.timestamp * ext_call.return_data[32] * (1000 * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) / 1000 / ext_call.return_data[0] * poolInfo[arg1].field_160) - (poolInfo[arg1].field_768 * ext_call.return_data[32] * (1000 * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) / 1000 / ext_call.return_data[0] * poolInfo[arg1].field_160) / totalAllocPoint / (block.timestamp * ext_call.return_data[32] * (1000 * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) / 1000 / ext_call.return_data[0] * poolInfo[arg1].field_160) - (poolInfo[arg1].field_768 * ext_call.return_data[32] * (1000 * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) / 1000 / ext_call.return_data[0] * poolInfo[arg1].field_160) / totalAllocPoint != stor159:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not stor159 * (block.timestamp * ext_call.return_data[32] * (1000 * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) / 1000 / ext_call.return_data[0] * poolInfo[arg1].field_160) - (poolInfo[arg1].field_768 * ext_call.return_data[32] * (1000 * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) / 1000 / ext_call.return_data[0] * poolInfo[arg1].field_160) / totalAllocPoint:
                                        if not 10000 * poolInfo[arg1].field_1280:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if (0 / 10000 * poolInfo[arg1].field_1280) + poolInfo[arg1].field_256 < poolInfo[arg1].field_256:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_256 += 0 / 10000 * poolInfo[arg1].field_1280
                                    else:
                                        if (10000 * stor159 * (block.timestamp * ext_call.return_data[32] * (1000 * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) / 1000 / ext_call.return_data[0] * poolInfo[arg1].field_160) - (poolInfo[arg1].field_768 * ext_call.return_data[32] * (1000 * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) / 1000 / ext_call.return_data[0] * poolInfo[arg1].field_160) / totalAllocPoint) - (poolInfo[arg1].field_992 * stor159 * (block.timestamp * ext_call.return_data[32] * (1000 * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) / 1000 / ext_call.return_data[0] * poolInfo[arg1].field_160) - (poolInfo[arg1].field_768 * ext_call.return_data[32] * (1000 * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) / 1000 / ext_call.return_data[0] * poolInfo[arg1].field_160) / totalAllocPoint) / stor159 * (block.timestamp * ext_call.return_data[32] * (1000 * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) / 1000 / ext_call.return_data[0] * poolInfo[arg1].field_160) - (poolInfo[arg1].field_768 * ext_call.return_data[32] * (1000 * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) / 1000 / ext_call.return_data[0] * poolInfo[arg1].field_160) / totalAllocPoint != -poolInfo[arg1].field_992 + 10000:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not 10000 * poolInfo[arg1].field_1280:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if ((10000 * stor159 * (block.timestamp * ext_call.return_data[32] * (1000 * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) / 1000 / ext_call.return_data[0] * poolInfo[arg1].field_160) - (poolInfo[arg1].field_768 * ext_call.return_data[32] * (1000 * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) / 1000 / ext_call.return_data[0] * poolInfo[arg1].field_160) / totalAllocPoint) - (poolInfo[arg1].field_992 * stor159 * (block.timestamp * ext_call.return_data[32] * (1000 * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) / 1000 / ext_call.return_data[0] * poolInfo[arg1].field_160) - (poolInfo[arg1].field_768 * ext_call.return_data[32] * (1000 * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) / 1000 / ext_call.return_data[0] * poolInfo[arg1].field_160) / totalAllocPoint) / 10000 * poolInfo[arg1].field_1280) + poolInfo[arg1].field_256 < poolInfo[arg1].field_256:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_256 += (10000 * stor159 * (block.timestamp * ext_call.return_data[32] * (1000 * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) / 1000 / ext_call.return_data[0] * poolInfo[arg1].field_160) - (poolInfo[arg1].field_768 * ext_call.return_data[32] * (1000 * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) / 1000 / ext_call.return_data[0] * poolInfo[arg1].field_160) / totalAllocPoint) - (poolInfo[arg1].field_992 * stor159 * (block.timestamp * ext_call.return_data[32] * (1000 * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) / 1000 / ext_call.return_data[0] * poolInfo[arg1].field_160) - (poolInfo[arg1].field_768 * ext_call.return_data[32] * (1000 * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) / 1000 / ext_call.return_data[0] * poolInfo[arg1].field_160) / totalAllocPoint) / 10000 * poolInfo[arg1].field_1280
                                if poolInfo[arg1].field_992:
                                    if poolInfo[arg1].field_1024:
                                        if not poolInfo[arg1].field_1024:
                                            if (block.timestamp * ext_call.return_data[32] * (1000 * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) / 1000 / ext_call.return_data[0] * poolInfo[arg1].field_160) - (poolInfo[arg1].field_768 * ext_call.return_data[32] * (1000 * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) / 1000 / ext_call.return_data[0] * poolInfo[arg1].field_160) / totalAllocPoint:
                                                if stor159 * (block.timestamp * ext_call.return_data[32] * (1000 * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) / 1000 / ext_call.return_data[0] * poolInfo[arg1].field_160) - (poolInfo[arg1].field_768 * ext_call.return_data[32] * (1000 * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) / 1000 / ext_call.return_data[0] * poolInfo[arg1].field_160) / totalAllocPoint / (block.timestamp * ext_call.return_data[32] * (1000 * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) / 1000 / ext_call.return_data[0] * poolInfo[arg1].field_160) - (poolInfo[arg1].field_768 * ext_call.return_data[32] * (1000 * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) / 1000 / ext_call.return_data[0] * poolInfo[arg1].field_160) / totalAllocPoint != stor159:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if stor159 * (block.timestamp * ext_call.return_data[32] * (1000 * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) / 1000 / ext_call.return_data[0] * poolInfo[arg1].field_160) - (poolInfo[arg1].field_768 * ext_call.return_data[32] * (1000 * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) / 1000 / ext_call.return_data[0] * poolInfo[arg1].field_160) / totalAllocPoint:
                                                    if poolInfo[arg1].field_992 * stor159 * (block.timestamp * ext_call.return_data[32] * (1000 * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) / 1000 / ext_call.return_data[0] * poolInfo[arg1].field_160) - (poolInfo[arg1].field_768 * ext_call.return_data[32] * (1000 * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) / 1000 / ext_call.return_data[0] * poolInfo[arg1].field_160) / totalAllocPoint / stor159 * (block.timestamp * ext_call.return_data[32] * (1000 * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) / 1000 / ext_call.return_data[0] * poolInfo[arg1].field_160) - (poolInfo[arg1].field_768 * ext_call.return_data[32] * (1000 * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) / 1000 / ext_call.return_data[0] * poolInfo[arg1].field_160) / totalAllocPoint != poolInfo[arg1].field_992:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if 10000 * poolInfo[arg1].field_1024 / poolInfo[arg1].field_1024 != 10000:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not (block.timestamp * ext_call.return_data[32] * (1000 * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) / 1000 / ext_call.return_data[0] * poolInfo[arg1].field_160) - (poolInfo[arg1].field_768 * ext_call.return_data[32] * (1000 * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) / 1000 / ext_call.return_data[0] * poolInfo[arg1].field_160) / totalAllocPoint:
                                            if not 10000 * poolInfo[arg1].field_1024:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if (0 / 10000 * poolInfo[arg1].field_1024) + poolInfo[arg1].field_512 < poolInfo[arg1].field_512:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_512 += 0 / 10000 * poolInfo[arg1].field_1024
                                        else:
                                            if stor159 * (block.timestamp * ext_call.return_data[32] * (1000 * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) / 1000 / ext_call.return_data[0] * poolInfo[arg1].field_160) - (poolInfo[arg1].field_768 * ext_call.return_data[32] * (1000 * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) / 1000 / ext_call.return_data[0] * poolInfo[arg1].field_160) / totalAllocPoint / (block.timestamp * ext_call.return_data[32] * (1000 * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) / 1000 / ext_call.return_data[0] * poolInfo[arg1].field_160) - (poolInfo[arg1].field_768 * ext_call.return_data[32] * (1000 * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) / 1000 / ext_call.return_data[0] * poolInfo[arg1].field_160) / totalAllocPoint != stor159:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if not stor159 * (block.timestamp * ext_call.return_data[32] * (1000 * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) / 1000 / ext_call.return_data[0] * poolInfo[arg1].field_160) - (poolInfo[arg1].field_768 * ext_call.return_data[32] * (1000 * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) / 1000 / ext_call.return_data[0] * poolInfo[arg1].field_160) / totalAllocPoint:
                                                if not 10000 * poolInfo[arg1].field_1024:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                if (0 / 10000 * poolInfo[arg1].field_1024) + poolInfo[arg1].field_512 < poolInfo[arg1].field_512:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_512 += 0 / 10000 * poolInfo[arg1].field_1024
                                            else:
                                                if poolInfo[arg1].field_992 * stor159 * (block.timestamp * ext_call.return_data[32] * (1000 * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) / 1000 / ext_call.return_data[0] * poolInfo[arg1].field_160) - (poolInfo[arg1].field_768 * ext_call.return_data[32] * (1000 * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) / 1000 / ext_call.return_data[0] * poolInfo[arg1].field_160) / totalAllocPoint / stor159 * (block.timestamp * ext_call.return_data[32] * (1000 * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) / 1000 / ext_call.return_data[0] * poolInfo[arg1].field_160) - (poolInfo[arg1].field_768 * ext_call.return_data[32] * (1000 * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) / 1000 / ext_call.return_data[0] * poolInfo[arg1].field_160) / totalAllocPoint != poolInfo[arg1].field_992:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not 10000 * poolInfo[arg1].field_1024:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                if (poolInfo[arg1].field_992 * stor159 * (block.timestamp * ext_call.return_data[32] * (1000 * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) / 1000 / ext_call.return_data[0] * poolInfo[arg1].field_160) - (poolInfo[arg1].field_768 * ext_call.return_data[32] * (1000 * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) / 1000 / ext_call.return_data[0] * poolInfo[arg1].field_160) / totalAllocPoint / 10000 * poolInfo[arg1].field_1024) + poolInfo[arg1].field_512 < poolInfo[arg1].field_512:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_512 += poolInfo[arg1].field_992 * stor159 * (block.timestamp * ext_call.return_data[32] * (1000 * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) / 1000 / ext_call.return_data[0] * poolInfo[arg1].field_160) - (poolInfo[arg1].field_768 * ext_call.return_data[32] * (1000 * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) - (ext_call.return_data[0] * ext_call.return_data[0]) / 1000 / ext_call.return_data[0] * poolInfo[arg1].field_160) / totalAllocPoint / 10000 * poolInfo[arg1].field_1024
        poolInfo[arg1].field_768 = uint64(block.timestamp)
        emit UpdatePool(block.timestamp << 192, poolInfo[arg1].field_1280, poolInfo[arg1].field_256, poolInfo[arg1].field_512, arg1);
}

function massUpdatePools() payable {
    mem[64] = 96
    idx = 0
    while idx < poolInfo.length:
        mem[0] = 155
        if poolInfo[idx].field_768 < block.timestamp:
            if poolInfo[idx].field_1280:
                if poolInfo[idx].field_160:
                    require ext_code.size(address(MASTER_CHEF_V2Address))
                    staticcall address(MASTER_CHEF_V2Address).investorPercent() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2305 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2306 = mem[_2305]
                    require ext_code.size(address(MASTER_CHEF_V2Address))
                    staticcall address(MASTER_CHEF_V2Address).treasuryPercent() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2309 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2310 = mem[_2309]
                    require ext_code.size(address(MASTER_CHEF_V2Address))
                    staticcall address(MASTER_CHEF_V2Address).devPercent() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2313 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2314 = mem[_2313]
                    _2315 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2315] = 30
                    mem[_2315 + 32] = 'SafeMath: subtraction overflow'
                    if _2314 > 1000:
                        _2316 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _2316 + 68] = mem[idx + _2315 + 32]
                            idx = idx + 32
                            continue 
                        mem[_2316 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _2316 + -mem[64] + 100
                    _2318 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2318] = 30
                    mem[_2318 + 32] = 'SafeMath: subtraction overflow'
                    if _2310 > -_2314 + 1000:
                        _2320 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _2320 + 68] = mem[idx + _2318 + 32]
                            idx = idx + 32
                            continue 
                        mem[_2320 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _2320 + -mem[64] + 100
                    _2322 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2322] = 30
                    mem[_2322 + 32] = 'SafeMath: subtraction overflow'
                    if _2306 > -_2314 + -_2310 + 1000:
                        _2326 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _2326 + 68] = mem[idx + _2322 + 32]
                            idx = idx + 32
                            continue 
                        mem[_2326 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _2326 + -mem[64] + 100
                    require ext_code.size(address(MASTER_CHEF_V2Address))
                    staticcall address(MASTER_CHEF_V2Address).0xca418d23 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2332 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2334 = mem[_2332]
                    if not mem[_2332]:
                        _2338 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2338] = 26
                        mem[_2338 + 32] = 'SafeMath: division by zero'
                        require ext_code.size(address(MASTER_CHEF_V2Address))
                        staticcall address(MASTER_CHEF_V2Address).0x17caf6f1 with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2345 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2347 = mem[_2345]
                        require ext_code.size(address(MASTER_CHEF_V2Address))
                        staticcall address(MASTER_CHEF_V2Address).0x1526fe27 with:
                                gas gas_remaining wei
                               args MASTER_PID
                        mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2353 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 128
                        _2355 = mem[64]
                        require mem[64] + 128 >= mem[64] and mem[64] + 128 <= test266151307()
                        mem[64] = mem[64] + 128
                        require mem[_2353] == mem[_2353 + 12 len 20]
                        mem[_2355] = mem[_2353]
                        mem[_2355 + 32] = mem[_2353 + 32]
                        mem[_2355 + 64] = mem[_2353 + 64]
                        mem[_2355 + 96] = mem[_2353 + 96]
                        _2367 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2367] = 26
                        mem[_2367 + 32] = 'SafeMath: division by zero'
                        if not _2347:
                            _2370 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _2370 + 68] = mem[idx + _2367 + 32]
                                idx = idx + 32
                                continue 
                            mem[_2370 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2370 + -mem[64] + 100
                        if not block.timestamp - poolInfo[idx].field_768:
                            _2392 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2392] = 26
                            mem[_2392 + 32] = 'SafeMath: division by zero'
                            if not totalAllocPoint:
                                _2397 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _2397 + 68] = mem[idx + _2392 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2397 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _2397 + -mem[64] + 100
                            if not poolInfo[idx].field_1280:
                                if not 0 / totalAllocPoint:
                                    _2481 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_2481] = 26
                                    mem[_2481 + 32] = 'SafeMath: division by zero'
                                    _2500 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _2500 + 68] = mem[idx + _2481 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2500 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2500 + -mem[64] + 100
                                if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not stor159 * 0 / totalAllocPoint:
                                    _2499 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_2499] = 26
                                    mem[_2499 + 32] = 'SafeMath: division by zero'
                                    _2525 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _2525 + 68] = mem[idx + _2499 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2525 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2525 + -mem[64] + 100
                                if (10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint) / stor159 * 0 / totalAllocPoint != -poolInfo[idx].field_992 + 10000:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _2524 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2524] = 26
                                mem[_2524 + 32] = 'SafeMath: division by zero'
                                _2563 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _2563 + 68] = mem[idx + _2524 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2563 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _2563 + -mem[64] + 100
                            if 10000 * poolInfo[idx].field_1280 / poolInfo[idx].field_1280 != 10000:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / totalAllocPoint:
                                _2498 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2498] = 26
                                mem[_2498 + 32] = 'SafeMath: division by zero'
                                if not 10000 * poolInfo[idx].field_1280:
                                    _2523 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _2523 + 68] = mem[idx + _2498 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2523 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2523 + -mem[64] + 100
                                if (0 / 10000 * poolInfo[idx].field_1280) + poolInfo[idx].field_256 < poolInfo[idx].field_256:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_256 += 0 / 10000 * poolInfo[idx].field_1280
                                if poolInfo[idx].field_992:
                                    if poolInfo[idx].field_1024:
                                        if not poolInfo[idx].field_1024:
                                            if not 0 / totalAllocPoint:
                                                _3086 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_3086] = 26
                                                mem[_3086 + 32] = 'SafeMath: division by zero'
                                                _3126 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _3126 + 68] = mem[idx + _3086 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_3126 + 94] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _3126 + -mem[64] + 100
                                            if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if not stor159 * 0 / totalAllocPoint:
                                                _3125 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_3125] = 26
                                                mem[_3125 + 32] = 'SafeMath: division by zero'
                                                _3180 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _3180 + 68] = mem[idx + _3125 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_3180 + 94] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _3180 + -mem[64] + 100
                                            if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _3179 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_3179] = 26
                                            mem[_3179 + 32] = 'SafeMath: division by zero'
                                            _3261 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _3261 + 68] = mem[idx + _3179 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_3261 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _3261 + -mem[64] + 100
                                        if 10000 * poolInfo[idx].field_1024 / poolInfo[idx].field_1024 != 10000:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not 0 / totalAllocPoint:
                                            _3124 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_3124] = 26
                                            mem[_3124 + 32] = 'SafeMath: division by zero'
                                            if not 10000 * poolInfo[idx].field_1024:
                                                _3178 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _3178 + 68] = mem[idx + _3124 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_3178 + 94] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _3178 + -mem[64] + 100
                                            if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                        else:
                                            if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if not stor159 * 0 / totalAllocPoint:
                                                _3177 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_3177] = 26
                                                mem[_3177 + 32] = 'SafeMath: division by zero'
                                                if not 10000 * poolInfo[idx].field_1024:
                                                    _3259 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _3259 + 68] = mem[idx + _3177 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_3259 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _3259 + -mem[64] + 100
                                                if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                            else:
                                                if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _3258 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_3258] = 26
                                                mem[_3258 + 32] = 'SafeMath: division by zero'
                                                if not 10000 * poolInfo[idx].field_1024:
                                                    _3371 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _3371 + 68] = mem[idx + _3258 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_3371 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _3371 + -mem[64] + 100
                                                if (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_512 += poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024
                            else:
                                if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not stor159 * 0 / totalAllocPoint:
                                    _2522 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_2522] = 26
                                    mem[_2522 + 32] = 'SafeMath: division by zero'
                                    if not 10000 * poolInfo[idx].field_1280:
                                        _2561 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _2561 + 68] = mem[idx + _2522 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_2561 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _2561 + -mem[64] + 100
                                    if (0 / 10000 * poolInfo[idx].field_1280) + poolInfo[idx].field_256 < poolInfo[idx].field_256:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_256 += 0 / 10000 * poolInfo[idx].field_1280
                                    if poolInfo[idx].field_992:
                                        if poolInfo[idx].field_1024:
                                            if not poolInfo[idx].field_1024:
                                                if not 0 / totalAllocPoint:
                                                    _3123 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_3123] = 26
                                                    mem[_3123 + 32] = 'SafeMath: division by zero'
                                                    _3176 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _3176 + 68] = mem[idx + _3123 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_3176 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _3176 + -mem[64] + 100
                                                if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not stor159 * 0 / totalAllocPoint:
                                                    _3175 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_3175] = 26
                                                    mem[_3175 + 32] = 'SafeMath: division by zero'
                                                    _3256 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _3256 + 68] = mem[idx + _3175 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_3256 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _3256 + -mem[64] + 100
                                                if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _3255 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_3255] = 26
                                                mem[_3255 + 32] = 'SafeMath: division by zero'
                                                _3369 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _3369 + 68] = mem[idx + _3255 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_3369 + 94] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _3369 + -mem[64] + 100
                                            if 10000 * poolInfo[idx].field_1024 / poolInfo[idx].field_1024 != 10000:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if not 0 / totalAllocPoint:
                                                _3174 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_3174] = 26
                                                mem[_3174 + 32] = 'SafeMath: division by zero'
                                                if not 10000 * poolInfo[idx].field_1024:
                                                    _3254 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _3254 + 68] = mem[idx + _3174 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_3254 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _3254 + -mem[64] + 100
                                                if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                            else:
                                                if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not stor159 * 0 / totalAllocPoint:
                                                    _3253 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_3253] = 26
                                                    mem[_3253 + 32] = 'SafeMath: division by zero'
                                                    if not 10000 * poolInfo[idx].field_1024:
                                                        _3367 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _3367 + 68] = mem[idx + _3253 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_3367 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _3367 + -mem[64] + 100
                                                    if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                else:
                                                    if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    _3366 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_3366] = 26
                                                    mem[_3366 + 32] = 'SafeMath: division by zero'
                                                    if not 10000 * poolInfo[idx].field_1024:
                                                        _3502 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _3502 + 68] = mem[idx + _3366 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_3502 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _3502 + -mem[64] + 100
                                                    if (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_512 += poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024
                                else:
                                    if (10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint) / stor159 * 0 / totalAllocPoint != -poolInfo[idx].field_992 + 10000:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _2560 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_2560] = 26
                                    mem[_2560 + 32] = 'SafeMath: division by zero'
                                    if not 10000 * poolInfo[idx].field_1280:
                                        _2609 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _2609 + 68] = mem[idx + _2560 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_2609 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _2609 + -mem[64] + 100
                                    if ((10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint) / 10000 * poolInfo[idx].field_1280) + poolInfo[idx].field_256 < poolInfo[idx].field_256:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_256 += (10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint) / 10000 * poolInfo[idx].field_1280
                                    if poolInfo[idx].field_992:
                                        if poolInfo[idx].field_1024:
                                            if not poolInfo[idx].field_1024:
                                                if not 0 / totalAllocPoint:
                                                    _3173 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_3173] = 26
                                                    mem[_3173 + 32] = 'SafeMath: division by zero'
                                                    _3252 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _3252 + 68] = mem[idx + _3173 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_3252 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _3252 + -mem[64] + 100
                                                if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not stor159 * 0 / totalAllocPoint:
                                                    _3251 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_3251] = 26
                                                    mem[_3251 + 32] = 'SafeMath: division by zero'
                                                    _3364 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _3364 + 68] = mem[idx + _3251 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_3364 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _3364 + -mem[64] + 100
                                                if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _3363 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_3363] = 26
                                                mem[_3363 + 32] = 'SafeMath: division by zero'
                                                _3500 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _3500 + 68] = mem[idx + _3363 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_3500 + 94] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _3500 + -mem[64] + 100
                                            if 10000 * poolInfo[idx].field_1024 / poolInfo[idx].field_1024 != 10000:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if not 0 / totalAllocPoint:
                                                _3250 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_3250] = 26
                                                mem[_3250 + 32] = 'SafeMath: division by zero'
                                                if not 10000 * poolInfo[idx].field_1024:
                                                    _3362 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _3362 + 68] = mem[idx + _3250 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_3362 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _3362 + -mem[64] + 100
                                                if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                            else:
                                                if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not stor159 * 0 / totalAllocPoint:
                                                    _3361 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_3361] = 26
                                                    mem[_3361 + 32] = 'SafeMath: division by zero'
                                                    if not 10000 * poolInfo[idx].field_1024:
                                                        _3498 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _3498 + 68] = mem[idx + _3361 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_3498 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _3498 + -mem[64] + 100
                                                    if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                else:
                                                    if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    _3497 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_3497] = 26
                                                    mem[_3497 + 32] = 'SafeMath: division by zero'
                                                    if not 10000 * poolInfo[idx].field_1024:
                                                        _3638 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        s = 0
                                                        while s < 26:
                                                            mem[s + _3638 + 68] = mem[s + _3497 + 32]
                                                            s = s + 32
                                                            continue 
                                                        mem[_3638 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _3638 + -mem[64] + 100
                                                    if (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_512 += poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024
                        else:
                            if (block.timestamp * 0 / _2347) - (poolInfo[idx].field_768 * 0 / _2347) / block.timestamp - poolInfo[idx].field_768 != 0 / _2347:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not (block.timestamp * 0 / _2347) - (poolInfo[idx].field_768 * 0 / _2347):
                                _2396 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2396] = 26
                                mem[_2396 + 32] = 'SafeMath: division by zero'
                                if not totalAllocPoint:
                                    _2404 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _2404 + 68] = mem[idx + _2396 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2404 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2404 + -mem[64] + 100
                                if not poolInfo[idx].field_1280:
                                    if not 0 / totalAllocPoint:
                                        _2497 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2497] = 26
                                        mem[_2497 + 32] = 'SafeMath: division by zero'
                                        _2521 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _2521 + 68] = mem[idx + _2497 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_2521 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _2521 + -mem[64] + 100
                                    if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not stor159 * 0 / totalAllocPoint:
                                        _2520 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2520] = 26
                                        mem[_2520 + 32] = 'SafeMath: division by zero'
                                        _2558 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _2558 + 68] = mem[idx + _2520 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_2558 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _2558 + -mem[64] + 100
                                    if (10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint) / stor159 * 0 / totalAllocPoint != -poolInfo[idx].field_992 + 10000:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _2557 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_2557] = 26
                                    mem[_2557 + 32] = 'SafeMath: division by zero'
                                    _2607 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _2607 + 68] = mem[idx + _2557 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2607 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2607 + -mem[64] + 100
                                if 10000 * poolInfo[idx].field_1280 / poolInfo[idx].field_1280 != 10000:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 0 / totalAllocPoint:
                                    _2519 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_2519] = 26
                                    mem[_2519 + 32] = 'SafeMath: division by zero'
                                    if not 10000 * poolInfo[idx].field_1280:
                                        _2556 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _2556 + 68] = mem[idx + _2519 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_2556 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _2556 + -mem[64] + 100
                                    if (0 / 10000 * poolInfo[idx].field_1280) + poolInfo[idx].field_256 < poolInfo[idx].field_256:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_256 += 0 / 10000 * poolInfo[idx].field_1280
                                    if poolInfo[idx].field_992:
                                        if poolInfo[idx].field_1024:
                                            if not poolInfo[idx].field_1024:
                                                if not 0 / totalAllocPoint:
                                                    _3122 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_3122] = 26
                                                    mem[_3122 + 32] = 'SafeMath: division by zero'
                                                    _3172 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _3172 + 68] = mem[idx + _3122 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_3172 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _3172 + -mem[64] + 100
                                                if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not stor159 * 0 / totalAllocPoint:
                                                    _3171 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_3171] = 26
                                                    mem[_3171 + 32] = 'SafeMath: division by zero'
                                                    _3248 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _3248 + 68] = mem[idx + _3171 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_3248 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _3248 + -mem[64] + 100
                                                if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _3247 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_3247] = 26
                                                mem[_3247 + 32] = 'SafeMath: division by zero'
                                                _3359 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _3359 + 68] = mem[idx + _3247 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_3359 + 94] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _3359 + -mem[64] + 100
                                            if 10000 * poolInfo[idx].field_1024 / poolInfo[idx].field_1024 != 10000:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if not 0 / totalAllocPoint:
                                                _3170 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_3170] = 26
                                                mem[_3170 + 32] = 'SafeMath: division by zero'
                                                if not 10000 * poolInfo[idx].field_1024:
                                                    _3246 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _3246 + 68] = mem[idx + _3170 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_3246 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _3246 + -mem[64] + 100
                                                if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                            else:
                                                if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not stor159 * 0 / totalAllocPoint:
                                                    _3245 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_3245] = 26
                                                    mem[_3245 + 32] = 'SafeMath: division by zero'
                                                    if not 10000 * poolInfo[idx].field_1024:
                                                        _3357 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _3357 + 68] = mem[idx + _3245 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_3357 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _3357 + -mem[64] + 100
                                                    if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                else:
                                                    if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    _3356 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_3356] = 26
                                                    mem[_3356 + 32] = 'SafeMath: division by zero'
                                                    if not 10000 * poolInfo[idx].field_1024:
                                                        _3494 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _3494 + 68] = mem[idx + _3356 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_3494 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _3494 + -mem[64] + 100
                                                    if (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_512 += poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024
                                else:
                                    if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not stor159 * 0 / totalAllocPoint:
                                        _2555 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2555] = 26
                                        mem[_2555 + 32] = 'SafeMath: division by zero'
                                        if not 10000 * poolInfo[idx].field_1280:
                                            _2605 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _2605 + 68] = mem[idx + _2555 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_2605 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _2605 + -mem[64] + 100
                                        if (0 / 10000 * poolInfo[idx].field_1280) + poolInfo[idx].field_256 < poolInfo[idx].field_256:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_256 += 0 / 10000 * poolInfo[idx].field_1280
                                        if poolInfo[idx].field_992:
                                            if poolInfo[idx].field_1024:
                                                if not poolInfo[idx].field_1024:
                                                    if not 0 / totalAllocPoint:
                                                        _3169 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3169] = 26
                                                        mem[_3169 + 32] = 'SafeMath: division by zero'
                                                        _3244 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _3244 + 68] = mem[idx + _3169 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_3244 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _3244 + -mem[64] + 100
                                                    if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not stor159 * 0 / totalAllocPoint:
                                                        _3243 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3243] = 26
                                                        mem[_3243 + 32] = 'SafeMath: division by zero'
                                                        _3354 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _3354 + 68] = mem[idx + _3243 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_3354 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _3354 + -mem[64] + 100
                                                    if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    _3353 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_3353] = 26
                                                    mem[_3353 + 32] = 'SafeMath: division by zero'
                                                    _3492 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _3492 + 68] = mem[idx + _3353 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_3492 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _3492 + -mem[64] + 100
                                                if 10000 * poolInfo[idx].field_1024 / poolInfo[idx].field_1024 != 10000:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not 0 / totalAllocPoint:
                                                    _3242 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_3242] = 26
                                                    mem[_3242 + 32] = 'SafeMath: division by zero'
                                                    if not 10000 * poolInfo[idx].field_1024:
                                                        _3352 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _3352 + 68] = mem[idx + _3242 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_3352 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _3352 + -mem[64] + 100
                                                    if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                else:
                                                    if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not stor159 * 0 / totalAllocPoint:
                                                        _3351 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3351] = 26
                                                        mem[_3351 + 32] = 'SafeMath: division by zero'
                                                        if not 10000 * poolInfo[idx].field_1024:
                                                            _3490 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _3490 + 68] = mem[idx + _3351 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_3490 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _3490 + -mem[64] + 100
                                                        if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                    else:
                                                        if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _3489 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3489] = 26
                                                        mem[_3489 + 32] = 'SafeMath: division by zero'
                                                        if not 10000 * poolInfo[idx].field_1024:
                                                            _3633 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            s = 0
                                                            while s < 26:
                                                                mem[s + _3633 + 68] = mem[s + _3489 + 32]
                                                                s = s + 32
                                                                continue 
                                                            mem[_3633 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _3633 + -mem[64] + 100
                                                        if (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_512 += poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024
                                    else:
                                        if (10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint) / stor159 * 0 / totalAllocPoint != -poolInfo[idx].field_992 + 10000:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _2604 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2604] = 26
                                        mem[_2604 + 32] = 'SafeMath: division by zero'
                                        if not 10000 * poolInfo[idx].field_1280:
                                            _2655 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _2655 + 68] = mem[idx + _2604 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_2655 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _2655 + -mem[64] + 100
                                        if ((10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint) / 10000 * poolInfo[idx].field_1280) + poolInfo[idx].field_256 < poolInfo[idx].field_256:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_256 += (10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint) / 10000 * poolInfo[idx].field_1280
                                        if poolInfo[idx].field_992:
                                            if poolInfo[idx].field_1024:
                                                if not poolInfo[idx].field_1024:
                                                    if not 0 / totalAllocPoint:
                                                        _3241 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3241] = 26
                                                        mem[_3241 + 32] = 'SafeMath: division by zero'
                                                        _3350 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _3350 + 68] = mem[idx + _3241 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_3350 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _3350 + -mem[64] + 100
                                                    if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not stor159 * 0 / totalAllocPoint:
                                                        _3349 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3349] = 26
                                                        mem[_3349 + 32] = 'SafeMath: division by zero'
                                                        _3487 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _3487 + 68] = mem[idx + _3349 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_3487 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _3487 + -mem[64] + 100
                                                    if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    _3486 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_3486] = 26
                                                    mem[_3486 + 32] = 'SafeMath: division by zero'
                                                    _3631 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    s = 0
                                                    while s < 26:
                                                        mem[s + _3631 + 68] = mem[s + _3486 + 32]
                                                        s = s + 32
                                                        continue 
                                                    mem[_3631 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _3631 + -mem[64] + 100
                                                if 10000 * poolInfo[idx].field_1024 / poolInfo[idx].field_1024 != 10000:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not 0 / totalAllocPoint:
                                                    _3348 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_3348] = 26
                                                    mem[_3348 + 32] = 'SafeMath: division by zero'
                                                    if not 10000 * poolInfo[idx].field_1024:
                                                        _3485 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _3485 + 68] = mem[idx + _3348 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_3485 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _3485 + -mem[64] + 100
                                                    if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                else:
                                                    if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not stor159 * 0 / totalAllocPoint:
                                                        _3484 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3484] = 26
                                                        mem[_3484 + 32] = 'SafeMath: division by zero'
                                                        if not 10000 * poolInfo[idx].field_1024:
                                                            _3629 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            s = 0
                                                            while s < 26:
                                                                mem[s + _3629 + 68] = mem[s + _3484 + 32]
                                                                s = s + 32
                                                                continue 
                                                            mem[_3629 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _3629 + -mem[64] + 100
                                                        if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                    else:
                                                        if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _3628 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3628] = 26
                                                        mem[_3628 + 32] = 'SafeMath: division by zero'
                                                        if not 10000 * poolInfo[idx].field_1024:
                                                            _3764 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _3764 + 68] = mem[idx + _3628 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_3764 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _3764 + -mem[64] + 100
                                                        if (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_512 += poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024
                            else:
                                if (block.timestamp * 0 / _2347 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2347 * poolInfo[idx].field_160) / (block.timestamp * 0 / _2347) - (poolInfo[idx].field_768 * 0 / _2347) != poolInfo[idx].field_160:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _2403 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2403] = 26
                                mem[_2403 + 32] = 'SafeMath: division by zero'
                                if not totalAllocPoint:
                                    _2413 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _2413 + 68] = mem[idx + _2403 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2413 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2413 + -mem[64] + 100
                                if not poolInfo[idx].field_1280:
                                    if not (block.timestamp * 0 / _2347 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2347 * poolInfo[idx].field_160) / totalAllocPoint:
                                        _2518 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2518] = 26
                                        mem[_2518 + 32] = 'SafeMath: division by zero'
                                        _2554 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _2554 + 68] = mem[idx + _2518 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_2554 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _2554 + -mem[64] + 100
                                    if stor159 * (block.timestamp * 0 / _2347 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2347 * poolInfo[idx].field_160) / totalAllocPoint / (block.timestamp * 0 / _2347 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2347 * poolInfo[idx].field_160) / totalAllocPoint != stor159:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not stor159 * (block.timestamp * 0 / _2347 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2347 * poolInfo[idx].field_160) / totalAllocPoint:
                                        _2553 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2553] = 26
                                        mem[_2553 + 32] = 'SafeMath: division by zero'
                                        _2602 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _2602 + 68] = mem[idx + _2553 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_2602 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _2602 + -mem[64] + 100
                                    if (10000 * stor159 * (block.timestamp * 0 / _2347 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2347 * poolInfo[idx].field_160) / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _2347 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2347 * poolInfo[idx].field_160) / totalAllocPoint) / stor159 * (block.timestamp * 0 / _2347 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2347 * poolInfo[idx].field_160) / totalAllocPoint != -poolInfo[idx].field_992 + 10000:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _2601 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_2601] = 26
                                    mem[_2601 + 32] = 'SafeMath: division by zero'
                                    _2653 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _2653 + 68] = mem[idx + _2601 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2653 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2653 + -mem[64] + 100
                                if 10000 * poolInfo[idx].field_1280 / poolInfo[idx].field_1280 != 10000:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not (block.timestamp * 0 / _2347 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2347 * poolInfo[idx].field_160) / totalAllocPoint:
                                    _2552 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_2552] = 26
                                    mem[_2552 + 32] = 'SafeMath: division by zero'
                                    if not 10000 * poolInfo[idx].field_1280:
                                        _2600 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _2600 + 68] = mem[idx + _2552 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_2600 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _2600 + -mem[64] + 100
                                    if (0 / 10000 * poolInfo[idx].field_1280) + poolInfo[idx].field_256 < poolInfo[idx].field_256:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_256 += 0 / 10000 * poolInfo[idx].field_1280
                                    if poolInfo[idx].field_992:
                                        if poolInfo[idx].field_1024:
                                            if not poolInfo[idx].field_1024:
                                                if not (block.timestamp * 0 / _2347 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2347 * poolInfo[idx].field_160) / totalAllocPoint:
                                                    _3168 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_3168] = 26
                                                    mem[_3168 + 32] = 'SafeMath: division by zero'
                                                    _3240 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _3240 + 68] = mem[idx + _3168 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_3240 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _3240 + -mem[64] + 100
                                                if stor159 * (block.timestamp * 0 / _2347 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2347 * poolInfo[idx].field_160) / totalAllocPoint / (block.timestamp * 0 / _2347 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2347 * poolInfo[idx].field_160) / totalAllocPoint != stor159:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not stor159 * (block.timestamp * 0 / _2347 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2347 * poolInfo[idx].field_160) / totalAllocPoint:
                                                    _3239 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_3239] = 26
                                                    mem[_3239 + 32] = 'SafeMath: division by zero'
                                                    _3346 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _3346 + 68] = mem[idx + _3239 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_3346 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _3346 + -mem[64] + 100
                                                if poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _2347 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2347 * poolInfo[idx].field_160) / totalAllocPoint / stor159 * (block.timestamp * 0 / _2347 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2347 * poolInfo[idx].field_160) / totalAllocPoint != poolInfo[idx].field_992:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _3345 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_3345] = 26
                                                mem[_3345 + 32] = 'SafeMath: division by zero'
                                                _3482 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _3482 + 68] = mem[idx + _3345 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_3482 + 94] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _3482 + -mem[64] + 100
                                            if 10000 * poolInfo[idx].field_1024 / poolInfo[idx].field_1024 != 10000:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if not (block.timestamp * 0 / _2347 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2347 * poolInfo[idx].field_160) / totalAllocPoint:
                                                _3238 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_3238] = 26
                                                mem[_3238 + 32] = 'SafeMath: division by zero'
                                                if not 10000 * poolInfo[idx].field_1024:
                                                    _3344 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _3344 + 68] = mem[idx + _3238 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_3344 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _3344 + -mem[64] + 100
                                                if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                            else:
                                                if stor159 * (block.timestamp * 0 / _2347 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2347 * poolInfo[idx].field_160) / totalAllocPoint / (block.timestamp * 0 / _2347 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2347 * poolInfo[idx].field_160) / totalAllocPoint != stor159:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not stor159 * (block.timestamp * 0 / _2347 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2347 * poolInfo[idx].field_160) / totalAllocPoint:
                                                    _3343 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_3343] = 26
                                                    mem[_3343 + 32] = 'SafeMath: division by zero'
                                                    if not 10000 * poolInfo[idx].field_1024:
                                                        _3480 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _3480 + 68] = mem[idx + _3343 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_3480 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _3480 + -mem[64] + 100
                                                    if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                else:
                                                    if poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _2347 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2347 * poolInfo[idx].field_160) / totalAllocPoint / stor159 * (block.timestamp * 0 / _2347 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2347 * poolInfo[idx].field_160) / totalAllocPoint != poolInfo[idx].field_992:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    _3479 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_3479] = 26
                                                    mem[_3479 + 32] = 'SafeMath: division by zero'
                                                    if not 10000 * poolInfo[idx].field_1024:
                                                        _3625 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        s = 0
                                                        while s < 26:
                                                            mem[s + _3625 + 68] = mem[s + _3479 + 32]
                                                            s = s + 32
                                                            continue 
                                                        mem[_3625 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _3625 + -mem[64] + 100
                                                    if (poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _2347 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2347 * poolInfo[idx].field_160) / totalAllocPoint / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_512 += poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _2347 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2347 * poolInfo[idx].field_160) / totalAllocPoint / 10000 * poolInfo[idx].field_1024
                                else:
                                    if stor159 * (block.timestamp * 0 / _2347 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2347 * poolInfo[idx].field_160) / totalAllocPoint / (block.timestamp * 0 / _2347 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2347 * poolInfo[idx].field_160) / totalAllocPoint != stor159:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not stor159 * (block.timestamp * 0 / _2347 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2347 * poolInfo[idx].field_160) / totalAllocPoint:
                                        _2599 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2599] = 26
                                        mem[_2599 + 32] = 'SafeMath: division by zero'
                                        if not 10000 * poolInfo[idx].field_1280:
                                            _2651 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _2651 + 68] = mem[idx + _2599 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_2651 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _2651 + -mem[64] + 100
                                        if (0 / 10000 * poolInfo[idx].field_1280) + poolInfo[idx].field_256 < poolInfo[idx].field_256:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_256 += 0 / 10000 * poolInfo[idx].field_1280
                                        if poolInfo[idx].field_992:
                                            if poolInfo[idx].field_1024:
                                                if not poolInfo[idx].field_1024:
                                                    if not (block.timestamp * 0 / _2347 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2347 * poolInfo[idx].field_160) / totalAllocPoint:
                                                        _3237 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3237] = 26
                                                        mem[_3237 + 32] = 'SafeMath: division by zero'
                                                        _3342 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _3342 + 68] = mem[idx + _3237 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_3342 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _3342 + -mem[64] + 100
                                                    if stor159 * (block.timestamp * 0 / _2347 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2347 * poolInfo[idx].field_160) / totalAllocPoint / (block.timestamp * 0 / _2347 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2347 * poolInfo[idx].field_160) / totalAllocPoint != stor159:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not stor159 * (block.timestamp * 0 / _2347 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2347 * poolInfo[idx].field_160) / totalAllocPoint:
                                                        _3341 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3341] = 26
                                                        mem[_3341 + 32] = 'SafeMath: division by zero'
                                                        _3477 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _3477 + 68] = mem[idx + _3341 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_3477 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _3477 + -mem[64] + 100
                                                    if poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _2347 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2347 * poolInfo[idx].field_160) / totalAllocPoint / stor159 * (block.timestamp * 0 / _2347 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2347 * poolInfo[idx].field_160) / totalAllocPoint != poolInfo[idx].field_992:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    _3476 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_3476] = 26
                                                    mem[_3476 + 32] = 'SafeMath: division by zero'
                                                    _3623 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    s = 0
                                                    while s < 26:
                                                        mem[s + _3623 + 68] = mem[s + _3476 + 32]
                                                        s = s + 32
                                                        continue 
                                                    mem[_3623 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _3623 + -mem[64] + 100
                                                if 10000 * poolInfo[idx].field_1024 / poolInfo[idx].field_1024 != 10000:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not (block.timestamp * 0 / _2347 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2347 * poolInfo[idx].field_160) / totalAllocPoint:
                                                    _3340 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_3340] = 26
                                                    mem[_3340 + 32] = 'SafeMath: division by zero'
                                                    if not 10000 * poolInfo[idx].field_1024:
                                                        _3475 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _3475 + 68] = mem[idx + _3340 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_3475 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _3475 + -mem[64] + 100
                                                    if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                else:
                                                    if stor159 * (block.timestamp * 0 / _2347 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2347 * poolInfo[idx].field_160) / totalAllocPoint / (block.timestamp * 0 / _2347 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2347 * poolInfo[idx].field_160) / totalAllocPoint != stor159:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not stor159 * (block.timestamp * 0 / _2347 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2347 * poolInfo[idx].field_160) / totalAllocPoint:
                                                        _3474 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3474] = 26
                                                        mem[_3474 + 32] = 'SafeMath: division by zero'
                                                        if not 10000 * poolInfo[idx].field_1024:
                                                            _3621 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            s = 0
                                                            while s < 26:
                                                                mem[s + _3621 + 68] = mem[s + _3474 + 32]
                                                                s = s + 32
                                                                continue 
                                                            mem[_3621 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _3621 + -mem[64] + 100
                                                        if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                    else:
                                                        if poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _2347 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2347 * poolInfo[idx].field_160) / totalAllocPoint / stor159 * (block.timestamp * 0 / _2347 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2347 * poolInfo[idx].field_160) / totalAllocPoint != poolInfo[idx].field_992:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _3620 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3620] = 26
                                                        mem[_3620 + 32] = 'SafeMath: division by zero'
                                                        if not 10000 * poolInfo[idx].field_1024:
                                                            _3759 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _3759 + 68] = mem[idx + _3620 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_3759 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _3759 + -mem[64] + 100
                                                        if (poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _2347 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2347 * poolInfo[idx].field_160) / totalAllocPoint / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_512 += poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _2347 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2347 * poolInfo[idx].field_160) / totalAllocPoint / 10000 * poolInfo[idx].field_1024
                                    else:
                                        if (10000 * stor159 * (block.timestamp * 0 / _2347 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2347 * poolInfo[idx].field_160) / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _2347 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2347 * poolInfo[idx].field_160) / totalAllocPoint) / stor159 * (block.timestamp * 0 / _2347 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2347 * poolInfo[idx].field_160) / totalAllocPoint != -poolInfo[idx].field_992 + 10000:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _2650 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2650] = 26
                                        mem[_2650 + 32] = 'SafeMath: division by zero'
                                        if not 10000 * poolInfo[idx].field_1280:
                                            _2696 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _2696 + 68] = mem[idx + _2650 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_2696 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _2696 + -mem[64] + 100
                                        if ((10000 * stor159 * (block.timestamp * 0 / _2347 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2347 * poolInfo[idx].field_160) / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _2347 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2347 * poolInfo[idx].field_160) / totalAllocPoint) / 10000 * poolInfo[idx].field_1280) + poolInfo[idx].field_256 < poolInfo[idx].field_256:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_256 += (10000 * stor159 * (block.timestamp * 0 / _2347 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2347 * poolInfo[idx].field_160) / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _2347 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2347 * poolInfo[idx].field_160) / totalAllocPoint) / 10000 * poolInfo[idx].field_1280
                                        if poolInfo[idx].field_992:
                                            if poolInfo[idx].field_1024:
                                                if not poolInfo[idx].field_1024:
                                                    if not (block.timestamp * 0 / _2347 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2347 * poolInfo[idx].field_160) / totalAllocPoint:
                                                        _3339 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3339] = 26
                                                        mem[_3339 + 32] = 'SafeMath: division by zero'
                                                        _3473 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _3473 + 68] = mem[idx + _3339 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_3473 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _3473 + -mem[64] + 100
                                                    if stor159 * (block.timestamp * 0 / _2347 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2347 * poolInfo[idx].field_160) / totalAllocPoint / (block.timestamp * 0 / _2347 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2347 * poolInfo[idx].field_160) / totalAllocPoint != stor159:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not stor159 * (block.timestamp * 0 / _2347 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2347 * poolInfo[idx].field_160) / totalAllocPoint:
                                                        _3472 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3472] = 26
                                                        mem[_3472 + 32] = 'SafeMath: division by zero'
                                                        _3618 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        s = 0
                                                        while s < 26:
                                                            mem[s + _3618 + 68] = mem[s + _3472 + 32]
                                                            s = s + 32
                                                            continue 
                                                        mem[_3618 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _3618 + -mem[64] + 100
                                                    if poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _2347 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2347 * poolInfo[idx].field_160) / totalAllocPoint / stor159 * (block.timestamp * 0 / _2347 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2347 * poolInfo[idx].field_160) / totalAllocPoint != poolInfo[idx].field_992:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    _3617 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_3617] = 26
                                                    mem[_3617 + 32] = 'SafeMath: division by zero'
                                                    _3757 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _3757 + 68] = mem[idx + _3617 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_3757 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _3757 + -mem[64] + 100
                                                if 10000 * poolInfo[idx].field_1024 / poolInfo[idx].field_1024 != 10000:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not (block.timestamp * 0 / _2347 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2347 * poolInfo[idx].field_160) / totalAllocPoint:
                                                    _3471 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_3471] = 26
                                                    mem[_3471 + 32] = 'SafeMath: division by zero'
                                                    if not 10000 * poolInfo[idx].field_1024:
                                                        _3616 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        s = 0
                                                        while s < 26:
                                                            mem[s + _3616 + 68] = mem[s + _3471 + 32]
                                                            s = s + 32
                                                            continue 
                                                        mem[_3616 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _3616 + -mem[64] + 100
                                                    if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                else:
                                                    if stor159 * (block.timestamp * 0 / _2347 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2347 * poolInfo[idx].field_160) / totalAllocPoint / (block.timestamp * 0 / _2347 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2347 * poolInfo[idx].field_160) / totalAllocPoint != stor159:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not stor159 * (block.timestamp * 0 / _2347 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2347 * poolInfo[idx].field_160) / totalAllocPoint:
                                                        _3615 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3615] = 26
                                                        mem[_3615 + 32] = 'SafeMath: division by zero'
                                                        if not 10000 * poolInfo[idx].field_1024:
                                                            _3755 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _3755 + 68] = mem[idx + _3615 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_3755 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _3755 + -mem[64] + 100
                                                        if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                    else:
                                                        if poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _2347 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2347 * poolInfo[idx].field_160) / totalAllocPoint / stor159 * (block.timestamp * 0 / _2347 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2347 * poolInfo[idx].field_160) / totalAllocPoint != poolInfo[idx].field_992:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _3754 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3754] = 26
                                                        mem[_3754 + 32] = 'SafeMath: division by zero'
                                                        if not 10000 * poolInfo[idx].field_1024:
                                                            _3890 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _3890 + 68] = mem[idx + _3754 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_3890 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _3890 + -mem[64] + 100
                                                        if (poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _2347 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2347 * poolInfo[idx].field_160) / totalAllocPoint / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_512 += poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _2347 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2347 * poolInfo[idx].field_160) / totalAllocPoint / 10000 * poolInfo[idx].field_1024
                    else:
                        if (1000 * mem[_2332]) - (_2314 * mem[_2332]) - (_2310 * mem[_2332]) - (_2306 * mem[_2332]) / mem[_2332] != -_2314 + -_2310 + -_2306 + 1000:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _2340 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2340] = 26
                        mem[_2340 + 32] = 'SafeMath: division by zero'
                        require ext_code.size(address(MASTER_CHEF_V2Address))
                        staticcall address(MASTER_CHEF_V2Address).0x17caf6f1 with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2346 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2349 = mem[_2346]
                        require ext_code.size(address(MASTER_CHEF_V2Address))
                        staticcall address(MASTER_CHEF_V2Address).0x1526fe27 with:
                                gas gas_remaining wei
                               args MASTER_PID
                        mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2354 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 128
                        _2356 = mem[64]
                        require mem[64] + 128 >= mem[64] and mem[64] + 128 <= test266151307()
                        mem[64] = mem[64] + 128
                        require mem[_2354] == mem[_2354 + 12 len 20]
                        mem[_2356] = mem[_2354]
                        mem[_2356 + 32] = mem[_2354 + 32]
                        mem[_2356 + 64] = mem[_2354 + 64]
                        mem[_2356 + 96] = mem[_2354 + 96]
                        _2366 = mem[_2356 + 32]
                        if not (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000:
                            _2369 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2369] = 26
                            mem[_2369 + 32] = 'SafeMath: division by zero'
                            if not _2349:
                                _2373 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _2373 + 68] = mem[idx + _2369 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2373 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _2373 + -mem[64] + 100
                            if not block.timestamp - poolInfo[idx].field_768:
                                _2395 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2395] = 26
                                mem[_2395 + 32] = 'SafeMath: division by zero'
                                if not totalAllocPoint:
                                    _2402 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _2402 + 68] = mem[idx + _2395 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2402 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2402 + -mem[64] + 100
                                if not poolInfo[idx].field_1280:
                                    if not 0 / totalAllocPoint:
                                        _2496 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2496] = 26
                                        mem[_2496 + 32] = 'SafeMath: division by zero'
                                        _2517 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _2517 + 68] = mem[idx + _2496 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_2517 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _2517 + -mem[64] + 100
                                    if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not stor159 * 0 / totalAllocPoint:
                                        _2516 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2516] = 26
                                        mem[_2516 + 32] = 'SafeMath: division by zero'
                                        _2550 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _2550 + 68] = mem[idx + _2516 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_2550 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _2550 + -mem[64] + 100
                                    if (10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint) / stor159 * 0 / totalAllocPoint != -poolInfo[idx].field_992 + 10000:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _2549 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_2549] = 26
                                    mem[_2549 + 32] = 'SafeMath: division by zero'
                                    _2597 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _2597 + 68] = mem[idx + _2549 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2597 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2597 + -mem[64] + 100
                                if 10000 * poolInfo[idx].field_1280 / poolInfo[idx].field_1280 != 10000:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 0 / totalAllocPoint:
                                    _2515 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_2515] = 26
                                    mem[_2515 + 32] = 'SafeMath: division by zero'
                                    if not 10000 * poolInfo[idx].field_1280:
                                        _2548 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _2548 + 68] = mem[idx + _2515 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_2548 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _2548 + -mem[64] + 100
                                    if (0 / 10000 * poolInfo[idx].field_1280) + poolInfo[idx].field_256 < poolInfo[idx].field_256:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_256 += 0 / 10000 * poolInfo[idx].field_1280
                                    if poolInfo[idx].field_992:
                                        if poolInfo[idx].field_1024:
                                            if not poolInfo[idx].field_1024:
                                                if not 0 / totalAllocPoint:
                                                    _3121 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_3121] = 26
                                                    mem[_3121 + 32] = 'SafeMath: division by zero'
                                                    _3167 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _3167 + 68] = mem[idx + _3121 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_3167 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _3167 + -mem[64] + 100
                                                if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not stor159 * 0 / totalAllocPoint:
                                                    _3166 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_3166] = 26
                                                    mem[_3166 + 32] = 'SafeMath: division by zero'
                                                    _3235 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _3235 + 68] = mem[idx + _3166 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_3235 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _3235 + -mem[64] + 100
                                                if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _3234 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_3234] = 26
                                                mem[_3234 + 32] = 'SafeMath: division by zero'
                                                _3337 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _3337 + 68] = mem[idx + _3234 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_3337 + 94] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _3337 + -mem[64] + 100
                                            if 10000 * poolInfo[idx].field_1024 / poolInfo[idx].field_1024 != 10000:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if not 0 / totalAllocPoint:
                                                _3165 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_3165] = 26
                                                mem[_3165 + 32] = 'SafeMath: division by zero'
                                                if not 10000 * poolInfo[idx].field_1024:
                                                    _3233 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _3233 + 68] = mem[idx + _3165 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_3233 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _3233 + -mem[64] + 100
                                                if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                            else:
                                                if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not stor159 * 0 / totalAllocPoint:
                                                    _3232 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_3232] = 26
                                                    mem[_3232 + 32] = 'SafeMath: division by zero'
                                                    if not 10000 * poolInfo[idx].field_1024:
                                                        _3335 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _3335 + 68] = mem[idx + _3232 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_3335 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _3335 + -mem[64] + 100
                                                    if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                else:
                                                    if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    _3334 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_3334] = 26
                                                    mem[_3334 + 32] = 'SafeMath: division by zero'
                                                    if not 10000 * poolInfo[idx].field_1024:
                                                        _3468 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _3468 + 68] = mem[idx + _3334 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_3468 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _3468 + -mem[64] + 100
                                                    if (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_512 += poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024
                                else:
                                    if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not stor159 * 0 / totalAllocPoint:
                                        _2547 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2547] = 26
                                        mem[_2547 + 32] = 'SafeMath: division by zero'
                                        if not 10000 * poolInfo[idx].field_1280:
                                            _2595 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _2595 + 68] = mem[idx + _2547 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_2595 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _2595 + -mem[64] + 100
                                        if (0 / 10000 * poolInfo[idx].field_1280) + poolInfo[idx].field_256 < poolInfo[idx].field_256:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_256 += 0 / 10000 * poolInfo[idx].field_1280
                                        if poolInfo[idx].field_992:
                                            if poolInfo[idx].field_1024:
                                                if not poolInfo[idx].field_1024:
                                                    if not 0 / totalAllocPoint:
                                                        _3164 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3164] = 26
                                                        mem[_3164 + 32] = 'SafeMath: division by zero'
                                                        _3231 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _3231 + 68] = mem[idx + _3164 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_3231 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _3231 + -mem[64] + 100
                                                    if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not stor159 * 0 / totalAllocPoint:
                                                        _3230 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3230] = 26
                                                        mem[_3230 + 32] = 'SafeMath: division by zero'
                                                        _3332 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _3332 + 68] = mem[idx + _3230 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_3332 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _3332 + -mem[64] + 100
                                                    if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    _3331 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_3331] = 26
                                                    mem[_3331 + 32] = 'SafeMath: division by zero'
                                                    _3466 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _3466 + 68] = mem[idx + _3331 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_3466 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _3466 + -mem[64] + 100
                                                if 10000 * poolInfo[idx].field_1024 / poolInfo[idx].field_1024 != 10000:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not 0 / totalAllocPoint:
                                                    _3229 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_3229] = 26
                                                    mem[_3229 + 32] = 'SafeMath: division by zero'
                                                    if not 10000 * poolInfo[idx].field_1024:
                                                        _3330 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _3330 + 68] = mem[idx + _3229 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_3330 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _3330 + -mem[64] + 100
                                                    if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                else:
                                                    if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not stor159 * 0 / totalAllocPoint:
                                                        _3329 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3329] = 26
                                                        mem[_3329 + 32] = 'SafeMath: division by zero'
                                                        if not 10000 * poolInfo[idx].field_1024:
                                                            _3464 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _3464 + 68] = mem[idx + _3329 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_3464 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _3464 + -mem[64] + 100
                                                        if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                    else:
                                                        if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _3463 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3463] = 26
                                                        mem[_3463 + 32] = 'SafeMath: division by zero'
                                                        if not 10000 * poolInfo[idx].field_1024:
                                                            _3610 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            s = 0
                                                            while s < 26:
                                                                mem[s + _3610 + 68] = mem[s + _3463 + 32]
                                                                s = s + 32
                                                                continue 
                                                            mem[_3610 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _3610 + -mem[64] + 100
                                                        if (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_512 += poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024
                                    else:
                                        if (10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint) / stor159 * 0 / totalAllocPoint != -poolInfo[idx].field_992 + 10000:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _2594 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2594] = 26
                                        mem[_2594 + 32] = 'SafeMath: division by zero'
                                        if not 10000 * poolInfo[idx].field_1280:
                                            _2647 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _2647 + 68] = mem[idx + _2594 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_2647 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _2647 + -mem[64] + 100
                                        if ((10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint) / 10000 * poolInfo[idx].field_1280) + poolInfo[idx].field_256 < poolInfo[idx].field_256:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_256 += (10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint) / 10000 * poolInfo[idx].field_1280
                                        if poolInfo[idx].field_992:
                                            if poolInfo[idx].field_1024:
                                                if not poolInfo[idx].field_1024:
                                                    if not 0 / totalAllocPoint:
                                                        _3228 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3228] = 26
                                                        mem[_3228 + 32] = 'SafeMath: division by zero'
                                                        _3328 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _3328 + 68] = mem[idx + _3228 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_3328 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _3328 + -mem[64] + 100
                                                    if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not stor159 * 0 / totalAllocPoint:
                                                        _3327 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3327] = 26
                                                        mem[_3327 + 32] = 'SafeMath: division by zero'
                                                        _3461 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _3461 + 68] = mem[idx + _3327 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_3461 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _3461 + -mem[64] + 100
                                                    if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    _3460 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_3460] = 26
                                                    mem[_3460 + 32] = 'SafeMath: division by zero'
                                                    _3608 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    s = 0
                                                    while s < 26:
                                                        mem[s + _3608 + 68] = mem[s + _3460 + 32]
                                                        s = s + 32
                                                        continue 
                                                    mem[_3608 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _3608 + -mem[64] + 100
                                                if 10000 * poolInfo[idx].field_1024 / poolInfo[idx].field_1024 != 10000:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not 0 / totalAllocPoint:
                                                    _3326 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_3326] = 26
                                                    mem[_3326 + 32] = 'SafeMath: division by zero'
                                                    if not 10000 * poolInfo[idx].field_1024:
                                                        _3459 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _3459 + 68] = mem[idx + _3326 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_3459 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _3459 + -mem[64] + 100
                                                    if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                else:
                                                    if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not stor159 * 0 / totalAllocPoint:
                                                        _3458 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3458] = 26
                                                        mem[_3458 + 32] = 'SafeMath: division by zero'
                                                        if not 10000 * poolInfo[idx].field_1024:
                                                            _3606 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            s = 0
                                                            while s < 26:
                                                                mem[s + _3606 + 68] = mem[s + _3458 + 32]
                                                                s = s + 32
                                                                continue 
                                                            mem[_3606 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _3606 + -mem[64] + 100
                                                        if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                    else:
                                                        if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _3605 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3605] = 26
                                                        mem[_3605 + 32] = 'SafeMath: division by zero'
                                                        if not 10000 * poolInfo[idx].field_1024:
                                                            _3745 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _3745 + 68] = mem[idx + _3605 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_3745 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _3745 + -mem[64] + 100
                                                        if (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_512 += poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024
                            else:
                                if (block.timestamp * 0 / _2349) - (poolInfo[idx].field_768 * 0 / _2349) / block.timestamp - poolInfo[idx].field_768 != 0 / _2349:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not (block.timestamp * 0 / _2349) - (poolInfo[idx].field_768 * 0 / _2349):
                                    _2401 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_2401] = 26
                                    mem[_2401 + 32] = 'SafeMath: division by zero'
                                    if not totalAllocPoint:
                                        _2411 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _2411 + 68] = mem[idx + _2401 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_2411 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _2411 + -mem[64] + 100
                                    if not poolInfo[idx].field_1280:
                                        if not 0 / totalAllocPoint:
                                            _2514 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2514] = 26
                                            mem[_2514 + 32] = 'SafeMath: division by zero'
                                            _2546 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _2546 + 68] = mem[idx + _2514 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_2546 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _2546 + -mem[64] + 100
                                        if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not stor159 * 0 / totalAllocPoint:
                                            _2545 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2545] = 26
                                            mem[_2545 + 32] = 'SafeMath: division by zero'
                                            _2592 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _2592 + 68] = mem[idx + _2545 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_2592 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _2592 + -mem[64] + 100
                                        if (10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint) / stor159 * 0 / totalAllocPoint != -poolInfo[idx].field_992 + 10000:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _2591 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2591] = 26
                                        mem[_2591 + 32] = 'SafeMath: division by zero'
                                        _2645 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _2645 + 68] = mem[idx + _2591 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_2645 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _2645 + -mem[64] + 100
                                    if 10000 * poolInfo[idx].field_1280 / poolInfo[idx].field_1280 != 10000:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not 0 / totalAllocPoint:
                                        _2544 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2544] = 26
                                        mem[_2544 + 32] = 'SafeMath: division by zero'
                                        if not 10000 * poolInfo[idx].field_1280:
                                            _2590 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _2590 + 68] = mem[idx + _2544 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_2590 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _2590 + -mem[64] + 100
                                        if (0 / 10000 * poolInfo[idx].field_1280) + poolInfo[idx].field_256 < poolInfo[idx].field_256:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_256 += 0 / 10000 * poolInfo[idx].field_1280
                                        if poolInfo[idx].field_992:
                                            if poolInfo[idx].field_1024:
                                                if not poolInfo[idx].field_1024:
                                                    if not 0 / totalAllocPoint:
                                                        _3163 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3163] = 26
                                                        mem[_3163 + 32] = 'SafeMath: division by zero'
                                                        _3227 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _3227 + 68] = mem[idx + _3163 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_3227 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _3227 + -mem[64] + 100
                                                    if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not stor159 * 0 / totalAllocPoint:
                                                        _3226 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3226] = 26
                                                        mem[_3226 + 32] = 'SafeMath: division by zero'
                                                        _3324 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _3324 + 68] = mem[idx + _3226 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_3324 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _3324 + -mem[64] + 100
                                                    if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    _3323 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_3323] = 26
                                                    mem[_3323 + 32] = 'SafeMath: division by zero'
                                                    _3456 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _3456 + 68] = mem[idx + _3323 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_3456 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _3456 + -mem[64] + 100
                                                if 10000 * poolInfo[idx].field_1024 / poolInfo[idx].field_1024 != 10000:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not 0 / totalAllocPoint:
                                                    _3225 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_3225] = 26
                                                    mem[_3225 + 32] = 'SafeMath: division by zero'
                                                    if not 10000 * poolInfo[idx].field_1024:
                                                        _3322 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _3322 + 68] = mem[idx + _3225 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_3322 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _3322 + -mem[64] + 100
                                                    if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                else:
                                                    if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not stor159 * 0 / totalAllocPoint:
                                                        _3321 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3321] = 26
                                                        mem[_3321 + 32] = 'SafeMath: division by zero'
                                                        if not 10000 * poolInfo[idx].field_1024:
                                                            _3454 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _3454 + 68] = mem[idx + _3321 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_3454 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _3454 + -mem[64] + 100
                                                        if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                    else:
                                                        if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _3453 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3453] = 26
                                                        mem[_3453 + 32] = 'SafeMath: division by zero'
                                                        if not 10000 * poolInfo[idx].field_1024:
                                                            _3602 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            s = 0
                                                            while s < 26:
                                                                mem[s + _3602 + 68] = mem[s + _3453 + 32]
                                                                s = s + 32
                                                                continue 
                                                            mem[_3602 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _3602 + -mem[64] + 100
                                                        if (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_512 += poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024
                                    else:
                                        if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not stor159 * 0 / totalAllocPoint:
                                            _2589 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2589] = 26
                                            mem[_2589 + 32] = 'SafeMath: division by zero'
                                            if not 10000 * poolInfo[idx].field_1280:
                                                _2643 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _2643 + 68] = mem[idx + _2589 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_2643 + 94] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _2643 + -mem[64] + 100
                                            if (0 / 10000 * poolInfo[idx].field_1280) + poolInfo[idx].field_256 < poolInfo[idx].field_256:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_256 += 0 / 10000 * poolInfo[idx].field_1280
                                            if poolInfo[idx].field_992:
                                                if poolInfo[idx].field_1024:
                                                    if not poolInfo[idx].field_1024:
                                                        if not 0 / totalAllocPoint:
                                                            _3224 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_3224] = 26
                                                            mem[_3224 + 32] = 'SafeMath: division by zero'
                                                            _3320 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _3320 + 68] = mem[idx + _3224 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_3320 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _3320 + -mem[64] + 100
                                                        if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if not stor159 * 0 / totalAllocPoint:
                                                            _3319 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_3319] = 26
                                                            mem[_3319 + 32] = 'SafeMath: division by zero'
                                                            _3451 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _3451 + 68] = mem[idx + _3319 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_3451 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _3451 + -mem[64] + 100
                                                        if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _3450 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3450] = 26
                                                        mem[_3450 + 32] = 'SafeMath: division by zero'
                                                        _3600 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        s = 0
                                                        while s < 26:
                                                            mem[s + _3600 + 68] = mem[s + _3450 + 32]
                                                            s = s + 32
                                                            continue 
                                                        mem[_3600 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _3600 + -mem[64] + 100
                                                    if 10000 * poolInfo[idx].field_1024 / poolInfo[idx].field_1024 != 10000:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not 0 / totalAllocPoint:
                                                        _3318 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3318] = 26
                                                        mem[_3318 + 32] = 'SafeMath: division by zero'
                                                        if not 10000 * poolInfo[idx].field_1024:
                                                            _3449 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _3449 + 68] = mem[idx + _3318 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_3449 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _3449 + -mem[64] + 100
                                                        if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                    else:
                                                        if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if not stor159 * 0 / totalAllocPoint:
                                                            _3448 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_3448] = 26
                                                            mem[_3448 + 32] = 'SafeMath: division by zero'
                                                            if not 10000 * poolInfo[idx].field_1024:
                                                                _3598 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                s = 0
                                                                while s < 26:
                                                                    mem[s + _3598 + 68] = mem[s + _3448 + 32]
                                                                    s = s + 32
                                                                    continue 
                                                                mem[_3598 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _3598 + -mem[64] + 100
                                                            if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                        else:
                                                            if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            _3597 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_3597] = 26
                                                            mem[_3597 + 32] = 'SafeMath: division by zero'
                                                            if not 10000 * poolInfo[idx].field_1024:
                                                                _3740 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _3740 + 68] = mem[idx + _3597 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_3740 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _3740 + -mem[64] + 100
                                                            if (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_512 += poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024
                                        else:
                                            if (10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint) / stor159 * 0 / totalAllocPoint != -poolInfo[idx].field_992 + 10000:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _2642 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2642] = 26
                                            mem[_2642 + 32] = 'SafeMath: division by zero'
                                            if not 10000 * poolInfo[idx].field_1280:
                                                _2691 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _2691 + 68] = mem[idx + _2642 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_2691 + 94] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _2691 + -mem[64] + 100
                                            if ((10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint) / 10000 * poolInfo[idx].field_1280) + poolInfo[idx].field_256 < poolInfo[idx].field_256:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_256 += (10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint) / 10000 * poolInfo[idx].field_1280
                                            if poolInfo[idx].field_992:
                                                if poolInfo[idx].field_1024:
                                                    if not poolInfo[idx].field_1024:
                                                        if not 0 / totalAllocPoint:
                                                            _3317 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_3317] = 26
                                                            mem[_3317 + 32] = 'SafeMath: division by zero'
                                                            _3447 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _3447 + 68] = mem[idx + _3317 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_3447 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _3447 + -mem[64] + 100
                                                        if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if not stor159 * 0 / totalAllocPoint:
                                                            _3446 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_3446] = 26
                                                            mem[_3446 + 32] = 'SafeMath: division by zero'
                                                            _3595 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            s = 0
                                                            while s < 26:
                                                                mem[s + _3595 + 68] = mem[s + _3446 + 32]
                                                                s = s + 32
                                                                continue 
                                                            mem[_3595 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _3595 + -mem[64] + 100
                                                        if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _3594 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3594] = 26
                                                        mem[_3594 + 32] = 'SafeMath: division by zero'
                                                        _3738 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _3738 + 68] = mem[idx + _3594 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_3738 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _3738 + -mem[64] + 100
                                                    if 10000 * poolInfo[idx].field_1024 / poolInfo[idx].field_1024 != 10000:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not 0 / totalAllocPoint:
                                                        _3445 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3445] = 26
                                                        mem[_3445 + 32] = 'SafeMath: division by zero'
                                                        if not 10000 * poolInfo[idx].field_1024:
                                                            _3593 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            s = 0
                                                            while s < 26:
                                                                mem[s + _3593 + 68] = mem[s + _3445 + 32]
                                                                s = s + 32
                                                                continue 
                                                            mem[_3593 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _3593 + -mem[64] + 100
                                                        if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                    else:
                                                        if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if not stor159 * 0 / totalAllocPoint:
                                                            _3592 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_3592] = 26
                                                            mem[_3592 + 32] = 'SafeMath: division by zero'
                                                            if not 10000 * poolInfo[idx].field_1024:
                                                                _3736 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _3736 + 68] = mem[idx + _3592 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_3736 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _3736 + -mem[64] + 100
                                                            if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                        else:
                                                            if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            _3735 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_3735] = 26
                                                            mem[_3735 + 32] = 'SafeMath: division by zero'
                                                            if not 10000 * poolInfo[idx].field_1024:
                                                                _3868 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _3868 + 68] = mem[idx + _3735 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_3868 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _3868 + -mem[64] + 100
                                                            if (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_512 += poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024
                                else:
                                    if (block.timestamp * 0 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2349 * poolInfo[idx].field_160) / (block.timestamp * 0 / _2349) - (poolInfo[idx].field_768 * 0 / _2349) != poolInfo[idx].field_160:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _2410 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_2410] = 26
                                    mem[_2410 + 32] = 'SafeMath: division by zero'
                                    if not totalAllocPoint:
                                        _2420 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _2420 + 68] = mem[idx + _2410 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_2420 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _2420 + -mem[64] + 100
                                    if not poolInfo[idx].field_1280:
                                        if not (block.timestamp * 0 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2349 * poolInfo[idx].field_160) / totalAllocPoint:
                                            _2543 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2543] = 26
                                            mem[_2543 + 32] = 'SafeMath: division by zero'
                                            _2588 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _2588 + 68] = mem[idx + _2543 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_2588 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _2588 + -mem[64] + 100
                                        if stor159 * (block.timestamp * 0 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2349 * poolInfo[idx].field_160) / totalAllocPoint / (block.timestamp * 0 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2349 * poolInfo[idx].field_160) / totalAllocPoint != stor159:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not stor159 * (block.timestamp * 0 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2349 * poolInfo[idx].field_160) / totalAllocPoint:
                                            _2587 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2587] = 26
                                            mem[_2587 + 32] = 'SafeMath: division by zero'
                                            _2640 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _2640 + 68] = mem[idx + _2587 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_2640 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _2640 + -mem[64] + 100
                                        if (10000 * stor159 * (block.timestamp * 0 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2349 * poolInfo[idx].field_160) / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2349 * poolInfo[idx].field_160) / totalAllocPoint) / stor159 * (block.timestamp * 0 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2349 * poolInfo[idx].field_160) / totalAllocPoint != -poolInfo[idx].field_992 + 10000:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _2639 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2639] = 26
                                        mem[_2639 + 32] = 'SafeMath: division by zero'
                                        _2689 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _2689 + 68] = mem[idx + _2639 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_2689 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _2689 + -mem[64] + 100
                                    if 10000 * poolInfo[idx].field_1280 / poolInfo[idx].field_1280 != 10000:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not (block.timestamp * 0 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2349 * poolInfo[idx].field_160) / totalAllocPoint:
                                        _2586 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2586] = 26
                                        mem[_2586 + 32] = 'SafeMath: division by zero'
                                        if not 10000 * poolInfo[idx].field_1280:
                                            _2638 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _2638 + 68] = mem[idx + _2586 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_2638 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _2638 + -mem[64] + 100
                                        if (0 / 10000 * poolInfo[idx].field_1280) + poolInfo[idx].field_256 < poolInfo[idx].field_256:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_256 += 0 / 10000 * poolInfo[idx].field_1280
                                        if poolInfo[idx].field_992:
                                            if poolInfo[idx].field_1024:
                                                if not poolInfo[idx].field_1024:
                                                    if not (block.timestamp * 0 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2349 * poolInfo[idx].field_160) / totalAllocPoint:
                                                        _3223 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3223] = 26
                                                        mem[_3223 + 32] = 'SafeMath: division by zero'
                                                        _3316 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _3316 + 68] = mem[idx + _3223 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_3316 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _3316 + -mem[64] + 100
                                                    if stor159 * (block.timestamp * 0 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2349 * poolInfo[idx].field_160) / totalAllocPoint / (block.timestamp * 0 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2349 * poolInfo[idx].field_160) / totalAllocPoint != stor159:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not stor159 * (block.timestamp * 0 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2349 * poolInfo[idx].field_160) / totalAllocPoint:
                                                        _3315 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3315] = 26
                                                        mem[_3315 + 32] = 'SafeMath: division by zero'
                                                        _3443 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _3443 + 68] = mem[idx + _3315 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_3443 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _3443 + -mem[64] + 100
                                                    if poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2349 * poolInfo[idx].field_160) / totalAllocPoint / stor159 * (block.timestamp * 0 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2349 * poolInfo[idx].field_160) / totalAllocPoint != poolInfo[idx].field_992:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    _3442 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_3442] = 26
                                                    mem[_3442 + 32] = 'SafeMath: division by zero'
                                                    _3590 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    s = 0
                                                    while s < 26:
                                                        mem[s + _3590 + 68] = mem[s + _3442 + 32]
                                                        s = s + 32
                                                        continue 
                                                    mem[_3590 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _3590 + -mem[64] + 100
                                                if 10000 * poolInfo[idx].field_1024 / poolInfo[idx].field_1024 != 10000:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not (block.timestamp * 0 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2349 * poolInfo[idx].field_160) / totalAllocPoint:
                                                    _3314 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_3314] = 26
                                                    mem[_3314 + 32] = 'SafeMath: division by zero'
                                                    if not 10000 * poolInfo[idx].field_1024:
                                                        _3441 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _3441 + 68] = mem[idx + _3314 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_3441 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _3441 + -mem[64] + 100
                                                    if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                else:
                                                    if stor159 * (block.timestamp * 0 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2349 * poolInfo[idx].field_160) / totalAllocPoint / (block.timestamp * 0 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2349 * poolInfo[idx].field_160) / totalAllocPoint != stor159:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not stor159 * (block.timestamp * 0 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2349 * poolInfo[idx].field_160) / totalAllocPoint:
                                                        _3440 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3440] = 26
                                                        mem[_3440 + 32] = 'SafeMath: division by zero'
                                                        if not 10000 * poolInfo[idx].field_1024:
                                                            _3588 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            s = 0
                                                            while s < 26:
                                                                mem[s + _3588 + 68] = mem[s + _3440 + 32]
                                                                s = s + 32
                                                                continue 
                                                            mem[_3588 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _3588 + -mem[64] + 100
                                                        if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                    else:
                                                        if poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2349 * poolInfo[idx].field_160) / totalAllocPoint / stor159 * (block.timestamp * 0 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2349 * poolInfo[idx].field_160) / totalAllocPoint != poolInfo[idx].field_992:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _3587 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3587] = 26
                                                        mem[_3587 + 32] = 'SafeMath: division by zero'
                                                        if not 10000 * poolInfo[idx].field_1024:
                                                            _3732 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _3732 + 68] = mem[idx + _3587 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_3732 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _3732 + -mem[64] + 100
                                                        if (poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2349 * poolInfo[idx].field_160) / totalAllocPoint / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_512 += poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2349 * poolInfo[idx].field_160) / totalAllocPoint / 10000 * poolInfo[idx].field_1024
                                    else:
                                        if stor159 * (block.timestamp * 0 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2349 * poolInfo[idx].field_160) / totalAllocPoint / (block.timestamp * 0 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2349 * poolInfo[idx].field_160) / totalAllocPoint != stor159:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not stor159 * (block.timestamp * 0 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2349 * poolInfo[idx].field_160) / totalAllocPoint:
                                            _2637 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2637] = 26
                                            mem[_2637 + 32] = 'SafeMath: division by zero'
                                            if not 10000 * poolInfo[idx].field_1280:
                                                _2687 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _2687 + 68] = mem[idx + _2637 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_2687 + 94] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _2687 + -mem[64] + 100
                                            if (0 / 10000 * poolInfo[idx].field_1280) + poolInfo[idx].field_256 < poolInfo[idx].field_256:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_256 += 0 / 10000 * poolInfo[idx].field_1280
                                            if poolInfo[idx].field_992:
                                                if poolInfo[idx].field_1024:
                                                    if not poolInfo[idx].field_1024:
                                                        if not (block.timestamp * 0 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2349 * poolInfo[idx].field_160) / totalAllocPoint:
                                                            _3313 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_3313] = 26
                                                            mem[_3313 + 32] = 'SafeMath: division by zero'
                                                            _3439 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _3439 + 68] = mem[idx + _3313 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_3439 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _3439 + -mem[64] + 100
                                                        if stor159 * (block.timestamp * 0 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2349 * poolInfo[idx].field_160) / totalAllocPoint / (block.timestamp * 0 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2349 * poolInfo[idx].field_160) / totalAllocPoint != stor159:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if not stor159 * (block.timestamp * 0 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2349 * poolInfo[idx].field_160) / totalAllocPoint:
                                                            _3438 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_3438] = 26
                                                            mem[_3438 + 32] = 'SafeMath: division by zero'
                                                            _3585 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            s = 0
                                                            while s < 26:
                                                                mem[s + _3585 + 68] = mem[s + _3438 + 32]
                                                                s = s + 32
                                                                continue 
                                                            mem[_3585 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _3585 + -mem[64] + 100
                                                        if poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2349 * poolInfo[idx].field_160) / totalAllocPoint / stor159 * (block.timestamp * 0 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2349 * poolInfo[idx].field_160) / totalAllocPoint != poolInfo[idx].field_992:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _3584 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3584] = 26
                                                        mem[_3584 + 32] = 'SafeMath: division by zero'
                                                        _3730 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _3730 + 68] = mem[idx + _3584 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_3730 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _3730 + -mem[64] + 100
                                                    if 10000 * poolInfo[idx].field_1024 / poolInfo[idx].field_1024 != 10000:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not (block.timestamp * 0 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2349 * poolInfo[idx].field_160) / totalAllocPoint:
                                                        _3437 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3437] = 26
                                                        mem[_3437 + 32] = 'SafeMath: division by zero'
                                                        if not 10000 * poolInfo[idx].field_1024:
                                                            _3583 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            s = 0
                                                            while s < 26:
                                                                mem[s + _3583 + 68] = mem[s + _3437 + 32]
                                                                s = s + 32
                                                                continue 
                                                            mem[_3583 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _3583 + -mem[64] + 100
                                                        if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                    else:
                                                        if stor159 * (block.timestamp * 0 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2349 * poolInfo[idx].field_160) / totalAllocPoint / (block.timestamp * 0 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2349 * poolInfo[idx].field_160) / totalAllocPoint != stor159:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if not stor159 * (block.timestamp * 0 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2349 * poolInfo[idx].field_160) / totalAllocPoint:
                                                            _3582 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_3582] = 26
                                                            mem[_3582 + 32] = 'SafeMath: division by zero'
                                                            if not 10000 * poolInfo[idx].field_1024:
                                                                _3728 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _3728 + 68] = mem[idx + _3582 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_3728 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _3728 + -mem[64] + 100
                                                            if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                        else:
                                                            if poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2349 * poolInfo[idx].field_160) / totalAllocPoint / stor159 * (block.timestamp * 0 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2349 * poolInfo[idx].field_160) / totalAllocPoint != poolInfo[idx].field_992:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            _3727 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_3727] = 26
                                                            mem[_3727 + 32] = 'SafeMath: division by zero'
                                                            if not 10000 * poolInfo[idx].field_1024:
                                                                _3863 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _3863 + 68] = mem[idx + _3727 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_3863 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _3863 + -mem[64] + 100
                                                            if (poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2349 * poolInfo[idx].field_160) / totalAllocPoint / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_512 += poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2349 * poolInfo[idx].field_160) / totalAllocPoint / 10000 * poolInfo[idx].field_1024
                                        else:
                                            if (10000 * stor159 * (block.timestamp * 0 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2349 * poolInfo[idx].field_160) / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2349 * poolInfo[idx].field_160) / totalAllocPoint) / stor159 * (block.timestamp * 0 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2349 * poolInfo[idx].field_160) / totalAllocPoint != -poolInfo[idx].field_992 + 10000:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _2686 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2686] = 26
                                            mem[_2686 + 32] = 'SafeMath: division by zero'
                                            if not 10000 * poolInfo[idx].field_1280:
                                                _2729 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _2729 + 68] = mem[idx + _2686 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_2729 + 94] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _2729 + -mem[64] + 100
                                            if ((10000 * stor159 * (block.timestamp * 0 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2349 * poolInfo[idx].field_160) / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2349 * poolInfo[idx].field_160) / totalAllocPoint) / 10000 * poolInfo[idx].field_1280) + poolInfo[idx].field_256 < poolInfo[idx].field_256:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_256 += (10000 * stor159 * (block.timestamp * 0 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2349 * poolInfo[idx].field_160) / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2349 * poolInfo[idx].field_160) / totalAllocPoint) / 10000 * poolInfo[idx].field_1280
                                            if poolInfo[idx].field_992:
                                                if poolInfo[idx].field_1024:
                                                    if not poolInfo[idx].field_1024:
                                                        if not (block.timestamp * 0 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2349 * poolInfo[idx].field_160) / totalAllocPoint:
                                                            _3436 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_3436] = 26
                                                            mem[_3436 + 32] = 'SafeMath: division by zero'
                                                            _3581 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            s = 0
                                                            while s < 26:
                                                                mem[s + _3581 + 68] = mem[s + _3436 + 32]
                                                                s = s + 32
                                                                continue 
                                                            mem[_3581 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _3581 + -mem[64] + 100
                                                        if stor159 * (block.timestamp * 0 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2349 * poolInfo[idx].field_160) / totalAllocPoint / (block.timestamp * 0 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2349 * poolInfo[idx].field_160) / totalAllocPoint != stor159:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if not stor159 * (block.timestamp * 0 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2349 * poolInfo[idx].field_160) / totalAllocPoint:
                                                            _3580 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_3580] = 26
                                                            mem[_3580 + 32] = 'SafeMath: division by zero'
                                                            _3725 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _3725 + 68] = mem[idx + _3580 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_3725 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _3725 + -mem[64] + 100
                                                        if poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2349 * poolInfo[idx].field_160) / totalAllocPoint / stor159 * (block.timestamp * 0 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2349 * poolInfo[idx].field_160) / totalAllocPoint != poolInfo[idx].field_992:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _3724 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3724] = 26
                                                        mem[_3724 + 32] = 'SafeMath: division by zero'
                                                        _3861 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _3861 + 68] = mem[idx + _3724 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_3861 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _3861 + -mem[64] + 100
                                                    if 10000 * poolInfo[idx].field_1024 / poolInfo[idx].field_1024 != 10000:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not (block.timestamp * 0 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2349 * poolInfo[idx].field_160) / totalAllocPoint:
                                                        _3579 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3579] = 26
                                                        mem[_3579 + 32] = 'SafeMath: division by zero'
                                                        if not 10000 * poolInfo[idx].field_1024:
                                                            _3723 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _3723 + 68] = mem[idx + _3579 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_3723 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _3723 + -mem[64] + 100
                                                        if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                    else:
                                                        if stor159 * (block.timestamp * 0 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2349 * poolInfo[idx].field_160) / totalAllocPoint / (block.timestamp * 0 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2349 * poolInfo[idx].field_160) / totalAllocPoint != stor159:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if not stor159 * (block.timestamp * 0 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2349 * poolInfo[idx].field_160) / totalAllocPoint:
                                                            _3722 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_3722] = 26
                                                            mem[_3722 + 32] = 'SafeMath: division by zero'
                                                            if not 10000 * poolInfo[idx].field_1024:
                                                                _3859 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _3859 + 68] = mem[idx + _3722 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_3859 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _3859 + -mem[64] + 100
                                                            if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                        else:
                                                            if poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2349 * poolInfo[idx].field_160) / totalAllocPoint / stor159 * (block.timestamp * 0 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2349 * poolInfo[idx].field_160) / totalAllocPoint != poolInfo[idx].field_992:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            _3858 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_3858] = 26
                                                            mem[_3858 + 32] = 'SafeMath: division by zero'
                                                            if not 10000 * poolInfo[idx].field_1024:
                                                                _3998 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _3998 + 68] = mem[idx + _3858 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_3998 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _3998 + -mem[64] + 100
                                                            if (poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2349 * poolInfo[idx].field_160) / totalAllocPoint / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_512 += poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2349 * poolInfo[idx].field_160) / totalAllocPoint / 10000 * poolInfo[idx].field_1024
                        else:
                            if mem[_2356 + 32] * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 != mem[_2356 + 32]:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _2372 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2372] = 26
                            mem[_2372 + 32] = 'SafeMath: division by zero'
                            if not _2349:
                                _2375 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _2375 + 68] = mem[idx + _2372 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2375 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _2375 + -mem[64] + 100
                            if not block.timestamp - poolInfo[idx].field_768:
                                _2400 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2400] = 26
                                mem[_2400 + 32] = 'SafeMath: division by zero'
                                if not totalAllocPoint:
                                    _2409 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _2409 + 68] = mem[idx + _2400 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2409 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2409 + -mem[64] + 100
                                if not poolInfo[idx].field_1280:
                                    if not 0 / totalAllocPoint:
                                        _2513 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2513] = 26
                                        mem[_2513 + 32] = 'SafeMath: division by zero'
                                        _2542 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _2542 + 68] = mem[idx + _2513 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_2542 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _2542 + -mem[64] + 100
                                    if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not stor159 * 0 / totalAllocPoint:
                                        _2541 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2541] = 26
                                        mem[_2541 + 32] = 'SafeMath: division by zero'
                                        _2584 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _2584 + 68] = mem[idx + _2541 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_2584 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _2584 + -mem[64] + 100
                                    if (10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint) / stor159 * 0 / totalAllocPoint != -poolInfo[idx].field_992 + 10000:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _2583 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_2583] = 26
                                    mem[_2583 + 32] = 'SafeMath: division by zero'
                                    _2635 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _2635 + 68] = mem[idx + _2583 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2635 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2635 + -mem[64] + 100
                                if 10000 * poolInfo[idx].field_1280 / poolInfo[idx].field_1280 != 10000:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 0 / totalAllocPoint:
                                    _2540 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_2540] = 26
                                    mem[_2540 + 32] = 'SafeMath: division by zero'
                                    if not 10000 * poolInfo[idx].field_1280:
                                        _2582 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _2582 + 68] = mem[idx + _2540 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_2582 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _2582 + -mem[64] + 100
                                    if (0 / 10000 * poolInfo[idx].field_1280) + poolInfo[idx].field_256 < poolInfo[idx].field_256:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_256 += 0 / 10000 * poolInfo[idx].field_1280
                                    if poolInfo[idx].field_992:
                                        if poolInfo[idx].field_1024:
                                            if not poolInfo[idx].field_1024:
                                                if not 0 / totalAllocPoint:
                                                    _3162 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_3162] = 26
                                                    mem[_3162 + 32] = 'SafeMath: division by zero'
                                                    _3222 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _3222 + 68] = mem[idx + _3162 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_3222 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _3222 + -mem[64] + 100
                                                if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not stor159 * 0 / totalAllocPoint:
                                                    _3221 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_3221] = 26
                                                    mem[_3221 + 32] = 'SafeMath: division by zero'
                                                    _3311 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _3311 + 68] = mem[idx + _3221 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_3311 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _3311 + -mem[64] + 100
                                                if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _3310 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_3310] = 26
                                                mem[_3310 + 32] = 'SafeMath: division by zero'
                                                _3434 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _3434 + 68] = mem[idx + _3310 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_3434 + 94] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _3434 + -mem[64] + 100
                                            if 10000 * poolInfo[idx].field_1024 / poolInfo[idx].field_1024 != 10000:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if not 0 / totalAllocPoint:
                                                _3220 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_3220] = 26
                                                mem[_3220 + 32] = 'SafeMath: division by zero'
                                                if not 10000 * poolInfo[idx].field_1024:
                                                    _3309 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _3309 + 68] = mem[idx + _3220 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_3309 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _3309 + -mem[64] + 100
                                                if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                            else:
                                                if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not stor159 * 0 / totalAllocPoint:
                                                    _3308 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_3308] = 26
                                                    mem[_3308 + 32] = 'SafeMath: division by zero'
                                                    if not 10000 * poolInfo[idx].field_1024:
                                                        _3432 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _3432 + 68] = mem[idx + _3308 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_3432 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _3432 + -mem[64] + 100
                                                    if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                else:
                                                    if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    _3431 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_3431] = 26
                                                    mem[_3431 + 32] = 'SafeMath: division by zero'
                                                    if not 10000 * poolInfo[idx].field_1024:
                                                        _3576 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        s = 0
                                                        while s < 26:
                                                            mem[s + _3576 + 68] = mem[s + _3431 + 32]
                                                            s = s + 32
                                                            continue 
                                                        mem[_3576 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _3576 + -mem[64] + 100
                                                    if (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_512 += poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024
                                else:
                                    if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not stor159 * 0 / totalAllocPoint:
                                        _2581 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2581] = 26
                                        mem[_2581 + 32] = 'SafeMath: division by zero'
                                        if not 10000 * poolInfo[idx].field_1280:
                                            _2633 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _2633 + 68] = mem[idx + _2581 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_2633 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _2633 + -mem[64] + 100
                                        if (0 / 10000 * poolInfo[idx].field_1280) + poolInfo[idx].field_256 < poolInfo[idx].field_256:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_256 += 0 / 10000 * poolInfo[idx].field_1280
                                        if poolInfo[idx].field_992:
                                            if poolInfo[idx].field_1024:
                                                if not poolInfo[idx].field_1024:
                                                    if not 0 / totalAllocPoint:
                                                        _3219 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3219] = 26
                                                        mem[_3219 + 32] = 'SafeMath: division by zero'
                                                        _3307 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _3307 + 68] = mem[idx + _3219 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_3307 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _3307 + -mem[64] + 100
                                                    if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not stor159 * 0 / totalAllocPoint:
                                                        _3306 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3306] = 26
                                                        mem[_3306 + 32] = 'SafeMath: division by zero'
                                                        _3429 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _3429 + 68] = mem[idx + _3306 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_3429 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _3429 + -mem[64] + 100
                                                    if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    _3428 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_3428] = 26
                                                    mem[_3428 + 32] = 'SafeMath: division by zero'
                                                    _3574 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    s = 0
                                                    while s < 26:
                                                        mem[s + _3574 + 68] = mem[s + _3428 + 32]
                                                        s = s + 32
                                                        continue 
                                                    mem[_3574 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _3574 + -mem[64] + 100
                                                if 10000 * poolInfo[idx].field_1024 / poolInfo[idx].field_1024 != 10000:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not 0 / totalAllocPoint:
                                                    _3305 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_3305] = 26
                                                    mem[_3305 + 32] = 'SafeMath: division by zero'
                                                    if not 10000 * poolInfo[idx].field_1024:
                                                        _3427 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _3427 + 68] = mem[idx + _3305 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_3427 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _3427 + -mem[64] + 100
                                                    if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                else:
                                                    if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not stor159 * 0 / totalAllocPoint:
                                                        _3426 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3426] = 26
                                                        mem[_3426 + 32] = 'SafeMath: division by zero'
                                                        if not 10000 * poolInfo[idx].field_1024:
                                                            _3572 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            s = 0
                                                            while s < 26:
                                                                mem[s + _3572 + 68] = mem[s + _3426 + 32]
                                                                s = s + 32
                                                                continue 
                                                            mem[_3572 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _3572 + -mem[64] + 100
                                                        if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                    else:
                                                        if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _3571 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3571] = 26
                                                        mem[_3571 + 32] = 'SafeMath: division by zero'
                                                        if not 10000 * poolInfo[idx].field_1024:
                                                            _3717 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _3717 + 68] = mem[idx + _3571 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_3717 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _3717 + -mem[64] + 100
                                                        if (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_512 += poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024
                                    else:
                                        if (10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint) / stor159 * 0 / totalAllocPoint != -poolInfo[idx].field_992 + 10000:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _2632 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2632] = 26
                                        mem[_2632 + 32] = 'SafeMath: division by zero'
                                        if not 10000 * poolInfo[idx].field_1280:
                                            _2683 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _2683 + 68] = mem[idx + _2632 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_2683 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _2683 + -mem[64] + 100
                                        if ((10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint) / 10000 * poolInfo[idx].field_1280) + poolInfo[idx].field_256 < poolInfo[idx].field_256:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_256 += (10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint) / 10000 * poolInfo[idx].field_1280
                                        if poolInfo[idx].field_992:
                                            if poolInfo[idx].field_1024:
                                                if not poolInfo[idx].field_1024:
                                                    if not 0 / totalAllocPoint:
                                                        _3304 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3304] = 26
                                                        mem[_3304 + 32] = 'SafeMath: division by zero'
                                                        _3425 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _3425 + 68] = mem[idx + _3304 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_3425 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _3425 + -mem[64] + 100
                                                    if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not stor159 * 0 / totalAllocPoint:
                                                        _3424 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3424] = 26
                                                        mem[_3424 + 32] = 'SafeMath: division by zero'
                                                        _3569 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        s = 0
                                                        while s < 26:
                                                            mem[s + _3569 + 68] = mem[s + _3424 + 32]
                                                            s = s + 32
                                                            continue 
                                                        mem[_3569 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _3569 + -mem[64] + 100
                                                    if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    _3568 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_3568] = 26
                                                    mem[_3568 + 32] = 'SafeMath: division by zero'
                                                    _3715 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _3715 + 68] = mem[idx + _3568 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_3715 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _3715 + -mem[64] + 100
                                                if 10000 * poolInfo[idx].field_1024 / poolInfo[idx].field_1024 != 10000:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not 0 / totalAllocPoint:
                                                    _3423 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_3423] = 26
                                                    mem[_3423 + 32] = 'SafeMath: division by zero'
                                                    if not 10000 * poolInfo[idx].field_1024:
                                                        _3567 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        s = 0
                                                        while s < 26:
                                                            mem[s + _3567 + 68] = mem[s + _3423 + 32]
                                                            s = s + 32
                                                            continue 
                                                        mem[_3567 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _3567 + -mem[64] + 100
                                                    if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                else:
                                                    if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not stor159 * 0 / totalAllocPoint:
                                                        _3566 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3566] = 26
                                                        mem[_3566 + 32] = 'SafeMath: division by zero'
                                                        if not 10000 * poolInfo[idx].field_1024:
                                                            _3713 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _3713 + 68] = mem[idx + _3566 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_3713 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _3713 + -mem[64] + 100
                                                        if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                    else:
                                                        if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _3712 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3712] = 26
                                                        mem[_3712 + 32] = 'SafeMath: division by zero'
                                                        if not 10000 * poolInfo[idx].field_1024:
                                                            _3849 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _3849 + 68] = mem[idx + _3712 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_3849 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _3849 + -mem[64] + 100
                                                        if (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_512 += poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024
                            else:
                                if (block.timestamp * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349) - (poolInfo[idx].field_768 * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349) / block.timestamp - poolInfo[idx].field_768 != _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not (block.timestamp * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349) - (poolInfo[idx].field_768 * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349):
                                    _2408 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_2408] = 26
                                    mem[_2408 + 32] = 'SafeMath: division by zero'
                                    if not totalAllocPoint:
                                        _2418 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _2418 + 68] = mem[idx + _2408 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_2418 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _2418 + -mem[64] + 100
                                    if not poolInfo[idx].field_1280:
                                        if not 0 / totalAllocPoint:
                                            _2539 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2539] = 26
                                            mem[_2539 + 32] = 'SafeMath: division by zero'
                                            _2580 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _2580 + 68] = mem[idx + _2539 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_2580 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _2580 + -mem[64] + 100
                                        if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not stor159 * 0 / totalAllocPoint:
                                            _2579 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2579] = 26
                                            mem[_2579 + 32] = 'SafeMath: division by zero'
                                            _2630 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _2630 + 68] = mem[idx + _2579 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_2630 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _2630 + -mem[64] + 100
                                        if (10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint) / stor159 * 0 / totalAllocPoint != -poolInfo[idx].field_992 + 10000:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _2629 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2629] = 26
                                        mem[_2629 + 32] = 'SafeMath: division by zero'
                                        _2681 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _2681 + 68] = mem[idx + _2629 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_2681 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _2681 + -mem[64] + 100
                                    if 10000 * poolInfo[idx].field_1280 / poolInfo[idx].field_1280 != 10000:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not 0 / totalAllocPoint:
                                        _2578 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2578] = 26
                                        mem[_2578 + 32] = 'SafeMath: division by zero'
                                        if not 10000 * poolInfo[idx].field_1280:
                                            _2628 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _2628 + 68] = mem[idx + _2578 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_2628 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _2628 + -mem[64] + 100
                                        if (0 / 10000 * poolInfo[idx].field_1280) + poolInfo[idx].field_256 < poolInfo[idx].field_256:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_256 += 0 / 10000 * poolInfo[idx].field_1280
                                        if poolInfo[idx].field_992:
                                            if poolInfo[idx].field_1024:
                                                if not poolInfo[idx].field_1024:
                                                    if not 0 / totalAllocPoint:
                                                        _3218 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3218] = 26
                                                        mem[_3218 + 32] = 'SafeMath: division by zero'
                                                        _3303 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _3303 + 68] = mem[idx + _3218 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_3303 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _3303 + -mem[64] + 100
                                                    if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not stor159 * 0 / totalAllocPoint:
                                                        _3302 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3302] = 26
                                                        mem[_3302 + 32] = 'SafeMath: division by zero'
                                                        _3421 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _3421 + 68] = mem[idx + _3302 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_3421 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _3421 + -mem[64] + 100
                                                    if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    _3420 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_3420] = 26
                                                    mem[_3420 + 32] = 'SafeMath: division by zero'
                                                    _3564 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    s = 0
                                                    while s < 26:
                                                        mem[s + _3564 + 68] = mem[s + _3420 + 32]
                                                        s = s + 32
                                                        continue 
                                                    mem[_3564 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _3564 + -mem[64] + 100
                                                if 10000 * poolInfo[idx].field_1024 / poolInfo[idx].field_1024 != 10000:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not 0 / totalAllocPoint:
                                                    _3301 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_3301] = 26
                                                    mem[_3301 + 32] = 'SafeMath: division by zero'
                                                    if not 10000 * poolInfo[idx].field_1024:
                                                        _3419 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _3419 + 68] = mem[idx + _3301 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_3419 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _3419 + -mem[64] + 100
                                                    if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                else:
                                                    if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not stor159 * 0 / totalAllocPoint:
                                                        _3418 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3418] = 26
                                                        mem[_3418 + 32] = 'SafeMath: division by zero'
                                                        if not 10000 * poolInfo[idx].field_1024:
                                                            _3562 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            s = 0
                                                            while s < 26:
                                                                mem[s + _3562 + 68] = mem[s + _3418 + 32]
                                                                s = s + 32
                                                                continue 
                                                            mem[_3562 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _3562 + -mem[64] + 100
                                                        if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                    else:
                                                        if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _3561 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3561] = 26
                                                        mem[_3561 + 32] = 'SafeMath: division by zero'
                                                        if not 10000 * poolInfo[idx].field_1024:
                                                            _3709 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _3709 + 68] = mem[idx + _3561 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_3709 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _3709 + -mem[64] + 100
                                                        if (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_512 += poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024
                                    else:
                                        if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not stor159 * 0 / totalAllocPoint:
                                            _2627 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2627] = 26
                                            mem[_2627 + 32] = 'SafeMath: division by zero'
                                            if not 10000 * poolInfo[idx].field_1280:
                                                _2679 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _2679 + 68] = mem[idx + _2627 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_2679 + 94] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _2679 + -mem[64] + 100
                                            if (0 / 10000 * poolInfo[idx].field_1280) + poolInfo[idx].field_256 < poolInfo[idx].field_256:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_256 += 0 / 10000 * poolInfo[idx].field_1280
                                            if poolInfo[idx].field_992:
                                                if poolInfo[idx].field_1024:
                                                    if not poolInfo[idx].field_1024:
                                                        if not 0 / totalAllocPoint:
                                                            _3300 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_3300] = 26
                                                            mem[_3300 + 32] = 'SafeMath: division by zero'
                                                            _3417 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _3417 + 68] = mem[idx + _3300 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_3417 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _3417 + -mem[64] + 100
                                                        if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if not stor159 * 0 / totalAllocPoint:
                                                            _3416 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_3416] = 26
                                                            mem[_3416 + 32] = 'SafeMath: division by zero'
                                                            _3559 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            s = 0
                                                            while s < 26:
                                                                mem[s + _3559 + 68] = mem[s + _3416 + 32]
                                                                s = s + 32
                                                                continue 
                                                            mem[_3559 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _3559 + -mem[64] + 100
                                                        if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _3558 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3558] = 26
                                                        mem[_3558 + 32] = 'SafeMath: division by zero'
                                                        _3707 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _3707 + 68] = mem[idx + _3558 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_3707 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _3707 + -mem[64] + 100
                                                    if 10000 * poolInfo[idx].field_1024 / poolInfo[idx].field_1024 != 10000:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not 0 / totalAllocPoint:
                                                        _3415 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3415] = 26
                                                        mem[_3415 + 32] = 'SafeMath: division by zero'
                                                        if not 10000 * poolInfo[idx].field_1024:
                                                            _3557 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            s = 0
                                                            while s < 26:
                                                                mem[s + _3557 + 68] = mem[s + _3415 + 32]
                                                                s = s + 32
                                                                continue 
                                                            mem[_3557 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _3557 + -mem[64] + 100
                                                        if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                    else:
                                                        if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if not stor159 * 0 / totalAllocPoint:
                                                            _3556 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_3556] = 26
                                                            mem[_3556 + 32] = 'SafeMath: division by zero'
                                                            if not 10000 * poolInfo[idx].field_1024:
                                                                _3705 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _3705 + 68] = mem[idx + _3556 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_3705 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _3705 + -mem[64] + 100
                                                            if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                        else:
                                                            if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            _3704 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_3704] = 26
                                                            mem[_3704 + 32] = 'SafeMath: division by zero'
                                                            if not 10000 * poolInfo[idx].field_1024:
                                                                _3844 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _3844 + 68] = mem[idx + _3704 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_3844 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _3844 + -mem[64] + 100
                                                            if (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_512 += poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024
                                        else:
                                            if (10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint) / stor159 * 0 / totalAllocPoint != -poolInfo[idx].field_992 + 10000:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _2678 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2678] = 26
                                            mem[_2678 + 32] = 'SafeMath: division by zero'
                                            if not 10000 * poolInfo[idx].field_1280:
                                                _2724 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _2724 + 68] = mem[idx + _2678 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_2724 + 94] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _2724 + -mem[64] + 100
                                            if ((10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint) / 10000 * poolInfo[idx].field_1280) + poolInfo[idx].field_256 < poolInfo[idx].field_256:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_256 += (10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint) / 10000 * poolInfo[idx].field_1280
                                            if poolInfo[idx].field_992:
                                                if poolInfo[idx].field_1024:
                                                    if not poolInfo[idx].field_1024:
                                                        if not 0 / totalAllocPoint:
                                                            _3414 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_3414] = 26
                                                            mem[_3414 + 32] = 'SafeMath: division by zero'
                                                            _3555 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            s = 0
                                                            while s < 26:
                                                                mem[s + _3555 + 68] = mem[s + _3414 + 32]
                                                                s = s + 32
                                                                continue 
                                                            mem[_3555 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _3555 + -mem[64] + 100
                                                        if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if not stor159 * 0 / totalAllocPoint:
                                                            _3554 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_3554] = 26
                                                            mem[_3554 + 32] = 'SafeMath: division by zero'
                                                            _3702 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _3702 + 68] = mem[idx + _3554 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_3702 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _3702 + -mem[64] + 100
                                                        if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _3701 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3701] = 26
                                                        mem[_3701 + 32] = 'SafeMath: division by zero'
                                                        _3842 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _3842 + 68] = mem[idx + _3701 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_3842 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _3842 + -mem[64] + 100
                                                    if 10000 * poolInfo[idx].field_1024 / poolInfo[idx].field_1024 != 10000:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not 0 / totalAllocPoint:
                                                        _3553 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3553] = 26
                                                        mem[_3553 + 32] = 'SafeMath: division by zero'
                                                        if not 10000 * poolInfo[idx].field_1024:
                                                            _3700 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _3700 + 68] = mem[idx + _3553 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_3700 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _3700 + -mem[64] + 100
                                                        if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                    else:
                                                        if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if not stor159 * 0 / totalAllocPoint:
                                                            _3699 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_3699] = 26
                                                            mem[_3699 + 32] = 'SafeMath: division by zero'
                                                            if not 10000 * poolInfo[idx].field_1024:
                                                                _3840 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _3840 + 68] = mem[idx + _3699 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_3840 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _3840 + -mem[64] + 100
                                                            if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                        else:
                                                            if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            _3839 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_3839] = 26
                                                            mem[_3839 + 32] = 'SafeMath: division by zero'
                                                            if not 10000 * poolInfo[idx].field_1024:
                                                                _3976 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _3976 + 68] = mem[idx + _3839 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_3976 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _3976 + -mem[64] + 100
                                                            if (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_512 += poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024
                                else:
                                    if (block.timestamp * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) / (block.timestamp * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349) - (poolInfo[idx].field_768 * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349) != poolInfo[idx].field_160:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _2417 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_2417] = 26
                                    mem[_2417 + 32] = 'SafeMath: division by zero'
                                    if not totalAllocPoint:
                                        _2425 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _2425 + 68] = mem[idx + _2417 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_2425 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _2425 + -mem[64] + 100
                                    if not poolInfo[idx].field_1280:
                                        if not (block.timestamp * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) / totalAllocPoint:
                                            _2577 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2577] = 26
                                            mem[_2577 + 32] = 'SafeMath: division by zero'
                                            _2626 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _2626 + 68] = mem[idx + _2577 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_2626 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _2626 + -mem[64] + 100
                                        if stor159 * (block.timestamp * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) / totalAllocPoint / (block.timestamp * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) / totalAllocPoint != stor159:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not stor159 * (block.timestamp * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) / totalAllocPoint:
                                            _2625 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2625] = 26
                                            mem[_2625 + 32] = 'SafeMath: division by zero'
                                            _2676 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _2676 + 68] = mem[idx + _2625 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_2676 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _2676 + -mem[64] + 100
                                        if (10000 * stor159 * (block.timestamp * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * (block.timestamp * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) / totalAllocPoint) / stor159 * (block.timestamp * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) / totalAllocPoint != -poolInfo[idx].field_992 + 10000:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _2675 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2675] = 26
                                        mem[_2675 + 32] = 'SafeMath: division by zero'
                                        _2722 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _2722 + 68] = mem[idx + _2675 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_2722 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _2722 + -mem[64] + 100
                                    if 10000 * poolInfo[idx].field_1280 / poolInfo[idx].field_1280 != 10000:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not (block.timestamp * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) / totalAllocPoint:
                                        _2624 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2624] = 26
                                        mem[_2624 + 32] = 'SafeMath: division by zero'
                                        if not 10000 * poolInfo[idx].field_1280:
                                            _2674 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _2674 + 68] = mem[idx + _2624 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_2674 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _2674 + -mem[64] + 100
                                        if (0 / 10000 * poolInfo[idx].field_1280) + poolInfo[idx].field_256 < poolInfo[idx].field_256:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_256 += 0 / 10000 * poolInfo[idx].field_1280
                                        if poolInfo[idx].field_992:
                                            if poolInfo[idx].field_1024:
                                                if not poolInfo[idx].field_1024:
                                                    if not (block.timestamp * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) / totalAllocPoint:
                                                        _3299 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3299] = 26
                                                        mem[_3299 + 32] = 'SafeMath: division by zero'
                                                        _3413 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _3413 + 68] = mem[idx + _3299 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_3413 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _3413 + -mem[64] + 100
                                                    if stor159 * (block.timestamp * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) / totalAllocPoint / (block.timestamp * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) / totalAllocPoint != stor159:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not stor159 * (block.timestamp * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) / totalAllocPoint:
                                                        _3412 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3412] = 26
                                                        mem[_3412 + 32] = 'SafeMath: division by zero'
                                                        _3551 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        s = 0
                                                        while s < 26:
                                                            mem[s + _3551 + 68] = mem[s + _3412 + 32]
                                                            s = s + 32
                                                            continue 
                                                        mem[_3551 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _3551 + -mem[64] + 100
                                                    if poolInfo[idx].field_992 * stor159 * (block.timestamp * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) / totalAllocPoint / stor159 * (block.timestamp * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) / totalAllocPoint != poolInfo[idx].field_992:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    _3550 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_3550] = 26
                                                    mem[_3550 + 32] = 'SafeMath: division by zero'
                                                    _3697 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _3697 + 68] = mem[idx + _3550 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_3697 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _3697 + -mem[64] + 100
                                                if 10000 * poolInfo[idx].field_1024 / poolInfo[idx].field_1024 != 10000:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not (block.timestamp * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) / totalAllocPoint:
                                                    _3411 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_3411] = 26
                                                    mem[_3411 + 32] = 'SafeMath: division by zero'
                                                    if not 10000 * poolInfo[idx].field_1024:
                                                        _3549 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        s = 0
                                                        while s < 26:
                                                            mem[s + _3549 + 68] = mem[s + _3411 + 32]
                                                            s = s + 32
                                                            continue 
                                                        mem[_3549 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _3549 + -mem[64] + 100
                                                    if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                else:
                                                    if stor159 * (block.timestamp * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) / totalAllocPoint / (block.timestamp * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) / totalAllocPoint != stor159:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not stor159 * (block.timestamp * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) / totalAllocPoint:
                                                        _3548 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3548] = 26
                                                        mem[_3548 + 32] = 'SafeMath: division by zero'
                                                        if not 10000 * poolInfo[idx].field_1024:
                                                            _3695 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _3695 + 68] = mem[idx + _3548 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_3695 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _3695 + -mem[64] + 100
                                                        if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                    else:
                                                        if poolInfo[idx].field_992 * stor159 * (block.timestamp * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) / totalAllocPoint / stor159 * (block.timestamp * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) / totalAllocPoint != poolInfo[idx].field_992:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _3694 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3694] = 26
                                                        mem[_3694 + 32] = 'SafeMath: division by zero'
                                                        if not 10000 * poolInfo[idx].field_1024:
                                                            _3836 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _3836 + 68] = mem[idx + _3694 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_3836 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _3836 + -mem[64] + 100
                                                        if (poolInfo[idx].field_992 * stor159 * (block.timestamp * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) / totalAllocPoint / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_512 += poolInfo[idx].field_992 * stor159 * (block.timestamp * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) / totalAllocPoint / 10000 * poolInfo[idx].field_1024
                                    else:
                                        if stor159 * (block.timestamp * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) / totalAllocPoint / (block.timestamp * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) / totalAllocPoint != stor159:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not stor159 * (block.timestamp * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) / totalAllocPoint:
                                            _2673 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2673] = 26
                                            mem[_2673 + 32] = 'SafeMath: division by zero'
                                            if not 10000 * poolInfo[idx].field_1280:
                                                _2720 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _2720 + 68] = mem[idx + _2673 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_2720 + 94] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _2720 + -mem[64] + 100
                                            if (0 / 10000 * poolInfo[idx].field_1280) + poolInfo[idx].field_256 < poolInfo[idx].field_256:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_256 += 0 / 10000 * poolInfo[idx].field_1280
                                            if poolInfo[idx].field_992:
                                                if poolInfo[idx].field_1024:
                                                    if not poolInfo[idx].field_1024:
                                                        if not (block.timestamp * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) / totalAllocPoint:
                                                            _3410 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_3410] = 26
                                                            mem[_3410 + 32] = 'SafeMath: division by zero'
                                                            _3547 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            s = 0
                                                            while s < 26:
                                                                mem[s + _3547 + 68] = mem[s + _3410 + 32]
                                                                s = s + 32
                                                                continue 
                                                            mem[_3547 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _3547 + -mem[64] + 100
                                                        if stor159 * (block.timestamp * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) / totalAllocPoint / (block.timestamp * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) / totalAllocPoint != stor159:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if not stor159 * (block.timestamp * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) / totalAllocPoint:
                                                            _3546 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_3546] = 26
                                                            mem[_3546 + 32] = 'SafeMath: division by zero'
                                                            _3692 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _3692 + 68] = mem[idx + _3546 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_3692 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _3692 + -mem[64] + 100
                                                        if poolInfo[idx].field_992 * stor159 * (block.timestamp * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) / totalAllocPoint / stor159 * (block.timestamp * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) / totalAllocPoint != poolInfo[idx].field_992:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _3691 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3691] = 26
                                                        mem[_3691 + 32] = 'SafeMath: division by zero'
                                                        _3834 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _3834 + 68] = mem[idx + _3691 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_3834 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _3834 + -mem[64] + 100
                                                    if 10000 * poolInfo[idx].field_1024 / poolInfo[idx].field_1024 != 10000:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not (block.timestamp * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) / totalAllocPoint:
                                                        _3545 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3545] = 26
                                                        mem[_3545 + 32] = 'SafeMath: division by zero'
                                                        if not 10000 * poolInfo[idx].field_1024:
                                                            _3690 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _3690 + 68] = mem[idx + _3545 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_3690 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _3690 + -mem[64] + 100
                                                        if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                    else:
                                                        if stor159 * (block.timestamp * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) / totalAllocPoint / (block.timestamp * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) / totalAllocPoint != stor159:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if not stor159 * (block.timestamp * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) / totalAllocPoint:
                                                            _3689 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_3689] = 26
                                                            mem[_3689 + 32] = 'SafeMath: division by zero'
                                                            if not 10000 * poolInfo[idx].field_1024:
                                                                _3832 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _3832 + 68] = mem[idx + _3689 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_3832 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _3832 + -mem[64] + 100
                                                            if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                        else:
                                                            if poolInfo[idx].field_992 * stor159 * (block.timestamp * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) / totalAllocPoint / stor159 * (block.timestamp * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) / totalAllocPoint != poolInfo[idx].field_992:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            _3831 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_3831] = 26
                                                            mem[_3831 + 32] = 'SafeMath: division by zero'
                                                            if not 10000 * poolInfo[idx].field_1024:
                                                                _3971 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _3971 + 68] = mem[idx + _3831 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_3971 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _3971 + -mem[64] + 100
                                                            if (poolInfo[idx].field_992 * stor159 * (block.timestamp * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) / totalAllocPoint / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_512 += poolInfo[idx].field_992 * stor159 * (block.timestamp * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) / totalAllocPoint / 10000 * poolInfo[idx].field_1024
                                        else:
                                            if (10000 * stor159 * (block.timestamp * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * (block.timestamp * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) / totalAllocPoint) / stor159 * (block.timestamp * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) / totalAllocPoint != -poolInfo[idx].field_992 + 10000:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _2719 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2719] = 26
                                            mem[_2719 + 32] = 'SafeMath: division by zero'
                                            if not 10000 * poolInfo[idx].field_1280:
                                                _2764 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _2764 + 68] = mem[idx + _2719 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_2764 + 94] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _2764 + -mem[64] + 100
                                            if ((10000 * stor159 * (block.timestamp * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * (block.timestamp * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) / totalAllocPoint) / 10000 * poolInfo[idx].field_1280) + poolInfo[idx].field_256 < poolInfo[idx].field_256:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_256 += (10000 * stor159 * (block.timestamp * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * (block.timestamp * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) / totalAllocPoint) / 10000 * poolInfo[idx].field_1280
                                            if poolInfo[idx].field_992:
                                                if poolInfo[idx].field_1024:
                                                    if not poolInfo[idx].field_1024:
                                                        if not (block.timestamp * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) / totalAllocPoint:
                                                            _3544 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_3544] = 26
                                                            mem[_3544 + 32] = 'SafeMath: division by zero'
                                                            _3688 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _3688 + 68] = mem[idx + _3544 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_3688 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _3688 + -mem[64] + 100
                                                        if stor159 * (block.timestamp * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) / totalAllocPoint / (block.timestamp * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) / totalAllocPoint != stor159:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if not stor159 * (block.timestamp * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) / totalAllocPoint:
                                                            _3687 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_3687] = 26
                                                            mem[_3687 + 32] = 'SafeMath: division by zero'
                                                            _3829 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _3829 + 68] = mem[idx + _3687 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_3829 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _3829 + -mem[64] + 100
                                                        if poolInfo[idx].field_992 * stor159 * (block.timestamp * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) / totalAllocPoint / stor159 * (block.timestamp * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) / totalAllocPoint != poolInfo[idx].field_992:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _3828 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3828] = 26
                                                        mem[_3828 + 32] = 'SafeMath: division by zero'
                                                        _3969 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _3969 + 68] = mem[idx + _3828 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_3969 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _3969 + -mem[64] + 100
                                                    if 10000 * poolInfo[idx].field_1024 / poolInfo[idx].field_1024 != 10000:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not (block.timestamp * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) / totalAllocPoint:
                                                        _3686 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3686] = 26
                                                        mem[_3686 + 32] = 'SafeMath: division by zero'
                                                        if not 10000 * poolInfo[idx].field_1024:
                                                            _3827 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _3827 + 68] = mem[idx + _3686 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_3827 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _3827 + -mem[64] + 100
                                                        if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                    else:
                                                        if stor159 * (block.timestamp * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) / totalAllocPoint / (block.timestamp * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) / totalAllocPoint != stor159:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if not stor159 * (block.timestamp * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) / totalAllocPoint:
                                                            _3826 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_3826] = 26
                                                            mem[_3826 + 32] = 'SafeMath: division by zero'
                                                            if not 10000 * poolInfo[idx].field_1024:
                                                                _3967 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _3967 + 68] = mem[idx + _3826 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_3967 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _3967 + -mem[64] + 100
                                                            if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                        else:
                                                            if poolInfo[idx].field_992 * stor159 * (block.timestamp * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) / totalAllocPoint / stor159 * (block.timestamp * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) / totalAllocPoint != poolInfo[idx].field_992:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            _3966 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_3966] = 26
                                                            mem[_3966 + 32] = 'SafeMath: division by zero'
                                                            if not 10000 * poolInfo[idx].field_1024:
                                                                _4113 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _4113 + 68] = mem[idx + _3966 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_4113 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _4113 + -mem[64] + 100
                                                            if (poolInfo[idx].field_992 * stor159 * (block.timestamp * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) / totalAllocPoint / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_512 += poolInfo[idx].field_992 * stor159 * (block.timestamp * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2366 * (1000 * _2334) - (_2314 * _2334) - (_2310 * _2334) - (_2306 * _2334) / 1000 / _2349 * poolInfo[idx].field_160) / totalAllocPoint / 10000 * poolInfo[idx].field_1024
            poolInfo[idx].field_768 = uint64(block.timestamp)
            mem[mem[64]] = uint64(block.timestamp)
            mem[mem[64] + 32] = poolInfo[idx].field_1280
            mem[mem[64] + 64] = poolInfo[idx].field_256
            mem[mem[64] + 96] = poolInfo[idx].field_512
            emit UpdatePool(block.timestamp << 192, poolInfo[idx].field_1280, poolInfo[idx].field_256, poolInfo[idx].field_512, idx);
        idx = idx + 1
        continue 
}

function sub_980e5f90(?) payable {
    mem[64] = 96
    require calldata.size - 4 >= 160
    require arg2 == Mask(96, 0, arg2)
    require arg3 == uint32(arg3)
    require arg4 == address(arg4)
    require arg5 == bool(arg5)
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if uint32(arg3) > 10000:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    'BoostedMasterChefJoe: veJoeShareBp needs to be lower than 10000'
    idx = 0
    while idx < poolInfo.length:
        mem[0] = 155
        if poolInfo[idx].field_768 < block.timestamp:
            if poolInfo[idx].field_1280:
                if poolInfo[idx].field_160:
                    require ext_code.size(address(MASTER_CHEF_V2Address))
                    staticcall address(MASTER_CHEF_V2Address).investorPercent() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2339 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2342 = mem[_2339]
                    require ext_code.size(address(MASTER_CHEF_V2Address))
                    staticcall address(MASTER_CHEF_V2Address).treasuryPercent() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2348 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2355 = mem[_2348]
                    require ext_code.size(address(MASTER_CHEF_V2Address))
                    staticcall address(MASTER_CHEF_V2Address).devPercent() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2362 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2366 = mem[_2362]
                    _2369 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2369] = 30
                    mem[_2369 + 32] = 'SafeMath: subtraction overflow'
                    if _2366 > 1000:
                        _2372 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _2372 + 68] = mem[idx + _2369 + 32]
                            idx = idx + 32
                            continue 
                        mem[_2372 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _2372 + -mem[64] + 100
                    _2374 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2374] = 30
                    mem[_2374 + 32] = 'SafeMath: subtraction overflow'
                    if _2355 > -_2366 + 1000:
                        _2376 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _2376 + 68] = mem[idx + _2374 + 32]
                            idx = idx + 32
                            continue 
                        mem[_2376 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _2376 + -mem[64] + 100
                    _2378 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2378] = 30
                    mem[_2378 + 32] = 'SafeMath: subtraction overflow'
                    if _2342 > -_2366 + -_2355 + 1000:
                        _2382 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _2382 + 68] = mem[idx + _2378 + 32]
                            idx = idx + 32
                            continue 
                        mem[_2382 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _2382 + -mem[64] + 100
                    require ext_code.size(address(MASTER_CHEF_V2Address))
                    staticcall address(MASTER_CHEF_V2Address).0xca418d23 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2388 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2390 = mem[_2388]
                    if not mem[_2388]:
                        _2394 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2394] = 26
                        mem[_2394 + 32] = 'SafeMath: division by zero'
                        require ext_code.size(address(MASTER_CHEF_V2Address))
                        staticcall address(MASTER_CHEF_V2Address).0x17caf6f1 with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2401 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2403 = mem[_2401]
                        require ext_code.size(address(MASTER_CHEF_V2Address))
                        staticcall address(MASTER_CHEF_V2Address).0x1526fe27 with:
                                gas gas_remaining wei
                               args MASTER_PID
                        mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2409 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 128
                        _2411 = mem[64]
                        require mem[64] + 128 >= mem[64] and mem[64] + 128 <= test266151307()
                        mem[64] = mem[64] + 128
                        require mem[_2409] == mem[_2409 + 12 len 20]
                        mem[_2411] = mem[_2409]
                        mem[_2411 + 32] = mem[_2409 + 32]
                        mem[_2411 + 64] = mem[_2409 + 64]
                        mem[_2411 + 96] = mem[_2409 + 96]
                        _2423 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2423] = 26
                        mem[_2423 + 32] = 'SafeMath: division by zero'
                        if not _2403:
                            _2426 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _2426 + 68] = mem[idx + _2423 + 32]
                                idx = idx + 32
                                continue 
                            mem[_2426 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2426 + -mem[64] + 100
                        if not block.timestamp - poolInfo[idx].field_768:
                            _2448 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2448] = 26
                            mem[_2448 + 32] = 'SafeMath: division by zero'
                            if not totalAllocPoint:
                                _2453 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _2453 + 68] = mem[idx + _2448 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2453 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _2453 + -mem[64] + 100
                            if not poolInfo[idx].field_1280:
                                if not 0 / totalAllocPoint:
                                    _2537 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_2537] = 26
                                    mem[_2537 + 32] = 'SafeMath: division by zero'
                                    _2556 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _2556 + 68] = mem[idx + _2537 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2556 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2556 + -mem[64] + 100
                                if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not stor159 * 0 / totalAllocPoint:
                                    _2555 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_2555] = 26
                                    mem[_2555 + 32] = 'SafeMath: division by zero'
                                    _2581 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _2581 + 68] = mem[idx + _2555 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2581 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2581 + -mem[64] + 100
                                if (10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint) / stor159 * 0 / totalAllocPoint != -poolInfo[idx].field_992 + 10000:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _2580 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2580] = 26
                                mem[_2580 + 32] = 'SafeMath: division by zero'
                                _2619 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _2619 + 68] = mem[idx + _2580 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2619 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _2619 + -mem[64] + 100
                            if 10000 * poolInfo[idx].field_1280 / poolInfo[idx].field_1280 != 10000:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / totalAllocPoint:
                                _2554 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2554] = 26
                                mem[_2554 + 32] = 'SafeMath: division by zero'
                                if not 10000 * poolInfo[idx].field_1280:
                                    _2579 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _2579 + 68] = mem[idx + _2554 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2579 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2579 + -mem[64] + 100
                                if (0 / 10000 * poolInfo[idx].field_1280) + poolInfo[idx].field_256 < poolInfo[idx].field_256:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_256 += 0 / 10000 * poolInfo[idx].field_1280
                                if poolInfo[idx].field_992:
                                    if poolInfo[idx].field_1024:
                                        if not poolInfo[idx].field_1024:
                                            if not 0 / totalAllocPoint:
                                                _3142 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_3142] = 26
                                                mem[_3142 + 32] = 'SafeMath: division by zero'
                                                _3182 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _3182 + 68] = mem[idx + _3142 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_3182 + 94] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _3182 + -mem[64] + 100
                                            if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if not stor159 * 0 / totalAllocPoint:
                                                _3181 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_3181] = 26
                                                mem[_3181 + 32] = 'SafeMath: division by zero'
                                                _3236 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _3236 + 68] = mem[idx + _3181 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_3236 + 94] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _3236 + -mem[64] + 100
                                            if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _3235 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_3235] = 26
                                            mem[_3235 + 32] = 'SafeMath: division by zero'
                                            _3317 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _3317 + 68] = mem[idx + _3235 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_3317 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _3317 + -mem[64] + 100
                                        if 10000 * poolInfo[idx].field_1024 / poolInfo[idx].field_1024 != 10000:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not 0 / totalAllocPoint:
                                            _3180 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_3180] = 26
                                            mem[_3180 + 32] = 'SafeMath: division by zero'
                                            if not 10000 * poolInfo[idx].field_1024:
                                                _3234 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _3234 + 68] = mem[idx + _3180 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_3234 + 94] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _3234 + -mem[64] + 100
                                            if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                        else:
                                            if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if not stor159 * 0 / totalAllocPoint:
                                                _3233 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_3233] = 26
                                                mem[_3233 + 32] = 'SafeMath: division by zero'
                                                if not 10000 * poolInfo[idx].field_1024:
                                                    _3315 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _3315 + 68] = mem[idx + _3233 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_3315 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _3315 + -mem[64] + 100
                                                if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                            else:
                                                if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _3314 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_3314] = 26
                                                mem[_3314 + 32] = 'SafeMath: division by zero'
                                                if not 10000 * poolInfo[idx].field_1024:
                                                    _3427 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _3427 + 68] = mem[idx + _3314 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_3427 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _3427 + -mem[64] + 100
                                                if (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_512 += poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024
                            else:
                                if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not stor159 * 0 / totalAllocPoint:
                                    _2578 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_2578] = 26
                                    mem[_2578 + 32] = 'SafeMath: division by zero'
                                    if not 10000 * poolInfo[idx].field_1280:
                                        _2617 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _2617 + 68] = mem[idx + _2578 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_2617 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _2617 + -mem[64] + 100
                                    if (0 / 10000 * poolInfo[idx].field_1280) + poolInfo[idx].field_256 < poolInfo[idx].field_256:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_256 += 0 / 10000 * poolInfo[idx].field_1280
                                    if poolInfo[idx].field_992:
                                        if poolInfo[idx].field_1024:
                                            if not poolInfo[idx].field_1024:
                                                if not 0 / totalAllocPoint:
                                                    _3179 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_3179] = 26
                                                    mem[_3179 + 32] = 'SafeMath: division by zero'
                                                    _3232 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _3232 + 68] = mem[idx + _3179 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_3232 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _3232 + -mem[64] + 100
                                                if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not stor159 * 0 / totalAllocPoint:
                                                    _3231 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_3231] = 26
                                                    mem[_3231 + 32] = 'SafeMath: division by zero'
                                                    _3312 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _3312 + 68] = mem[idx + _3231 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_3312 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _3312 + -mem[64] + 100
                                                if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _3311 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_3311] = 26
                                                mem[_3311 + 32] = 'SafeMath: division by zero'
                                                _3425 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _3425 + 68] = mem[idx + _3311 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_3425 + 94] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _3425 + -mem[64] + 100
                                            if 10000 * poolInfo[idx].field_1024 / poolInfo[idx].field_1024 != 10000:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if not 0 / totalAllocPoint:
                                                _3230 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_3230] = 26
                                                mem[_3230 + 32] = 'SafeMath: division by zero'
                                                if not 10000 * poolInfo[idx].field_1024:
                                                    _3310 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _3310 + 68] = mem[idx + _3230 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_3310 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _3310 + -mem[64] + 100
                                                if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                            else:
                                                if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not stor159 * 0 / totalAllocPoint:
                                                    _3309 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_3309] = 26
                                                    mem[_3309 + 32] = 'SafeMath: division by zero'
                                                    if not 10000 * poolInfo[idx].field_1024:
                                                        _3423 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _3423 + 68] = mem[idx + _3309 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_3423 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _3423 + -mem[64] + 100
                                                    if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                else:
                                                    if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    _3422 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_3422] = 26
                                                    mem[_3422 + 32] = 'SafeMath: division by zero'
                                                    if not 10000 * poolInfo[idx].field_1024:
                                                        _3558 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _3558 + 68] = mem[idx + _3422 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_3558 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _3558 + -mem[64] + 100
                                                    if (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_512 += poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024
                                else:
                                    if (10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint) / stor159 * 0 / totalAllocPoint != -poolInfo[idx].field_992 + 10000:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _2616 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_2616] = 26
                                    mem[_2616 + 32] = 'SafeMath: division by zero'
                                    if not 10000 * poolInfo[idx].field_1280:
                                        _2665 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _2665 + 68] = mem[idx + _2616 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_2665 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _2665 + -mem[64] + 100
                                    if ((10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint) / 10000 * poolInfo[idx].field_1280) + poolInfo[idx].field_256 < poolInfo[idx].field_256:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_256 += (10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint) / 10000 * poolInfo[idx].field_1280
                                    if poolInfo[idx].field_992:
                                        if poolInfo[idx].field_1024:
                                            if not poolInfo[idx].field_1024:
                                                if not 0 / totalAllocPoint:
                                                    _3229 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_3229] = 26
                                                    mem[_3229 + 32] = 'SafeMath: division by zero'
                                                    _3308 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _3308 + 68] = mem[idx + _3229 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_3308 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _3308 + -mem[64] + 100
                                                if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not stor159 * 0 / totalAllocPoint:
                                                    _3307 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_3307] = 26
                                                    mem[_3307 + 32] = 'SafeMath: division by zero'
                                                    _3420 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _3420 + 68] = mem[idx + _3307 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_3420 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _3420 + -mem[64] + 100
                                                if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _3419 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_3419] = 26
                                                mem[_3419 + 32] = 'SafeMath: division by zero'
                                                _3556 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _3556 + 68] = mem[idx + _3419 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_3556 + 94] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _3556 + -mem[64] + 100
                                            if 10000 * poolInfo[idx].field_1024 / poolInfo[idx].field_1024 != 10000:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if not 0 / totalAllocPoint:
                                                _3306 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_3306] = 26
                                                mem[_3306 + 32] = 'SafeMath: division by zero'
                                                if not 10000 * poolInfo[idx].field_1024:
                                                    _3418 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _3418 + 68] = mem[idx + _3306 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_3418 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _3418 + -mem[64] + 100
                                                if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                            else:
                                                if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not stor159 * 0 / totalAllocPoint:
                                                    _3417 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_3417] = 26
                                                    mem[_3417 + 32] = 'SafeMath: division by zero'
                                                    if not 10000 * poolInfo[idx].field_1024:
                                                        _3554 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _3554 + 68] = mem[idx + _3417 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_3554 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _3554 + -mem[64] + 100
                                                    if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                else:
                                                    if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    _3553 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_3553] = 26
                                                    mem[_3553 + 32] = 'SafeMath: division by zero'
                                                    if not 10000 * poolInfo[idx].field_1024:
                                                        _3694 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        s = 0
                                                        while s < 26:
                                                            mem[s + _3694 + 68] = mem[s + _3553 + 32]
                                                            s = s + 32
                                                            continue 
                                                        mem[_3694 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _3694 + -mem[64] + 100
                                                    if (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_512 += poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024
                        else:
                            if (block.timestamp * 0 / _2403) - (poolInfo[idx].field_768 * 0 / _2403) / block.timestamp - poolInfo[idx].field_768 != 0 / _2403:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not (block.timestamp * 0 / _2403) - (poolInfo[idx].field_768 * 0 / _2403):
                                _2452 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2452] = 26
                                mem[_2452 + 32] = 'SafeMath: division by zero'
                                if not totalAllocPoint:
                                    _2460 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _2460 + 68] = mem[idx + _2452 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2460 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2460 + -mem[64] + 100
                                if not poolInfo[idx].field_1280:
                                    if not 0 / totalAllocPoint:
                                        _2553 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2553] = 26
                                        mem[_2553 + 32] = 'SafeMath: division by zero'
                                        _2577 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _2577 + 68] = mem[idx + _2553 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_2577 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _2577 + -mem[64] + 100
                                    if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not stor159 * 0 / totalAllocPoint:
                                        _2576 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2576] = 26
                                        mem[_2576 + 32] = 'SafeMath: division by zero'
                                        _2614 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _2614 + 68] = mem[idx + _2576 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_2614 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _2614 + -mem[64] + 100
                                    if (10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint) / stor159 * 0 / totalAllocPoint != -poolInfo[idx].field_992 + 10000:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _2613 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_2613] = 26
                                    mem[_2613 + 32] = 'SafeMath: division by zero'
                                    _2663 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _2663 + 68] = mem[idx + _2613 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2663 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2663 + -mem[64] + 100
                                if 10000 * poolInfo[idx].field_1280 / poolInfo[idx].field_1280 != 10000:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 0 / totalAllocPoint:
                                    _2575 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_2575] = 26
                                    mem[_2575 + 32] = 'SafeMath: division by zero'
                                    if not 10000 * poolInfo[idx].field_1280:
                                        _2612 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _2612 + 68] = mem[idx + _2575 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_2612 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _2612 + -mem[64] + 100
                                    if (0 / 10000 * poolInfo[idx].field_1280) + poolInfo[idx].field_256 < poolInfo[idx].field_256:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_256 += 0 / 10000 * poolInfo[idx].field_1280
                                    if poolInfo[idx].field_992:
                                        if poolInfo[idx].field_1024:
                                            if not poolInfo[idx].field_1024:
                                                if not 0 / totalAllocPoint:
                                                    _3178 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_3178] = 26
                                                    mem[_3178 + 32] = 'SafeMath: division by zero'
                                                    _3228 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _3228 + 68] = mem[idx + _3178 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_3228 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _3228 + -mem[64] + 100
                                                if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not stor159 * 0 / totalAllocPoint:
                                                    _3227 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_3227] = 26
                                                    mem[_3227 + 32] = 'SafeMath: division by zero'
                                                    _3304 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _3304 + 68] = mem[idx + _3227 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_3304 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _3304 + -mem[64] + 100
                                                if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _3303 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_3303] = 26
                                                mem[_3303 + 32] = 'SafeMath: division by zero'
                                                _3415 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _3415 + 68] = mem[idx + _3303 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_3415 + 94] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _3415 + -mem[64] + 100
                                            if 10000 * poolInfo[idx].field_1024 / poolInfo[idx].field_1024 != 10000:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if not 0 / totalAllocPoint:
                                                _3226 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_3226] = 26
                                                mem[_3226 + 32] = 'SafeMath: division by zero'
                                                if not 10000 * poolInfo[idx].field_1024:
                                                    _3302 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _3302 + 68] = mem[idx + _3226 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_3302 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _3302 + -mem[64] + 100
                                                if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                            else:
                                                if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not stor159 * 0 / totalAllocPoint:
                                                    _3301 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_3301] = 26
                                                    mem[_3301 + 32] = 'SafeMath: division by zero'
                                                    if not 10000 * poolInfo[idx].field_1024:
                                                        _3413 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _3413 + 68] = mem[idx + _3301 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_3413 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _3413 + -mem[64] + 100
                                                    if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                else:
                                                    if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    _3412 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_3412] = 26
                                                    mem[_3412 + 32] = 'SafeMath: division by zero'
                                                    if not 10000 * poolInfo[idx].field_1024:
                                                        _3550 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _3550 + 68] = mem[idx + _3412 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_3550 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _3550 + -mem[64] + 100
                                                    if (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_512 += poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024
                                else:
                                    if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not stor159 * 0 / totalAllocPoint:
                                        _2611 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2611] = 26
                                        mem[_2611 + 32] = 'SafeMath: division by zero'
                                        if not 10000 * poolInfo[idx].field_1280:
                                            _2661 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _2661 + 68] = mem[idx + _2611 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_2661 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _2661 + -mem[64] + 100
                                        if (0 / 10000 * poolInfo[idx].field_1280) + poolInfo[idx].field_256 < poolInfo[idx].field_256:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_256 += 0 / 10000 * poolInfo[idx].field_1280
                                        if poolInfo[idx].field_992:
                                            if poolInfo[idx].field_1024:
                                                if not poolInfo[idx].field_1024:
                                                    if not 0 / totalAllocPoint:
                                                        _3225 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3225] = 26
                                                        mem[_3225 + 32] = 'SafeMath: division by zero'
                                                        _3300 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _3300 + 68] = mem[idx + _3225 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_3300 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _3300 + -mem[64] + 100
                                                    if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not stor159 * 0 / totalAllocPoint:
                                                        _3299 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3299] = 26
                                                        mem[_3299 + 32] = 'SafeMath: division by zero'
                                                        _3410 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _3410 + 68] = mem[idx + _3299 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_3410 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _3410 + -mem[64] + 100
                                                    if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    _3409 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_3409] = 26
                                                    mem[_3409 + 32] = 'SafeMath: division by zero'
                                                    _3548 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _3548 + 68] = mem[idx + _3409 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_3548 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _3548 + -mem[64] + 100
                                                if 10000 * poolInfo[idx].field_1024 / poolInfo[idx].field_1024 != 10000:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not 0 / totalAllocPoint:
                                                    _3298 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_3298] = 26
                                                    mem[_3298 + 32] = 'SafeMath: division by zero'
                                                    if not 10000 * poolInfo[idx].field_1024:
                                                        _3408 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _3408 + 68] = mem[idx + _3298 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_3408 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _3408 + -mem[64] + 100
                                                    if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                else:
                                                    if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not stor159 * 0 / totalAllocPoint:
                                                        _3407 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3407] = 26
                                                        mem[_3407 + 32] = 'SafeMath: division by zero'
                                                        if not 10000 * poolInfo[idx].field_1024:
                                                            _3546 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _3546 + 68] = mem[idx + _3407 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_3546 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _3546 + -mem[64] + 100
                                                        if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                    else:
                                                        if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _3545 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3545] = 26
                                                        mem[_3545 + 32] = 'SafeMath: division by zero'
                                                        if not 10000 * poolInfo[idx].field_1024:
                                                            _3689 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            s = 0
                                                            while s < 26:
                                                                mem[s + _3689 + 68] = mem[s + _3545 + 32]
                                                                s = s + 32
                                                                continue 
                                                            mem[_3689 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _3689 + -mem[64] + 100
                                                        if (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_512 += poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024
                                    else:
                                        if (10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint) / stor159 * 0 / totalAllocPoint != -poolInfo[idx].field_992 + 10000:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _2660 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2660] = 26
                                        mem[_2660 + 32] = 'SafeMath: division by zero'
                                        if not 10000 * poolInfo[idx].field_1280:
                                            _2711 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _2711 + 68] = mem[idx + _2660 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_2711 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _2711 + -mem[64] + 100
                                        if ((10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint) / 10000 * poolInfo[idx].field_1280) + poolInfo[idx].field_256 < poolInfo[idx].field_256:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_256 += (10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint) / 10000 * poolInfo[idx].field_1280
                                        if poolInfo[idx].field_992:
                                            if poolInfo[idx].field_1024:
                                                if not poolInfo[idx].field_1024:
                                                    if not 0 / totalAllocPoint:
                                                        _3297 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3297] = 26
                                                        mem[_3297 + 32] = 'SafeMath: division by zero'
                                                        _3406 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _3406 + 68] = mem[idx + _3297 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_3406 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _3406 + -mem[64] + 100
                                                    if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not stor159 * 0 / totalAllocPoint:
                                                        _3405 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3405] = 26
                                                        mem[_3405 + 32] = 'SafeMath: division by zero'
                                                        _3543 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _3543 + 68] = mem[idx + _3405 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_3543 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _3543 + -mem[64] + 100
                                                    if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    _3542 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_3542] = 26
                                                    mem[_3542 + 32] = 'SafeMath: division by zero'
                                                    _3687 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    s = 0
                                                    while s < 26:
                                                        mem[s + _3687 + 68] = mem[s + _3542 + 32]
                                                        s = s + 32
                                                        continue 
                                                    mem[_3687 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _3687 + -mem[64] + 100
                                                if 10000 * poolInfo[idx].field_1024 / poolInfo[idx].field_1024 != 10000:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not 0 / totalAllocPoint:
                                                    _3404 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_3404] = 26
                                                    mem[_3404 + 32] = 'SafeMath: division by zero'
                                                    if not 10000 * poolInfo[idx].field_1024:
                                                        _3541 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _3541 + 68] = mem[idx + _3404 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_3541 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _3541 + -mem[64] + 100
                                                    if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                else:
                                                    if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not stor159 * 0 / totalAllocPoint:
                                                        _3540 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3540] = 26
                                                        mem[_3540 + 32] = 'SafeMath: division by zero'
                                                        if not 10000 * poolInfo[idx].field_1024:
                                                            _3685 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            s = 0
                                                            while s < 26:
                                                                mem[s + _3685 + 68] = mem[s + _3540 + 32]
                                                                s = s + 32
                                                                continue 
                                                            mem[_3685 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _3685 + -mem[64] + 100
                                                        if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                    else:
                                                        if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _3684 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3684] = 26
                                                        mem[_3684 + 32] = 'SafeMath: division by zero'
                                                        if not 10000 * poolInfo[idx].field_1024:
                                                            _3820 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _3820 + 68] = mem[idx + _3684 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_3820 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _3820 + -mem[64] + 100
                                                        if (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_512 += poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024
                            else:
                                if (block.timestamp * 0 / _2403 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2403 * poolInfo[idx].field_160) / (block.timestamp * 0 / _2403) - (poolInfo[idx].field_768 * 0 / _2403) != poolInfo[idx].field_160:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _2459 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2459] = 26
                                mem[_2459 + 32] = 'SafeMath: division by zero'
                                if not totalAllocPoint:
                                    _2469 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _2469 + 68] = mem[idx + _2459 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2469 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2469 + -mem[64] + 100
                                if not poolInfo[idx].field_1280:
                                    if not (block.timestamp * 0 / _2403 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2403 * poolInfo[idx].field_160) / totalAllocPoint:
                                        _2574 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2574] = 26
                                        mem[_2574 + 32] = 'SafeMath: division by zero'
                                        _2610 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _2610 + 68] = mem[idx + _2574 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_2610 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _2610 + -mem[64] + 100
                                    if stor159 * (block.timestamp * 0 / _2403 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2403 * poolInfo[idx].field_160) / totalAllocPoint / (block.timestamp * 0 / _2403 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2403 * poolInfo[idx].field_160) / totalAllocPoint != stor159:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not stor159 * (block.timestamp * 0 / _2403 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2403 * poolInfo[idx].field_160) / totalAllocPoint:
                                        _2609 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2609] = 26
                                        mem[_2609 + 32] = 'SafeMath: division by zero'
                                        _2658 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _2658 + 68] = mem[idx + _2609 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_2658 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _2658 + -mem[64] + 100
                                    if (10000 * stor159 * (block.timestamp * 0 / _2403 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2403 * poolInfo[idx].field_160) / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _2403 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2403 * poolInfo[idx].field_160) / totalAllocPoint) / stor159 * (block.timestamp * 0 / _2403 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2403 * poolInfo[idx].field_160) / totalAllocPoint != -poolInfo[idx].field_992 + 10000:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _2657 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_2657] = 26
                                    mem[_2657 + 32] = 'SafeMath: division by zero'
                                    _2709 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _2709 + 68] = mem[idx + _2657 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2709 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2709 + -mem[64] + 100
                                if 10000 * poolInfo[idx].field_1280 / poolInfo[idx].field_1280 != 10000:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not (block.timestamp * 0 / _2403 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2403 * poolInfo[idx].field_160) / totalAllocPoint:
                                    _2608 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_2608] = 26
                                    mem[_2608 + 32] = 'SafeMath: division by zero'
                                    if not 10000 * poolInfo[idx].field_1280:
                                        _2656 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _2656 + 68] = mem[idx + _2608 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_2656 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _2656 + -mem[64] + 100
                                    if (0 / 10000 * poolInfo[idx].field_1280) + poolInfo[idx].field_256 < poolInfo[idx].field_256:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_256 += 0 / 10000 * poolInfo[idx].field_1280
                                    if poolInfo[idx].field_992:
                                        if poolInfo[idx].field_1024:
                                            if not poolInfo[idx].field_1024:
                                                if not (block.timestamp * 0 / _2403 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2403 * poolInfo[idx].field_160) / totalAllocPoint:
                                                    _3224 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_3224] = 26
                                                    mem[_3224 + 32] = 'SafeMath: division by zero'
                                                    _3296 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _3296 + 68] = mem[idx + _3224 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_3296 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _3296 + -mem[64] + 100
                                                if stor159 * (block.timestamp * 0 / _2403 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2403 * poolInfo[idx].field_160) / totalAllocPoint / (block.timestamp * 0 / _2403 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2403 * poolInfo[idx].field_160) / totalAllocPoint != stor159:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not stor159 * (block.timestamp * 0 / _2403 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2403 * poolInfo[idx].field_160) / totalAllocPoint:
                                                    _3295 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_3295] = 26
                                                    mem[_3295 + 32] = 'SafeMath: division by zero'
                                                    _3402 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _3402 + 68] = mem[idx + _3295 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_3402 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _3402 + -mem[64] + 100
                                                if poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _2403 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2403 * poolInfo[idx].field_160) / totalAllocPoint / stor159 * (block.timestamp * 0 / _2403 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2403 * poolInfo[idx].field_160) / totalAllocPoint != poolInfo[idx].field_992:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _3401 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_3401] = 26
                                                mem[_3401 + 32] = 'SafeMath: division by zero'
                                                _3538 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _3538 + 68] = mem[idx + _3401 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_3538 + 94] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _3538 + -mem[64] + 100
                                            if 10000 * poolInfo[idx].field_1024 / poolInfo[idx].field_1024 != 10000:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if not (block.timestamp * 0 / _2403 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2403 * poolInfo[idx].field_160) / totalAllocPoint:
                                                _3294 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_3294] = 26
                                                mem[_3294 + 32] = 'SafeMath: division by zero'
                                                if not 10000 * poolInfo[idx].field_1024:
                                                    _3400 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _3400 + 68] = mem[idx + _3294 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_3400 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _3400 + -mem[64] + 100
                                                if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                            else:
                                                if stor159 * (block.timestamp * 0 / _2403 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2403 * poolInfo[idx].field_160) / totalAllocPoint / (block.timestamp * 0 / _2403 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2403 * poolInfo[idx].field_160) / totalAllocPoint != stor159:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not stor159 * (block.timestamp * 0 / _2403 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2403 * poolInfo[idx].field_160) / totalAllocPoint:
                                                    _3399 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_3399] = 26
                                                    mem[_3399 + 32] = 'SafeMath: division by zero'
                                                    if not 10000 * poolInfo[idx].field_1024:
                                                        _3536 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _3536 + 68] = mem[idx + _3399 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_3536 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _3536 + -mem[64] + 100
                                                    if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                else:
                                                    if poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _2403 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2403 * poolInfo[idx].field_160) / totalAllocPoint / stor159 * (block.timestamp * 0 / _2403 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2403 * poolInfo[idx].field_160) / totalAllocPoint != poolInfo[idx].field_992:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    _3535 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_3535] = 26
                                                    mem[_3535 + 32] = 'SafeMath: division by zero'
                                                    if not 10000 * poolInfo[idx].field_1024:
                                                        _3681 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        s = 0
                                                        while s < 26:
                                                            mem[s + _3681 + 68] = mem[s + _3535 + 32]
                                                            s = s + 32
                                                            continue 
                                                        mem[_3681 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _3681 + -mem[64] + 100
                                                    if (poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _2403 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2403 * poolInfo[idx].field_160) / totalAllocPoint / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_512 += poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _2403 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2403 * poolInfo[idx].field_160) / totalAllocPoint / 10000 * poolInfo[idx].field_1024
                                else:
                                    if stor159 * (block.timestamp * 0 / _2403 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2403 * poolInfo[idx].field_160) / totalAllocPoint / (block.timestamp * 0 / _2403 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2403 * poolInfo[idx].field_160) / totalAllocPoint != stor159:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not stor159 * (block.timestamp * 0 / _2403 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2403 * poolInfo[idx].field_160) / totalAllocPoint:
                                        _2655 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2655] = 26
                                        mem[_2655 + 32] = 'SafeMath: division by zero'
                                        if not 10000 * poolInfo[idx].field_1280:
                                            _2707 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _2707 + 68] = mem[idx + _2655 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_2707 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _2707 + -mem[64] + 100
                                        if (0 / 10000 * poolInfo[idx].field_1280) + poolInfo[idx].field_256 < poolInfo[idx].field_256:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_256 += 0 / 10000 * poolInfo[idx].field_1280
                                        if poolInfo[idx].field_992:
                                            if poolInfo[idx].field_1024:
                                                if not poolInfo[idx].field_1024:
                                                    if not (block.timestamp * 0 / _2403 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2403 * poolInfo[idx].field_160) / totalAllocPoint:
                                                        _3293 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3293] = 26
                                                        mem[_3293 + 32] = 'SafeMath: division by zero'
                                                        _3398 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _3398 + 68] = mem[idx + _3293 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_3398 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _3398 + -mem[64] + 100
                                                    if stor159 * (block.timestamp * 0 / _2403 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2403 * poolInfo[idx].field_160) / totalAllocPoint / (block.timestamp * 0 / _2403 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2403 * poolInfo[idx].field_160) / totalAllocPoint != stor159:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not stor159 * (block.timestamp * 0 / _2403 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2403 * poolInfo[idx].field_160) / totalAllocPoint:
                                                        _3397 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3397] = 26
                                                        mem[_3397 + 32] = 'SafeMath: division by zero'
                                                        _3533 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _3533 + 68] = mem[idx + _3397 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_3533 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _3533 + -mem[64] + 100
                                                    if poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _2403 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2403 * poolInfo[idx].field_160) / totalAllocPoint / stor159 * (block.timestamp * 0 / _2403 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2403 * poolInfo[idx].field_160) / totalAllocPoint != poolInfo[idx].field_992:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    _3532 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_3532] = 26
                                                    mem[_3532 + 32] = 'SafeMath: division by zero'
                                                    _3679 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    s = 0
                                                    while s < 26:
                                                        mem[s + _3679 + 68] = mem[s + _3532 + 32]
                                                        s = s + 32
                                                        continue 
                                                    mem[_3679 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _3679 + -mem[64] + 100
                                                if 10000 * poolInfo[idx].field_1024 / poolInfo[idx].field_1024 != 10000:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not (block.timestamp * 0 / _2403 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2403 * poolInfo[idx].field_160) / totalAllocPoint:
                                                    _3396 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_3396] = 26
                                                    mem[_3396 + 32] = 'SafeMath: division by zero'
                                                    if not 10000 * poolInfo[idx].field_1024:
                                                        _3531 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _3531 + 68] = mem[idx + _3396 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_3531 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _3531 + -mem[64] + 100
                                                    if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                else:
                                                    if stor159 * (block.timestamp * 0 / _2403 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2403 * poolInfo[idx].field_160) / totalAllocPoint / (block.timestamp * 0 / _2403 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2403 * poolInfo[idx].field_160) / totalAllocPoint != stor159:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not stor159 * (block.timestamp * 0 / _2403 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2403 * poolInfo[idx].field_160) / totalAllocPoint:
                                                        _3530 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3530] = 26
                                                        mem[_3530 + 32] = 'SafeMath: division by zero'
                                                        if not 10000 * poolInfo[idx].field_1024:
                                                            _3677 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            s = 0
                                                            while s < 26:
                                                                mem[s + _3677 + 68] = mem[s + _3530 + 32]
                                                                s = s + 32
                                                                continue 
                                                            mem[_3677 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _3677 + -mem[64] + 100
                                                        if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                    else:
                                                        if poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _2403 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2403 * poolInfo[idx].field_160) / totalAllocPoint / stor159 * (block.timestamp * 0 / _2403 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2403 * poolInfo[idx].field_160) / totalAllocPoint != poolInfo[idx].field_992:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _3676 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3676] = 26
                                                        mem[_3676 + 32] = 'SafeMath: division by zero'
                                                        if not 10000 * poolInfo[idx].field_1024:
                                                            _3815 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _3815 + 68] = mem[idx + _3676 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_3815 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _3815 + -mem[64] + 100
                                                        if (poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _2403 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2403 * poolInfo[idx].field_160) / totalAllocPoint / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_512 += poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _2403 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2403 * poolInfo[idx].field_160) / totalAllocPoint / 10000 * poolInfo[idx].field_1024
                                    else:
                                        if (10000 * stor159 * (block.timestamp * 0 / _2403 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2403 * poolInfo[idx].field_160) / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _2403 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2403 * poolInfo[idx].field_160) / totalAllocPoint) / stor159 * (block.timestamp * 0 / _2403 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2403 * poolInfo[idx].field_160) / totalAllocPoint != -poolInfo[idx].field_992 + 10000:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _2706 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2706] = 26
                                        mem[_2706 + 32] = 'SafeMath: division by zero'
                                        if not 10000 * poolInfo[idx].field_1280:
                                            _2752 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _2752 + 68] = mem[idx + _2706 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_2752 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _2752 + -mem[64] + 100
                                        if ((10000 * stor159 * (block.timestamp * 0 / _2403 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2403 * poolInfo[idx].field_160) / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _2403 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2403 * poolInfo[idx].field_160) / totalAllocPoint) / 10000 * poolInfo[idx].field_1280) + poolInfo[idx].field_256 < poolInfo[idx].field_256:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_256 += (10000 * stor159 * (block.timestamp * 0 / _2403 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2403 * poolInfo[idx].field_160) / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _2403 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2403 * poolInfo[idx].field_160) / totalAllocPoint) / 10000 * poolInfo[idx].field_1280
                                        if poolInfo[idx].field_992:
                                            if poolInfo[idx].field_1024:
                                                if not poolInfo[idx].field_1024:
                                                    if not (block.timestamp * 0 / _2403 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2403 * poolInfo[idx].field_160) / totalAllocPoint:
                                                        _3395 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3395] = 26
                                                        mem[_3395 + 32] = 'SafeMath: division by zero'
                                                        _3529 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _3529 + 68] = mem[idx + _3395 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_3529 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _3529 + -mem[64] + 100
                                                    if stor159 * (block.timestamp * 0 / _2403 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2403 * poolInfo[idx].field_160) / totalAllocPoint / (block.timestamp * 0 / _2403 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2403 * poolInfo[idx].field_160) / totalAllocPoint != stor159:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not stor159 * (block.timestamp * 0 / _2403 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2403 * poolInfo[idx].field_160) / totalAllocPoint:
                                                        _3528 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3528] = 26
                                                        mem[_3528 + 32] = 'SafeMath: division by zero'
                                                        _3674 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        s = 0
                                                        while s < 26:
                                                            mem[s + _3674 + 68] = mem[s + _3528 + 32]
                                                            s = s + 32
                                                            continue 
                                                        mem[_3674 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _3674 + -mem[64] + 100
                                                    if poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _2403 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2403 * poolInfo[idx].field_160) / totalAllocPoint / stor159 * (block.timestamp * 0 / _2403 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2403 * poolInfo[idx].field_160) / totalAllocPoint != poolInfo[idx].field_992:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    _3673 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_3673] = 26
                                                    mem[_3673 + 32] = 'SafeMath: division by zero'
                                                    _3813 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _3813 + 68] = mem[idx + _3673 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_3813 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _3813 + -mem[64] + 100
                                                if 10000 * poolInfo[idx].field_1024 / poolInfo[idx].field_1024 != 10000:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not (block.timestamp * 0 / _2403 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2403 * poolInfo[idx].field_160) / totalAllocPoint:
                                                    _3527 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_3527] = 26
                                                    mem[_3527 + 32] = 'SafeMath: division by zero'
                                                    if not 10000 * poolInfo[idx].field_1024:
                                                        _3672 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        s = 0
                                                        while s < 26:
                                                            mem[s + _3672 + 68] = mem[s + _3527 + 32]
                                                            s = s + 32
                                                            continue 
                                                        mem[_3672 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _3672 + -mem[64] + 100
                                                    if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                else:
                                                    if stor159 * (block.timestamp * 0 / _2403 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2403 * poolInfo[idx].field_160) / totalAllocPoint / (block.timestamp * 0 / _2403 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2403 * poolInfo[idx].field_160) / totalAllocPoint != stor159:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not stor159 * (block.timestamp * 0 / _2403 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2403 * poolInfo[idx].field_160) / totalAllocPoint:
                                                        _3671 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3671] = 26
                                                        mem[_3671 + 32] = 'SafeMath: division by zero'
                                                        if not 10000 * poolInfo[idx].field_1024:
                                                            _3811 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _3811 + 68] = mem[idx + _3671 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_3811 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _3811 + -mem[64] + 100
                                                        if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                    else:
                                                        if poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _2403 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2403 * poolInfo[idx].field_160) / totalAllocPoint / stor159 * (block.timestamp * 0 / _2403 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2403 * poolInfo[idx].field_160) / totalAllocPoint != poolInfo[idx].field_992:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _3810 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3810] = 26
                                                        mem[_3810 + 32] = 'SafeMath: division by zero'
                                                        if not 10000 * poolInfo[idx].field_1024:
                                                            _3946 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _3946 + 68] = mem[idx + _3810 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_3946 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _3946 + -mem[64] + 100
                                                        if (poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _2403 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2403 * poolInfo[idx].field_160) / totalAllocPoint / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_512 += poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _2403 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2403 * poolInfo[idx].field_160) / totalAllocPoint / 10000 * poolInfo[idx].field_1024
                    else:
                        if (1000 * mem[_2388]) - (_2366 * mem[_2388]) - (_2355 * mem[_2388]) - (_2342 * mem[_2388]) / mem[_2388] != -_2366 + -_2355 + -_2342 + 1000:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _2396 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2396] = 26
                        mem[_2396 + 32] = 'SafeMath: division by zero'
                        require ext_code.size(address(MASTER_CHEF_V2Address))
                        staticcall address(MASTER_CHEF_V2Address).0x17caf6f1 with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2402 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2405 = mem[_2402]
                        require ext_code.size(address(MASTER_CHEF_V2Address))
                        staticcall address(MASTER_CHEF_V2Address).0x1526fe27 with:
                                gas gas_remaining wei
                               args MASTER_PID
                        mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2410 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 128
                        _2412 = mem[64]
                        require mem[64] + 128 >= mem[64] and mem[64] + 128 <= test266151307()
                        mem[64] = mem[64] + 128
                        require mem[_2410] == mem[_2410 + 12 len 20]
                        mem[_2412] = mem[_2410]
                        mem[_2412 + 32] = mem[_2410 + 32]
                        mem[_2412 + 64] = mem[_2410 + 64]
                        mem[_2412 + 96] = mem[_2410 + 96]
                        _2422 = mem[_2412 + 32]
                        if not (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000:
                            _2425 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2425] = 26
                            mem[_2425 + 32] = 'SafeMath: division by zero'
                            if not _2405:
                                _2429 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _2429 + 68] = mem[idx + _2425 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2429 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _2429 + -mem[64] + 100
                            if not block.timestamp - poolInfo[idx].field_768:
                                _2451 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2451] = 26
                                mem[_2451 + 32] = 'SafeMath: division by zero'
                                if not totalAllocPoint:
                                    _2458 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _2458 + 68] = mem[idx + _2451 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2458 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2458 + -mem[64] + 100
                                if not poolInfo[idx].field_1280:
                                    if not 0 / totalAllocPoint:
                                        _2552 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2552] = 26
                                        mem[_2552 + 32] = 'SafeMath: division by zero'
                                        _2573 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _2573 + 68] = mem[idx + _2552 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_2573 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _2573 + -mem[64] + 100
                                    if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not stor159 * 0 / totalAllocPoint:
                                        _2572 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2572] = 26
                                        mem[_2572 + 32] = 'SafeMath: division by zero'
                                        _2606 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _2606 + 68] = mem[idx + _2572 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_2606 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _2606 + -mem[64] + 100
                                    if (10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint) / stor159 * 0 / totalAllocPoint != -poolInfo[idx].field_992 + 10000:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _2605 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_2605] = 26
                                    mem[_2605 + 32] = 'SafeMath: division by zero'
                                    _2653 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _2653 + 68] = mem[idx + _2605 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2653 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2653 + -mem[64] + 100
                                if 10000 * poolInfo[idx].field_1280 / poolInfo[idx].field_1280 != 10000:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 0 / totalAllocPoint:
                                    _2571 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_2571] = 26
                                    mem[_2571 + 32] = 'SafeMath: division by zero'
                                    if not 10000 * poolInfo[idx].field_1280:
                                        _2604 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _2604 + 68] = mem[idx + _2571 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_2604 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _2604 + -mem[64] + 100
                                    if (0 / 10000 * poolInfo[idx].field_1280) + poolInfo[idx].field_256 < poolInfo[idx].field_256:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_256 += 0 / 10000 * poolInfo[idx].field_1280
                                    if poolInfo[idx].field_992:
                                        if poolInfo[idx].field_1024:
                                            if not poolInfo[idx].field_1024:
                                                if not 0 / totalAllocPoint:
                                                    _3177 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_3177] = 26
                                                    mem[_3177 + 32] = 'SafeMath: division by zero'
                                                    _3223 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _3223 + 68] = mem[idx + _3177 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_3223 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _3223 + -mem[64] + 100
                                                if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not stor159 * 0 / totalAllocPoint:
                                                    _3222 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_3222] = 26
                                                    mem[_3222 + 32] = 'SafeMath: division by zero'
                                                    _3291 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _3291 + 68] = mem[idx + _3222 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_3291 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _3291 + -mem[64] + 100
                                                if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _3290 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_3290] = 26
                                                mem[_3290 + 32] = 'SafeMath: division by zero'
                                                _3393 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _3393 + 68] = mem[idx + _3290 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_3393 + 94] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _3393 + -mem[64] + 100
                                            if 10000 * poolInfo[idx].field_1024 / poolInfo[idx].field_1024 != 10000:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if not 0 / totalAllocPoint:
                                                _3221 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_3221] = 26
                                                mem[_3221 + 32] = 'SafeMath: division by zero'
                                                if not 10000 * poolInfo[idx].field_1024:
                                                    _3289 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _3289 + 68] = mem[idx + _3221 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_3289 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _3289 + -mem[64] + 100
                                                if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                            else:
                                                if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not stor159 * 0 / totalAllocPoint:
                                                    _3288 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_3288] = 26
                                                    mem[_3288 + 32] = 'SafeMath: division by zero'
                                                    if not 10000 * poolInfo[idx].field_1024:
                                                        _3391 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _3391 + 68] = mem[idx + _3288 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_3391 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _3391 + -mem[64] + 100
                                                    if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                else:
                                                    if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    _3390 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_3390] = 26
                                                    mem[_3390 + 32] = 'SafeMath: division by zero'
                                                    if not 10000 * poolInfo[idx].field_1024:
                                                        _3524 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _3524 + 68] = mem[idx + _3390 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_3524 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _3524 + -mem[64] + 100
                                                    if (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_512 += poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024
                                else:
                                    if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not stor159 * 0 / totalAllocPoint:
                                        _2603 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2603] = 26
                                        mem[_2603 + 32] = 'SafeMath: division by zero'
                                        if not 10000 * poolInfo[idx].field_1280:
                                            _2651 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _2651 + 68] = mem[idx + _2603 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_2651 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _2651 + -mem[64] + 100
                                        if (0 / 10000 * poolInfo[idx].field_1280) + poolInfo[idx].field_256 < poolInfo[idx].field_256:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_256 += 0 / 10000 * poolInfo[idx].field_1280
                                        if poolInfo[idx].field_992:
                                            if poolInfo[idx].field_1024:
                                                if not poolInfo[idx].field_1024:
                                                    if not 0 / totalAllocPoint:
                                                        _3220 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3220] = 26
                                                        mem[_3220 + 32] = 'SafeMath: division by zero'
                                                        _3287 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _3287 + 68] = mem[idx + _3220 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_3287 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _3287 + -mem[64] + 100
                                                    if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not stor159 * 0 / totalAllocPoint:
                                                        _3286 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3286] = 26
                                                        mem[_3286 + 32] = 'SafeMath: division by zero'
                                                        _3388 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _3388 + 68] = mem[idx + _3286 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_3388 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _3388 + -mem[64] + 100
                                                    if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    _3387 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_3387] = 26
                                                    mem[_3387 + 32] = 'SafeMath: division by zero'
                                                    _3522 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _3522 + 68] = mem[idx + _3387 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_3522 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _3522 + -mem[64] + 100
                                                if 10000 * poolInfo[idx].field_1024 / poolInfo[idx].field_1024 != 10000:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not 0 / totalAllocPoint:
                                                    _3285 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_3285] = 26
                                                    mem[_3285 + 32] = 'SafeMath: division by zero'
                                                    if not 10000 * poolInfo[idx].field_1024:
                                                        _3386 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _3386 + 68] = mem[idx + _3285 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_3386 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _3386 + -mem[64] + 100
                                                    if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                else:
                                                    if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not stor159 * 0 / totalAllocPoint:
                                                        _3385 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3385] = 26
                                                        mem[_3385 + 32] = 'SafeMath: division by zero'
                                                        if not 10000 * poolInfo[idx].field_1024:
                                                            _3520 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _3520 + 68] = mem[idx + _3385 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_3520 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _3520 + -mem[64] + 100
                                                        if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                    else:
                                                        if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _3519 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3519] = 26
                                                        mem[_3519 + 32] = 'SafeMath: division by zero'
                                                        if not 10000 * poolInfo[idx].field_1024:
                                                            _3666 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            s = 0
                                                            while s < 26:
                                                                mem[s + _3666 + 68] = mem[s + _3519 + 32]
                                                                s = s + 32
                                                                continue 
                                                            mem[_3666 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _3666 + -mem[64] + 100
                                                        if (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_512 += poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024
                                    else:
                                        if (10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint) / stor159 * 0 / totalAllocPoint != -poolInfo[idx].field_992 + 10000:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _2650 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2650] = 26
                                        mem[_2650 + 32] = 'SafeMath: division by zero'
                                        if not 10000 * poolInfo[idx].field_1280:
                                            _2703 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _2703 + 68] = mem[idx + _2650 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_2703 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _2703 + -mem[64] + 100
                                        if ((10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint) / 10000 * poolInfo[idx].field_1280) + poolInfo[idx].field_256 < poolInfo[idx].field_256:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_256 += (10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint) / 10000 * poolInfo[idx].field_1280
                                        if poolInfo[idx].field_992:
                                            if poolInfo[idx].field_1024:
                                                if not poolInfo[idx].field_1024:
                                                    if not 0 / totalAllocPoint:
                                                        _3284 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3284] = 26
                                                        mem[_3284 + 32] = 'SafeMath: division by zero'
                                                        _3384 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _3384 + 68] = mem[idx + _3284 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_3384 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _3384 + -mem[64] + 100
                                                    if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not stor159 * 0 / totalAllocPoint:
                                                        _3383 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3383] = 26
                                                        mem[_3383 + 32] = 'SafeMath: division by zero'
                                                        _3517 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _3517 + 68] = mem[idx + _3383 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_3517 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _3517 + -mem[64] + 100
                                                    if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    _3516 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_3516] = 26
                                                    mem[_3516 + 32] = 'SafeMath: division by zero'
                                                    _3664 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    s = 0
                                                    while s < 26:
                                                        mem[s + _3664 + 68] = mem[s + _3516 + 32]
                                                        s = s + 32
                                                        continue 
                                                    mem[_3664 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _3664 + -mem[64] + 100
                                                if 10000 * poolInfo[idx].field_1024 / poolInfo[idx].field_1024 != 10000:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not 0 / totalAllocPoint:
                                                    _3382 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_3382] = 26
                                                    mem[_3382 + 32] = 'SafeMath: division by zero'
                                                    if not 10000 * poolInfo[idx].field_1024:
                                                        _3515 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _3515 + 68] = mem[idx + _3382 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_3515 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _3515 + -mem[64] + 100
                                                    if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                else:
                                                    if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not stor159 * 0 / totalAllocPoint:
                                                        _3514 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3514] = 26
                                                        mem[_3514 + 32] = 'SafeMath: division by zero'
                                                        if not 10000 * poolInfo[idx].field_1024:
                                                            _3662 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            s = 0
                                                            while s < 26:
                                                                mem[s + _3662 + 68] = mem[s + _3514 + 32]
                                                                s = s + 32
                                                                continue 
                                                            mem[_3662 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _3662 + -mem[64] + 100
                                                        if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                    else:
                                                        if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _3661 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3661] = 26
                                                        mem[_3661 + 32] = 'SafeMath: division by zero'
                                                        if not 10000 * poolInfo[idx].field_1024:
                                                            _3801 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _3801 + 68] = mem[idx + _3661 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_3801 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _3801 + -mem[64] + 100
                                                        if (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_512 += poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024
                            else:
                                if (block.timestamp * 0 / _2405) - (poolInfo[idx].field_768 * 0 / _2405) / block.timestamp - poolInfo[idx].field_768 != 0 / _2405:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not (block.timestamp * 0 / _2405) - (poolInfo[idx].field_768 * 0 / _2405):
                                    _2457 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_2457] = 26
                                    mem[_2457 + 32] = 'SafeMath: division by zero'
                                    if not totalAllocPoint:
                                        _2467 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _2467 + 68] = mem[idx + _2457 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_2467 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _2467 + -mem[64] + 100
                                    if not poolInfo[idx].field_1280:
                                        if not 0 / totalAllocPoint:
                                            _2570 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2570] = 26
                                            mem[_2570 + 32] = 'SafeMath: division by zero'
                                            _2602 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _2602 + 68] = mem[idx + _2570 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_2602 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _2602 + -mem[64] + 100
                                        if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not stor159 * 0 / totalAllocPoint:
                                            _2601 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2601] = 26
                                            mem[_2601 + 32] = 'SafeMath: division by zero'
                                            _2648 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _2648 + 68] = mem[idx + _2601 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_2648 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _2648 + -mem[64] + 100
                                        if (10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint) / stor159 * 0 / totalAllocPoint != -poolInfo[idx].field_992 + 10000:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _2647 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2647] = 26
                                        mem[_2647 + 32] = 'SafeMath: division by zero'
                                        _2701 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _2701 + 68] = mem[idx + _2647 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_2701 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _2701 + -mem[64] + 100
                                    if 10000 * poolInfo[idx].field_1280 / poolInfo[idx].field_1280 != 10000:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not 0 / totalAllocPoint:
                                        _2600 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2600] = 26
                                        mem[_2600 + 32] = 'SafeMath: division by zero'
                                        if not 10000 * poolInfo[idx].field_1280:
                                            _2646 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _2646 + 68] = mem[idx + _2600 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_2646 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _2646 + -mem[64] + 100
                                        if (0 / 10000 * poolInfo[idx].field_1280) + poolInfo[idx].field_256 < poolInfo[idx].field_256:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_256 += 0 / 10000 * poolInfo[idx].field_1280
                                        if poolInfo[idx].field_992:
                                            if poolInfo[idx].field_1024:
                                                if not poolInfo[idx].field_1024:
                                                    if not 0 / totalAllocPoint:
                                                        _3219 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3219] = 26
                                                        mem[_3219 + 32] = 'SafeMath: division by zero'
                                                        _3283 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _3283 + 68] = mem[idx + _3219 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_3283 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _3283 + -mem[64] + 100
                                                    if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not stor159 * 0 / totalAllocPoint:
                                                        _3282 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3282] = 26
                                                        mem[_3282 + 32] = 'SafeMath: division by zero'
                                                        _3380 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _3380 + 68] = mem[idx + _3282 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_3380 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _3380 + -mem[64] + 100
                                                    if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    _3379 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_3379] = 26
                                                    mem[_3379 + 32] = 'SafeMath: division by zero'
                                                    _3512 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _3512 + 68] = mem[idx + _3379 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_3512 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _3512 + -mem[64] + 100
                                                if 10000 * poolInfo[idx].field_1024 / poolInfo[idx].field_1024 != 10000:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not 0 / totalAllocPoint:
                                                    _3281 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_3281] = 26
                                                    mem[_3281 + 32] = 'SafeMath: division by zero'
                                                    if not 10000 * poolInfo[idx].field_1024:
                                                        _3378 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _3378 + 68] = mem[idx + _3281 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_3378 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _3378 + -mem[64] + 100
                                                    if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                else:
                                                    if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not stor159 * 0 / totalAllocPoint:
                                                        _3377 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3377] = 26
                                                        mem[_3377 + 32] = 'SafeMath: division by zero'
                                                        if not 10000 * poolInfo[idx].field_1024:
                                                            _3510 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _3510 + 68] = mem[idx + _3377 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_3510 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _3510 + -mem[64] + 100
                                                        if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                    else:
                                                        if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _3509 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3509] = 26
                                                        mem[_3509 + 32] = 'SafeMath: division by zero'
                                                        if not 10000 * poolInfo[idx].field_1024:
                                                            _3658 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            s = 0
                                                            while s < 26:
                                                                mem[s + _3658 + 68] = mem[s + _3509 + 32]
                                                                s = s + 32
                                                                continue 
                                                            mem[_3658 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _3658 + -mem[64] + 100
                                                        if (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_512 += poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024
                                    else:
                                        if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not stor159 * 0 / totalAllocPoint:
                                            _2645 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2645] = 26
                                            mem[_2645 + 32] = 'SafeMath: division by zero'
                                            if not 10000 * poolInfo[idx].field_1280:
                                                _2699 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _2699 + 68] = mem[idx + _2645 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_2699 + 94] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _2699 + -mem[64] + 100
                                            if (0 / 10000 * poolInfo[idx].field_1280) + poolInfo[idx].field_256 < poolInfo[idx].field_256:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_256 += 0 / 10000 * poolInfo[idx].field_1280
                                            if poolInfo[idx].field_992:
                                                if poolInfo[idx].field_1024:
                                                    if not poolInfo[idx].field_1024:
                                                        if not 0 / totalAllocPoint:
                                                            _3280 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_3280] = 26
                                                            mem[_3280 + 32] = 'SafeMath: division by zero'
                                                            _3376 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _3376 + 68] = mem[idx + _3280 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_3376 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _3376 + -mem[64] + 100
                                                        if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if not stor159 * 0 / totalAllocPoint:
                                                            _3375 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_3375] = 26
                                                            mem[_3375 + 32] = 'SafeMath: division by zero'
                                                            _3507 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _3507 + 68] = mem[idx + _3375 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_3507 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _3507 + -mem[64] + 100
                                                        if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _3506 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3506] = 26
                                                        mem[_3506 + 32] = 'SafeMath: division by zero'
                                                        _3656 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        s = 0
                                                        while s < 26:
                                                            mem[s + _3656 + 68] = mem[s + _3506 + 32]
                                                            s = s + 32
                                                            continue 
                                                        mem[_3656 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _3656 + -mem[64] + 100
                                                    if 10000 * poolInfo[idx].field_1024 / poolInfo[idx].field_1024 != 10000:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not 0 / totalAllocPoint:
                                                        _3374 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3374] = 26
                                                        mem[_3374 + 32] = 'SafeMath: division by zero'
                                                        if not 10000 * poolInfo[idx].field_1024:
                                                            _3505 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _3505 + 68] = mem[idx + _3374 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_3505 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _3505 + -mem[64] + 100
                                                        if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                    else:
                                                        if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if not stor159 * 0 / totalAllocPoint:
                                                            _3504 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_3504] = 26
                                                            mem[_3504 + 32] = 'SafeMath: division by zero'
                                                            if not 10000 * poolInfo[idx].field_1024:
                                                                _3654 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                s = 0
                                                                while s < 26:
                                                                    mem[s + _3654 + 68] = mem[s + _3504 + 32]
                                                                    s = s + 32
                                                                    continue 
                                                                mem[_3654 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _3654 + -mem[64] + 100
                                                            if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                        else:
                                                            if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            _3653 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_3653] = 26
                                                            mem[_3653 + 32] = 'SafeMath: division by zero'
                                                            if not 10000 * poolInfo[idx].field_1024:
                                                                _3796 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _3796 + 68] = mem[idx + _3653 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_3796 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _3796 + -mem[64] + 100
                                                            if (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_512 += poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024
                                        else:
                                            if (10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint) / stor159 * 0 / totalAllocPoint != -poolInfo[idx].field_992 + 10000:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _2698 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2698] = 26
                                            mem[_2698 + 32] = 'SafeMath: division by zero'
                                            if not 10000 * poolInfo[idx].field_1280:
                                                _2747 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _2747 + 68] = mem[idx + _2698 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_2747 + 94] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _2747 + -mem[64] + 100
                                            if ((10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint) / 10000 * poolInfo[idx].field_1280) + poolInfo[idx].field_256 < poolInfo[idx].field_256:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_256 += (10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint) / 10000 * poolInfo[idx].field_1280
                                            if poolInfo[idx].field_992:
                                                if poolInfo[idx].field_1024:
                                                    if not poolInfo[idx].field_1024:
                                                        if not 0 / totalAllocPoint:
                                                            _3373 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_3373] = 26
                                                            mem[_3373 + 32] = 'SafeMath: division by zero'
                                                            _3503 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _3503 + 68] = mem[idx + _3373 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_3503 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _3503 + -mem[64] + 100
                                                        if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if not stor159 * 0 / totalAllocPoint:
                                                            _3502 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_3502] = 26
                                                            mem[_3502 + 32] = 'SafeMath: division by zero'
                                                            _3651 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            s = 0
                                                            while s < 26:
                                                                mem[s + _3651 + 68] = mem[s + _3502 + 32]
                                                                s = s + 32
                                                                continue 
                                                            mem[_3651 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _3651 + -mem[64] + 100
                                                        if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _3650 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3650] = 26
                                                        mem[_3650 + 32] = 'SafeMath: division by zero'
                                                        _3794 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _3794 + 68] = mem[idx + _3650 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_3794 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _3794 + -mem[64] + 100
                                                    if 10000 * poolInfo[idx].field_1024 / poolInfo[idx].field_1024 != 10000:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not 0 / totalAllocPoint:
                                                        _3501 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3501] = 26
                                                        mem[_3501 + 32] = 'SafeMath: division by zero'
                                                        if not 10000 * poolInfo[idx].field_1024:
                                                            _3649 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            s = 0
                                                            while s < 26:
                                                                mem[s + _3649 + 68] = mem[s + _3501 + 32]
                                                                s = s + 32
                                                                continue 
                                                            mem[_3649 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _3649 + -mem[64] + 100
                                                        if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                    else:
                                                        if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if not stor159 * 0 / totalAllocPoint:
                                                            _3648 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_3648] = 26
                                                            mem[_3648 + 32] = 'SafeMath: division by zero'
                                                            if not 10000 * poolInfo[idx].field_1024:
                                                                _3792 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _3792 + 68] = mem[idx + _3648 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_3792 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _3792 + -mem[64] + 100
                                                            if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                        else:
                                                            if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            _3791 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_3791] = 26
                                                            mem[_3791 + 32] = 'SafeMath: division by zero'
                                                            if not 10000 * poolInfo[idx].field_1024:
                                                                _3924 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _3924 + 68] = mem[idx + _3791 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_3924 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _3924 + -mem[64] + 100
                                                            if (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_512 += poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024
                                else:
                                    if (block.timestamp * 0 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2405 * poolInfo[idx].field_160) / (block.timestamp * 0 / _2405) - (poolInfo[idx].field_768 * 0 / _2405) != poolInfo[idx].field_160:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _2466 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_2466] = 26
                                    mem[_2466 + 32] = 'SafeMath: division by zero'
                                    if not totalAllocPoint:
                                        _2476 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _2476 + 68] = mem[idx + _2466 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_2476 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _2476 + -mem[64] + 100
                                    if not poolInfo[idx].field_1280:
                                        if not (block.timestamp * 0 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2405 * poolInfo[idx].field_160) / totalAllocPoint:
                                            _2599 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2599] = 26
                                            mem[_2599 + 32] = 'SafeMath: division by zero'
                                            _2644 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _2644 + 68] = mem[idx + _2599 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_2644 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _2644 + -mem[64] + 100
                                        if stor159 * (block.timestamp * 0 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2405 * poolInfo[idx].field_160) / totalAllocPoint / (block.timestamp * 0 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2405 * poolInfo[idx].field_160) / totalAllocPoint != stor159:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not stor159 * (block.timestamp * 0 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2405 * poolInfo[idx].field_160) / totalAllocPoint:
                                            _2643 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2643] = 26
                                            mem[_2643 + 32] = 'SafeMath: division by zero'
                                            _2696 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _2696 + 68] = mem[idx + _2643 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_2696 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _2696 + -mem[64] + 100
                                        if (10000 * stor159 * (block.timestamp * 0 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2405 * poolInfo[idx].field_160) / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2405 * poolInfo[idx].field_160) / totalAllocPoint) / stor159 * (block.timestamp * 0 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2405 * poolInfo[idx].field_160) / totalAllocPoint != -poolInfo[idx].field_992 + 10000:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _2695 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2695] = 26
                                        mem[_2695 + 32] = 'SafeMath: division by zero'
                                        _2745 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _2745 + 68] = mem[idx + _2695 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_2745 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _2745 + -mem[64] + 100
                                    if 10000 * poolInfo[idx].field_1280 / poolInfo[idx].field_1280 != 10000:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not (block.timestamp * 0 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2405 * poolInfo[idx].field_160) / totalAllocPoint:
                                        _2642 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2642] = 26
                                        mem[_2642 + 32] = 'SafeMath: division by zero'
                                        if not 10000 * poolInfo[idx].field_1280:
                                            _2694 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _2694 + 68] = mem[idx + _2642 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_2694 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _2694 + -mem[64] + 100
                                        if (0 / 10000 * poolInfo[idx].field_1280) + poolInfo[idx].field_256 < poolInfo[idx].field_256:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_256 += 0 / 10000 * poolInfo[idx].field_1280
                                        if poolInfo[idx].field_992:
                                            if poolInfo[idx].field_1024:
                                                if not poolInfo[idx].field_1024:
                                                    if not (block.timestamp * 0 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2405 * poolInfo[idx].field_160) / totalAllocPoint:
                                                        _3279 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3279] = 26
                                                        mem[_3279 + 32] = 'SafeMath: division by zero'
                                                        _3372 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _3372 + 68] = mem[idx + _3279 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_3372 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _3372 + -mem[64] + 100
                                                    if stor159 * (block.timestamp * 0 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2405 * poolInfo[idx].field_160) / totalAllocPoint / (block.timestamp * 0 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2405 * poolInfo[idx].field_160) / totalAllocPoint != stor159:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not stor159 * (block.timestamp * 0 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2405 * poolInfo[idx].field_160) / totalAllocPoint:
                                                        _3371 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3371] = 26
                                                        mem[_3371 + 32] = 'SafeMath: division by zero'
                                                        _3499 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _3499 + 68] = mem[idx + _3371 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_3499 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _3499 + -mem[64] + 100
                                                    if poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2405 * poolInfo[idx].field_160) / totalAllocPoint / stor159 * (block.timestamp * 0 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2405 * poolInfo[idx].field_160) / totalAllocPoint != poolInfo[idx].field_992:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    _3498 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_3498] = 26
                                                    mem[_3498 + 32] = 'SafeMath: division by zero'
                                                    _3646 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    s = 0
                                                    while s < 26:
                                                        mem[s + _3646 + 68] = mem[s + _3498 + 32]
                                                        s = s + 32
                                                        continue 
                                                    mem[_3646 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _3646 + -mem[64] + 100
                                                if 10000 * poolInfo[idx].field_1024 / poolInfo[idx].field_1024 != 10000:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not (block.timestamp * 0 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2405 * poolInfo[idx].field_160) / totalAllocPoint:
                                                    _3370 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_3370] = 26
                                                    mem[_3370 + 32] = 'SafeMath: division by zero'
                                                    if not 10000 * poolInfo[idx].field_1024:
                                                        _3497 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _3497 + 68] = mem[idx + _3370 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_3497 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _3497 + -mem[64] + 100
                                                    if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                else:
                                                    if stor159 * (block.timestamp * 0 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2405 * poolInfo[idx].field_160) / totalAllocPoint / (block.timestamp * 0 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2405 * poolInfo[idx].field_160) / totalAllocPoint != stor159:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not stor159 * (block.timestamp * 0 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2405 * poolInfo[idx].field_160) / totalAllocPoint:
                                                        _3496 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3496] = 26
                                                        mem[_3496 + 32] = 'SafeMath: division by zero'
                                                        if not 10000 * poolInfo[idx].field_1024:
                                                            _3644 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            s = 0
                                                            while s < 26:
                                                                mem[s + _3644 + 68] = mem[s + _3496 + 32]
                                                                s = s + 32
                                                                continue 
                                                            mem[_3644 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _3644 + -mem[64] + 100
                                                        if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                    else:
                                                        if poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2405 * poolInfo[idx].field_160) / totalAllocPoint / stor159 * (block.timestamp * 0 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2405 * poolInfo[idx].field_160) / totalAllocPoint != poolInfo[idx].field_992:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _3643 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3643] = 26
                                                        mem[_3643 + 32] = 'SafeMath: division by zero'
                                                        if not 10000 * poolInfo[idx].field_1024:
                                                            _3788 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _3788 + 68] = mem[idx + _3643 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_3788 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _3788 + -mem[64] + 100
                                                        if (poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2405 * poolInfo[idx].field_160) / totalAllocPoint / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_512 += poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2405 * poolInfo[idx].field_160) / totalAllocPoint / 10000 * poolInfo[idx].field_1024
                                    else:
                                        if stor159 * (block.timestamp * 0 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2405 * poolInfo[idx].field_160) / totalAllocPoint / (block.timestamp * 0 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2405 * poolInfo[idx].field_160) / totalAllocPoint != stor159:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not stor159 * (block.timestamp * 0 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2405 * poolInfo[idx].field_160) / totalAllocPoint:
                                            _2693 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2693] = 26
                                            mem[_2693 + 32] = 'SafeMath: division by zero'
                                            if not 10000 * poolInfo[idx].field_1280:
                                                _2743 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _2743 + 68] = mem[idx + _2693 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_2743 + 94] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _2743 + -mem[64] + 100
                                            if (0 / 10000 * poolInfo[idx].field_1280) + poolInfo[idx].field_256 < poolInfo[idx].field_256:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_256 += 0 / 10000 * poolInfo[idx].field_1280
                                            if poolInfo[idx].field_992:
                                                if poolInfo[idx].field_1024:
                                                    if not poolInfo[idx].field_1024:
                                                        if not (block.timestamp * 0 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2405 * poolInfo[idx].field_160) / totalAllocPoint:
                                                            _3369 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_3369] = 26
                                                            mem[_3369 + 32] = 'SafeMath: division by zero'
                                                            _3495 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _3495 + 68] = mem[idx + _3369 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_3495 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _3495 + -mem[64] + 100
                                                        if stor159 * (block.timestamp * 0 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2405 * poolInfo[idx].field_160) / totalAllocPoint / (block.timestamp * 0 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2405 * poolInfo[idx].field_160) / totalAllocPoint != stor159:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if not stor159 * (block.timestamp * 0 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2405 * poolInfo[idx].field_160) / totalAllocPoint:
                                                            _3494 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_3494] = 26
                                                            mem[_3494 + 32] = 'SafeMath: division by zero'
                                                            _3641 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            s = 0
                                                            while s < 26:
                                                                mem[s + _3641 + 68] = mem[s + _3494 + 32]
                                                                s = s + 32
                                                                continue 
                                                            mem[_3641 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _3641 + -mem[64] + 100
                                                        if poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2405 * poolInfo[idx].field_160) / totalAllocPoint / stor159 * (block.timestamp * 0 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2405 * poolInfo[idx].field_160) / totalAllocPoint != poolInfo[idx].field_992:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _3640 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3640] = 26
                                                        mem[_3640 + 32] = 'SafeMath: division by zero'
                                                        _3786 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _3786 + 68] = mem[idx + _3640 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_3786 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _3786 + -mem[64] + 100
                                                    if 10000 * poolInfo[idx].field_1024 / poolInfo[idx].field_1024 != 10000:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not (block.timestamp * 0 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2405 * poolInfo[idx].field_160) / totalAllocPoint:
                                                        _3493 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3493] = 26
                                                        mem[_3493 + 32] = 'SafeMath: division by zero'
                                                        if not 10000 * poolInfo[idx].field_1024:
                                                            _3639 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            s = 0
                                                            while s < 26:
                                                                mem[s + _3639 + 68] = mem[s + _3493 + 32]
                                                                s = s + 32
                                                                continue 
                                                            mem[_3639 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _3639 + -mem[64] + 100
                                                        if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                    else:
                                                        if stor159 * (block.timestamp * 0 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2405 * poolInfo[idx].field_160) / totalAllocPoint / (block.timestamp * 0 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2405 * poolInfo[idx].field_160) / totalAllocPoint != stor159:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if not stor159 * (block.timestamp * 0 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2405 * poolInfo[idx].field_160) / totalAllocPoint:
                                                            _3638 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_3638] = 26
                                                            mem[_3638 + 32] = 'SafeMath: division by zero'
                                                            if not 10000 * poolInfo[idx].field_1024:
                                                                _3784 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _3784 + 68] = mem[idx + _3638 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_3784 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _3784 + -mem[64] + 100
                                                            if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                        else:
                                                            if poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2405 * poolInfo[idx].field_160) / totalAllocPoint / stor159 * (block.timestamp * 0 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2405 * poolInfo[idx].field_160) / totalAllocPoint != poolInfo[idx].field_992:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            _3783 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_3783] = 26
                                                            mem[_3783 + 32] = 'SafeMath: division by zero'
                                                            if not 10000 * poolInfo[idx].field_1024:
                                                                _3919 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _3919 + 68] = mem[idx + _3783 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_3919 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _3919 + -mem[64] + 100
                                                            if (poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2405 * poolInfo[idx].field_160) / totalAllocPoint / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_512 += poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2405 * poolInfo[idx].field_160) / totalAllocPoint / 10000 * poolInfo[idx].field_1024
                                        else:
                                            if (10000 * stor159 * (block.timestamp * 0 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2405 * poolInfo[idx].field_160) / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2405 * poolInfo[idx].field_160) / totalAllocPoint) / stor159 * (block.timestamp * 0 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2405 * poolInfo[idx].field_160) / totalAllocPoint != -poolInfo[idx].field_992 + 10000:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _2742 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2742] = 26
                                            mem[_2742 + 32] = 'SafeMath: division by zero'
                                            if not 10000 * poolInfo[idx].field_1280:
                                                _2785 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _2785 + 68] = mem[idx + _2742 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_2785 + 94] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _2785 + -mem[64] + 100
                                            if ((10000 * stor159 * (block.timestamp * 0 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2405 * poolInfo[idx].field_160) / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2405 * poolInfo[idx].field_160) / totalAllocPoint) / 10000 * poolInfo[idx].field_1280) + poolInfo[idx].field_256 < poolInfo[idx].field_256:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_256 += (10000 * stor159 * (block.timestamp * 0 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2405 * poolInfo[idx].field_160) / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2405 * poolInfo[idx].field_160) / totalAllocPoint) / 10000 * poolInfo[idx].field_1280
                                            if poolInfo[idx].field_992:
                                                if poolInfo[idx].field_1024:
                                                    if not poolInfo[idx].field_1024:
                                                        if not (block.timestamp * 0 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2405 * poolInfo[idx].field_160) / totalAllocPoint:
                                                            _3492 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_3492] = 26
                                                            mem[_3492 + 32] = 'SafeMath: division by zero'
                                                            _3637 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            s = 0
                                                            while s < 26:
                                                                mem[s + _3637 + 68] = mem[s + _3492 + 32]
                                                                s = s + 32
                                                                continue 
                                                            mem[_3637 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _3637 + -mem[64] + 100
                                                        if stor159 * (block.timestamp * 0 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2405 * poolInfo[idx].field_160) / totalAllocPoint / (block.timestamp * 0 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2405 * poolInfo[idx].field_160) / totalAllocPoint != stor159:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if not stor159 * (block.timestamp * 0 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2405 * poolInfo[idx].field_160) / totalAllocPoint:
                                                            _3636 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_3636] = 26
                                                            mem[_3636 + 32] = 'SafeMath: division by zero'
                                                            _3781 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _3781 + 68] = mem[idx + _3636 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_3781 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _3781 + -mem[64] + 100
                                                        if poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2405 * poolInfo[idx].field_160) / totalAllocPoint / stor159 * (block.timestamp * 0 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2405 * poolInfo[idx].field_160) / totalAllocPoint != poolInfo[idx].field_992:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _3780 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3780] = 26
                                                        mem[_3780 + 32] = 'SafeMath: division by zero'
                                                        _3917 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _3917 + 68] = mem[idx + _3780 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_3917 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _3917 + -mem[64] + 100
                                                    if 10000 * poolInfo[idx].field_1024 / poolInfo[idx].field_1024 != 10000:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not (block.timestamp * 0 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2405 * poolInfo[idx].field_160) / totalAllocPoint:
                                                        _3635 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3635] = 26
                                                        mem[_3635 + 32] = 'SafeMath: division by zero'
                                                        if not 10000 * poolInfo[idx].field_1024:
                                                            _3779 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _3779 + 68] = mem[idx + _3635 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_3779 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _3779 + -mem[64] + 100
                                                        if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                    else:
                                                        if stor159 * (block.timestamp * 0 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2405 * poolInfo[idx].field_160) / totalAllocPoint / (block.timestamp * 0 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2405 * poolInfo[idx].field_160) / totalAllocPoint != stor159:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if not stor159 * (block.timestamp * 0 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2405 * poolInfo[idx].field_160) / totalAllocPoint:
                                                            _3778 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_3778] = 26
                                                            mem[_3778 + 32] = 'SafeMath: division by zero'
                                                            if not 10000 * poolInfo[idx].field_1024:
                                                                _3915 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _3915 + 68] = mem[idx + _3778 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_3915 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _3915 + -mem[64] + 100
                                                            if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                        else:
                                                            if poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2405 * poolInfo[idx].field_160) / totalAllocPoint / stor159 * (block.timestamp * 0 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2405 * poolInfo[idx].field_160) / totalAllocPoint != poolInfo[idx].field_992:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            _3914 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_3914] = 26
                                                            mem[_3914 + 32] = 'SafeMath: division by zero'
                                                            if not 10000 * poolInfo[idx].field_1024:
                                                                _4054 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _4054 + 68] = mem[idx + _3914 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_4054 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _4054 + -mem[64] + 100
                                                            if (poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2405 * poolInfo[idx].field_160) / totalAllocPoint / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_512 += poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _2405 * poolInfo[idx].field_160) / totalAllocPoint / 10000 * poolInfo[idx].field_1024
                        else:
                            if mem[_2412 + 32] * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 != mem[_2412 + 32]:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _2428 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2428] = 26
                            mem[_2428 + 32] = 'SafeMath: division by zero'
                            if not _2405:
                                _2431 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _2431 + 68] = mem[idx + _2428 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2431 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _2431 + -mem[64] + 100
                            if not block.timestamp - poolInfo[idx].field_768:
                                _2456 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2456] = 26
                                mem[_2456 + 32] = 'SafeMath: division by zero'
                                if not totalAllocPoint:
                                    _2465 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _2465 + 68] = mem[idx + _2456 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2465 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2465 + -mem[64] + 100
                                if not poolInfo[idx].field_1280:
                                    if not 0 / totalAllocPoint:
                                        _2569 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2569] = 26
                                        mem[_2569 + 32] = 'SafeMath: division by zero'
                                        _2598 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _2598 + 68] = mem[idx + _2569 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_2598 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _2598 + -mem[64] + 100
                                    if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not stor159 * 0 / totalAllocPoint:
                                        _2597 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2597] = 26
                                        mem[_2597 + 32] = 'SafeMath: division by zero'
                                        _2640 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _2640 + 68] = mem[idx + _2597 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_2640 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _2640 + -mem[64] + 100
                                    if (10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint) / stor159 * 0 / totalAllocPoint != -poolInfo[idx].field_992 + 10000:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _2639 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_2639] = 26
                                    mem[_2639 + 32] = 'SafeMath: division by zero'
                                    _2691 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _2691 + 68] = mem[idx + _2639 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2691 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2691 + -mem[64] + 100
                                if 10000 * poolInfo[idx].field_1280 / poolInfo[idx].field_1280 != 10000:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 0 / totalAllocPoint:
                                    _2596 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_2596] = 26
                                    mem[_2596 + 32] = 'SafeMath: division by zero'
                                    if not 10000 * poolInfo[idx].field_1280:
                                        _2638 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _2638 + 68] = mem[idx + _2596 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_2638 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _2638 + -mem[64] + 100
                                    if (0 / 10000 * poolInfo[idx].field_1280) + poolInfo[idx].field_256 < poolInfo[idx].field_256:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_256 += 0 / 10000 * poolInfo[idx].field_1280
                                    if poolInfo[idx].field_992:
                                        if poolInfo[idx].field_1024:
                                            if not poolInfo[idx].field_1024:
                                                if not 0 / totalAllocPoint:
                                                    _3218 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_3218] = 26
                                                    mem[_3218 + 32] = 'SafeMath: division by zero'
                                                    _3278 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _3278 + 68] = mem[idx + _3218 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_3278 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _3278 + -mem[64] + 100
                                                if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not stor159 * 0 / totalAllocPoint:
                                                    _3277 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_3277] = 26
                                                    mem[_3277 + 32] = 'SafeMath: division by zero'
                                                    _3367 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _3367 + 68] = mem[idx + _3277 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_3367 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _3367 + -mem[64] + 100
                                                if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _3366 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_3366] = 26
                                                mem[_3366 + 32] = 'SafeMath: division by zero'
                                                _3490 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _3490 + 68] = mem[idx + _3366 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_3490 + 94] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _3490 + -mem[64] + 100
                                            if 10000 * poolInfo[idx].field_1024 / poolInfo[idx].field_1024 != 10000:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if not 0 / totalAllocPoint:
                                                _3276 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_3276] = 26
                                                mem[_3276 + 32] = 'SafeMath: division by zero'
                                                if not 10000 * poolInfo[idx].field_1024:
                                                    _3365 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _3365 + 68] = mem[idx + _3276 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_3365 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _3365 + -mem[64] + 100
                                                if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                            else:
                                                if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not stor159 * 0 / totalAllocPoint:
                                                    _3364 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_3364] = 26
                                                    mem[_3364 + 32] = 'SafeMath: division by zero'
                                                    if not 10000 * poolInfo[idx].field_1024:
                                                        _3488 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _3488 + 68] = mem[idx + _3364 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_3488 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _3488 + -mem[64] + 100
                                                    if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                else:
                                                    if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    _3487 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_3487] = 26
                                                    mem[_3487 + 32] = 'SafeMath: division by zero'
                                                    if not 10000 * poolInfo[idx].field_1024:
                                                        _3632 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        s = 0
                                                        while s < 26:
                                                            mem[s + _3632 + 68] = mem[s + _3487 + 32]
                                                            s = s + 32
                                                            continue 
                                                        mem[_3632 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _3632 + -mem[64] + 100
                                                    if (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_512 += poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024
                                else:
                                    if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not stor159 * 0 / totalAllocPoint:
                                        _2637 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2637] = 26
                                        mem[_2637 + 32] = 'SafeMath: division by zero'
                                        if not 10000 * poolInfo[idx].field_1280:
                                            _2689 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _2689 + 68] = mem[idx + _2637 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_2689 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _2689 + -mem[64] + 100
                                        if (0 / 10000 * poolInfo[idx].field_1280) + poolInfo[idx].field_256 < poolInfo[idx].field_256:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_256 += 0 / 10000 * poolInfo[idx].field_1280
                                        if poolInfo[idx].field_992:
                                            if poolInfo[idx].field_1024:
                                                if not poolInfo[idx].field_1024:
                                                    if not 0 / totalAllocPoint:
                                                        _3275 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3275] = 26
                                                        mem[_3275 + 32] = 'SafeMath: division by zero'
                                                        _3363 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _3363 + 68] = mem[idx + _3275 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_3363 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _3363 + -mem[64] + 100
                                                    if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not stor159 * 0 / totalAllocPoint:
                                                        _3362 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3362] = 26
                                                        mem[_3362 + 32] = 'SafeMath: division by zero'
                                                        _3485 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _3485 + 68] = mem[idx + _3362 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_3485 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _3485 + -mem[64] + 100
                                                    if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    _3484 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_3484] = 26
                                                    mem[_3484 + 32] = 'SafeMath: division by zero'
                                                    _3630 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    s = 0
                                                    while s < 26:
                                                        mem[s + _3630 + 68] = mem[s + _3484 + 32]
                                                        s = s + 32
                                                        continue 
                                                    mem[_3630 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _3630 + -mem[64] + 100
                                                if 10000 * poolInfo[idx].field_1024 / poolInfo[idx].field_1024 != 10000:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not 0 / totalAllocPoint:
                                                    _3361 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_3361] = 26
                                                    mem[_3361 + 32] = 'SafeMath: division by zero'
                                                    if not 10000 * poolInfo[idx].field_1024:
                                                        _3483 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _3483 + 68] = mem[idx + _3361 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_3483 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _3483 + -mem[64] + 100
                                                    if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                else:
                                                    if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not stor159 * 0 / totalAllocPoint:
                                                        _3482 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3482] = 26
                                                        mem[_3482 + 32] = 'SafeMath: division by zero'
                                                        if not 10000 * poolInfo[idx].field_1024:
                                                            _3628 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            s = 0
                                                            while s < 26:
                                                                mem[s + _3628 + 68] = mem[s + _3482 + 32]
                                                                s = s + 32
                                                                continue 
                                                            mem[_3628 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _3628 + -mem[64] + 100
                                                        if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                    else:
                                                        if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _3627 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3627] = 26
                                                        mem[_3627 + 32] = 'SafeMath: division by zero'
                                                        if not 10000 * poolInfo[idx].field_1024:
                                                            _3773 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _3773 + 68] = mem[idx + _3627 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_3773 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _3773 + -mem[64] + 100
                                                        if (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_512 += poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024
                                    else:
                                        if (10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint) / stor159 * 0 / totalAllocPoint != -poolInfo[idx].field_992 + 10000:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _2688 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2688] = 26
                                        mem[_2688 + 32] = 'SafeMath: division by zero'
                                        if not 10000 * poolInfo[idx].field_1280:
                                            _2739 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _2739 + 68] = mem[idx + _2688 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_2739 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _2739 + -mem[64] + 100
                                        if ((10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint) / 10000 * poolInfo[idx].field_1280) + poolInfo[idx].field_256 < poolInfo[idx].field_256:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_256 += (10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint) / 10000 * poolInfo[idx].field_1280
                                        if poolInfo[idx].field_992:
                                            if poolInfo[idx].field_1024:
                                                if not poolInfo[idx].field_1024:
                                                    if not 0 / totalAllocPoint:
                                                        _3360 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3360] = 26
                                                        mem[_3360 + 32] = 'SafeMath: division by zero'
                                                        _3481 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _3481 + 68] = mem[idx + _3360 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_3481 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _3481 + -mem[64] + 100
                                                    if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not stor159 * 0 / totalAllocPoint:
                                                        _3480 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3480] = 26
                                                        mem[_3480 + 32] = 'SafeMath: division by zero'
                                                        _3625 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        s = 0
                                                        while s < 26:
                                                            mem[s + _3625 + 68] = mem[s + _3480 + 32]
                                                            s = s + 32
                                                            continue 
                                                        mem[_3625 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _3625 + -mem[64] + 100
                                                    if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    _3624 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_3624] = 26
                                                    mem[_3624 + 32] = 'SafeMath: division by zero'
                                                    _3771 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _3771 + 68] = mem[idx + _3624 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_3771 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _3771 + -mem[64] + 100
                                                if 10000 * poolInfo[idx].field_1024 / poolInfo[idx].field_1024 != 10000:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not 0 / totalAllocPoint:
                                                    _3479 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_3479] = 26
                                                    mem[_3479 + 32] = 'SafeMath: division by zero'
                                                    if not 10000 * poolInfo[idx].field_1024:
                                                        _3623 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        s = 0
                                                        while s < 26:
                                                            mem[s + _3623 + 68] = mem[s + _3479 + 32]
                                                            s = s + 32
                                                            continue 
                                                        mem[_3623 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _3623 + -mem[64] + 100
                                                    if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                else:
                                                    if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not stor159 * 0 / totalAllocPoint:
                                                        _3622 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3622] = 26
                                                        mem[_3622 + 32] = 'SafeMath: division by zero'
                                                        if not 10000 * poolInfo[idx].field_1024:
                                                            _3769 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _3769 + 68] = mem[idx + _3622 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_3769 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _3769 + -mem[64] + 100
                                                        if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                    else:
                                                        if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _3768 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3768] = 26
                                                        mem[_3768 + 32] = 'SafeMath: division by zero'
                                                        if not 10000 * poolInfo[idx].field_1024:
                                                            _3905 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _3905 + 68] = mem[idx + _3768 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_3905 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _3905 + -mem[64] + 100
                                                        if (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_512 += poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024
                            else:
                                if (block.timestamp * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405) - (poolInfo[idx].field_768 * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405) / block.timestamp - poolInfo[idx].field_768 != _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not (block.timestamp * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405) - (poolInfo[idx].field_768 * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405):
                                    _2464 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_2464] = 26
                                    mem[_2464 + 32] = 'SafeMath: division by zero'
                                    if not totalAllocPoint:
                                        _2474 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _2474 + 68] = mem[idx + _2464 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_2474 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _2474 + -mem[64] + 100
                                    if not poolInfo[idx].field_1280:
                                        if not 0 / totalAllocPoint:
                                            _2595 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2595] = 26
                                            mem[_2595 + 32] = 'SafeMath: division by zero'
                                            _2636 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _2636 + 68] = mem[idx + _2595 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_2636 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _2636 + -mem[64] + 100
                                        if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not stor159 * 0 / totalAllocPoint:
                                            _2635 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2635] = 26
                                            mem[_2635 + 32] = 'SafeMath: division by zero'
                                            _2686 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _2686 + 68] = mem[idx + _2635 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_2686 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _2686 + -mem[64] + 100
                                        if (10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint) / stor159 * 0 / totalAllocPoint != -poolInfo[idx].field_992 + 10000:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _2685 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2685] = 26
                                        mem[_2685 + 32] = 'SafeMath: division by zero'
                                        _2737 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _2737 + 68] = mem[idx + _2685 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_2737 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _2737 + -mem[64] + 100
                                    if 10000 * poolInfo[idx].field_1280 / poolInfo[idx].field_1280 != 10000:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not 0 / totalAllocPoint:
                                        _2634 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2634] = 26
                                        mem[_2634 + 32] = 'SafeMath: division by zero'
                                        if not 10000 * poolInfo[idx].field_1280:
                                            _2684 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _2684 + 68] = mem[idx + _2634 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_2684 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _2684 + -mem[64] + 100
                                        if (0 / 10000 * poolInfo[idx].field_1280) + poolInfo[idx].field_256 < poolInfo[idx].field_256:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_256 += 0 / 10000 * poolInfo[idx].field_1280
                                        if poolInfo[idx].field_992:
                                            if poolInfo[idx].field_1024:
                                                if not poolInfo[idx].field_1024:
                                                    if not 0 / totalAllocPoint:
                                                        _3274 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3274] = 26
                                                        mem[_3274 + 32] = 'SafeMath: division by zero'
                                                        _3359 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _3359 + 68] = mem[idx + _3274 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_3359 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _3359 + -mem[64] + 100
                                                    if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not stor159 * 0 / totalAllocPoint:
                                                        _3358 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3358] = 26
                                                        mem[_3358 + 32] = 'SafeMath: division by zero'
                                                        _3477 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _3477 + 68] = mem[idx + _3358 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_3477 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _3477 + -mem[64] + 100
                                                    if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    _3476 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_3476] = 26
                                                    mem[_3476 + 32] = 'SafeMath: division by zero'
                                                    _3620 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    s = 0
                                                    while s < 26:
                                                        mem[s + _3620 + 68] = mem[s + _3476 + 32]
                                                        s = s + 32
                                                        continue 
                                                    mem[_3620 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _3620 + -mem[64] + 100
                                                if 10000 * poolInfo[idx].field_1024 / poolInfo[idx].field_1024 != 10000:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not 0 / totalAllocPoint:
                                                    _3357 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_3357] = 26
                                                    mem[_3357 + 32] = 'SafeMath: division by zero'
                                                    if not 10000 * poolInfo[idx].field_1024:
                                                        _3475 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _3475 + 68] = mem[idx + _3357 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_3475 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _3475 + -mem[64] + 100
                                                    if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                else:
                                                    if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not stor159 * 0 / totalAllocPoint:
                                                        _3474 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3474] = 26
                                                        mem[_3474 + 32] = 'SafeMath: division by zero'
                                                        if not 10000 * poolInfo[idx].field_1024:
                                                            _3618 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            s = 0
                                                            while s < 26:
                                                                mem[s + _3618 + 68] = mem[s + _3474 + 32]
                                                                s = s + 32
                                                                continue 
                                                            mem[_3618 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _3618 + -mem[64] + 100
                                                        if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                    else:
                                                        if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _3617 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3617] = 26
                                                        mem[_3617 + 32] = 'SafeMath: division by zero'
                                                        if not 10000 * poolInfo[idx].field_1024:
                                                            _3765 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _3765 + 68] = mem[idx + _3617 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_3765 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _3765 + -mem[64] + 100
                                                        if (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_512 += poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024
                                    else:
                                        if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not stor159 * 0 / totalAllocPoint:
                                            _2683 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2683] = 26
                                            mem[_2683 + 32] = 'SafeMath: division by zero'
                                            if not 10000 * poolInfo[idx].field_1280:
                                                _2735 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _2735 + 68] = mem[idx + _2683 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_2735 + 94] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _2735 + -mem[64] + 100
                                            if (0 / 10000 * poolInfo[idx].field_1280) + poolInfo[idx].field_256 < poolInfo[idx].field_256:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_256 += 0 / 10000 * poolInfo[idx].field_1280
                                            if poolInfo[idx].field_992:
                                                if poolInfo[idx].field_1024:
                                                    if not poolInfo[idx].field_1024:
                                                        if not 0 / totalAllocPoint:
                                                            _3356 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_3356] = 26
                                                            mem[_3356 + 32] = 'SafeMath: division by zero'
                                                            _3473 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _3473 + 68] = mem[idx + _3356 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_3473 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _3473 + -mem[64] + 100
                                                        if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if not stor159 * 0 / totalAllocPoint:
                                                            _3472 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_3472] = 26
                                                            mem[_3472 + 32] = 'SafeMath: division by zero'
                                                            _3615 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            s = 0
                                                            while s < 26:
                                                                mem[s + _3615 + 68] = mem[s + _3472 + 32]
                                                                s = s + 32
                                                                continue 
                                                            mem[_3615 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _3615 + -mem[64] + 100
                                                        if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _3614 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3614] = 26
                                                        mem[_3614 + 32] = 'SafeMath: division by zero'
                                                        _3763 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _3763 + 68] = mem[idx + _3614 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_3763 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _3763 + -mem[64] + 100
                                                    if 10000 * poolInfo[idx].field_1024 / poolInfo[idx].field_1024 != 10000:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not 0 / totalAllocPoint:
                                                        _3471 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3471] = 26
                                                        mem[_3471 + 32] = 'SafeMath: division by zero'
                                                        if not 10000 * poolInfo[idx].field_1024:
                                                            _3613 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            s = 0
                                                            while s < 26:
                                                                mem[s + _3613 + 68] = mem[s + _3471 + 32]
                                                                s = s + 32
                                                                continue 
                                                            mem[_3613 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _3613 + -mem[64] + 100
                                                        if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                    else:
                                                        if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if not stor159 * 0 / totalAllocPoint:
                                                            _3612 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_3612] = 26
                                                            mem[_3612 + 32] = 'SafeMath: division by zero'
                                                            if not 10000 * poolInfo[idx].field_1024:
                                                                _3761 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _3761 + 68] = mem[idx + _3612 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_3761 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _3761 + -mem[64] + 100
                                                            if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                        else:
                                                            if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            _3760 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_3760] = 26
                                                            mem[_3760 + 32] = 'SafeMath: division by zero'
                                                            if not 10000 * poolInfo[idx].field_1024:
                                                                _3900 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _3900 + 68] = mem[idx + _3760 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_3900 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _3900 + -mem[64] + 100
                                                            if (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_512 += poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024
                                        else:
                                            if (10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint) / stor159 * 0 / totalAllocPoint != -poolInfo[idx].field_992 + 10000:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _2734 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2734] = 26
                                            mem[_2734 + 32] = 'SafeMath: division by zero'
                                            if not 10000 * poolInfo[idx].field_1280:
                                                _2780 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _2780 + 68] = mem[idx + _2734 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_2780 + 94] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _2780 + -mem[64] + 100
                                            if ((10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint) / 10000 * poolInfo[idx].field_1280) + poolInfo[idx].field_256 < poolInfo[idx].field_256:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_256 += (10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint) / 10000 * poolInfo[idx].field_1280
                                            if poolInfo[idx].field_992:
                                                if poolInfo[idx].field_1024:
                                                    if not poolInfo[idx].field_1024:
                                                        if not 0 / totalAllocPoint:
                                                            _3470 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_3470] = 26
                                                            mem[_3470 + 32] = 'SafeMath: division by zero'
                                                            _3611 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            s = 0
                                                            while s < 26:
                                                                mem[s + _3611 + 68] = mem[s + _3470 + 32]
                                                                s = s + 32
                                                                continue 
                                                            mem[_3611 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _3611 + -mem[64] + 100
                                                        if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if not stor159 * 0 / totalAllocPoint:
                                                            _3610 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_3610] = 26
                                                            mem[_3610 + 32] = 'SafeMath: division by zero'
                                                            _3758 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _3758 + 68] = mem[idx + _3610 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_3758 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _3758 + -mem[64] + 100
                                                        if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _3757 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3757] = 26
                                                        mem[_3757 + 32] = 'SafeMath: division by zero'
                                                        _3898 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _3898 + 68] = mem[idx + _3757 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_3898 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _3898 + -mem[64] + 100
                                                    if 10000 * poolInfo[idx].field_1024 / poolInfo[idx].field_1024 != 10000:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not 0 / totalAllocPoint:
                                                        _3609 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3609] = 26
                                                        mem[_3609 + 32] = 'SafeMath: division by zero'
                                                        if not 10000 * poolInfo[idx].field_1024:
                                                            _3756 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _3756 + 68] = mem[idx + _3609 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_3756 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _3756 + -mem[64] + 100
                                                        if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                    else:
                                                        if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if not stor159 * 0 / totalAllocPoint:
                                                            _3755 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_3755] = 26
                                                            mem[_3755 + 32] = 'SafeMath: division by zero'
                                                            if not 10000 * poolInfo[idx].field_1024:
                                                                _3896 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _3896 + 68] = mem[idx + _3755 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_3896 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _3896 + -mem[64] + 100
                                                            if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                        else:
                                                            if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            _3895 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_3895] = 26
                                                            mem[_3895 + 32] = 'SafeMath: division by zero'
                                                            if not 10000 * poolInfo[idx].field_1024:
                                                                _4032 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _4032 + 68] = mem[idx + _3895 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_4032 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _4032 + -mem[64] + 100
                                                            if (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_512 += poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024
                                else:
                                    if (block.timestamp * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) / (block.timestamp * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405) - (poolInfo[idx].field_768 * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405) != poolInfo[idx].field_160:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _2473 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_2473] = 26
                                    mem[_2473 + 32] = 'SafeMath: division by zero'
                                    if not totalAllocPoint:
                                        _2481 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _2481 + 68] = mem[idx + _2473 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_2481 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _2481 + -mem[64] + 100
                                    if not poolInfo[idx].field_1280:
                                        if not (block.timestamp * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) / totalAllocPoint:
                                            _2633 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2633] = 26
                                            mem[_2633 + 32] = 'SafeMath: division by zero'
                                            _2682 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _2682 + 68] = mem[idx + _2633 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_2682 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _2682 + -mem[64] + 100
                                        if stor159 * (block.timestamp * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) / totalAllocPoint / (block.timestamp * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) / totalAllocPoint != stor159:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not stor159 * (block.timestamp * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) / totalAllocPoint:
                                            _2681 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2681] = 26
                                            mem[_2681 + 32] = 'SafeMath: division by zero'
                                            _2732 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _2732 + 68] = mem[idx + _2681 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_2732 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _2732 + -mem[64] + 100
                                        if (10000 * stor159 * (block.timestamp * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * (block.timestamp * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) / totalAllocPoint) / stor159 * (block.timestamp * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) / totalAllocPoint != -poolInfo[idx].field_992 + 10000:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _2731 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2731] = 26
                                        mem[_2731 + 32] = 'SafeMath: division by zero'
                                        _2778 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _2778 + 68] = mem[idx + _2731 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_2778 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _2778 + -mem[64] + 100
                                    if 10000 * poolInfo[idx].field_1280 / poolInfo[idx].field_1280 != 10000:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not (block.timestamp * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) / totalAllocPoint:
                                        _2680 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2680] = 26
                                        mem[_2680 + 32] = 'SafeMath: division by zero'
                                        if not 10000 * poolInfo[idx].field_1280:
                                            _2730 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _2730 + 68] = mem[idx + _2680 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_2730 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _2730 + -mem[64] + 100
                                        if (0 / 10000 * poolInfo[idx].field_1280) + poolInfo[idx].field_256 < poolInfo[idx].field_256:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_256 += 0 / 10000 * poolInfo[idx].field_1280
                                        if poolInfo[idx].field_992:
                                            if poolInfo[idx].field_1024:
                                                if not poolInfo[idx].field_1024:
                                                    if not (block.timestamp * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) / totalAllocPoint:
                                                        _3355 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3355] = 26
                                                        mem[_3355 + 32] = 'SafeMath: division by zero'
                                                        _3469 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _3469 + 68] = mem[idx + _3355 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_3469 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _3469 + -mem[64] + 100
                                                    if stor159 * (block.timestamp * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) / totalAllocPoint / (block.timestamp * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) / totalAllocPoint != stor159:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not stor159 * (block.timestamp * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) / totalAllocPoint:
                                                        _3468 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3468] = 26
                                                        mem[_3468 + 32] = 'SafeMath: division by zero'
                                                        _3607 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        s = 0
                                                        while s < 26:
                                                            mem[s + _3607 + 68] = mem[s + _3468 + 32]
                                                            s = s + 32
                                                            continue 
                                                        mem[_3607 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _3607 + -mem[64] + 100
                                                    if poolInfo[idx].field_992 * stor159 * (block.timestamp * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) / totalAllocPoint / stor159 * (block.timestamp * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) / totalAllocPoint != poolInfo[idx].field_992:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    _3606 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_3606] = 26
                                                    mem[_3606 + 32] = 'SafeMath: division by zero'
                                                    _3753 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _3753 + 68] = mem[idx + _3606 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_3753 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _3753 + -mem[64] + 100
                                                if 10000 * poolInfo[idx].field_1024 / poolInfo[idx].field_1024 != 10000:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not (block.timestamp * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) / totalAllocPoint:
                                                    _3467 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_3467] = 26
                                                    mem[_3467 + 32] = 'SafeMath: division by zero'
                                                    if not 10000 * poolInfo[idx].field_1024:
                                                        _3605 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        s = 0
                                                        while s < 26:
                                                            mem[s + _3605 + 68] = mem[s + _3467 + 32]
                                                            s = s + 32
                                                            continue 
                                                        mem[_3605 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _3605 + -mem[64] + 100
                                                    if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                else:
                                                    if stor159 * (block.timestamp * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) / totalAllocPoint / (block.timestamp * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) / totalAllocPoint != stor159:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not stor159 * (block.timestamp * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) / totalAllocPoint:
                                                        _3604 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3604] = 26
                                                        mem[_3604 + 32] = 'SafeMath: division by zero'
                                                        if not 10000 * poolInfo[idx].field_1024:
                                                            _3751 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _3751 + 68] = mem[idx + _3604 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_3751 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _3751 + -mem[64] + 100
                                                        if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                    else:
                                                        if poolInfo[idx].field_992 * stor159 * (block.timestamp * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) / totalAllocPoint / stor159 * (block.timestamp * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) / totalAllocPoint != poolInfo[idx].field_992:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _3750 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3750] = 26
                                                        mem[_3750 + 32] = 'SafeMath: division by zero'
                                                        if not 10000 * poolInfo[idx].field_1024:
                                                            _3892 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _3892 + 68] = mem[idx + _3750 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_3892 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _3892 + -mem[64] + 100
                                                        if (poolInfo[idx].field_992 * stor159 * (block.timestamp * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) / totalAllocPoint / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_512 += poolInfo[idx].field_992 * stor159 * (block.timestamp * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) / totalAllocPoint / 10000 * poolInfo[idx].field_1024
                                    else:
                                        if stor159 * (block.timestamp * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) / totalAllocPoint / (block.timestamp * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) / totalAllocPoint != stor159:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not stor159 * (block.timestamp * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) / totalAllocPoint:
                                            _2729 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2729] = 26
                                            mem[_2729 + 32] = 'SafeMath: division by zero'
                                            if not 10000 * poolInfo[idx].field_1280:
                                                _2776 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _2776 + 68] = mem[idx + _2729 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_2776 + 94] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _2776 + -mem[64] + 100
                                            if (0 / 10000 * poolInfo[idx].field_1280) + poolInfo[idx].field_256 < poolInfo[idx].field_256:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_256 += 0 / 10000 * poolInfo[idx].field_1280
                                            if poolInfo[idx].field_992:
                                                if poolInfo[idx].field_1024:
                                                    if not poolInfo[idx].field_1024:
                                                        if not (block.timestamp * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) / totalAllocPoint:
                                                            _3466 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_3466] = 26
                                                            mem[_3466 + 32] = 'SafeMath: division by zero'
                                                            _3603 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            s = 0
                                                            while s < 26:
                                                                mem[s + _3603 + 68] = mem[s + _3466 + 32]
                                                                s = s + 32
                                                                continue 
                                                            mem[_3603 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _3603 + -mem[64] + 100
                                                        if stor159 * (block.timestamp * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) / totalAllocPoint / (block.timestamp * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) / totalAllocPoint != stor159:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if not stor159 * (block.timestamp * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) / totalAllocPoint:
                                                            _3602 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_3602] = 26
                                                            mem[_3602 + 32] = 'SafeMath: division by zero'
                                                            _3748 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _3748 + 68] = mem[idx + _3602 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_3748 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _3748 + -mem[64] + 100
                                                        if poolInfo[idx].field_992 * stor159 * (block.timestamp * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) / totalAllocPoint / stor159 * (block.timestamp * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) / totalAllocPoint != poolInfo[idx].field_992:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _3747 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3747] = 26
                                                        mem[_3747 + 32] = 'SafeMath: division by zero'
                                                        _3890 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _3890 + 68] = mem[idx + _3747 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_3890 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _3890 + -mem[64] + 100
                                                    if 10000 * poolInfo[idx].field_1024 / poolInfo[idx].field_1024 != 10000:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not (block.timestamp * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) / totalAllocPoint:
                                                        _3601 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3601] = 26
                                                        mem[_3601 + 32] = 'SafeMath: division by zero'
                                                        if not 10000 * poolInfo[idx].field_1024:
                                                            _3746 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _3746 + 68] = mem[idx + _3601 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_3746 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _3746 + -mem[64] + 100
                                                        if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                    else:
                                                        if stor159 * (block.timestamp * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) / totalAllocPoint / (block.timestamp * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) / totalAllocPoint != stor159:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if not stor159 * (block.timestamp * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) / totalAllocPoint:
                                                            _3745 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_3745] = 26
                                                            mem[_3745 + 32] = 'SafeMath: division by zero'
                                                            if not 10000 * poolInfo[idx].field_1024:
                                                                _3888 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _3888 + 68] = mem[idx + _3745 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_3888 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _3888 + -mem[64] + 100
                                                            if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                        else:
                                                            if poolInfo[idx].field_992 * stor159 * (block.timestamp * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) / totalAllocPoint / stor159 * (block.timestamp * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) / totalAllocPoint != poolInfo[idx].field_992:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            _3887 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_3887] = 26
                                                            mem[_3887 + 32] = 'SafeMath: division by zero'
                                                            if not 10000 * poolInfo[idx].field_1024:
                                                                _4027 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _4027 + 68] = mem[idx + _3887 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_4027 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _4027 + -mem[64] + 100
                                                            if (poolInfo[idx].field_992 * stor159 * (block.timestamp * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) / totalAllocPoint / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_512 += poolInfo[idx].field_992 * stor159 * (block.timestamp * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) / totalAllocPoint / 10000 * poolInfo[idx].field_1024
                                        else:
                                            if (10000 * stor159 * (block.timestamp * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * (block.timestamp * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) / totalAllocPoint) / stor159 * (block.timestamp * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) / totalAllocPoint != -poolInfo[idx].field_992 + 10000:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _2775 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2775] = 26
                                            mem[_2775 + 32] = 'SafeMath: division by zero'
                                            if not 10000 * poolInfo[idx].field_1280:
                                                _2820 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _2820 + 68] = mem[idx + _2775 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_2820 + 94] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _2820 + -mem[64] + 100
                                            if ((10000 * stor159 * (block.timestamp * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * (block.timestamp * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) / totalAllocPoint) / 10000 * poolInfo[idx].field_1280) + poolInfo[idx].field_256 < poolInfo[idx].field_256:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_256 += (10000 * stor159 * (block.timestamp * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * (block.timestamp * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) / totalAllocPoint) / 10000 * poolInfo[idx].field_1280
                                            if poolInfo[idx].field_992:
                                                if poolInfo[idx].field_1024:
                                                    if not poolInfo[idx].field_1024:
                                                        if not (block.timestamp * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) / totalAllocPoint:
                                                            _3600 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_3600] = 26
                                                            mem[_3600 + 32] = 'SafeMath: division by zero'
                                                            _3744 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _3744 + 68] = mem[idx + _3600 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_3744 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _3744 + -mem[64] + 100
                                                        if stor159 * (block.timestamp * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) / totalAllocPoint / (block.timestamp * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) / totalAllocPoint != stor159:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if not stor159 * (block.timestamp * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) / totalAllocPoint:
                                                            _3743 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_3743] = 26
                                                            mem[_3743 + 32] = 'SafeMath: division by zero'
                                                            _3885 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _3885 + 68] = mem[idx + _3743 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_3885 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _3885 + -mem[64] + 100
                                                        if poolInfo[idx].field_992 * stor159 * (block.timestamp * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) / totalAllocPoint / stor159 * (block.timestamp * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) / totalAllocPoint != poolInfo[idx].field_992:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _3884 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3884] = 26
                                                        mem[_3884 + 32] = 'SafeMath: division by zero'
                                                        _4025 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _4025 + 68] = mem[idx + _3884 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_4025 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _4025 + -mem[64] + 100
                                                    if 10000 * poolInfo[idx].field_1024 / poolInfo[idx].field_1024 != 10000:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not (block.timestamp * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) / totalAllocPoint:
                                                        _3742 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_3742] = 26
                                                        mem[_3742 + 32] = 'SafeMath: division by zero'
                                                        if not 10000 * poolInfo[idx].field_1024:
                                                            _3883 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _3883 + 68] = mem[idx + _3742 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_3883 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _3883 + -mem[64] + 100
                                                        if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                    else:
                                                        if stor159 * (block.timestamp * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) / totalAllocPoint / (block.timestamp * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) / totalAllocPoint != stor159:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if not stor159 * (block.timestamp * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) / totalAllocPoint:
                                                            _3882 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_3882] = 26
                                                            mem[_3882 + 32] = 'SafeMath: division by zero'
                                                            if not 10000 * poolInfo[idx].field_1024:
                                                                _4023 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _4023 + 68] = mem[idx + _3882 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_4023 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _4023 + -mem[64] + 100
                                                            if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                        else:
                                                            if poolInfo[idx].field_992 * stor159 * (block.timestamp * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) / totalAllocPoint / stor159 * (block.timestamp * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) / totalAllocPoint != poolInfo[idx].field_992:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            _4022 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_4022] = 26
                                                            mem[_4022 + 32] = 'SafeMath: division by zero'
                                                            if not 10000 * poolInfo[idx].field_1024:
                                                                _4169 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _4169 + 68] = mem[idx + _4022 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_4169 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _4169 + -mem[64] + 100
                                                            if (poolInfo[idx].field_992 * stor159 * (block.timestamp * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) / totalAllocPoint / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_512 += poolInfo[idx].field_992 * stor159 * (block.timestamp * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _2422 * (1000 * _2390) - (_2366 * _2390) - (_2355 * _2390) - (_2342 * _2390) / 1000 / _2405 * poolInfo[idx].field_160) / totalAllocPoint / 10000 * poolInfo[idx].field_1024
            poolInfo[idx].field_768 = uint64(block.timestamp)
            mem[mem[64]] = uint64(block.timestamp)
            mem[mem[64] + 32] = poolInfo[idx].field_1280
            mem[mem[64] + 64] = poolInfo[idx].field_256
            mem[mem[64] + 96] = poolInfo[idx].field_512
            emit UpdatePool(block.timestamp << 192, poolInfo[idx].field_1280, poolInfo[idx].field_256, poolInfo[idx].field_512, idx);
        idx = idx + 1
        continue 
    require arg1 < poolInfo.length
    if poolInfo[arg1].field_160 > totalAllocPoint:
        revert with 0, 'SafeMath: subtraction overflow', 0
    if Mask(96, 0, arg2) < 0:
        revert with 0, 'SafeMath: addition overflow'
    totalAllocPoint = Mask(96, 0, arg2) + totalAllocPoint - poolInfo[arg1].field_160
    poolInfo[arg1].field_160 = Mask(96, 0, arg2)
    poolInfo[arg1].field_992 = uint32(arg3)
    if arg5:
        if address(arg4):
            require ext_code.size(address(arg4))
            call address(arg4).onJoeReward(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args 0
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
        poolInfo[arg1].field_832 = address(arg4)
    require arg1 < poolInfo.length
    poolInfo[arg1].field_0 = poolInfo[arg1].field_0
    poolInfo[arg1].field_0 = poolInfo[arg1].field_0
    poolInfo[arg1].field_160 = poolInfo[arg1].field_160
    poolInfo[arg1].field_768 = poolInfo[arg1].field_768
    poolInfo[arg1].field_768 = poolInfo[arg1].field_768
    poolInfo[arg1].field_832 = poolInfo[arg1].field_832
    poolInfo[arg1].field_992 = 0
    poolInfo[arg1].field_768 = poolInfo[arg1].field_768
    poolInfo[arg1].field_832 = poolInfo[arg1].field_832
    poolInfo[arg1].field_992 = poolInfo[arg1].field_992
    if arg5:
        emit 0xdb1d9531: arg2 << 160, arg3 << 224, bool(arg5), arg1, address(arg4)
    else:
        emit 0xdb1d9531: arg2 << 160, arg3 << 224, bool(arg5), arg1, poolInfo[arg1].field_832
}

function sub_561be05a(?) payable {
    require calldata.size - 4 >= 128
    require arg1 == Mask(96, 0, arg1)
    require arg2 == uint32(arg2)
    require arg3 == address(arg3)
    require arg4 == address(arg4)
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if stor156[address(arg3)]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BoostedMasterChefJoe: LP already added'
    if uint32(arg2) > 10000:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    'BoostedMasterChefJoe: veJoeShareBp needs to be lower than 10000'
    if 50 < poolInfo.length:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BoostedMasterChefJoe: Too many pools'
    mem[0] = address(arg3)
    mem[32] = 156
    stor156[address(arg3)] = 1
    mem[100] = this.address
    require ext_code.size(address(arg3))
    staticcall address(arg3).0x70a08231 with:
            gas gas_remaining wei
           args this.address
    mem[96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    mem[64] = ceil32(return_data.size) + 96
    require return_data.size >= 32
    if not address(arg4):
        idx = 0
        while idx < poolInfo.length:
            mem[0] = 155
            if poolInfo[idx].field_768 < block.timestamp:
                if poolInfo[idx].field_1280:
                    if poolInfo[idx].field_160:
                        require ext_code.size(address(MASTER_CHEF_V2Address))
                        staticcall address(MASTER_CHEF_V2Address).investorPercent() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _4110 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _4112 = mem[_4110]
                        require ext_code.size(address(MASTER_CHEF_V2Address))
                        staticcall address(MASTER_CHEF_V2Address).treasuryPercent() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _4118 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _4120 = mem[_4118]
                        require ext_code.size(address(MASTER_CHEF_V2Address))
                        staticcall address(MASTER_CHEF_V2Address).devPercent() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _4126 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _4128 = mem[_4126]
                        _4130 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4130] = 30
                        mem[_4130 + 32] = 'SafeMath: subtraction overflow'
                        if _4128 > 1000:
                            _4132 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _4132 + 68] = mem[idx + _4130 + 32]
                                idx = idx + 32
                                continue 
                            mem[_4132 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _4132 + -mem[64] + 100
                        _4136 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4136] = 30
                        mem[_4136 + 32] = 'SafeMath: subtraction overflow'
                        if _4120 > -_4128 + 1000:
                            _4140 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _4140 + 68] = mem[idx + _4136 + 32]
                                idx = idx + 32
                                continue 
                            mem[_4140 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _4140 + -mem[64] + 100
                        _4144 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4144] = 30
                        mem[_4144 + 32] = 'SafeMath: subtraction overflow'
                        if _4112 > -_4128 + -_4120 + 1000:
                            _4152 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _4152 + 68] = mem[idx + _4144 + 32]
                                idx = idx + 32
                                continue 
                            mem[_4152 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _4152 + -mem[64] + 100
                        require ext_code.size(address(MASTER_CHEF_V2Address))
                        staticcall address(MASTER_CHEF_V2Address).0xca418d23 with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _4164 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _4168 = mem[_4164]
                        if not mem[_4164]:
                            _4176 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4176] = 26
                            mem[_4176 + 32] = 'SafeMath: division by zero'
                            require ext_code.size(address(MASTER_CHEF_V2Address))
                            staticcall address(MASTER_CHEF_V2Address).0x17caf6f1 with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _4188 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _4193 = mem[_4188]
                            require ext_code.size(address(MASTER_CHEF_V2Address))
                            staticcall address(MASTER_CHEF_V2Address).0x1526fe27 with:
                                    gas gas_remaining wei
                                   args MASTER_PID
                            mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _4205 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 128
                            _4210 = mem[64]
                            require mem[64] + 128 >= mem[64] and mem[64] + 128 <= test266151307()
                            mem[64] = mem[64] + 128
                            require mem[_4205] == mem[_4205 + 12 len 20]
                            mem[_4210] = mem[_4205]
                            mem[_4210 + 32] = mem[_4205 + 32]
                            mem[_4210 + 64] = mem[_4205 + 64]
                            mem[_4210 + 96] = mem[_4205 + 96]
                            _4234 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4234] = 26
                            mem[_4234 + 32] = 'SafeMath: division by zero'
                            if not _4193:
                                _4239 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _4239 + 68] = mem[idx + _4234 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4239 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _4239 + -mem[64] + 100
                            if not block.timestamp - poolInfo[idx].field_768:
                                _4282 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4282] = 26
                                mem[_4282 + 32] = 'SafeMath: division by zero'
                                if not totalAllocPoint:
                                    _4292 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _4292 + 68] = mem[idx + _4282 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4292 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4292 + -mem[64] + 100
                                if not poolInfo[idx].field_1280:
                                    if not 0 / totalAllocPoint:
                                        _4462 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_4462] = 26
                                        mem[_4462 + 32] = 'SafeMath: division by zero'
                                        _4496 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _4496 + 68] = mem[idx + _4462 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_4496 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _4496 + -mem[64] + 100
                                    if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not stor159 * 0 / totalAllocPoint:
                                        _4495 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_4495] = 26
                                        mem[_4495 + 32] = 'SafeMath: division by zero'
                                        _4538 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _4538 + 68] = mem[idx + _4495 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_4538 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _4538 + -mem[64] + 100
                                    if (10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint) / stor159 * 0 / totalAllocPoint != -poolInfo[idx].field_992 + 10000:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _4537 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4537] = 26
                                    mem[_4537 + 32] = 'SafeMath: division by zero'
                                    _4602 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _4602 + 68] = mem[idx + _4537 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4602 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4602 + -mem[64] + 100
                                if 10000 * poolInfo[idx].field_1280 / poolInfo[idx].field_1280 != 10000:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 0 / totalAllocPoint:
                                    _4494 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4494] = 26
                                    mem[_4494 + 32] = 'SafeMath: division by zero'
                                    if not 10000 * poolInfo[idx].field_1280:
                                        _4536 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _4536 + 68] = mem[idx + _4494 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_4536 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _4536 + -mem[64] + 100
                                    if (0 / 10000 * poolInfo[idx].field_1280) + poolInfo[idx].field_256 < poolInfo[idx].field_256:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_256 += 0 / 10000 * poolInfo[idx].field_1280
                                    if poolInfo[idx].field_992:
                                        if poolInfo[idx].field_1024:
                                            if not poolInfo[idx].field_1024:
                                                if not 0 / totalAllocPoint:
                                                    _5668 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_5668] = 26
                                                    mem[_5668 + 32] = 'SafeMath: division by zero'
                                                    _5746 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _5746 + 68] = mem[idx + _5668 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_5746 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _5746 + -mem[64] + 100
                                                if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not stor159 * 0 / totalAllocPoint:
                                                    _5745 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_5745] = 26
                                                    mem[_5745 + 32] = 'SafeMath: division by zero'
                                                    _5842 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _5842 + 68] = mem[idx + _5745 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_5842 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _5842 + -mem[64] + 100
                                                if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _5841 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_5841] = 26
                                                mem[_5841 + 32] = 'SafeMath: division by zero'
                                                _5979 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _5979 + 68] = mem[idx + _5841 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_5979 + 94] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _5979 + -mem[64] + 100
                                            if 10000 * poolInfo[idx].field_1024 / poolInfo[idx].field_1024 != 10000:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if not 0 / totalAllocPoint:
                                                _5744 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_5744] = 26
                                                mem[_5744 + 32] = 'SafeMath: division by zero'
                                                if not 10000 * poolInfo[idx].field_1024:
                                                    _5840 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _5840 + 68] = mem[idx + _5744 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_5840 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _5840 + -mem[64] + 100
                                                if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                            else:
                                                if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not stor159 * 0 / totalAllocPoint:
                                                    _5839 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_5839] = 26
                                                    mem[_5839 + 32] = 'SafeMath: division by zero'
                                                    if not 10000 * poolInfo[idx].field_1024:
                                                        _5977 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _5977 + 68] = mem[idx + _5839 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_5977 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _5977 + -mem[64] + 100
                                                    if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                else:
                                                    if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    _5976 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_5976] = 26
                                                    mem[_5976 + 32] = 'SafeMath: division by zero'
                                                    if not 10000 * poolInfo[idx].field_1024:
                                                        _6170 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _6170 + 68] = mem[idx + _5976 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_6170 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _6170 + -mem[64] + 100
                                                    if (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_512 += poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024
                                else:
                                    if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not stor159 * 0 / totalAllocPoint:
                                        _4535 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_4535] = 26
                                        mem[_4535 + 32] = 'SafeMath: division by zero'
                                        if not 10000 * poolInfo[idx].field_1280:
                                            _4600 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _4600 + 68] = mem[idx + _4535 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_4600 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _4600 + -mem[64] + 100
                                        if (0 / 10000 * poolInfo[idx].field_1280) + poolInfo[idx].field_256 < poolInfo[idx].field_256:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_256 += 0 / 10000 * poolInfo[idx].field_1280
                                        if poolInfo[idx].field_992:
                                            if poolInfo[idx].field_1024:
                                                if not poolInfo[idx].field_1024:
                                                    if not 0 / totalAllocPoint:
                                                        _5743 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_5743] = 26
                                                        mem[_5743 + 32] = 'SafeMath: division by zero'
                                                        _5838 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _5838 + 68] = mem[idx + _5743 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_5838 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _5838 + -mem[64] + 100
                                                    if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not stor159 * 0 / totalAllocPoint:
                                                        _5837 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_5837] = 26
                                                        mem[_5837 + 32] = 'SafeMath: division by zero'
                                                        _5974 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _5974 + 68] = mem[idx + _5837 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_5974 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _5974 + -mem[64] + 100
                                                    if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    _5973 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_5973] = 26
                                                    mem[_5973 + 32] = 'SafeMath: division by zero'
                                                    _6168 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _6168 + 68] = mem[idx + _5973 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_6168 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _6168 + -mem[64] + 100
                                                if 10000 * poolInfo[idx].field_1024 / poolInfo[idx].field_1024 != 10000:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not 0 / totalAllocPoint:
                                                    _5836 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_5836] = 26
                                                    mem[_5836 + 32] = 'SafeMath: division by zero'
                                                    if not 10000 * poolInfo[idx].field_1024:
                                                        _5972 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _5972 + 68] = mem[idx + _5836 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_5972 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _5972 + -mem[64] + 100
                                                    if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                else:
                                                    if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not stor159 * 0 / totalAllocPoint:
                                                        _5971 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_5971] = 26
                                                        mem[_5971 + 32] = 'SafeMath: division by zero'
                                                        if not 10000 * poolInfo[idx].field_1024:
                                                            _6166 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _6166 + 68] = mem[idx + _5971 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_6166 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _6166 + -mem[64] + 100
                                                        if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                    else:
                                                        if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _6165 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_6165] = 26
                                                        mem[_6165 + 32] = 'SafeMath: division by zero'
                                                        if not 10000 * poolInfo[idx].field_1024:
                                                            _6412 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _6412 + 68] = mem[idx + _6165 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_6412 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _6412 + -mem[64] + 100
                                                        if (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_512 += poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024
                                    else:
                                        if (10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint) / stor159 * 0 / totalAllocPoint != -poolInfo[idx].field_992 + 10000:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _4599 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_4599] = 26
                                        mem[_4599 + 32] = 'SafeMath: division by zero'
                                        if not 10000 * poolInfo[idx].field_1280:
                                            _4686 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _4686 + 68] = mem[idx + _4599 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_4686 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _4686 + -mem[64] + 100
                                        if ((10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint) / 10000 * poolInfo[idx].field_1280) + poolInfo[idx].field_256 < poolInfo[idx].field_256:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_256 += (10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint) / 10000 * poolInfo[idx].field_1280
                                        if poolInfo[idx].field_992:
                                            if poolInfo[idx].field_1024:
                                                if not poolInfo[idx].field_1024:
                                                    if not 0 / totalAllocPoint:
                                                        _5835 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_5835] = 26
                                                        mem[_5835 + 32] = 'SafeMath: division by zero'
                                                        _5970 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _5970 + 68] = mem[idx + _5835 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_5970 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _5970 + -mem[64] + 100
                                                    if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not stor159 * 0 / totalAllocPoint:
                                                        _5969 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_5969] = 26
                                                        mem[_5969 + 32] = 'SafeMath: division by zero'
                                                        _6163 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _6163 + 68] = mem[idx + _5969 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_6163 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _6163 + -mem[64] + 100
                                                    if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    _6162 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_6162] = 26
                                                    mem[_6162 + 32] = 'SafeMath: division by zero'
                                                    _6410 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _6410 + 68] = mem[idx + _6162 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_6410 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _6410 + -mem[64] + 100
                                                if 10000 * poolInfo[idx].field_1024 / poolInfo[idx].field_1024 != 10000:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not 0 / totalAllocPoint:
                                                    _5968 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_5968] = 26
                                                    mem[_5968 + 32] = 'SafeMath: division by zero'
                                                    if not 10000 * poolInfo[idx].field_1024:
                                                        _6161 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _6161 + 68] = mem[idx + _5968 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_6161 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _6161 + -mem[64] + 100
                                                    if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                else:
                                                    if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not stor159 * 0 / totalAllocPoint:
                                                        _6160 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_6160] = 26
                                                        mem[_6160 + 32] = 'SafeMath: division by zero'
                                                        if not 10000 * poolInfo[idx].field_1024:
                                                            _6408 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _6408 + 68] = mem[idx + _6160 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_6408 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _6408 + -mem[64] + 100
                                                        if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                    else:
                                                        if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _6407 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_6407] = 26
                                                        mem[_6407 + 32] = 'SafeMath: division by zero'
                                                        if not 10000 * poolInfo[idx].field_1024:
                                                            _6682 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            s = 0
                                                            while s < 26:
                                                                mem[s + _6682 + 68] = mem[s + _6407 + 32]
                                                                s = s + 32
                                                                continue 
                                                            mem[_6682 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _6682 + -mem[64] + 100
                                                        if (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_512 += poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024
                            else:
                                if (block.timestamp * 0 / _4193) - (poolInfo[idx].field_768 * 0 / _4193) / block.timestamp - poolInfo[idx].field_768 != 0 / _4193:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not (block.timestamp * 0 / _4193) - (poolInfo[idx].field_768 * 0 / _4193):
                                    _4291 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4291] = 26
                                    mem[_4291 + 32] = 'SafeMath: division by zero'
                                    if not totalAllocPoint:
                                        _4304 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _4304 + 68] = mem[idx + _4291 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_4304 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _4304 + -mem[64] + 100
                                    if not poolInfo[idx].field_1280:
                                        if not 0 / totalAllocPoint:
                                            _4493 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_4493] = 26
                                            mem[_4493 + 32] = 'SafeMath: division by zero'
                                            _4534 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _4534 + 68] = mem[idx + _4493 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_4534 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _4534 + -mem[64] + 100
                                        if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not stor159 * 0 / totalAllocPoint:
                                            _4533 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_4533] = 26
                                            mem[_4533 + 32] = 'SafeMath: division by zero'
                                            _4597 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _4597 + 68] = mem[idx + _4533 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_4597 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _4597 + -mem[64] + 100
                                        if (10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint) / stor159 * 0 / totalAllocPoint != -poolInfo[idx].field_992 + 10000:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _4596 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_4596] = 26
                                        mem[_4596 + 32] = 'SafeMath: division by zero'
                                        _4684 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _4684 + 68] = mem[idx + _4596 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_4684 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _4684 + -mem[64] + 100
                                    if 10000 * poolInfo[idx].field_1280 / poolInfo[idx].field_1280 != 10000:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not 0 / totalAllocPoint:
                                        _4532 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_4532] = 26
                                        mem[_4532 + 32] = 'SafeMath: division by zero'
                                        if not 10000 * poolInfo[idx].field_1280:
                                            _4595 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _4595 + 68] = mem[idx + _4532 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_4595 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _4595 + -mem[64] + 100
                                        if (0 / 10000 * poolInfo[idx].field_1280) + poolInfo[idx].field_256 < poolInfo[idx].field_256:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_256 += 0 / 10000 * poolInfo[idx].field_1280
                                        if poolInfo[idx].field_992:
                                            if poolInfo[idx].field_1024:
                                                if not poolInfo[idx].field_1024:
                                                    if not 0 / totalAllocPoint:
                                                        _5742 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_5742] = 26
                                                        mem[_5742 + 32] = 'SafeMath: division by zero'
                                                        _5834 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _5834 + 68] = mem[idx + _5742 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_5834 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _5834 + -mem[64] + 100
                                                    if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not stor159 * 0 / totalAllocPoint:
                                                        _5833 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_5833] = 26
                                                        mem[_5833 + 32] = 'SafeMath: division by zero'
                                                        _5966 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _5966 + 68] = mem[idx + _5833 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_5966 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _5966 + -mem[64] + 100
                                                    if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    _5965 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_5965] = 26
                                                    mem[_5965 + 32] = 'SafeMath: division by zero'
                                                    _6158 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _6158 + 68] = mem[idx + _5965 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_6158 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _6158 + -mem[64] + 100
                                                if 10000 * poolInfo[idx].field_1024 / poolInfo[idx].field_1024 != 10000:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not 0 / totalAllocPoint:
                                                    _5832 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_5832] = 26
                                                    mem[_5832 + 32] = 'SafeMath: division by zero'
                                                    if not 10000 * poolInfo[idx].field_1024:
                                                        _5964 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _5964 + 68] = mem[idx + _5832 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_5964 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _5964 + -mem[64] + 100
                                                    if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                else:
                                                    if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not stor159 * 0 / totalAllocPoint:
                                                        _5963 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_5963] = 26
                                                        mem[_5963 + 32] = 'SafeMath: division by zero'
                                                        if not 10000 * poolInfo[idx].field_1024:
                                                            _6156 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _6156 + 68] = mem[idx + _5963 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_6156 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _6156 + -mem[64] + 100
                                                        if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                    else:
                                                        if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _6155 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_6155] = 26
                                                        mem[_6155 + 32] = 'SafeMath: division by zero'
                                                        if not 10000 * poolInfo[idx].field_1024:
                                                            _6404 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _6404 + 68] = mem[idx + _6155 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_6404 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _6404 + -mem[64] + 100
                                                        if (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_512 += poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024
                                    else:
                                        if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not stor159 * 0 / totalAllocPoint:
                                            _4594 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_4594] = 26
                                            mem[_4594 + 32] = 'SafeMath: division by zero'
                                            if not 10000 * poolInfo[idx].field_1280:
                                                _4682 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _4682 + 68] = mem[idx + _4594 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_4682 + 94] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _4682 + -mem[64] + 100
                                            if (0 / 10000 * poolInfo[idx].field_1280) + poolInfo[idx].field_256 < poolInfo[idx].field_256:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_256 += 0 / 10000 * poolInfo[idx].field_1280
                                            if poolInfo[idx].field_992:
                                                if poolInfo[idx].field_1024:
                                                    if not poolInfo[idx].field_1024:
                                                        if not 0 / totalAllocPoint:
                                                            _5831 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_5831] = 26
                                                            mem[_5831 + 32] = 'SafeMath: division by zero'
                                                            _5962 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _5962 + 68] = mem[idx + _5831 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_5962 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _5962 + -mem[64] + 100
                                                        if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if not stor159 * 0 / totalAllocPoint:
                                                            _5961 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_5961] = 26
                                                            mem[_5961 + 32] = 'SafeMath: division by zero'
                                                            _6153 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _6153 + 68] = mem[idx + _5961 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_6153 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _6153 + -mem[64] + 100
                                                        if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _6152 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_6152] = 26
                                                        mem[_6152 + 32] = 'SafeMath: division by zero'
                                                        _6402 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _6402 + 68] = mem[idx + _6152 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_6402 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _6402 + -mem[64] + 100
                                                    if 10000 * poolInfo[idx].field_1024 / poolInfo[idx].field_1024 != 10000:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not 0 / totalAllocPoint:
                                                        _5960 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_5960] = 26
                                                        mem[_5960 + 32] = 'SafeMath: division by zero'
                                                        if not 10000 * poolInfo[idx].field_1024:
                                                            _6151 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _6151 + 68] = mem[idx + _5960 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_6151 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _6151 + -mem[64] + 100
                                                        if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                    else:
                                                        if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if not stor159 * 0 / totalAllocPoint:
                                                            _6150 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_6150] = 26
                                                            mem[_6150 + 32] = 'SafeMath: division by zero'
                                                            if not 10000 * poolInfo[idx].field_1024:
                                                                _6400 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _6400 + 68] = mem[idx + _6150 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_6400 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _6400 + -mem[64] + 100
                                                            if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                        else:
                                                            if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            _6399 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_6399] = 26
                                                            mem[_6399 + 32] = 'SafeMath: division by zero'
                                                            if not 10000 * poolInfo[idx].field_1024:
                                                                _6677 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                s = 0
                                                                while s < 26:
                                                                    mem[s + _6677 + 68] = mem[s + _6399 + 32]
                                                                    s = s + 32
                                                                    continue 
                                                                mem[_6677 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _6677 + -mem[64] + 100
                                                            if (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_512 += poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024
                                        else:
                                            if (10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint) / stor159 * 0 / totalAllocPoint != -poolInfo[idx].field_992 + 10000:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _4681 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_4681] = 26
                                            mem[_4681 + 32] = 'SafeMath: division by zero'
                                            if not 10000 * poolInfo[idx].field_1280:
                                                _4779 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _4779 + 68] = mem[idx + _4681 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_4779 + 94] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _4779 + -mem[64] + 100
                                            if ((10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint) / 10000 * poolInfo[idx].field_1280) + poolInfo[idx].field_256 < poolInfo[idx].field_256:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_256 += (10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint) / 10000 * poolInfo[idx].field_1280
                                            if poolInfo[idx].field_992:
                                                if poolInfo[idx].field_1024:
                                                    if not poolInfo[idx].field_1024:
                                                        if not 0 / totalAllocPoint:
                                                            _5959 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_5959] = 26
                                                            mem[_5959 + 32] = 'SafeMath: division by zero'
                                                            _6149 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _6149 + 68] = mem[idx + _5959 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_6149 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _6149 + -mem[64] + 100
                                                        if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if not stor159 * 0 / totalAllocPoint:
                                                            _6148 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_6148] = 26
                                                            mem[_6148 + 32] = 'SafeMath: division by zero'
                                                            _6397 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _6397 + 68] = mem[idx + _6148 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_6397 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _6397 + -mem[64] + 100
                                                        if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _6396 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_6396] = 26
                                                        mem[_6396 + 32] = 'SafeMath: division by zero'
                                                        _6675 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        s = 0
                                                        while s < 26:
                                                            mem[s + _6675 + 68] = mem[s + _6396 + 32]
                                                            s = s + 32
                                                            continue 
                                                        mem[_6675 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _6675 + -mem[64] + 100
                                                    if 10000 * poolInfo[idx].field_1024 / poolInfo[idx].field_1024 != 10000:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not 0 / totalAllocPoint:
                                                        _6147 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_6147] = 26
                                                        mem[_6147 + 32] = 'SafeMath: division by zero'
                                                        if not 10000 * poolInfo[idx].field_1024:
                                                            _6395 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _6395 + 68] = mem[idx + _6147 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_6395 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _6395 + -mem[64] + 100
                                                        if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                    else:
                                                        if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if not stor159 * 0 / totalAllocPoint:
                                                            _6394 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_6394] = 26
                                                            mem[_6394 + 32] = 'SafeMath: division by zero'
                                                            if not 10000 * poolInfo[idx].field_1024:
                                                                _6673 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                s = 0
                                                                while s < 26:
                                                                    mem[s + _6673 + 68] = mem[s + _6394 + 32]
                                                                    s = s + 32
                                                                    continue 
                                                                mem[_6673 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _6673 + -mem[64] + 100
                                                            if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                        else:
                                                            if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            _6672 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_6672] = 26
                                                            mem[_6672 + 32] = 'SafeMath: division by zero'
                                                            if not 10000 * poolInfo[idx].field_1024:
                                                                _6950 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _6950 + 68] = mem[idx + _6672 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_6950 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _6950 + -mem[64] + 100
                                                            if (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_512 += poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024
                                else:
                                    if (block.timestamp * 0 / _4193 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4193 * poolInfo[idx].field_160) / (block.timestamp * 0 / _4193) - (poolInfo[idx].field_768 * 0 / _4193) != poolInfo[idx].field_160:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _4303 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4303] = 26
                                    mem[_4303 + 32] = 'SafeMath: division by zero'
                                    if not totalAllocPoint:
                                        _4321 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _4321 + 68] = mem[idx + _4303 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_4321 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _4321 + -mem[64] + 100
                                    if not poolInfo[idx].field_1280:
                                        if not (block.timestamp * 0 / _4193 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4193 * poolInfo[idx].field_160) / totalAllocPoint:
                                            _4531 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_4531] = 26
                                            mem[_4531 + 32] = 'SafeMath: division by zero'
                                            _4593 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _4593 + 68] = mem[idx + _4531 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_4593 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _4593 + -mem[64] + 100
                                        if stor159 * (block.timestamp * 0 / _4193 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4193 * poolInfo[idx].field_160) / totalAllocPoint / (block.timestamp * 0 / _4193 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4193 * poolInfo[idx].field_160) / totalAllocPoint != stor159:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not stor159 * (block.timestamp * 0 / _4193 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4193 * poolInfo[idx].field_160) / totalAllocPoint:
                                            _4592 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_4592] = 26
                                            mem[_4592 + 32] = 'SafeMath: division by zero'
                                            _4679 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _4679 + 68] = mem[idx + _4592 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_4679 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _4679 + -mem[64] + 100
                                        if (10000 * stor159 * (block.timestamp * 0 / _4193 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4193 * poolInfo[idx].field_160) / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _4193 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4193 * poolInfo[idx].field_160) / totalAllocPoint) / stor159 * (block.timestamp * 0 / _4193 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4193 * poolInfo[idx].field_160) / totalAllocPoint != -poolInfo[idx].field_992 + 10000:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _4678 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_4678] = 26
                                        mem[_4678 + 32] = 'SafeMath: division by zero'
                                        _4777 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _4777 + 68] = mem[idx + _4678 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_4777 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _4777 + -mem[64] + 100
                                    if 10000 * poolInfo[idx].field_1280 / poolInfo[idx].field_1280 != 10000:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not (block.timestamp * 0 / _4193 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4193 * poolInfo[idx].field_160) / totalAllocPoint:
                                        _4591 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_4591] = 26
                                        mem[_4591 + 32] = 'SafeMath: division by zero'
                                        if not 10000 * poolInfo[idx].field_1280:
                                            _4677 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _4677 + 68] = mem[idx + _4591 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_4677 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _4677 + -mem[64] + 100
                                        if (0 / 10000 * poolInfo[idx].field_1280) + poolInfo[idx].field_256 < poolInfo[idx].field_256:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_256 += 0 / 10000 * poolInfo[idx].field_1280
                                        if poolInfo[idx].field_992:
                                            if poolInfo[idx].field_1024:
                                                if not poolInfo[idx].field_1024:
                                                    if not (block.timestamp * 0 / _4193 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4193 * poolInfo[idx].field_160) / totalAllocPoint:
                                                        _5830 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_5830] = 26
                                                        mem[_5830 + 32] = 'SafeMath: division by zero'
                                                        _5958 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _5958 + 68] = mem[idx + _5830 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_5958 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _5958 + -mem[64] + 100
                                                    if stor159 * (block.timestamp * 0 / _4193 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4193 * poolInfo[idx].field_160) / totalAllocPoint / (block.timestamp * 0 / _4193 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4193 * poolInfo[idx].field_160) / totalAllocPoint != stor159:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not stor159 * (block.timestamp * 0 / _4193 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4193 * poolInfo[idx].field_160) / totalAllocPoint:
                                                        _5957 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_5957] = 26
                                                        mem[_5957 + 32] = 'SafeMath: division by zero'
                                                        _6145 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _6145 + 68] = mem[idx + _5957 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_6145 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _6145 + -mem[64] + 100
                                                    if poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _4193 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4193 * poolInfo[idx].field_160) / totalAllocPoint / stor159 * (block.timestamp * 0 / _4193 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4193 * poolInfo[idx].field_160) / totalAllocPoint != poolInfo[idx].field_992:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    _6144 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_6144] = 26
                                                    mem[_6144 + 32] = 'SafeMath: division by zero'
                                                    _6392 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _6392 + 68] = mem[idx + _6144 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_6392 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _6392 + -mem[64] + 100
                                                if 10000 * poolInfo[idx].field_1024 / poolInfo[idx].field_1024 != 10000:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not (block.timestamp * 0 / _4193 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4193 * poolInfo[idx].field_160) / totalAllocPoint:
                                                    _5956 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_5956] = 26
                                                    mem[_5956 + 32] = 'SafeMath: division by zero'
                                                    if not 10000 * poolInfo[idx].field_1024:
                                                        _6143 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _6143 + 68] = mem[idx + _5956 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_6143 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _6143 + -mem[64] + 100
                                                    if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                else:
                                                    if stor159 * (block.timestamp * 0 / _4193 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4193 * poolInfo[idx].field_160) / totalAllocPoint / (block.timestamp * 0 / _4193 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4193 * poolInfo[idx].field_160) / totalAllocPoint != stor159:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not stor159 * (block.timestamp * 0 / _4193 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4193 * poolInfo[idx].field_160) / totalAllocPoint:
                                                        _6142 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_6142] = 26
                                                        mem[_6142 + 32] = 'SafeMath: division by zero'
                                                        if not 10000 * poolInfo[idx].field_1024:
                                                            _6390 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _6390 + 68] = mem[idx + _6142 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_6390 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _6390 + -mem[64] + 100
                                                        if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                    else:
                                                        if poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _4193 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4193 * poolInfo[idx].field_160) / totalAllocPoint / stor159 * (block.timestamp * 0 / _4193 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4193 * poolInfo[idx].field_160) / totalAllocPoint != poolInfo[idx].field_992:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _6389 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_6389] = 26
                                                        mem[_6389 + 32] = 'SafeMath: division by zero'
                                                        if not 10000 * poolInfo[idx].field_1024:
                                                            _6669 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            s = 0
                                                            while s < 26:
                                                                mem[s + _6669 + 68] = mem[s + _6389 + 32]
                                                                s = s + 32
                                                                continue 
                                                            mem[_6669 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _6669 + -mem[64] + 100
                                                        if (poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _4193 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4193 * poolInfo[idx].field_160) / totalAllocPoint / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_512 += poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _4193 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4193 * poolInfo[idx].field_160) / totalAllocPoint / 10000 * poolInfo[idx].field_1024
                                    else:
                                        if stor159 * (block.timestamp * 0 / _4193 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4193 * poolInfo[idx].field_160) / totalAllocPoint / (block.timestamp * 0 / _4193 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4193 * poolInfo[idx].field_160) / totalAllocPoint != stor159:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not stor159 * (block.timestamp * 0 / _4193 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4193 * poolInfo[idx].field_160) / totalAllocPoint:
                                            _4676 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_4676] = 26
                                            mem[_4676 + 32] = 'SafeMath: division by zero'
                                            if not 10000 * poolInfo[idx].field_1280:
                                                _4775 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _4775 + 68] = mem[idx + _4676 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_4775 + 94] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _4775 + -mem[64] + 100
                                            if (0 / 10000 * poolInfo[idx].field_1280) + poolInfo[idx].field_256 < poolInfo[idx].field_256:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_256 += 0 / 10000 * poolInfo[idx].field_1280
                                            if poolInfo[idx].field_992:
                                                if poolInfo[idx].field_1024:
                                                    if not poolInfo[idx].field_1024:
                                                        if not (block.timestamp * 0 / _4193 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4193 * poolInfo[idx].field_160) / totalAllocPoint:
                                                            _5955 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_5955] = 26
                                                            mem[_5955 + 32] = 'SafeMath: division by zero'
                                                            _6141 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _6141 + 68] = mem[idx + _5955 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_6141 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _6141 + -mem[64] + 100
                                                        if stor159 * (block.timestamp * 0 / _4193 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4193 * poolInfo[idx].field_160) / totalAllocPoint / (block.timestamp * 0 / _4193 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4193 * poolInfo[idx].field_160) / totalAllocPoint != stor159:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if not stor159 * (block.timestamp * 0 / _4193 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4193 * poolInfo[idx].field_160) / totalAllocPoint:
                                                            _6140 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_6140] = 26
                                                            mem[_6140 + 32] = 'SafeMath: division by zero'
                                                            _6387 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _6387 + 68] = mem[idx + _6140 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_6387 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _6387 + -mem[64] + 100
                                                        if poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _4193 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4193 * poolInfo[idx].field_160) / totalAllocPoint / stor159 * (block.timestamp * 0 / _4193 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4193 * poolInfo[idx].field_160) / totalAllocPoint != poolInfo[idx].field_992:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _6386 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_6386] = 26
                                                        mem[_6386 + 32] = 'SafeMath: division by zero'
                                                        _6667 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        s = 0
                                                        while s < 26:
                                                            mem[s + _6667 + 68] = mem[s + _6386 + 32]
                                                            s = s + 32
                                                            continue 
                                                        mem[_6667 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _6667 + -mem[64] + 100
                                                    if 10000 * poolInfo[idx].field_1024 / poolInfo[idx].field_1024 != 10000:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not (block.timestamp * 0 / _4193 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4193 * poolInfo[idx].field_160) / totalAllocPoint:
                                                        _6139 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_6139] = 26
                                                        mem[_6139 + 32] = 'SafeMath: division by zero'
                                                        if not 10000 * poolInfo[idx].field_1024:
                                                            _6385 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _6385 + 68] = mem[idx + _6139 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_6385 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _6385 + -mem[64] + 100
                                                        if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                    else:
                                                        if stor159 * (block.timestamp * 0 / _4193 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4193 * poolInfo[idx].field_160) / totalAllocPoint / (block.timestamp * 0 / _4193 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4193 * poolInfo[idx].field_160) / totalAllocPoint != stor159:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if not stor159 * (block.timestamp * 0 / _4193 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4193 * poolInfo[idx].field_160) / totalAllocPoint:
                                                            _6384 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_6384] = 26
                                                            mem[_6384 + 32] = 'SafeMath: division by zero'
                                                            if not 10000 * poolInfo[idx].field_1024:
                                                                _6665 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                s = 0
                                                                while s < 26:
                                                                    mem[s + _6665 + 68] = mem[s + _6384 + 32]
                                                                    s = s + 32
                                                                    continue 
                                                                mem[_6665 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _6665 + -mem[64] + 100
                                                            if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                        else:
                                                            if poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _4193 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4193 * poolInfo[idx].field_160) / totalAllocPoint / stor159 * (block.timestamp * 0 / _4193 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4193 * poolInfo[idx].field_160) / totalAllocPoint != poolInfo[idx].field_992:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            _6664 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_6664] = 26
                                                            mem[_6664 + 32] = 'SafeMath: division by zero'
                                                            if not 10000 * poolInfo[idx].field_1024:
                                                                _6945 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _6945 + 68] = mem[idx + _6664 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_6945 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _6945 + -mem[64] + 100
                                                            if (poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _4193 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4193 * poolInfo[idx].field_160) / totalAllocPoint / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_512 += poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _4193 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4193 * poolInfo[idx].field_160) / totalAllocPoint / 10000 * poolInfo[idx].field_1024
                                        else:
                                            if (10000 * stor159 * (block.timestamp * 0 / _4193 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4193 * poolInfo[idx].field_160) / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _4193 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4193 * poolInfo[idx].field_160) / totalAllocPoint) / stor159 * (block.timestamp * 0 / _4193 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4193 * poolInfo[idx].field_160) / totalAllocPoint != -poolInfo[idx].field_992 + 10000:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _4774 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_4774] = 26
                                            mem[_4774 + 32] = 'SafeMath: division by zero'
                                            if not 10000 * poolInfo[idx].field_1280:
                                                _4869 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _4869 + 68] = mem[idx + _4774 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_4869 + 94] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _4869 + -mem[64] + 100
                                            if ((10000 * stor159 * (block.timestamp * 0 / _4193 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4193 * poolInfo[idx].field_160) / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _4193 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4193 * poolInfo[idx].field_160) / totalAllocPoint) / 10000 * poolInfo[idx].field_1280) + poolInfo[idx].field_256 < poolInfo[idx].field_256:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_256 += (10000 * stor159 * (block.timestamp * 0 / _4193 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4193 * poolInfo[idx].field_160) / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _4193 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4193 * poolInfo[idx].field_160) / totalAllocPoint) / 10000 * poolInfo[idx].field_1280
                                            if poolInfo[idx].field_992:
                                                if poolInfo[idx].field_1024:
                                                    if not poolInfo[idx].field_1024:
                                                        if not (block.timestamp * 0 / _4193 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4193 * poolInfo[idx].field_160) / totalAllocPoint:
                                                            _6138 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_6138] = 26
                                                            mem[_6138 + 32] = 'SafeMath: division by zero'
                                                            _6383 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _6383 + 68] = mem[idx + _6138 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_6383 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _6383 + -mem[64] + 100
                                                        if stor159 * (block.timestamp * 0 / _4193 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4193 * poolInfo[idx].field_160) / totalAllocPoint / (block.timestamp * 0 / _4193 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4193 * poolInfo[idx].field_160) / totalAllocPoint != stor159:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if not stor159 * (block.timestamp * 0 / _4193 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4193 * poolInfo[idx].field_160) / totalAllocPoint:
                                                            _6382 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_6382] = 26
                                                            mem[_6382 + 32] = 'SafeMath: division by zero'
                                                            _6662 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            s = 0
                                                            while s < 26:
                                                                mem[s + _6662 + 68] = mem[s + _6382 + 32]
                                                                s = s + 32
                                                                continue 
                                                            mem[_6662 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _6662 + -mem[64] + 100
                                                        if poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _4193 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4193 * poolInfo[idx].field_160) / totalAllocPoint / stor159 * (block.timestamp * 0 / _4193 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4193 * poolInfo[idx].field_160) / totalAllocPoint != poolInfo[idx].field_992:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _6661 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_6661] = 26
                                                        mem[_6661 + 32] = 'SafeMath: division by zero'
                                                        _6943 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _6943 + 68] = mem[idx + _6661 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_6943 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _6943 + -mem[64] + 100
                                                    if 10000 * poolInfo[idx].field_1024 / poolInfo[idx].field_1024 != 10000:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not (block.timestamp * 0 / _4193 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4193 * poolInfo[idx].field_160) / totalAllocPoint:
                                                        _6381 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_6381] = 26
                                                        mem[_6381 + 32] = 'SafeMath: division by zero'
                                                        if not 10000 * poolInfo[idx].field_1024:
                                                            _6660 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            s = 0
                                                            while s < 26:
                                                                mem[s + _6660 + 68] = mem[s + _6381 + 32]
                                                                s = s + 32
                                                                continue 
                                                            mem[_6660 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _6660 + -mem[64] + 100
                                                        if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                    else:
                                                        if stor159 * (block.timestamp * 0 / _4193 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4193 * poolInfo[idx].field_160) / totalAllocPoint / (block.timestamp * 0 / _4193 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4193 * poolInfo[idx].field_160) / totalAllocPoint != stor159:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if not stor159 * (block.timestamp * 0 / _4193 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4193 * poolInfo[idx].field_160) / totalAllocPoint:
                                                            _6659 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_6659] = 26
                                                            mem[_6659 + 32] = 'SafeMath: division by zero'
                                                            if not 10000 * poolInfo[idx].field_1024:
                                                                _6941 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _6941 + 68] = mem[idx + _6659 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_6941 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _6941 + -mem[64] + 100
                                                            if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                        else:
                                                            if poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _4193 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4193 * poolInfo[idx].field_160) / totalAllocPoint / stor159 * (block.timestamp * 0 / _4193 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4193 * poolInfo[idx].field_160) / totalAllocPoint != poolInfo[idx].field_992:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            _6940 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_6940] = 26
                                                            mem[_6940 + 32] = 'SafeMath: division by zero'
                                                            if not 10000 * poolInfo[idx].field_1024:
                                                                _7216 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _7216 + 68] = mem[idx + _6940 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_7216 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _7216 + -mem[64] + 100
                                                            if (poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _4193 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4193 * poolInfo[idx].field_160) / totalAllocPoint / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_512 += poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _4193 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4193 * poolInfo[idx].field_160) / totalAllocPoint / 10000 * poolInfo[idx].field_1024
                        else:
                            if (1000 * mem[_4164]) - (_4128 * mem[_4164]) - (_4120 * mem[_4164]) - (_4112 * mem[_4164]) / mem[_4164] != -_4128 + -_4120 + -_4112 + 1000:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _4180 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4180] = 26
                            mem[_4180 + 32] = 'SafeMath: division by zero'
                            require ext_code.size(address(MASTER_CHEF_V2Address))
                            staticcall address(MASTER_CHEF_V2Address).0x17caf6f1 with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _4192 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _4198 = mem[_4192]
                            require ext_code.size(address(MASTER_CHEF_V2Address))
                            staticcall address(MASTER_CHEF_V2Address).0x1526fe27 with:
                                    gas gas_remaining wei
                                   args MASTER_PID
                            mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _4208 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 128
                            _4212 = mem[64]
                            require mem[64] + 128 >= mem[64] and mem[64] + 128 <= test266151307()
                            mem[64] = mem[64] + 128
                            require mem[_4208] == mem[_4208 + 12 len 20]
                            mem[_4212] = mem[_4208]
                            mem[_4212 + 32] = mem[_4208 + 32]
                            mem[_4212 + 64] = mem[_4208 + 64]
                            mem[_4212 + 96] = mem[_4208 + 96]
                            _4232 = mem[_4212 + 32]
                            if not (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000:
                                _4238 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4238] = 26
                                mem[_4238 + 32] = 'SafeMath: division by zero'
                                if not _4198:
                                    _4245 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _4245 + 68] = mem[idx + _4238 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4245 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4245 + -mem[64] + 100
                                if not block.timestamp - poolInfo[idx].field_768:
                                    _4290 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4290] = 26
                                    mem[_4290 + 32] = 'SafeMath: division by zero'
                                    if not totalAllocPoint:
                                        _4302 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _4302 + 68] = mem[idx + _4290 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_4302 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _4302 + -mem[64] + 100
                                    if not poolInfo[idx].field_1280:
                                        if not 0 / totalAllocPoint:
                                            _4492 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_4492] = 26
                                            mem[_4492 + 32] = 'SafeMath: division by zero'
                                            _4530 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _4530 + 68] = mem[idx + _4492 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_4530 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _4530 + -mem[64] + 100
                                        if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not stor159 * 0 / totalAllocPoint:
                                            _4529 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_4529] = 26
                                            mem[_4529 + 32] = 'SafeMath: division by zero'
                                            _4589 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _4589 + 68] = mem[idx + _4529 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_4589 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _4589 + -mem[64] + 100
                                        if (10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint) / stor159 * 0 / totalAllocPoint != -poolInfo[idx].field_992 + 10000:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _4588 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_4588] = 26
                                        mem[_4588 + 32] = 'SafeMath: division by zero'
                                        _4674 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _4674 + 68] = mem[idx + _4588 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_4674 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _4674 + -mem[64] + 100
                                    if 10000 * poolInfo[idx].field_1280 / poolInfo[idx].field_1280 != 10000:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not 0 / totalAllocPoint:
                                        _4528 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_4528] = 26
                                        mem[_4528 + 32] = 'SafeMath: division by zero'
                                        if not 10000 * poolInfo[idx].field_1280:
                                            _4587 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _4587 + 68] = mem[idx + _4528 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_4587 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _4587 + -mem[64] + 100
                                        if (0 / 10000 * poolInfo[idx].field_1280) + poolInfo[idx].field_256 < poolInfo[idx].field_256:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_256 += 0 / 10000 * poolInfo[idx].field_1280
                                        if poolInfo[idx].field_992:
                                            if poolInfo[idx].field_1024:
                                                if not poolInfo[idx].field_1024:
                                                    if not 0 / totalAllocPoint:
                                                        _5741 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_5741] = 26
                                                        mem[_5741 + 32] = 'SafeMath: division by zero'
                                                        _5829 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _5829 + 68] = mem[idx + _5741 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_5829 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _5829 + -mem[64] + 100
                                                    if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not stor159 * 0 / totalAllocPoint:
                                                        _5828 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_5828] = 26
                                                        mem[_5828 + 32] = 'SafeMath: division by zero'
                                                        _5953 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _5953 + 68] = mem[idx + _5828 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_5953 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _5953 + -mem[64] + 100
                                                    if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    _5952 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_5952] = 26
                                                    mem[_5952 + 32] = 'SafeMath: division by zero'
                                                    _6136 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _6136 + 68] = mem[idx + _5952 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_6136 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _6136 + -mem[64] + 100
                                                if 10000 * poolInfo[idx].field_1024 / poolInfo[idx].field_1024 != 10000:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not 0 / totalAllocPoint:
                                                    _5827 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_5827] = 26
                                                    mem[_5827 + 32] = 'SafeMath: division by zero'
                                                    if not 10000 * poolInfo[idx].field_1024:
                                                        _5951 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _5951 + 68] = mem[idx + _5827 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_5951 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _5951 + -mem[64] + 100
                                                    if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                else:
                                                    if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not stor159 * 0 / totalAllocPoint:
                                                        _5950 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_5950] = 26
                                                        mem[_5950 + 32] = 'SafeMath: division by zero'
                                                        if not 10000 * poolInfo[idx].field_1024:
                                                            _6134 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _6134 + 68] = mem[idx + _5950 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_6134 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _6134 + -mem[64] + 100
                                                        if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                    else:
                                                        if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _6133 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_6133] = 26
                                                        mem[_6133 + 32] = 'SafeMath: division by zero'
                                                        if not 10000 * poolInfo[idx].field_1024:
                                                            _6378 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _6378 + 68] = mem[idx + _6133 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_6378 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _6378 + -mem[64] + 100
                                                        if (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_512 += poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024
                                    else:
                                        if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not stor159 * 0 / totalAllocPoint:
                                            _4586 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_4586] = 26
                                            mem[_4586 + 32] = 'SafeMath: division by zero'
                                            if not 10000 * poolInfo[idx].field_1280:
                                                _4672 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _4672 + 68] = mem[idx + _4586 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_4672 + 94] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _4672 + -mem[64] + 100
                                            if (0 / 10000 * poolInfo[idx].field_1280) + poolInfo[idx].field_256 < poolInfo[idx].field_256:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_256 += 0 / 10000 * poolInfo[idx].field_1280
                                            if poolInfo[idx].field_992:
                                                if poolInfo[idx].field_1024:
                                                    if not poolInfo[idx].field_1024:
                                                        if not 0 / totalAllocPoint:
                                                            _5826 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_5826] = 26
                                                            mem[_5826 + 32] = 'SafeMath: division by zero'
                                                            _5949 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _5949 + 68] = mem[idx + _5826 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_5949 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _5949 + -mem[64] + 100
                                                        if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if not stor159 * 0 / totalAllocPoint:
                                                            _5948 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_5948] = 26
                                                            mem[_5948 + 32] = 'SafeMath: division by zero'
                                                            _6131 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _6131 + 68] = mem[idx + _5948 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_6131 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _6131 + -mem[64] + 100
                                                        if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _6130 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_6130] = 26
                                                        mem[_6130 + 32] = 'SafeMath: division by zero'
                                                        _6376 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _6376 + 68] = mem[idx + _6130 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_6376 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _6376 + -mem[64] + 100
                                                    if 10000 * poolInfo[idx].field_1024 / poolInfo[idx].field_1024 != 10000:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not 0 / totalAllocPoint:
                                                        _5947 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_5947] = 26
                                                        mem[_5947 + 32] = 'SafeMath: division by zero'
                                                        if not 10000 * poolInfo[idx].field_1024:
                                                            _6129 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _6129 + 68] = mem[idx + _5947 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_6129 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _6129 + -mem[64] + 100
                                                        if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                    else:
                                                        if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if not stor159 * 0 / totalAllocPoint:
                                                            _6128 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_6128] = 26
                                                            mem[_6128 + 32] = 'SafeMath: division by zero'
                                                            if not 10000 * poolInfo[idx].field_1024:
                                                                _6374 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _6374 + 68] = mem[idx + _6128 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_6374 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _6374 + -mem[64] + 100
                                                            if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                        else:
                                                            if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            _6373 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_6373] = 26
                                                            mem[_6373 + 32] = 'SafeMath: division by zero'
                                                            if not 10000 * poolInfo[idx].field_1024:
                                                                _6654 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                s = 0
                                                                while s < 26:
                                                                    mem[s + _6654 + 68] = mem[s + _6373 + 32]
                                                                    s = s + 32
                                                                    continue 
                                                                mem[_6654 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _6654 + -mem[64] + 100
                                                            if (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_512 += poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024
                                        else:
                                            if (10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint) / stor159 * 0 / totalAllocPoint != -poolInfo[idx].field_992 + 10000:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _4671 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_4671] = 26
                                            mem[_4671 + 32] = 'SafeMath: division by zero'
                                            if not 10000 * poolInfo[idx].field_1280:
                                                _4771 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _4771 + 68] = mem[idx + _4671 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_4771 + 94] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _4771 + -mem[64] + 100
                                            if ((10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint) / 10000 * poolInfo[idx].field_1280) + poolInfo[idx].field_256 < poolInfo[idx].field_256:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_256 += (10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint) / 10000 * poolInfo[idx].field_1280
                                            if poolInfo[idx].field_992:
                                                if poolInfo[idx].field_1024:
                                                    if not poolInfo[idx].field_1024:
                                                        if not 0 / totalAllocPoint:
                                                            _5946 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_5946] = 26
                                                            mem[_5946 + 32] = 'SafeMath: division by zero'
                                                            _6127 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _6127 + 68] = mem[idx + _5946 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_6127 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _6127 + -mem[64] + 100
                                                        if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if not stor159 * 0 / totalAllocPoint:
                                                            _6126 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_6126] = 26
                                                            mem[_6126 + 32] = 'SafeMath: division by zero'
                                                            _6371 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _6371 + 68] = mem[idx + _6126 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_6371 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _6371 + -mem[64] + 100
                                                        if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _6370 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_6370] = 26
                                                        mem[_6370 + 32] = 'SafeMath: division by zero'
                                                        _6652 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        s = 0
                                                        while s < 26:
                                                            mem[s + _6652 + 68] = mem[s + _6370 + 32]
                                                            s = s + 32
                                                            continue 
                                                        mem[_6652 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _6652 + -mem[64] + 100
                                                    if 10000 * poolInfo[idx].field_1024 / poolInfo[idx].field_1024 != 10000:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not 0 / totalAllocPoint:
                                                        _6125 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_6125] = 26
                                                        mem[_6125 + 32] = 'SafeMath: division by zero'
                                                        if not 10000 * poolInfo[idx].field_1024:
                                                            _6369 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _6369 + 68] = mem[idx + _6125 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_6369 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _6369 + -mem[64] + 100
                                                        if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                    else:
                                                        if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if not stor159 * 0 / totalAllocPoint:
                                                            _6368 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_6368] = 26
                                                            mem[_6368 + 32] = 'SafeMath: division by zero'
                                                            if not 10000 * poolInfo[idx].field_1024:
                                                                _6650 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                s = 0
                                                                while s < 26:
                                                                    mem[s + _6650 + 68] = mem[s + _6368 + 32]
                                                                    s = s + 32
                                                                    continue 
                                                                mem[_6650 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _6650 + -mem[64] + 100
                                                            if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                        else:
                                                            if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            _6649 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_6649] = 26
                                                            mem[_6649 + 32] = 'SafeMath: division by zero'
                                                            if not 10000 * poolInfo[idx].field_1024:
                                                                _6931 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _6931 + 68] = mem[idx + _6649 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_6931 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _6931 + -mem[64] + 100
                                                            if (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_512 += poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024
                                else:
                                    if (block.timestamp * 0 / _4198) - (poolInfo[idx].field_768 * 0 / _4198) / block.timestamp - poolInfo[idx].field_768 != 0 / _4198:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not (block.timestamp * 0 / _4198) - (poolInfo[idx].field_768 * 0 / _4198):
                                        _4301 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_4301] = 26
                                        mem[_4301 + 32] = 'SafeMath: division by zero'
                                        if not totalAllocPoint:
                                            _4319 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _4319 + 68] = mem[idx + _4301 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_4319 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _4319 + -mem[64] + 100
                                        if not poolInfo[idx].field_1280:
                                            if not 0 / totalAllocPoint:
                                                _4527 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_4527] = 26
                                                mem[_4527 + 32] = 'SafeMath: division by zero'
                                                _4585 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _4585 + 68] = mem[idx + _4527 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_4585 + 94] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _4585 + -mem[64] + 100
                                            if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if not stor159 * 0 / totalAllocPoint:
                                                _4584 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_4584] = 26
                                                mem[_4584 + 32] = 'SafeMath: division by zero'
                                                _4669 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _4669 + 68] = mem[idx + _4584 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_4669 + 94] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _4669 + -mem[64] + 100
                                            if (10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint) / stor159 * 0 / totalAllocPoint != -poolInfo[idx].field_992 + 10000:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _4668 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_4668] = 26
                                            mem[_4668 + 32] = 'SafeMath: division by zero'
                                            _4769 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _4769 + 68] = mem[idx + _4668 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_4769 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _4769 + -mem[64] + 100
                                        if 10000 * poolInfo[idx].field_1280 / poolInfo[idx].field_1280 != 10000:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not 0 / totalAllocPoint:
                                            _4583 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_4583] = 26
                                            mem[_4583 + 32] = 'SafeMath: division by zero'
                                            if not 10000 * poolInfo[idx].field_1280:
                                                _4667 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _4667 + 68] = mem[idx + _4583 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_4667 + 94] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _4667 + -mem[64] + 100
                                            if (0 / 10000 * poolInfo[idx].field_1280) + poolInfo[idx].field_256 < poolInfo[idx].field_256:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_256 += 0 / 10000 * poolInfo[idx].field_1280
                                            if poolInfo[idx].field_992:
                                                if poolInfo[idx].field_1024:
                                                    if not poolInfo[idx].field_1024:
                                                        if not 0 / totalAllocPoint:
                                                            _5825 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_5825] = 26
                                                            mem[_5825 + 32] = 'SafeMath: division by zero'
                                                            _5945 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _5945 + 68] = mem[idx + _5825 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_5945 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _5945 + -mem[64] + 100
                                                        if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if not stor159 * 0 / totalAllocPoint:
                                                            _5944 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_5944] = 26
                                                            mem[_5944 + 32] = 'SafeMath: division by zero'
                                                            _6123 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _6123 + 68] = mem[idx + _5944 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_6123 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _6123 + -mem[64] + 100
                                                        if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _6122 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_6122] = 26
                                                        mem[_6122 + 32] = 'SafeMath: division by zero'
                                                        _6366 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _6366 + 68] = mem[idx + _6122 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_6366 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _6366 + -mem[64] + 100
                                                    if 10000 * poolInfo[idx].field_1024 / poolInfo[idx].field_1024 != 10000:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not 0 / totalAllocPoint:
                                                        _5943 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_5943] = 26
                                                        mem[_5943 + 32] = 'SafeMath: division by zero'
                                                        if not 10000 * poolInfo[idx].field_1024:
                                                            _6121 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _6121 + 68] = mem[idx + _5943 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_6121 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _6121 + -mem[64] + 100
                                                        if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                    else:
                                                        if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if not stor159 * 0 / totalAllocPoint:
                                                            _6120 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_6120] = 26
                                                            mem[_6120 + 32] = 'SafeMath: division by zero'
                                                            if not 10000 * poolInfo[idx].field_1024:
                                                                _6364 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _6364 + 68] = mem[idx + _6120 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_6364 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _6364 + -mem[64] + 100
                                                            if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                        else:
                                                            if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            _6363 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_6363] = 26
                                                            mem[_6363 + 32] = 'SafeMath: division by zero'
                                                            if not 10000 * poolInfo[idx].field_1024:
                                                                _6646 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                s = 0
                                                                while s < 26:
                                                                    mem[s + _6646 + 68] = mem[s + _6363 + 32]
                                                                    s = s + 32
                                                                    continue 
                                                                mem[_6646 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _6646 + -mem[64] + 100
                                                            if (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_512 += poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024
                                        else:
                                            if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if not stor159 * 0 / totalAllocPoint:
                                                _4666 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_4666] = 26
                                                mem[_4666 + 32] = 'SafeMath: division by zero'
                                                if not 10000 * poolInfo[idx].field_1280:
                                                    _4767 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _4767 + 68] = mem[idx + _4666 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_4767 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _4767 + -mem[64] + 100
                                                if (0 / 10000 * poolInfo[idx].field_1280) + poolInfo[idx].field_256 < poolInfo[idx].field_256:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_256 += 0 / 10000 * poolInfo[idx].field_1280
                                                if poolInfo[idx].field_992:
                                                    if poolInfo[idx].field_1024:
                                                        if not poolInfo[idx].field_1024:
                                                            if not 0 / totalAllocPoint:
                                                                _5942 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_5942] = 26
                                                                mem[_5942 + 32] = 'SafeMath: division by zero'
                                                                _6119 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _6119 + 68] = mem[idx + _5942 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_6119 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _6119 + -mem[64] + 100
                                                            if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            if not stor159 * 0 / totalAllocPoint:
                                                                _6118 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_6118] = 26
                                                                mem[_6118 + 32] = 'SafeMath: division by zero'
                                                                _6361 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _6361 + 68] = mem[idx + _6118 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_6361 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _6361 + -mem[64] + 100
                                                            if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            _6360 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_6360] = 26
                                                            mem[_6360 + 32] = 'SafeMath: division by zero'
                                                            _6644 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            s = 0
                                                            while s < 26:
                                                                mem[s + _6644 + 68] = mem[s + _6360 + 32]
                                                                s = s + 32
                                                                continue 
                                                            mem[_6644 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _6644 + -mem[64] + 100
                                                        if 10000 * poolInfo[idx].field_1024 / poolInfo[idx].field_1024 != 10000:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if not 0 / totalAllocPoint:
                                                            _6117 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_6117] = 26
                                                            mem[_6117 + 32] = 'SafeMath: division by zero'
                                                            if not 10000 * poolInfo[idx].field_1024:
                                                                _6359 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _6359 + 68] = mem[idx + _6117 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_6359 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _6359 + -mem[64] + 100
                                                            if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                        else:
                                                            if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            if not stor159 * 0 / totalAllocPoint:
                                                                _6358 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_6358] = 26
                                                                mem[_6358 + 32] = 'SafeMath: division by zero'
                                                                if not 10000 * poolInfo[idx].field_1024:
                                                                    _6642 = mem[64]
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 26
                                                                    s = 0
                                                                    while s < 26:
                                                                        mem[s + _6642 + 68] = mem[s + _6358 + 32]
                                                                        s = s + 32
                                                                        continue 
                                                                    mem[_6642 + 94] = 0
                                                                    revert with memory
                                                                      from mem[64]
                                                                       len _6642 + -mem[64] + 100
                                                                if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                            else:
                                                                if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                _6641 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_6641] = 26
                                                                mem[_6641 + 32] = 'SafeMath: division by zero'
                                                                if not 10000 * poolInfo[idx].field_1024:
                                                                    _6926 = mem[64]
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 26
                                                                    idx = 0
                                                                    while idx < 26:
                                                                        mem[idx + _6926 + 68] = mem[idx + _6641 + 32]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    mem[_6926 + 94] = 0
                                                                    revert with memory
                                                                      from mem[64]
                                                                       len _6926 + -mem[64] + 100
                                                                if (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_512 += poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024
                                            else:
                                                if (10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint) / stor159 * 0 / totalAllocPoint != -poolInfo[idx].field_992 + 10000:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _4766 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_4766] = 26
                                                mem[_4766 + 32] = 'SafeMath: division by zero'
                                                if not 10000 * poolInfo[idx].field_1280:
                                                    _4864 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _4864 + 68] = mem[idx + _4766 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_4864 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _4864 + -mem[64] + 100
                                                if ((10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint) / 10000 * poolInfo[idx].field_1280) + poolInfo[idx].field_256 < poolInfo[idx].field_256:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_256 += (10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint) / 10000 * poolInfo[idx].field_1280
                                                if poolInfo[idx].field_992:
                                                    if poolInfo[idx].field_1024:
                                                        if not poolInfo[idx].field_1024:
                                                            if not 0 / totalAllocPoint:
                                                                _6116 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_6116] = 26
                                                                mem[_6116 + 32] = 'SafeMath: division by zero'
                                                                _6357 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _6357 + 68] = mem[idx + _6116 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_6357 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _6357 + -mem[64] + 100
                                                            if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            if not stor159 * 0 / totalAllocPoint:
                                                                _6356 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_6356] = 26
                                                                mem[_6356 + 32] = 'SafeMath: division by zero'
                                                                _6639 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                s = 0
                                                                while s < 26:
                                                                    mem[s + _6639 + 68] = mem[s + _6356 + 32]
                                                                    s = s + 32
                                                                    continue 
                                                                mem[_6639 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _6639 + -mem[64] + 100
                                                            if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            _6638 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_6638] = 26
                                                            mem[_6638 + 32] = 'SafeMath: division by zero'
                                                            _6924 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _6924 + 68] = mem[idx + _6638 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_6924 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _6924 + -mem[64] + 100
                                                        if 10000 * poolInfo[idx].field_1024 / poolInfo[idx].field_1024 != 10000:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if not 0 / totalAllocPoint:
                                                            _6355 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_6355] = 26
                                                            mem[_6355 + 32] = 'SafeMath: division by zero'
                                                            if not 10000 * poolInfo[idx].field_1024:
                                                                _6637 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                s = 0
                                                                while s < 26:
                                                                    mem[s + _6637 + 68] = mem[s + _6355 + 32]
                                                                    s = s + 32
                                                                    continue 
                                                                mem[_6637 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _6637 + -mem[64] + 100
                                                            if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                        else:
                                                            if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            if not stor159 * 0 / totalAllocPoint:
                                                                _6636 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_6636] = 26
                                                                mem[_6636 + 32] = 'SafeMath: division by zero'
                                                                if not 10000 * poolInfo[idx].field_1024:
                                                                    _6922 = mem[64]
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 26
                                                                    idx = 0
                                                                    while idx < 26:
                                                                        mem[idx + _6922 + 68] = mem[idx + _6636 + 32]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    mem[_6922 + 94] = 0
                                                                    revert with memory
                                                                      from mem[64]
                                                                       len _6922 + -mem[64] + 100
                                                                if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                            else:
                                                                if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                _6921 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_6921] = 26
                                                                mem[_6921 + 32] = 'SafeMath: division by zero'
                                                                if not 10000 * poolInfo[idx].field_1024:
                                                                    _7194 = mem[64]
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 26
                                                                    idx = 0
                                                                    while idx < 26:
                                                                        mem[idx + _7194 + 68] = mem[idx + _6921 + 32]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    mem[_7194 + 94] = 0
                                                                    revert with memory
                                                                      from mem[64]
                                                                       len _7194 + -mem[64] + 100
                                                                if (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_512 += poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024
                                    else:
                                        if (block.timestamp * 0 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4198 * poolInfo[idx].field_160) / (block.timestamp * 0 / _4198) - (poolInfo[idx].field_768 * 0 / _4198) != poolInfo[idx].field_160:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _4318 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_4318] = 26
                                        mem[_4318 + 32] = 'SafeMath: division by zero'
                                        if not totalAllocPoint:
                                            _4337 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _4337 + 68] = mem[idx + _4318 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_4337 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _4337 + -mem[64] + 100
                                        if not poolInfo[idx].field_1280:
                                            if not (block.timestamp * 0 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4198 * poolInfo[idx].field_160) / totalAllocPoint:
                                                _4582 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_4582] = 26
                                                mem[_4582 + 32] = 'SafeMath: division by zero'
                                                _4665 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _4665 + 68] = mem[idx + _4582 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_4665 + 94] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _4665 + -mem[64] + 100
                                            if stor159 * (block.timestamp * 0 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4198 * poolInfo[idx].field_160) / totalAllocPoint / (block.timestamp * 0 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4198 * poolInfo[idx].field_160) / totalAllocPoint != stor159:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if not stor159 * (block.timestamp * 0 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4198 * poolInfo[idx].field_160) / totalAllocPoint:
                                                _4664 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_4664] = 26
                                                mem[_4664 + 32] = 'SafeMath: division by zero'
                                                _4764 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _4764 + 68] = mem[idx + _4664 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_4764 + 94] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _4764 + -mem[64] + 100
                                            if (10000 * stor159 * (block.timestamp * 0 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4198 * poolInfo[idx].field_160) / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4198 * poolInfo[idx].field_160) / totalAllocPoint) / stor159 * (block.timestamp * 0 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4198 * poolInfo[idx].field_160) / totalAllocPoint != -poolInfo[idx].field_992 + 10000:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _4763 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_4763] = 26
                                            mem[_4763 + 32] = 'SafeMath: division by zero'
                                            _4862 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _4862 + 68] = mem[idx + _4763 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_4862 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _4862 + -mem[64] + 100
                                        if 10000 * poolInfo[idx].field_1280 / poolInfo[idx].field_1280 != 10000:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not (block.timestamp * 0 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4198 * poolInfo[idx].field_160) / totalAllocPoint:
                                            _4663 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_4663] = 26
                                            mem[_4663 + 32] = 'SafeMath: division by zero'
                                            if not 10000 * poolInfo[idx].field_1280:
                                                _4762 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _4762 + 68] = mem[idx + _4663 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_4762 + 94] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _4762 + -mem[64] + 100
                                            if (0 / 10000 * poolInfo[idx].field_1280) + poolInfo[idx].field_256 < poolInfo[idx].field_256:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_256 += 0 / 10000 * poolInfo[idx].field_1280
                                            if poolInfo[idx].field_992:
                                                if poolInfo[idx].field_1024:
                                                    if not poolInfo[idx].field_1024:
                                                        if not (block.timestamp * 0 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4198 * poolInfo[idx].field_160) / totalAllocPoint:
                                                            _5941 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_5941] = 26
                                                            mem[_5941 + 32] = 'SafeMath: division by zero'
                                                            _6115 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _6115 + 68] = mem[idx + _5941 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_6115 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _6115 + -mem[64] + 100
                                                        if stor159 * (block.timestamp * 0 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4198 * poolInfo[idx].field_160) / totalAllocPoint / (block.timestamp * 0 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4198 * poolInfo[idx].field_160) / totalAllocPoint != stor159:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if not stor159 * (block.timestamp * 0 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4198 * poolInfo[idx].field_160) / totalAllocPoint:
                                                            _6114 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_6114] = 26
                                                            mem[_6114 + 32] = 'SafeMath: division by zero'
                                                            _6353 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _6353 + 68] = mem[idx + _6114 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_6353 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _6353 + -mem[64] + 100
                                                        if poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4198 * poolInfo[idx].field_160) / totalAllocPoint / stor159 * (block.timestamp * 0 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4198 * poolInfo[idx].field_160) / totalAllocPoint != poolInfo[idx].field_992:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _6352 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_6352] = 26
                                                        mem[_6352 + 32] = 'SafeMath: division by zero'
                                                        _6634 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        s = 0
                                                        while s < 26:
                                                            mem[s + _6634 + 68] = mem[s + _6352 + 32]
                                                            s = s + 32
                                                            continue 
                                                        mem[_6634 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _6634 + -mem[64] + 100
                                                    if 10000 * poolInfo[idx].field_1024 / poolInfo[idx].field_1024 != 10000:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not (block.timestamp * 0 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4198 * poolInfo[idx].field_160) / totalAllocPoint:
                                                        _6113 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_6113] = 26
                                                        mem[_6113 + 32] = 'SafeMath: division by zero'
                                                        if not 10000 * poolInfo[idx].field_1024:
                                                            _6351 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _6351 + 68] = mem[idx + _6113 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_6351 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _6351 + -mem[64] + 100
                                                        if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                    else:
                                                        if stor159 * (block.timestamp * 0 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4198 * poolInfo[idx].field_160) / totalAllocPoint / (block.timestamp * 0 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4198 * poolInfo[idx].field_160) / totalAllocPoint != stor159:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if not stor159 * (block.timestamp * 0 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4198 * poolInfo[idx].field_160) / totalAllocPoint:
                                                            _6350 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_6350] = 26
                                                            mem[_6350 + 32] = 'SafeMath: division by zero'
                                                            if not 10000 * poolInfo[idx].field_1024:
                                                                _6632 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                s = 0
                                                                while s < 26:
                                                                    mem[s + _6632 + 68] = mem[s + _6350 + 32]
                                                                    s = s + 32
                                                                    continue 
                                                                mem[_6632 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _6632 + -mem[64] + 100
                                                            if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                        else:
                                                            if poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4198 * poolInfo[idx].field_160) / totalAllocPoint / stor159 * (block.timestamp * 0 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4198 * poolInfo[idx].field_160) / totalAllocPoint != poolInfo[idx].field_992:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            _6631 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_6631] = 26
                                                            mem[_6631 + 32] = 'SafeMath: division by zero'
                                                            if not 10000 * poolInfo[idx].field_1024:
                                                                _6918 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _6918 + 68] = mem[idx + _6631 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_6918 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _6918 + -mem[64] + 100
                                                            if (poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4198 * poolInfo[idx].field_160) / totalAllocPoint / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_512 += poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4198 * poolInfo[idx].field_160) / totalAllocPoint / 10000 * poolInfo[idx].field_1024
                                        else:
                                            if stor159 * (block.timestamp * 0 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4198 * poolInfo[idx].field_160) / totalAllocPoint / (block.timestamp * 0 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4198 * poolInfo[idx].field_160) / totalAllocPoint != stor159:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if not stor159 * (block.timestamp * 0 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4198 * poolInfo[idx].field_160) / totalAllocPoint:
                                                _4761 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_4761] = 26
                                                mem[_4761 + 32] = 'SafeMath: division by zero'
                                                if not 10000 * poolInfo[idx].field_1280:
                                                    _4860 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _4860 + 68] = mem[idx + _4761 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_4860 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _4860 + -mem[64] + 100
                                                if (0 / 10000 * poolInfo[idx].field_1280) + poolInfo[idx].field_256 < poolInfo[idx].field_256:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_256 += 0 / 10000 * poolInfo[idx].field_1280
                                                if poolInfo[idx].field_992:
                                                    if poolInfo[idx].field_1024:
                                                        if not poolInfo[idx].field_1024:
                                                            if not (block.timestamp * 0 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4198 * poolInfo[idx].field_160) / totalAllocPoint:
                                                                _6112 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_6112] = 26
                                                                mem[_6112 + 32] = 'SafeMath: division by zero'
                                                                _6349 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _6349 + 68] = mem[idx + _6112 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_6349 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _6349 + -mem[64] + 100
                                                            if stor159 * (block.timestamp * 0 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4198 * poolInfo[idx].field_160) / totalAllocPoint / (block.timestamp * 0 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4198 * poolInfo[idx].field_160) / totalAllocPoint != stor159:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            if not stor159 * (block.timestamp * 0 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4198 * poolInfo[idx].field_160) / totalAllocPoint:
                                                                _6348 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_6348] = 26
                                                                mem[_6348 + 32] = 'SafeMath: division by zero'
                                                                _6629 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                s = 0
                                                                while s < 26:
                                                                    mem[s + _6629 + 68] = mem[s + _6348 + 32]
                                                                    s = s + 32
                                                                    continue 
                                                                mem[_6629 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _6629 + -mem[64] + 100
                                                            if poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4198 * poolInfo[idx].field_160) / totalAllocPoint / stor159 * (block.timestamp * 0 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4198 * poolInfo[idx].field_160) / totalAllocPoint != poolInfo[idx].field_992:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            _6628 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_6628] = 26
                                                            mem[_6628 + 32] = 'SafeMath: division by zero'
                                                            _6916 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _6916 + 68] = mem[idx + _6628 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_6916 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _6916 + -mem[64] + 100
                                                        if 10000 * poolInfo[idx].field_1024 / poolInfo[idx].field_1024 != 10000:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if not (block.timestamp * 0 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4198 * poolInfo[idx].field_160) / totalAllocPoint:
                                                            _6347 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_6347] = 26
                                                            mem[_6347 + 32] = 'SafeMath: division by zero'
                                                            if not 10000 * poolInfo[idx].field_1024:
                                                                _6627 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                s = 0
                                                                while s < 26:
                                                                    mem[s + _6627 + 68] = mem[s + _6347 + 32]
                                                                    s = s + 32
                                                                    continue 
                                                                mem[_6627 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _6627 + -mem[64] + 100
                                                            if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                        else:
                                                            if stor159 * (block.timestamp * 0 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4198 * poolInfo[idx].field_160) / totalAllocPoint / (block.timestamp * 0 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4198 * poolInfo[idx].field_160) / totalAllocPoint != stor159:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            if not stor159 * (block.timestamp * 0 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4198 * poolInfo[idx].field_160) / totalAllocPoint:
                                                                _6626 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_6626] = 26
                                                                mem[_6626 + 32] = 'SafeMath: division by zero'
                                                                if not 10000 * poolInfo[idx].field_1024:
                                                                    _6914 = mem[64]
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 26
                                                                    idx = 0
                                                                    while idx < 26:
                                                                        mem[idx + _6914 + 68] = mem[idx + _6626 + 32]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    mem[_6914 + 94] = 0
                                                                    revert with memory
                                                                      from mem[64]
                                                                       len _6914 + -mem[64] + 100
                                                                if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                            else:
                                                                if poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4198 * poolInfo[idx].field_160) / totalAllocPoint / stor159 * (block.timestamp * 0 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4198 * poolInfo[idx].field_160) / totalAllocPoint != poolInfo[idx].field_992:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                _6913 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_6913] = 26
                                                                mem[_6913 + 32] = 'SafeMath: division by zero'
                                                                if not 10000 * poolInfo[idx].field_1024:
                                                                    _7189 = mem[64]
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 26
                                                                    idx = 0
                                                                    while idx < 26:
                                                                        mem[idx + _7189 + 68] = mem[idx + _6913 + 32]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    mem[_7189 + 94] = 0
                                                                    revert with memory
                                                                      from mem[64]
                                                                       len _7189 + -mem[64] + 100
                                                                if (poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4198 * poolInfo[idx].field_160) / totalAllocPoint / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_512 += poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4198 * poolInfo[idx].field_160) / totalAllocPoint / 10000 * poolInfo[idx].field_1024
                                            else:
                                                if (10000 * stor159 * (block.timestamp * 0 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4198 * poolInfo[idx].field_160) / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4198 * poolInfo[idx].field_160) / totalAllocPoint) / stor159 * (block.timestamp * 0 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4198 * poolInfo[idx].field_160) / totalAllocPoint != -poolInfo[idx].field_992 + 10000:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _4859 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_4859] = 26
                                                mem[_4859 + 32] = 'SafeMath: division by zero'
                                                if not 10000 * poolInfo[idx].field_1280:
                                                    _4948 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _4948 + 68] = mem[idx + _4859 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_4948 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _4948 + -mem[64] + 100
                                                if ((10000 * stor159 * (block.timestamp * 0 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4198 * poolInfo[idx].field_160) / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4198 * poolInfo[idx].field_160) / totalAllocPoint) / 10000 * poolInfo[idx].field_1280) + poolInfo[idx].field_256 < poolInfo[idx].field_256:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_256 += (10000 * stor159 * (block.timestamp * 0 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4198 * poolInfo[idx].field_160) / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4198 * poolInfo[idx].field_160) / totalAllocPoint) / 10000 * poolInfo[idx].field_1280
                                                if poolInfo[idx].field_992:
                                                    if poolInfo[idx].field_1024:
                                                        if not poolInfo[idx].field_1024:
                                                            if not (block.timestamp * 0 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4198 * poolInfo[idx].field_160) / totalAllocPoint:
                                                                _6346 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_6346] = 26
                                                                mem[_6346 + 32] = 'SafeMath: division by zero'
                                                                _6625 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                s = 0
                                                                while s < 26:
                                                                    mem[s + _6625 + 68] = mem[s + _6346 + 32]
                                                                    s = s + 32
                                                                    continue 
                                                                mem[_6625 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _6625 + -mem[64] + 100
                                                            if stor159 * (block.timestamp * 0 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4198 * poolInfo[idx].field_160) / totalAllocPoint / (block.timestamp * 0 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4198 * poolInfo[idx].field_160) / totalAllocPoint != stor159:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            if not stor159 * (block.timestamp * 0 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4198 * poolInfo[idx].field_160) / totalAllocPoint:
                                                                _6624 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_6624] = 26
                                                                mem[_6624 + 32] = 'SafeMath: division by zero'
                                                                _6911 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _6911 + 68] = mem[idx + _6624 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_6911 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _6911 + -mem[64] + 100
                                                            if poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4198 * poolInfo[idx].field_160) / totalAllocPoint / stor159 * (block.timestamp * 0 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4198 * poolInfo[idx].field_160) / totalAllocPoint != poolInfo[idx].field_992:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            _6910 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_6910] = 26
                                                            mem[_6910 + 32] = 'SafeMath: division by zero'
                                                            _7187 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _7187 + 68] = mem[idx + _6910 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_7187 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _7187 + -mem[64] + 100
                                                        if 10000 * poolInfo[idx].field_1024 / poolInfo[idx].field_1024 != 10000:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if not (block.timestamp * 0 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4198 * poolInfo[idx].field_160) / totalAllocPoint:
                                                            _6623 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_6623] = 26
                                                            mem[_6623 + 32] = 'SafeMath: division by zero'
                                                            if not 10000 * poolInfo[idx].field_1024:
                                                                _6909 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _6909 + 68] = mem[idx + _6623 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_6909 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _6909 + -mem[64] + 100
                                                            if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                        else:
                                                            if stor159 * (block.timestamp * 0 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4198 * poolInfo[idx].field_160) / totalAllocPoint / (block.timestamp * 0 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4198 * poolInfo[idx].field_160) / totalAllocPoint != stor159:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            if not stor159 * (block.timestamp * 0 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4198 * poolInfo[idx].field_160) / totalAllocPoint:
                                                                _6908 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_6908] = 26
                                                                mem[_6908 + 32] = 'SafeMath: division by zero'
                                                                if not 10000 * poolInfo[idx].field_1024:
                                                                    _7185 = mem[64]
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 26
                                                                    idx = 0
                                                                    while idx < 26:
                                                                        mem[idx + _7185 + 68] = mem[idx + _6908 + 32]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    mem[_7185 + 94] = 0
                                                                    revert with memory
                                                                      from mem[64]
                                                                       len _7185 + -mem[64] + 100
                                                                if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                            else:
                                                                if poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4198 * poolInfo[idx].field_160) / totalAllocPoint / stor159 * (block.timestamp * 0 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4198 * poolInfo[idx].field_160) / totalAllocPoint != poolInfo[idx].field_992:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                _7184 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_7184] = 26
                                                                mem[_7184 + 32] = 'SafeMath: division by zero'
                                                                if not 10000 * poolInfo[idx].field_1024:
                                                                    _7464 = mem[64]
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 26
                                                                    idx = 0
                                                                    while idx < 26:
                                                                        mem[idx + _7464 + 68] = mem[idx + _7184 + 32]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    mem[_7464 + 94] = 0
                                                                    revert with memory
                                                                      from mem[64]
                                                                       len _7464 + -mem[64] + 100
                                                                if (poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4198 * poolInfo[idx].field_160) / totalAllocPoint / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_512 += poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4198 * poolInfo[idx].field_160) / totalAllocPoint / 10000 * poolInfo[idx].field_1024
                            else:
                                if mem[_4212 + 32] * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 != mem[_4212 + 32]:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _4244 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4244] = 26
                                mem[_4244 + 32] = 'SafeMath: division by zero'
                                if not _4198:
                                    _4250 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _4250 + 68] = mem[idx + _4244 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4250 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4250 + -mem[64] + 100
                                if not block.timestamp - poolInfo[idx].field_768:
                                    _4300 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4300] = 26
                                    mem[_4300 + 32] = 'SafeMath: division by zero'
                                    if not totalAllocPoint:
                                        _4317 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _4317 + 68] = mem[idx + _4300 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_4317 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _4317 + -mem[64] + 100
                                    if not poolInfo[idx].field_1280:
                                        if not 0 / totalAllocPoint:
                                            _4526 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_4526] = 26
                                            mem[_4526 + 32] = 'SafeMath: division by zero'
                                            _4581 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _4581 + 68] = mem[idx + _4526 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_4581 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _4581 + -mem[64] + 100
                                        if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not stor159 * 0 / totalAllocPoint:
                                            _4580 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_4580] = 26
                                            mem[_4580 + 32] = 'SafeMath: division by zero'
                                            _4661 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _4661 + 68] = mem[idx + _4580 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_4661 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _4661 + -mem[64] + 100
                                        if (10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint) / stor159 * 0 / totalAllocPoint != -poolInfo[idx].field_992 + 10000:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _4660 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_4660] = 26
                                        mem[_4660 + 32] = 'SafeMath: division by zero'
                                        _4759 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _4759 + 68] = mem[idx + _4660 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_4759 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _4759 + -mem[64] + 100
                                    if 10000 * poolInfo[idx].field_1280 / poolInfo[idx].field_1280 != 10000:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not 0 / totalAllocPoint:
                                        _4579 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_4579] = 26
                                        mem[_4579 + 32] = 'SafeMath: division by zero'
                                        if not 10000 * poolInfo[idx].field_1280:
                                            _4659 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _4659 + 68] = mem[idx + _4579 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_4659 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _4659 + -mem[64] + 100
                                        if (0 / 10000 * poolInfo[idx].field_1280) + poolInfo[idx].field_256 < poolInfo[idx].field_256:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_256 += 0 / 10000 * poolInfo[idx].field_1280
                                        if poolInfo[idx].field_992:
                                            if poolInfo[idx].field_1024:
                                                if not poolInfo[idx].field_1024:
                                                    if not 0 / totalAllocPoint:
                                                        _5824 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_5824] = 26
                                                        mem[_5824 + 32] = 'SafeMath: division by zero'
                                                        _5940 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _5940 + 68] = mem[idx + _5824 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_5940 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _5940 + -mem[64] + 100
                                                    if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not stor159 * 0 / totalAllocPoint:
                                                        _5939 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_5939] = 26
                                                        mem[_5939 + 32] = 'SafeMath: division by zero'
                                                        _6110 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _6110 + 68] = mem[idx + _5939 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_6110 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _6110 + -mem[64] + 100
                                                    if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    _6109 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_6109] = 26
                                                    mem[_6109 + 32] = 'SafeMath: division by zero'
                                                    _6344 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _6344 + 68] = mem[idx + _6109 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_6344 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _6344 + -mem[64] + 100
                                                if 10000 * poolInfo[idx].field_1024 / poolInfo[idx].field_1024 != 10000:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not 0 / totalAllocPoint:
                                                    _5938 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_5938] = 26
                                                    mem[_5938 + 32] = 'SafeMath: division by zero'
                                                    if not 10000 * poolInfo[idx].field_1024:
                                                        _6108 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _6108 + 68] = mem[idx + _5938 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_6108 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _6108 + -mem[64] + 100
                                                    if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                else:
                                                    if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not stor159 * 0 / totalAllocPoint:
                                                        _6107 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_6107] = 26
                                                        mem[_6107 + 32] = 'SafeMath: division by zero'
                                                        if not 10000 * poolInfo[idx].field_1024:
                                                            _6342 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _6342 + 68] = mem[idx + _6107 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_6342 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _6342 + -mem[64] + 100
                                                        if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                    else:
                                                        if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _6341 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_6341] = 26
                                                        mem[_6341 + 32] = 'SafeMath: division by zero'
                                                        if not 10000 * poolInfo[idx].field_1024:
                                                            _6620 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            s = 0
                                                            while s < 26:
                                                                mem[s + _6620 + 68] = mem[s + _6341 + 32]
                                                                s = s + 32
                                                                continue 
                                                            mem[_6620 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _6620 + -mem[64] + 100
                                                        if (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_512 += poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024
                                    else:
                                        if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not stor159 * 0 / totalAllocPoint:
                                            _4658 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_4658] = 26
                                            mem[_4658 + 32] = 'SafeMath: division by zero'
                                            if not 10000 * poolInfo[idx].field_1280:
                                                _4757 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _4757 + 68] = mem[idx + _4658 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_4757 + 94] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _4757 + -mem[64] + 100
                                            if (0 / 10000 * poolInfo[idx].field_1280) + poolInfo[idx].field_256 < poolInfo[idx].field_256:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_256 += 0 / 10000 * poolInfo[idx].field_1280
                                            if poolInfo[idx].field_992:
                                                if poolInfo[idx].field_1024:
                                                    if not poolInfo[idx].field_1024:
                                                        if not 0 / totalAllocPoint:
                                                            _5937 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_5937] = 26
                                                            mem[_5937 + 32] = 'SafeMath: division by zero'
                                                            _6106 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _6106 + 68] = mem[idx + _5937 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_6106 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _6106 + -mem[64] + 100
                                                        if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if not stor159 * 0 / totalAllocPoint:
                                                            _6105 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_6105] = 26
                                                            mem[_6105 + 32] = 'SafeMath: division by zero'
                                                            _6339 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _6339 + 68] = mem[idx + _6105 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_6339 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _6339 + -mem[64] + 100
                                                        if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _6338 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_6338] = 26
                                                        mem[_6338 + 32] = 'SafeMath: division by zero'
                                                        _6618 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        s = 0
                                                        while s < 26:
                                                            mem[s + _6618 + 68] = mem[s + _6338 + 32]
                                                            s = s + 32
                                                            continue 
                                                        mem[_6618 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _6618 + -mem[64] + 100
                                                    if 10000 * poolInfo[idx].field_1024 / poolInfo[idx].field_1024 != 10000:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not 0 / totalAllocPoint:
                                                        _6104 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_6104] = 26
                                                        mem[_6104 + 32] = 'SafeMath: division by zero'
                                                        if not 10000 * poolInfo[idx].field_1024:
                                                            _6337 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _6337 + 68] = mem[idx + _6104 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_6337 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _6337 + -mem[64] + 100
                                                        if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                    else:
                                                        if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if not stor159 * 0 / totalAllocPoint:
                                                            _6336 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_6336] = 26
                                                            mem[_6336 + 32] = 'SafeMath: division by zero'
                                                            if not 10000 * poolInfo[idx].field_1024:
                                                                _6616 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                s = 0
                                                                while s < 26:
                                                                    mem[s + _6616 + 68] = mem[s + _6336 + 32]
                                                                    s = s + 32
                                                                    continue 
                                                                mem[_6616 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _6616 + -mem[64] + 100
                                                            if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                        else:
                                                            if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            _6615 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_6615] = 26
                                                            mem[_6615 + 32] = 'SafeMath: division by zero'
                                                            if not 10000 * poolInfo[idx].field_1024:
                                                                _6903 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _6903 + 68] = mem[idx + _6615 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_6903 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _6903 + -mem[64] + 100
                                                            if (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_512 += poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024
                                        else:
                                            if (10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint) / stor159 * 0 / totalAllocPoint != -poolInfo[idx].field_992 + 10000:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _4756 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_4756] = 26
                                            mem[_4756 + 32] = 'SafeMath: division by zero'
                                            if not 10000 * poolInfo[idx].field_1280:
                                                _4856 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _4856 + 68] = mem[idx + _4756 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_4856 + 94] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _4856 + -mem[64] + 100
                                            if ((10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint) / 10000 * poolInfo[idx].field_1280) + poolInfo[idx].field_256 < poolInfo[idx].field_256:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_256 += (10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint) / 10000 * poolInfo[idx].field_1280
                                            if poolInfo[idx].field_992:
                                                if poolInfo[idx].field_1024:
                                                    if not poolInfo[idx].field_1024:
                                                        if not 0 / totalAllocPoint:
                                                            _6103 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_6103] = 26
                                                            mem[_6103 + 32] = 'SafeMath: division by zero'
                                                            _6335 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _6335 + 68] = mem[idx + _6103 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_6335 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _6335 + -mem[64] + 100
                                                        if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if not stor159 * 0 / totalAllocPoint:
                                                            _6334 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_6334] = 26
                                                            mem[_6334 + 32] = 'SafeMath: division by zero'
                                                            _6613 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            s = 0
                                                            while s < 26:
                                                                mem[s + _6613 + 68] = mem[s + _6334 + 32]
                                                                s = s + 32
                                                                continue 
                                                            mem[_6613 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _6613 + -mem[64] + 100
                                                        if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _6612 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_6612] = 26
                                                        mem[_6612 + 32] = 'SafeMath: division by zero'
                                                        _6901 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _6901 + 68] = mem[idx + _6612 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_6901 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _6901 + -mem[64] + 100
                                                    if 10000 * poolInfo[idx].field_1024 / poolInfo[idx].field_1024 != 10000:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not 0 / totalAllocPoint:
                                                        _6333 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_6333] = 26
                                                        mem[_6333 + 32] = 'SafeMath: division by zero'
                                                        if not 10000 * poolInfo[idx].field_1024:
                                                            _6611 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            s = 0
                                                            while s < 26:
                                                                mem[s + _6611 + 68] = mem[s + _6333 + 32]
                                                                s = s + 32
                                                                continue 
                                                            mem[_6611 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _6611 + -mem[64] + 100
                                                        if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                    else:
                                                        if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if not stor159 * 0 / totalAllocPoint:
                                                            _6610 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_6610] = 26
                                                            mem[_6610 + 32] = 'SafeMath: division by zero'
                                                            if not 10000 * poolInfo[idx].field_1024:
                                                                _6899 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _6899 + 68] = mem[idx + _6610 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_6899 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _6899 + -mem[64] + 100
                                                            if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                        else:
                                                            if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            _6898 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_6898] = 26
                                                            mem[_6898 + 32] = 'SafeMath: division by zero'
                                                            if not 10000 * poolInfo[idx].field_1024:
                                                                _7175 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _7175 + 68] = mem[idx + _6898 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_7175 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _7175 + -mem[64] + 100
                                                            if (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_512 += poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024
                                else:
                                    if (block.timestamp * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198) - (poolInfo[idx].field_768 * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198) / block.timestamp - poolInfo[idx].field_768 != _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not (block.timestamp * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198) - (poolInfo[idx].field_768 * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198):
                                        _4316 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_4316] = 26
                                        mem[_4316 + 32] = 'SafeMath: division by zero'
                                        if not totalAllocPoint:
                                            _4335 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _4335 + 68] = mem[idx + _4316 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_4335 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _4335 + -mem[64] + 100
                                        if not poolInfo[idx].field_1280:
                                            if not 0 / totalAllocPoint:
                                                _4578 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_4578] = 26
                                                mem[_4578 + 32] = 'SafeMath: division by zero'
                                                _4657 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _4657 + 68] = mem[idx + _4578 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_4657 + 94] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _4657 + -mem[64] + 100
                                            if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if not stor159 * 0 / totalAllocPoint:
                                                _4656 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_4656] = 26
                                                mem[_4656 + 32] = 'SafeMath: division by zero'
                                                _4754 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _4754 + 68] = mem[idx + _4656 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_4754 + 94] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _4754 + -mem[64] + 100
                                            if (10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint) / stor159 * 0 / totalAllocPoint != -poolInfo[idx].field_992 + 10000:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _4753 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_4753] = 26
                                            mem[_4753 + 32] = 'SafeMath: division by zero'
                                            _4854 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _4854 + 68] = mem[idx + _4753 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_4854 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _4854 + -mem[64] + 100
                                        if 10000 * poolInfo[idx].field_1280 / poolInfo[idx].field_1280 != 10000:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not 0 / totalAllocPoint:
                                            _4655 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_4655] = 26
                                            mem[_4655 + 32] = 'SafeMath: division by zero'
                                            if not 10000 * poolInfo[idx].field_1280:
                                                _4752 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _4752 + 68] = mem[idx + _4655 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_4752 + 94] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _4752 + -mem[64] + 100
                                            if (0 / 10000 * poolInfo[idx].field_1280) + poolInfo[idx].field_256 < poolInfo[idx].field_256:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_256 += 0 / 10000 * poolInfo[idx].field_1280
                                            if poolInfo[idx].field_992:
                                                if poolInfo[idx].field_1024:
                                                    if not poolInfo[idx].field_1024:
                                                        if not 0 / totalAllocPoint:
                                                            _5936 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_5936] = 26
                                                            mem[_5936 + 32] = 'SafeMath: division by zero'
                                                            _6102 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _6102 + 68] = mem[idx + _5936 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_6102 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _6102 + -mem[64] + 100
                                                        if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if not stor159 * 0 / totalAllocPoint:
                                                            _6101 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_6101] = 26
                                                            mem[_6101 + 32] = 'SafeMath: division by zero'
                                                            _6331 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _6331 + 68] = mem[idx + _6101 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_6331 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _6331 + -mem[64] + 100
                                                        if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _6330 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_6330] = 26
                                                        mem[_6330 + 32] = 'SafeMath: division by zero'
                                                        _6608 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        s = 0
                                                        while s < 26:
                                                            mem[s + _6608 + 68] = mem[s + _6330 + 32]
                                                            s = s + 32
                                                            continue 
                                                        mem[_6608 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _6608 + -mem[64] + 100
                                                    if 10000 * poolInfo[idx].field_1024 / poolInfo[idx].field_1024 != 10000:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not 0 / totalAllocPoint:
                                                        _6100 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_6100] = 26
                                                        mem[_6100 + 32] = 'SafeMath: division by zero'
                                                        if not 10000 * poolInfo[idx].field_1024:
                                                            _6329 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _6329 + 68] = mem[idx + _6100 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_6329 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _6329 + -mem[64] + 100
                                                        if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                    else:
                                                        if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if not stor159 * 0 / totalAllocPoint:
                                                            _6328 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_6328] = 26
                                                            mem[_6328 + 32] = 'SafeMath: division by zero'
                                                            if not 10000 * poolInfo[idx].field_1024:
                                                                _6606 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                s = 0
                                                                while s < 26:
                                                                    mem[s + _6606 + 68] = mem[s + _6328 + 32]
                                                                    s = s + 32
                                                                    continue 
                                                                mem[_6606 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _6606 + -mem[64] + 100
                                                            if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                        else:
                                                            if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            _6605 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_6605] = 26
                                                            mem[_6605 + 32] = 'SafeMath: division by zero'
                                                            if not 10000 * poolInfo[idx].field_1024:
                                                                _6895 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _6895 + 68] = mem[idx + _6605 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_6895 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _6895 + -mem[64] + 100
                                                            if (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_512 += poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024
                                        else:
                                            if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if not stor159 * 0 / totalAllocPoint:
                                                _4751 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_4751] = 26
                                                mem[_4751 + 32] = 'SafeMath: division by zero'
                                                if not 10000 * poolInfo[idx].field_1280:
                                                    _4852 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _4852 + 68] = mem[idx + _4751 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_4852 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _4852 + -mem[64] + 100
                                                if (0 / 10000 * poolInfo[idx].field_1280) + poolInfo[idx].field_256 < poolInfo[idx].field_256:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_256 += 0 / 10000 * poolInfo[idx].field_1280
                                                if poolInfo[idx].field_992:
                                                    if poolInfo[idx].field_1024:
                                                        if not poolInfo[idx].field_1024:
                                                            if not 0 / totalAllocPoint:
                                                                _6099 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_6099] = 26
                                                                mem[_6099 + 32] = 'SafeMath: division by zero'
                                                                _6327 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _6327 + 68] = mem[idx + _6099 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_6327 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _6327 + -mem[64] + 100
                                                            if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            if not stor159 * 0 / totalAllocPoint:
                                                                _6326 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_6326] = 26
                                                                mem[_6326 + 32] = 'SafeMath: division by zero'
                                                                _6603 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                s = 0
                                                                while s < 26:
                                                                    mem[s + _6603 + 68] = mem[s + _6326 + 32]
                                                                    s = s + 32
                                                                    continue 
                                                                mem[_6603 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _6603 + -mem[64] + 100
                                                            if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            _6602 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_6602] = 26
                                                            mem[_6602 + 32] = 'SafeMath: division by zero'
                                                            _6893 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _6893 + 68] = mem[idx + _6602 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_6893 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _6893 + -mem[64] + 100
                                                        if 10000 * poolInfo[idx].field_1024 / poolInfo[idx].field_1024 != 10000:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if not 0 / totalAllocPoint:
                                                            _6325 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_6325] = 26
                                                            mem[_6325 + 32] = 'SafeMath: division by zero'
                                                            if not 10000 * poolInfo[idx].field_1024:
                                                                _6601 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                s = 0
                                                                while s < 26:
                                                                    mem[s + _6601 + 68] = mem[s + _6325 + 32]
                                                                    s = s + 32
                                                                    continue 
                                                                mem[_6601 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _6601 + -mem[64] + 100
                                                            if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                        else:
                                                            if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            if not stor159 * 0 / totalAllocPoint:
                                                                _6600 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_6600] = 26
                                                                mem[_6600 + 32] = 'SafeMath: division by zero'
                                                                if not 10000 * poolInfo[idx].field_1024:
                                                                    _6891 = mem[64]
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 26
                                                                    idx = 0
                                                                    while idx < 26:
                                                                        mem[idx + _6891 + 68] = mem[idx + _6600 + 32]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    mem[_6891 + 94] = 0
                                                                    revert with memory
                                                                      from mem[64]
                                                                       len _6891 + -mem[64] + 100
                                                                if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                            else:
                                                                if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                _6890 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_6890] = 26
                                                                mem[_6890 + 32] = 'SafeMath: division by zero'
                                                                if not 10000 * poolInfo[idx].field_1024:
                                                                    _7170 = mem[64]
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 26
                                                                    idx = 0
                                                                    while idx < 26:
                                                                        mem[idx + _7170 + 68] = mem[idx + _6890 + 32]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    mem[_7170 + 94] = 0
                                                                    revert with memory
                                                                      from mem[64]
                                                                       len _7170 + -mem[64] + 100
                                                                if (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_512 += poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024
                                            else:
                                                if (10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint) / stor159 * 0 / totalAllocPoint != -poolInfo[idx].field_992 + 10000:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _4851 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_4851] = 26
                                                mem[_4851 + 32] = 'SafeMath: division by zero'
                                                if not 10000 * poolInfo[idx].field_1280:
                                                    _4943 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _4943 + 68] = mem[idx + _4851 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_4943 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _4943 + -mem[64] + 100
                                                if ((10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint) / 10000 * poolInfo[idx].field_1280) + poolInfo[idx].field_256 < poolInfo[idx].field_256:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_256 += (10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint) / 10000 * poolInfo[idx].field_1280
                                                if poolInfo[idx].field_992:
                                                    if poolInfo[idx].field_1024:
                                                        if not poolInfo[idx].field_1024:
                                                            if not 0 / totalAllocPoint:
                                                                _6324 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_6324] = 26
                                                                mem[_6324 + 32] = 'SafeMath: division by zero'
                                                                _6599 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                s = 0
                                                                while s < 26:
                                                                    mem[s + _6599 + 68] = mem[s + _6324 + 32]
                                                                    s = s + 32
                                                                    continue 
                                                                mem[_6599 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _6599 + -mem[64] + 100
                                                            if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            if not stor159 * 0 / totalAllocPoint:
                                                                _6598 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_6598] = 26
                                                                mem[_6598 + 32] = 'SafeMath: division by zero'
                                                                _6888 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _6888 + 68] = mem[idx + _6598 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_6888 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _6888 + -mem[64] + 100
                                                            if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            _6887 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_6887] = 26
                                                            mem[_6887 + 32] = 'SafeMath: division by zero'
                                                            _7168 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _7168 + 68] = mem[idx + _6887 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_7168 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _7168 + -mem[64] + 100
                                                        if 10000 * poolInfo[idx].field_1024 / poolInfo[idx].field_1024 != 10000:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if not 0 / totalAllocPoint:
                                                            _6597 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_6597] = 26
                                                            mem[_6597 + 32] = 'SafeMath: division by zero'
                                                            if not 10000 * poolInfo[idx].field_1024:
                                                                _6886 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _6886 + 68] = mem[idx + _6597 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_6886 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _6886 + -mem[64] + 100
                                                            if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                        else:
                                                            if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            if not stor159 * 0 / totalAllocPoint:
                                                                _6885 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_6885] = 26
                                                                mem[_6885 + 32] = 'SafeMath: division by zero'
                                                                if not 10000 * poolInfo[idx].field_1024:
                                                                    _7166 = mem[64]
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 26
                                                                    idx = 0
                                                                    while idx < 26:
                                                                        mem[idx + _7166 + 68] = mem[idx + _6885 + 32]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    mem[_7166 + 94] = 0
                                                                    revert with memory
                                                                      from mem[64]
                                                                       len _7166 + -mem[64] + 100
                                                                if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                            else:
                                                                if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                _7165 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_7165] = 26
                                                                mem[_7165 + 32] = 'SafeMath: division by zero'
                                                                if not 10000 * poolInfo[idx].field_1024:
                                                                    _7442 = mem[64]
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 26
                                                                    idx = 0
                                                                    while idx < 26:
                                                                        mem[idx + _7442 + 68] = mem[idx + _7165 + 32]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    mem[_7442 + 94] = 0
                                                                    revert with memory
                                                                      from mem[64]
                                                                       len _7442 + -mem[64] + 100
                                                                if (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_512 += poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024
                                    else:
                                        if (block.timestamp * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) / (block.timestamp * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198) - (poolInfo[idx].field_768 * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198) != poolInfo[idx].field_160:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _4334 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_4334] = 26
                                        mem[_4334 + 32] = 'SafeMath: division by zero'
                                        if not totalAllocPoint:
                                            _4350 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _4350 + 68] = mem[idx + _4334 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_4350 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _4350 + -mem[64] + 100
                                        if not poolInfo[idx].field_1280:
                                            if not (block.timestamp * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) / totalAllocPoint:
                                                _4654 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_4654] = 26
                                                mem[_4654 + 32] = 'SafeMath: division by zero'
                                                _4750 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _4750 + 68] = mem[idx + _4654 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_4750 + 94] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _4750 + -mem[64] + 100
                                            if stor159 * (block.timestamp * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) / totalAllocPoint / (block.timestamp * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) / totalAllocPoint != stor159:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if not stor159 * (block.timestamp * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) / totalAllocPoint:
                                                _4749 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_4749] = 26
                                                mem[_4749 + 32] = 'SafeMath: division by zero'
                                                _4849 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _4849 + 68] = mem[idx + _4749 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_4849 + 94] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _4849 + -mem[64] + 100
                                            if (10000 * stor159 * (block.timestamp * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * (block.timestamp * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) / totalAllocPoint) / stor159 * (block.timestamp * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) / totalAllocPoint != -poolInfo[idx].field_992 + 10000:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _4848 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_4848] = 26
                                            mem[_4848 + 32] = 'SafeMath: division by zero'
                                            _4941 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _4941 + 68] = mem[idx + _4848 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_4941 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _4941 + -mem[64] + 100
                                        if 10000 * poolInfo[idx].field_1280 / poolInfo[idx].field_1280 != 10000:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not (block.timestamp * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) / totalAllocPoint:
                                            _4748 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_4748] = 26
                                            mem[_4748 + 32] = 'SafeMath: division by zero'
                                            if not 10000 * poolInfo[idx].field_1280:
                                                _4847 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _4847 + 68] = mem[idx + _4748 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_4847 + 94] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _4847 + -mem[64] + 100
                                            if (0 / 10000 * poolInfo[idx].field_1280) + poolInfo[idx].field_256 < poolInfo[idx].field_256:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_256 += 0 / 10000 * poolInfo[idx].field_1280
                                            if poolInfo[idx].field_992:
                                                if poolInfo[idx].field_1024:
                                                    if not poolInfo[idx].field_1024:
                                                        if not (block.timestamp * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) / totalAllocPoint:
                                                            _6098 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_6098] = 26
                                                            mem[_6098 + 32] = 'SafeMath: division by zero'
                                                            _6323 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _6323 + 68] = mem[idx + _6098 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_6323 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _6323 + -mem[64] + 100
                                                        if stor159 * (block.timestamp * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) / totalAllocPoint / (block.timestamp * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) / totalAllocPoint != stor159:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if not stor159 * (block.timestamp * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) / totalAllocPoint:
                                                            _6322 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_6322] = 26
                                                            mem[_6322 + 32] = 'SafeMath: division by zero'
                                                            _6595 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            s = 0
                                                            while s < 26:
                                                                mem[s + _6595 + 68] = mem[s + _6322 + 32]
                                                                s = s + 32
                                                                continue 
                                                            mem[_6595 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _6595 + -mem[64] + 100
                                                        if poolInfo[idx].field_992 * stor159 * (block.timestamp * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) / totalAllocPoint / stor159 * (block.timestamp * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) / totalAllocPoint != poolInfo[idx].field_992:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _6594 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_6594] = 26
                                                        mem[_6594 + 32] = 'SafeMath: division by zero'
                                                        _6883 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _6883 + 68] = mem[idx + _6594 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_6883 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _6883 + -mem[64] + 100
                                                    if 10000 * poolInfo[idx].field_1024 / poolInfo[idx].field_1024 != 10000:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not (block.timestamp * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) / totalAllocPoint:
                                                        _6321 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_6321] = 26
                                                        mem[_6321 + 32] = 'SafeMath: division by zero'
                                                        if not 10000 * poolInfo[idx].field_1024:
                                                            _6593 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            s = 0
                                                            while s < 26:
                                                                mem[s + _6593 + 68] = mem[s + _6321 + 32]
                                                                s = s + 32
                                                                continue 
                                                            mem[_6593 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _6593 + -mem[64] + 100
                                                        if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                    else:
                                                        if stor159 * (block.timestamp * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) / totalAllocPoint / (block.timestamp * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) / totalAllocPoint != stor159:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if not stor159 * (block.timestamp * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) / totalAllocPoint:
                                                            _6592 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_6592] = 26
                                                            mem[_6592 + 32] = 'SafeMath: division by zero'
                                                            if not 10000 * poolInfo[idx].field_1024:
                                                                _6881 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _6881 + 68] = mem[idx + _6592 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_6881 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _6881 + -mem[64] + 100
                                                            if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                        else:
                                                            if poolInfo[idx].field_992 * stor159 * (block.timestamp * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) / totalAllocPoint / stor159 * (block.timestamp * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) / totalAllocPoint != poolInfo[idx].field_992:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            _6880 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_6880] = 26
                                                            mem[_6880 + 32] = 'SafeMath: division by zero'
                                                            if not 10000 * poolInfo[idx].field_1024:
                                                                _7162 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _7162 + 68] = mem[idx + _6880 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_7162 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _7162 + -mem[64] + 100
                                                            if (poolInfo[idx].field_992 * stor159 * (block.timestamp * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) / totalAllocPoint / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_512 += poolInfo[idx].field_992 * stor159 * (block.timestamp * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) / totalAllocPoint / 10000 * poolInfo[idx].field_1024
                                        else:
                                            if stor159 * (block.timestamp * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) / totalAllocPoint / (block.timestamp * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) / totalAllocPoint != stor159:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if not stor159 * (block.timestamp * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) / totalAllocPoint:
                                                _4846 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_4846] = 26
                                                mem[_4846 + 32] = 'SafeMath: division by zero'
                                                if not 10000 * poolInfo[idx].field_1280:
                                                    _4939 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _4939 + 68] = mem[idx + _4846 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_4939 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _4939 + -mem[64] + 100
                                                if (0 / 10000 * poolInfo[idx].field_1280) + poolInfo[idx].field_256 < poolInfo[idx].field_256:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_256 += 0 / 10000 * poolInfo[idx].field_1280
                                                if poolInfo[idx].field_992:
                                                    if poolInfo[idx].field_1024:
                                                        if not poolInfo[idx].field_1024:
                                                            if not (block.timestamp * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) / totalAllocPoint:
                                                                _6320 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_6320] = 26
                                                                mem[_6320 + 32] = 'SafeMath: division by zero'
                                                                _6591 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                s = 0
                                                                while s < 26:
                                                                    mem[s + _6591 + 68] = mem[s + _6320 + 32]
                                                                    s = s + 32
                                                                    continue 
                                                                mem[_6591 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _6591 + -mem[64] + 100
                                                            if stor159 * (block.timestamp * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) / totalAllocPoint / (block.timestamp * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) / totalAllocPoint != stor159:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            if not stor159 * (block.timestamp * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) / totalAllocPoint:
                                                                _6590 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_6590] = 26
                                                                mem[_6590 + 32] = 'SafeMath: division by zero'
                                                                _6878 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _6878 + 68] = mem[idx + _6590 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_6878 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _6878 + -mem[64] + 100
                                                            if poolInfo[idx].field_992 * stor159 * (block.timestamp * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) / totalAllocPoint / stor159 * (block.timestamp * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) / totalAllocPoint != poolInfo[idx].field_992:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            _6877 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_6877] = 26
                                                            mem[_6877 + 32] = 'SafeMath: division by zero'
                                                            _7160 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _7160 + 68] = mem[idx + _6877 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_7160 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _7160 + -mem[64] + 100
                                                        if 10000 * poolInfo[idx].field_1024 / poolInfo[idx].field_1024 != 10000:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if not (block.timestamp * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) / totalAllocPoint:
                                                            _6589 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_6589] = 26
                                                            mem[_6589 + 32] = 'SafeMath: division by zero'
                                                            if not 10000 * poolInfo[idx].field_1024:
                                                                _6876 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _6876 + 68] = mem[idx + _6589 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_6876 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _6876 + -mem[64] + 100
                                                            if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                        else:
                                                            if stor159 * (block.timestamp * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) / totalAllocPoint / (block.timestamp * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) / totalAllocPoint != stor159:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            if not stor159 * (block.timestamp * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) / totalAllocPoint:
                                                                _6875 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_6875] = 26
                                                                mem[_6875 + 32] = 'SafeMath: division by zero'
                                                                if not 10000 * poolInfo[idx].field_1024:
                                                                    _7158 = mem[64]
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 26
                                                                    idx = 0
                                                                    while idx < 26:
                                                                        mem[idx + _7158 + 68] = mem[idx + _6875 + 32]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    mem[_7158 + 94] = 0
                                                                    revert with memory
                                                                      from mem[64]
                                                                       len _7158 + -mem[64] + 100
                                                                if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                            else:
                                                                if poolInfo[idx].field_992 * stor159 * (block.timestamp * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) / totalAllocPoint / stor159 * (block.timestamp * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) / totalAllocPoint != poolInfo[idx].field_992:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                _7157 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_7157] = 26
                                                                mem[_7157 + 32] = 'SafeMath: division by zero'
                                                                if not 10000 * poolInfo[idx].field_1024:
                                                                    _7437 = mem[64]
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 26
                                                                    idx = 0
                                                                    while idx < 26:
                                                                        mem[idx + _7437 + 68] = mem[idx + _7157 + 32]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    mem[_7437 + 94] = 0
                                                                    revert with memory
                                                                      from mem[64]
                                                                       len _7437 + -mem[64] + 100
                                                                if (poolInfo[idx].field_992 * stor159 * (block.timestamp * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) / totalAllocPoint / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_512 += poolInfo[idx].field_992 * stor159 * (block.timestamp * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) / totalAllocPoint / 10000 * poolInfo[idx].field_1024
                                            else:
                                                if (10000 * stor159 * (block.timestamp * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * (block.timestamp * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) / totalAllocPoint) / stor159 * (block.timestamp * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) / totalAllocPoint != -poolInfo[idx].field_992 + 10000:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _4938 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_4938] = 26
                                                mem[_4938 + 32] = 'SafeMath: division by zero'
                                                if not 10000 * poolInfo[idx].field_1280:
                                                    _5028 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _5028 + 68] = mem[idx + _4938 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_5028 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _5028 + -mem[64] + 100
                                                if ((10000 * stor159 * (block.timestamp * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * (block.timestamp * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) / totalAllocPoint) / 10000 * poolInfo[idx].field_1280) + poolInfo[idx].field_256 < poolInfo[idx].field_256:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_256 += (10000 * stor159 * (block.timestamp * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * (block.timestamp * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) / totalAllocPoint) / 10000 * poolInfo[idx].field_1280
                                                if poolInfo[idx].field_992:
                                                    if poolInfo[idx].field_1024:
                                                        if not poolInfo[idx].field_1024:
                                                            if not (block.timestamp * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) / totalAllocPoint:
                                                                _6588 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_6588] = 26
                                                                mem[_6588 + 32] = 'SafeMath: division by zero'
                                                                _6874 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _6874 + 68] = mem[idx + _6588 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_6874 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _6874 + -mem[64] + 100
                                                            if stor159 * (block.timestamp * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) / totalAllocPoint / (block.timestamp * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) / totalAllocPoint != stor159:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            if not stor159 * (block.timestamp * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) / totalAllocPoint:
                                                                _6873 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_6873] = 26
                                                                mem[_6873 + 32] = 'SafeMath: division by zero'
                                                                _7155 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _7155 + 68] = mem[idx + _6873 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_7155 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _7155 + -mem[64] + 100
                                                            if poolInfo[idx].field_992 * stor159 * (block.timestamp * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) / totalAllocPoint / stor159 * (block.timestamp * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) / totalAllocPoint != poolInfo[idx].field_992:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            _7154 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_7154] = 26
                                                            mem[_7154 + 32] = 'SafeMath: division by zero'
                                                            _7435 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _7435 + 68] = mem[idx + _7154 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_7435 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _7435 + -mem[64] + 100
                                                        if 10000 * poolInfo[idx].field_1024 / poolInfo[idx].field_1024 != 10000:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if not (block.timestamp * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) / totalAllocPoint:
                                                            _6872 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_6872] = 26
                                                            mem[_6872 + 32] = 'SafeMath: division by zero'
                                                            if not 10000 * poolInfo[idx].field_1024:
                                                                _7153 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _7153 + 68] = mem[idx + _6872 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_7153 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _7153 + -mem[64] + 100
                                                            if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                        else:
                                                            if stor159 * (block.timestamp * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) / totalAllocPoint / (block.timestamp * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) / totalAllocPoint != stor159:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            if not stor159 * (block.timestamp * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) / totalAllocPoint:
                                                                _7152 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_7152] = 26
                                                                mem[_7152 + 32] = 'SafeMath: division by zero'
                                                                if not 10000 * poolInfo[idx].field_1024:
                                                                    _7433 = mem[64]
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 26
                                                                    idx = 0
                                                                    while idx < 26:
                                                                        mem[idx + _7433 + 68] = mem[idx + _7152 + 32]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    mem[_7433 + 94] = 0
                                                                    revert with memory
                                                                      from mem[64]
                                                                       len _7433 + -mem[64] + 100
                                                                if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                            else:
                                                                if poolInfo[idx].field_992 * stor159 * (block.timestamp * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) / totalAllocPoint / stor159 * (block.timestamp * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) / totalAllocPoint != poolInfo[idx].field_992:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                _7432 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_7432] = 26
                                                                mem[_7432 + 32] = 'SafeMath: division by zero'
                                                                if not 10000 * poolInfo[idx].field_1024:
                                                                    _7726 = mem[64]
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 26
                                                                    idx = 0
                                                                    while idx < 26:
                                                                        mem[idx + _7726 + 68] = mem[idx + _7432 + 32]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    mem[_7726 + 94] = 0
                                                                    revert with memory
                                                                      from mem[64]
                                                                       len _7726 + -mem[64] + 100
                                                                if (poolInfo[idx].field_992 * stor159 * (block.timestamp * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) / totalAllocPoint / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_512 += poolInfo[idx].field_992 * stor159 * (block.timestamp * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4232 * (1000 * _4168) - (_4128 * _4168) - (_4120 * _4168) - (_4112 * _4168) / 1000 / _4198 * poolInfo[idx].field_160) / totalAllocPoint / 10000 * poolInfo[idx].field_1024
                poolInfo[idx].field_768 = uint64(block.timestamp)
                mem[mem[64]] = uint64(block.timestamp)
                mem[mem[64] + 32] = poolInfo[idx].field_1280
                mem[mem[64] + 64] = poolInfo[idx].field_256
                mem[mem[64] + 96] = poolInfo[idx].field_512
                emit UpdatePool(block.timestamp << 192, poolInfo[idx].field_1280, poolInfo[idx].field_256, poolInfo[idx].field_512, idx);
            idx = idx + 1
            continue 
    else:
        mem[ceil32(return_data.size) + 96] = 0x1a7af8b000000000000000000000000000000000000000000000000000000000
        mem[ceil32(return_data.size) + 100] = 0
        mem[ceil32(return_data.size) + 132] = 0
        require ext_code.size(address(arg4))
        call address(arg4).onJoeReward(address arg1, uint256 arg2) with:
             gas gas_remaining wei
            args 0
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        idx = 0
        while idx < poolInfo.length:
            mem[0] = 155
            if poolInfo[idx].field_768 < block.timestamp:
                if poolInfo[idx].field_1280:
                    if poolInfo[idx].field_160:
                        require ext_code.size(address(MASTER_CHEF_V2Address))
                        staticcall address(MASTER_CHEF_V2Address).investorPercent() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _4111 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _4113 = mem[_4111]
                        require ext_code.size(address(MASTER_CHEF_V2Address))
                        staticcall address(MASTER_CHEF_V2Address).treasuryPercent() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _4119 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _4121 = mem[_4119]
                        require ext_code.size(address(MASTER_CHEF_V2Address))
                        staticcall address(MASTER_CHEF_V2Address).devPercent() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _4127 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _4129 = mem[_4127]
                        _4131 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4131] = 30
                        mem[_4131 + 32] = 'SafeMath: subtraction overflow'
                        if _4129 > 1000:
                            _4133 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _4133 + 68] = mem[idx + _4131 + 32]
                                idx = idx + 32
                                continue 
                            mem[_4133 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _4133 + -mem[64] + 100
                        _4137 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4137] = 30
                        mem[_4137 + 32] = 'SafeMath: subtraction overflow'
                        if _4121 > -_4129 + 1000:
                            _4141 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _4141 + 68] = mem[idx + _4137 + 32]
                                idx = idx + 32
                                continue 
                            mem[_4141 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _4141 + -mem[64] + 100
                        _4147 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4147] = 30
                        mem[_4147 + 32] = 'SafeMath: subtraction overflow'
                        if _4113 > -_4129 + -_4121 + 1000:
                            _4153 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _4153 + 68] = mem[idx + _4147 + 32]
                                idx = idx + 32
                                continue 
                            mem[_4153 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _4153 + -mem[64] + 100
                        require ext_code.size(address(MASTER_CHEF_V2Address))
                        staticcall address(MASTER_CHEF_V2Address).0xca418d23 with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _4166 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _4169 = mem[_4166]
                        if not mem[_4166]:
                            _4177 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4177] = 26
                            mem[_4177 + 32] = 'SafeMath: division by zero'
                            require ext_code.size(address(MASTER_CHEF_V2Address))
                            staticcall address(MASTER_CHEF_V2Address).0x17caf6f1 with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _4191 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _4195 = mem[_4191]
                            require ext_code.size(address(MASTER_CHEF_V2Address))
                            staticcall address(MASTER_CHEF_V2Address).0x1526fe27 with:
                                    gas gas_remaining wei
                                   args MASTER_PID
                            mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _4207 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 128
                            _4211 = mem[64]
                            require mem[64] + 128 >= mem[64] and mem[64] + 128 <= test266151307()
                            mem[64] = mem[64] + 128
                            require mem[_4207] == mem[_4207 + 12 len 20]
                            mem[_4211] = mem[_4207]
                            mem[_4211 + 32] = mem[_4207 + 32]
                            mem[_4211 + 64] = mem[_4207 + 64]
                            mem[_4211 + 96] = mem[_4207 + 96]
                            _4235 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4235] = 26
                            mem[_4235 + 32] = 'SafeMath: division by zero'
                            if not _4195:
                                _4241 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _4241 + 68] = mem[idx + _4235 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4241 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _4241 + -mem[64] + 100
                            if not block.timestamp - poolInfo[idx].field_768:
                                _4285 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4285] = 26
                                mem[_4285 + 32] = 'SafeMath: division by zero'
                                if not totalAllocPoint:
                                    _4295 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _4295 + 68] = mem[idx + _4285 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4295 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4295 + -mem[64] + 100
                                if not poolInfo[idx].field_1280:
                                    if not 0 / totalAllocPoint:
                                        _4463 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_4463] = 26
                                        mem[_4463 + 32] = 'SafeMath: division by zero'
                                        _4501 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _4501 + 68] = mem[idx + _4463 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_4501 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _4501 + -mem[64] + 100
                                    if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not stor159 * 0 / totalAllocPoint:
                                        _4500 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_4500] = 26
                                        mem[_4500 + 32] = 'SafeMath: division by zero'
                                        _4552 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _4552 + 68] = mem[idx + _4500 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_4552 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _4552 + -mem[64] + 100
                                    if (10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint) / stor159 * 0 / totalAllocPoint != -poolInfo[idx].field_992 + 10000:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _4551 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4551] = 26
                                    mem[_4551 + 32] = 'SafeMath: division by zero'
                                    _4628 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _4628 + 68] = mem[idx + _4551 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4628 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4628 + -mem[64] + 100
                                if 10000 * poolInfo[idx].field_1280 / poolInfo[idx].field_1280 != 10000:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 0 / totalAllocPoint:
                                    _4499 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4499] = 26
                                    mem[_4499 + 32] = 'SafeMath: division by zero'
                                    if not 10000 * poolInfo[idx].field_1280:
                                        _4550 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _4550 + 68] = mem[idx + _4499 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_4550 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _4550 + -mem[64] + 100
                                    if (0 / 10000 * poolInfo[idx].field_1280) + poolInfo[idx].field_256 < poolInfo[idx].field_256:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_256 += 0 / 10000 * poolInfo[idx].field_1280
                                    if poolInfo[idx].field_992:
                                        if poolInfo[idx].field_1024:
                                            if not poolInfo[idx].field_1024:
                                                if not 0 / totalAllocPoint:
                                                    _5673 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_5673] = 26
                                                    mem[_5673 + 32] = 'SafeMath: division by zero'
                                                    _5753 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _5753 + 68] = mem[idx + _5673 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_5753 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _5753 + -mem[64] + 100
                                                if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not stor159 * 0 / totalAllocPoint:
                                                    _5752 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_5752] = 26
                                                    mem[_5752 + 32] = 'SafeMath: division by zero'
                                                    _5862 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _5862 + 68] = mem[idx + _5752 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_5862 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _5862 + -mem[64] + 100
                                                if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _5861 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_5861] = 26
                                                mem[_5861 + 32] = 'SafeMath: division by zero'
                                                _6024 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _6024 + 68] = mem[idx + _5861 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_6024 + 94] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _6024 + -mem[64] + 100
                                            if 10000 * poolInfo[idx].field_1024 / poolInfo[idx].field_1024 != 10000:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if not 0 / totalAllocPoint:
                                                _5751 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_5751] = 26
                                                mem[_5751 + 32] = 'SafeMath: division by zero'
                                                if not 10000 * poolInfo[idx].field_1024:
                                                    _5860 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _5860 + 68] = mem[idx + _5751 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_5860 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _5860 + -mem[64] + 100
                                                if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                            else:
                                                if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not stor159 * 0 / totalAllocPoint:
                                                    _5859 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_5859] = 26
                                                    mem[_5859 + 32] = 'SafeMath: division by zero'
                                                    if not 10000 * poolInfo[idx].field_1024:
                                                        _6022 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _6022 + 68] = mem[idx + _5859 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_6022 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _6022 + -mem[64] + 100
                                                    if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                else:
                                                    if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    _6021 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_6021] = 26
                                                    mem[_6021 + 32] = 'SafeMath: division by zero'
                                                    if not 10000 * poolInfo[idx].field_1024:
                                                        _6245 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _6245 + 68] = mem[idx + _6021 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_6245 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _6245 + -mem[64] + 100
                                                    if (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_512 += poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024
                                else:
                                    if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not stor159 * 0 / totalAllocPoint:
                                        _4549 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_4549] = 26
                                        mem[_4549 + 32] = 'SafeMath: division by zero'
                                        if not 10000 * poolInfo[idx].field_1280:
                                            _4626 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _4626 + 68] = mem[idx + _4549 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_4626 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _4626 + -mem[64] + 100
                                        if (0 / 10000 * poolInfo[idx].field_1280) + poolInfo[idx].field_256 < poolInfo[idx].field_256:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_256 += 0 / 10000 * poolInfo[idx].field_1280
                                        if poolInfo[idx].field_992:
                                            if poolInfo[idx].field_1024:
                                                if not poolInfo[idx].field_1024:
                                                    if not 0 / totalAllocPoint:
                                                        _5750 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_5750] = 26
                                                        mem[_5750 + 32] = 'SafeMath: division by zero'
                                                        _5858 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _5858 + 68] = mem[idx + _5750 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_5858 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _5858 + -mem[64] + 100
                                                    if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not stor159 * 0 / totalAllocPoint:
                                                        _5857 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_5857] = 26
                                                        mem[_5857 + 32] = 'SafeMath: division by zero'
                                                        _6019 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _6019 + 68] = mem[idx + _5857 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_6019 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _6019 + -mem[64] + 100
                                                    if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    _6018 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_6018] = 26
                                                    mem[_6018 + 32] = 'SafeMath: division by zero'
                                                    _6243 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _6243 + 68] = mem[idx + _6018 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_6243 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _6243 + -mem[64] + 100
                                                if 10000 * poolInfo[idx].field_1024 / poolInfo[idx].field_1024 != 10000:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not 0 / totalAllocPoint:
                                                    _5856 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_5856] = 26
                                                    mem[_5856 + 32] = 'SafeMath: division by zero'
                                                    if not 10000 * poolInfo[idx].field_1024:
                                                        _6017 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _6017 + 68] = mem[idx + _5856 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_6017 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _6017 + -mem[64] + 100
                                                    if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                else:
                                                    if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not stor159 * 0 / totalAllocPoint:
                                                        _6016 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_6016] = 26
                                                        mem[_6016 + 32] = 'SafeMath: division by zero'
                                                        if not 10000 * poolInfo[idx].field_1024:
                                                            _6241 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _6241 + 68] = mem[idx + _6016 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_6241 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _6241 + -mem[64] + 100
                                                        if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                    else:
                                                        if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _6240 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_6240] = 26
                                                        mem[_6240 + 32] = 'SafeMath: division by zero'
                                                        if not 10000 * poolInfo[idx].field_1024:
                                                            _6509 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _6509 + 68] = mem[idx + _6240 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_6509 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _6509 + -mem[64] + 100
                                                        if (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_512 += poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024
                                    else:
                                        if (10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint) / stor159 * 0 / totalAllocPoint != -poolInfo[idx].field_992 + 10000:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _4625 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_4625] = 26
                                        mem[_4625 + 32] = 'SafeMath: division by zero'
                                        if not 10000 * poolInfo[idx].field_1280:
                                            _4721 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _4721 + 68] = mem[idx + _4625 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_4721 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _4721 + -mem[64] + 100
                                        if ((10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint) / 10000 * poolInfo[idx].field_1280) + poolInfo[idx].field_256 < poolInfo[idx].field_256:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_256 += (10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint) / 10000 * poolInfo[idx].field_1280
                                        if poolInfo[idx].field_992:
                                            if poolInfo[idx].field_1024:
                                                if not poolInfo[idx].field_1024:
                                                    if not 0 / totalAllocPoint:
                                                        _5855 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_5855] = 26
                                                        mem[_5855 + 32] = 'SafeMath: division by zero'
                                                        _6015 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _6015 + 68] = mem[idx + _5855 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_6015 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _6015 + -mem[64] + 100
                                                    if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not stor159 * 0 / totalAllocPoint:
                                                        _6014 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_6014] = 26
                                                        mem[_6014 + 32] = 'SafeMath: division by zero'
                                                        _6238 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _6238 + 68] = mem[idx + _6014 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_6238 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _6238 + -mem[64] + 100
                                                    if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    _6237 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_6237] = 26
                                                    mem[_6237 + 32] = 'SafeMath: division by zero'
                                                    _6507 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _6507 + 68] = mem[idx + _6237 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_6507 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _6507 + -mem[64] + 100
                                                if 10000 * poolInfo[idx].field_1024 / poolInfo[idx].field_1024 != 10000:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not 0 / totalAllocPoint:
                                                    _6013 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_6013] = 26
                                                    mem[_6013 + 32] = 'SafeMath: division by zero'
                                                    if not 10000 * poolInfo[idx].field_1024:
                                                        _6236 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _6236 + 68] = mem[idx + _6013 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_6236 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _6236 + -mem[64] + 100
                                                    if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                else:
                                                    if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not stor159 * 0 / totalAllocPoint:
                                                        _6235 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_6235] = 26
                                                        mem[_6235 + 32] = 'SafeMath: division by zero'
                                                        if not 10000 * poolInfo[idx].field_1024:
                                                            _6505 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _6505 + 68] = mem[idx + _6235 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_6505 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _6505 + -mem[64] + 100
                                                        if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                    else:
                                                        if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _6504 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_6504] = 26
                                                        mem[_6504 + 32] = 'SafeMath: division by zero'
                                                        if not 10000 * poolInfo[idx].field_1024:
                                                            _6785 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            s = 0
                                                            while s < 26:
                                                                mem[s + _6785 + 68] = mem[s + _6504 + 32]
                                                                s = s + 32
                                                                continue 
                                                            mem[_6785 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _6785 + -mem[64] + 100
                                                        if (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_512 += poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024
                            else:
                                if (block.timestamp * 0 / _4195) - (poolInfo[idx].field_768 * 0 / _4195) / block.timestamp - poolInfo[idx].field_768 != 0 / _4195:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not (block.timestamp * 0 / _4195) - (poolInfo[idx].field_768 * 0 / _4195):
                                    _4294 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4294] = 26
                                    mem[_4294 + 32] = 'SafeMath: division by zero'
                                    if not totalAllocPoint:
                                        _4310 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _4310 + 68] = mem[idx + _4294 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_4310 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _4310 + -mem[64] + 100
                                    if not poolInfo[idx].field_1280:
                                        if not 0 / totalAllocPoint:
                                            _4498 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_4498] = 26
                                            mem[_4498 + 32] = 'SafeMath: division by zero'
                                            _4548 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _4548 + 68] = mem[idx + _4498 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_4548 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _4548 + -mem[64] + 100
                                        if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not stor159 * 0 / totalAllocPoint:
                                            _4547 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_4547] = 26
                                            mem[_4547 + 32] = 'SafeMath: division by zero'
                                            _4623 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _4623 + 68] = mem[idx + _4547 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_4623 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _4623 + -mem[64] + 100
                                        if (10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint) / stor159 * 0 / totalAllocPoint != -poolInfo[idx].field_992 + 10000:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _4622 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_4622] = 26
                                        mem[_4622 + 32] = 'SafeMath: division by zero'
                                        _4719 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _4719 + 68] = mem[idx + _4622 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_4719 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _4719 + -mem[64] + 100
                                    if 10000 * poolInfo[idx].field_1280 / poolInfo[idx].field_1280 != 10000:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not 0 / totalAllocPoint:
                                        _4546 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_4546] = 26
                                        mem[_4546 + 32] = 'SafeMath: division by zero'
                                        if not 10000 * poolInfo[idx].field_1280:
                                            _4621 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _4621 + 68] = mem[idx + _4546 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_4621 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _4621 + -mem[64] + 100
                                        if (0 / 10000 * poolInfo[idx].field_1280) + poolInfo[idx].field_256 < poolInfo[idx].field_256:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_256 += 0 / 10000 * poolInfo[idx].field_1280
                                        if poolInfo[idx].field_992:
                                            if poolInfo[idx].field_1024:
                                                if not poolInfo[idx].field_1024:
                                                    if not 0 / totalAllocPoint:
                                                        _5749 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_5749] = 26
                                                        mem[_5749 + 32] = 'SafeMath: division by zero'
                                                        _5854 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _5854 + 68] = mem[idx + _5749 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_5854 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _5854 + -mem[64] + 100
                                                    if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not stor159 * 0 / totalAllocPoint:
                                                        _5853 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_5853] = 26
                                                        mem[_5853 + 32] = 'SafeMath: division by zero'
                                                        _6011 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _6011 + 68] = mem[idx + _5853 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_6011 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _6011 + -mem[64] + 100
                                                    if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    _6010 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_6010] = 26
                                                    mem[_6010 + 32] = 'SafeMath: division by zero'
                                                    _6233 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _6233 + 68] = mem[idx + _6010 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_6233 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _6233 + -mem[64] + 100
                                                if 10000 * poolInfo[idx].field_1024 / poolInfo[idx].field_1024 != 10000:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not 0 / totalAllocPoint:
                                                    _5852 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_5852] = 26
                                                    mem[_5852 + 32] = 'SafeMath: division by zero'
                                                    if not 10000 * poolInfo[idx].field_1024:
                                                        _6009 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _6009 + 68] = mem[idx + _5852 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_6009 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _6009 + -mem[64] + 100
                                                    if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                else:
                                                    if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not stor159 * 0 / totalAllocPoint:
                                                        _6008 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_6008] = 26
                                                        mem[_6008 + 32] = 'SafeMath: division by zero'
                                                        if not 10000 * poolInfo[idx].field_1024:
                                                            _6231 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _6231 + 68] = mem[idx + _6008 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_6231 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _6231 + -mem[64] + 100
                                                        if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                    else:
                                                        if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _6230 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_6230] = 26
                                                        mem[_6230 + 32] = 'SafeMath: division by zero'
                                                        if not 10000 * poolInfo[idx].field_1024:
                                                            _6501 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _6501 + 68] = mem[idx + _6230 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_6501 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _6501 + -mem[64] + 100
                                                        if (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_512 += poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024
                                    else:
                                        if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not stor159 * 0 / totalAllocPoint:
                                            _4620 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_4620] = 26
                                            mem[_4620 + 32] = 'SafeMath: division by zero'
                                            if not 10000 * poolInfo[idx].field_1280:
                                                _4717 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _4717 + 68] = mem[idx + _4620 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_4717 + 94] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _4717 + -mem[64] + 100
                                            if (0 / 10000 * poolInfo[idx].field_1280) + poolInfo[idx].field_256 < poolInfo[idx].field_256:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_256 += 0 / 10000 * poolInfo[idx].field_1280
                                            if poolInfo[idx].field_992:
                                                if poolInfo[idx].field_1024:
                                                    if not poolInfo[idx].field_1024:
                                                        if not 0 / totalAllocPoint:
                                                            _5851 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_5851] = 26
                                                            mem[_5851 + 32] = 'SafeMath: division by zero'
                                                            _6007 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _6007 + 68] = mem[idx + _5851 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_6007 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _6007 + -mem[64] + 100
                                                        if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if not stor159 * 0 / totalAllocPoint:
                                                            _6006 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_6006] = 26
                                                            mem[_6006 + 32] = 'SafeMath: division by zero'
                                                            _6228 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _6228 + 68] = mem[idx + _6006 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_6228 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _6228 + -mem[64] + 100
                                                        if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _6227 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_6227] = 26
                                                        mem[_6227 + 32] = 'SafeMath: division by zero'
                                                        _6499 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _6499 + 68] = mem[idx + _6227 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_6499 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _6499 + -mem[64] + 100
                                                    if 10000 * poolInfo[idx].field_1024 / poolInfo[idx].field_1024 != 10000:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not 0 / totalAllocPoint:
                                                        _6005 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_6005] = 26
                                                        mem[_6005 + 32] = 'SafeMath: division by zero'
                                                        if not 10000 * poolInfo[idx].field_1024:
                                                            _6226 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _6226 + 68] = mem[idx + _6005 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_6226 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _6226 + -mem[64] + 100
                                                        if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                    else:
                                                        if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if not stor159 * 0 / totalAllocPoint:
                                                            _6225 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_6225] = 26
                                                            mem[_6225 + 32] = 'SafeMath: division by zero'
                                                            if not 10000 * poolInfo[idx].field_1024:
                                                                _6497 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _6497 + 68] = mem[idx + _6225 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_6497 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _6497 + -mem[64] + 100
                                                            if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                        else:
                                                            if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            _6496 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_6496] = 26
                                                            mem[_6496 + 32] = 'SafeMath: division by zero'
                                                            if not 10000 * poolInfo[idx].field_1024:
                                                                _6780 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                s = 0
                                                                while s < 26:
                                                                    mem[s + _6780 + 68] = mem[s + _6496 + 32]
                                                                    s = s + 32
                                                                    continue 
                                                                mem[_6780 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _6780 + -mem[64] + 100
                                                            if (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_512 += poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024
                                        else:
                                            if (10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint) / stor159 * 0 / totalAllocPoint != -poolInfo[idx].field_992 + 10000:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _4716 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_4716] = 26
                                            mem[_4716 + 32] = 'SafeMath: division by zero'
                                            if not 10000 * poolInfo[idx].field_1280:
                                                _4815 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _4815 + 68] = mem[idx + _4716 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_4815 + 94] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _4815 + -mem[64] + 100
                                            if ((10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint) / 10000 * poolInfo[idx].field_1280) + poolInfo[idx].field_256 < poolInfo[idx].field_256:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_256 += (10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint) / 10000 * poolInfo[idx].field_1280
                                            if poolInfo[idx].field_992:
                                                if poolInfo[idx].field_1024:
                                                    if not poolInfo[idx].field_1024:
                                                        if not 0 / totalAllocPoint:
                                                            _6004 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_6004] = 26
                                                            mem[_6004 + 32] = 'SafeMath: division by zero'
                                                            _6224 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _6224 + 68] = mem[idx + _6004 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_6224 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _6224 + -mem[64] + 100
                                                        if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if not stor159 * 0 / totalAllocPoint:
                                                            _6223 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_6223] = 26
                                                            mem[_6223 + 32] = 'SafeMath: division by zero'
                                                            _6494 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _6494 + 68] = mem[idx + _6223 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_6494 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _6494 + -mem[64] + 100
                                                        if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _6493 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_6493] = 26
                                                        mem[_6493 + 32] = 'SafeMath: division by zero'
                                                        _6778 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        s = 0
                                                        while s < 26:
                                                            mem[s + _6778 + 68] = mem[s + _6493 + 32]
                                                            s = s + 32
                                                            continue 
                                                        mem[_6778 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _6778 + -mem[64] + 100
                                                    if 10000 * poolInfo[idx].field_1024 / poolInfo[idx].field_1024 != 10000:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not 0 / totalAllocPoint:
                                                        _6222 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_6222] = 26
                                                        mem[_6222 + 32] = 'SafeMath: division by zero'
                                                        if not 10000 * poolInfo[idx].field_1024:
                                                            _6492 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _6492 + 68] = mem[idx + _6222 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_6492 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _6492 + -mem[64] + 100
                                                        if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                    else:
                                                        if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if not stor159 * 0 / totalAllocPoint:
                                                            _6491 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_6491] = 26
                                                            mem[_6491 + 32] = 'SafeMath: division by zero'
                                                            if not 10000 * poolInfo[idx].field_1024:
                                                                _6776 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                s = 0
                                                                while s < 26:
                                                                    mem[s + _6776 + 68] = mem[s + _6491 + 32]
                                                                    s = s + 32
                                                                    continue 
                                                                mem[_6776 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _6776 + -mem[64] + 100
                                                            if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                        else:
                                                            if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            _6775 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_6775] = 26
                                                            mem[_6775 + 32] = 'SafeMath: division by zero'
                                                            if not 10000 * poolInfo[idx].field_1024:
                                                                _7050 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _7050 + 68] = mem[idx + _6775 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_7050 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _7050 + -mem[64] + 100
                                                            if (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_512 += poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024
                                else:
                                    if (block.timestamp * 0 / _4195 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4195 * poolInfo[idx].field_160) / (block.timestamp * 0 / _4195) - (poolInfo[idx].field_768 * 0 / _4195) != poolInfo[idx].field_160:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _4309 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4309] = 26
                                    mem[_4309 + 32] = 'SafeMath: division by zero'
                                    if not totalAllocPoint:
                                        _4328 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _4328 + 68] = mem[idx + _4309 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_4328 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _4328 + -mem[64] + 100
                                    if not poolInfo[idx].field_1280:
                                        if not (block.timestamp * 0 / _4195 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4195 * poolInfo[idx].field_160) / totalAllocPoint:
                                            _4545 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_4545] = 26
                                            mem[_4545 + 32] = 'SafeMath: division by zero'
                                            _4619 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _4619 + 68] = mem[idx + _4545 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_4619 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _4619 + -mem[64] + 100
                                        if stor159 * (block.timestamp * 0 / _4195 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4195 * poolInfo[idx].field_160) / totalAllocPoint / (block.timestamp * 0 / _4195 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4195 * poolInfo[idx].field_160) / totalAllocPoint != stor159:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not stor159 * (block.timestamp * 0 / _4195 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4195 * poolInfo[idx].field_160) / totalAllocPoint:
                                            _4618 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_4618] = 26
                                            mem[_4618 + 32] = 'SafeMath: division by zero'
                                            _4714 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _4714 + 68] = mem[idx + _4618 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_4714 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _4714 + -mem[64] + 100
                                        if (10000 * stor159 * (block.timestamp * 0 / _4195 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4195 * poolInfo[idx].field_160) / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _4195 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4195 * poolInfo[idx].field_160) / totalAllocPoint) / stor159 * (block.timestamp * 0 / _4195 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4195 * poolInfo[idx].field_160) / totalAllocPoint != -poolInfo[idx].field_992 + 10000:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _4713 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_4713] = 26
                                        mem[_4713 + 32] = 'SafeMath: division by zero'
                                        _4813 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _4813 + 68] = mem[idx + _4713 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_4813 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _4813 + -mem[64] + 100
                                    if 10000 * poolInfo[idx].field_1280 / poolInfo[idx].field_1280 != 10000:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not (block.timestamp * 0 / _4195 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4195 * poolInfo[idx].field_160) / totalAllocPoint:
                                        _4617 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_4617] = 26
                                        mem[_4617 + 32] = 'SafeMath: division by zero'
                                        if not 10000 * poolInfo[idx].field_1280:
                                            _4712 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _4712 + 68] = mem[idx + _4617 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_4712 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _4712 + -mem[64] + 100
                                        if (0 / 10000 * poolInfo[idx].field_1280) + poolInfo[idx].field_256 < poolInfo[idx].field_256:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_256 += 0 / 10000 * poolInfo[idx].field_1280
                                        if poolInfo[idx].field_992:
                                            if poolInfo[idx].field_1024:
                                                if not poolInfo[idx].field_1024:
                                                    if not (block.timestamp * 0 / _4195 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4195 * poolInfo[idx].field_160) / totalAllocPoint:
                                                        _5850 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_5850] = 26
                                                        mem[_5850 + 32] = 'SafeMath: division by zero'
                                                        _6003 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _6003 + 68] = mem[idx + _5850 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_6003 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _6003 + -mem[64] + 100
                                                    if stor159 * (block.timestamp * 0 / _4195 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4195 * poolInfo[idx].field_160) / totalAllocPoint / (block.timestamp * 0 / _4195 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4195 * poolInfo[idx].field_160) / totalAllocPoint != stor159:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not stor159 * (block.timestamp * 0 / _4195 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4195 * poolInfo[idx].field_160) / totalAllocPoint:
                                                        _6002 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_6002] = 26
                                                        mem[_6002 + 32] = 'SafeMath: division by zero'
                                                        _6220 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _6220 + 68] = mem[idx + _6002 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_6220 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _6220 + -mem[64] + 100
                                                    if poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _4195 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4195 * poolInfo[idx].field_160) / totalAllocPoint / stor159 * (block.timestamp * 0 / _4195 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4195 * poolInfo[idx].field_160) / totalAllocPoint != poolInfo[idx].field_992:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    _6219 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_6219] = 26
                                                    mem[_6219 + 32] = 'SafeMath: division by zero'
                                                    _6489 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _6489 + 68] = mem[idx + _6219 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_6489 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _6489 + -mem[64] + 100
                                                if 10000 * poolInfo[idx].field_1024 / poolInfo[idx].field_1024 != 10000:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not (block.timestamp * 0 / _4195 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4195 * poolInfo[idx].field_160) / totalAllocPoint:
                                                    _6001 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_6001] = 26
                                                    mem[_6001 + 32] = 'SafeMath: division by zero'
                                                    if not 10000 * poolInfo[idx].field_1024:
                                                        _6218 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _6218 + 68] = mem[idx + _6001 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_6218 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _6218 + -mem[64] + 100
                                                    if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                else:
                                                    if stor159 * (block.timestamp * 0 / _4195 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4195 * poolInfo[idx].field_160) / totalAllocPoint / (block.timestamp * 0 / _4195 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4195 * poolInfo[idx].field_160) / totalAllocPoint != stor159:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not stor159 * (block.timestamp * 0 / _4195 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4195 * poolInfo[idx].field_160) / totalAllocPoint:
                                                        _6217 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_6217] = 26
                                                        mem[_6217 + 32] = 'SafeMath: division by zero'
                                                        if not 10000 * poolInfo[idx].field_1024:
                                                            _6487 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _6487 + 68] = mem[idx + _6217 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_6487 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _6487 + -mem[64] + 100
                                                        if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                    else:
                                                        if poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _4195 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4195 * poolInfo[idx].field_160) / totalAllocPoint / stor159 * (block.timestamp * 0 / _4195 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4195 * poolInfo[idx].field_160) / totalAllocPoint != poolInfo[idx].field_992:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _6486 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_6486] = 26
                                                        mem[_6486 + 32] = 'SafeMath: division by zero'
                                                        if not 10000 * poolInfo[idx].field_1024:
                                                            _6772 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            s = 0
                                                            while s < 26:
                                                                mem[s + _6772 + 68] = mem[s + _6486 + 32]
                                                                s = s + 32
                                                                continue 
                                                            mem[_6772 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _6772 + -mem[64] + 100
                                                        if (poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _4195 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4195 * poolInfo[idx].field_160) / totalAllocPoint / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_512 += poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _4195 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4195 * poolInfo[idx].field_160) / totalAllocPoint / 10000 * poolInfo[idx].field_1024
                                    else:
                                        if stor159 * (block.timestamp * 0 / _4195 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4195 * poolInfo[idx].field_160) / totalAllocPoint / (block.timestamp * 0 / _4195 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4195 * poolInfo[idx].field_160) / totalAllocPoint != stor159:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not stor159 * (block.timestamp * 0 / _4195 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4195 * poolInfo[idx].field_160) / totalAllocPoint:
                                            _4711 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_4711] = 26
                                            mem[_4711 + 32] = 'SafeMath: division by zero'
                                            if not 10000 * poolInfo[idx].field_1280:
                                                _4811 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _4811 + 68] = mem[idx + _4711 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_4811 + 94] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _4811 + -mem[64] + 100
                                            if (0 / 10000 * poolInfo[idx].field_1280) + poolInfo[idx].field_256 < poolInfo[idx].field_256:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_256 += 0 / 10000 * poolInfo[idx].field_1280
                                            if poolInfo[idx].field_992:
                                                if poolInfo[idx].field_1024:
                                                    if not poolInfo[idx].field_1024:
                                                        if not (block.timestamp * 0 / _4195 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4195 * poolInfo[idx].field_160) / totalAllocPoint:
                                                            _6000 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_6000] = 26
                                                            mem[_6000 + 32] = 'SafeMath: division by zero'
                                                            _6216 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _6216 + 68] = mem[idx + _6000 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_6216 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _6216 + -mem[64] + 100
                                                        if stor159 * (block.timestamp * 0 / _4195 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4195 * poolInfo[idx].field_160) / totalAllocPoint / (block.timestamp * 0 / _4195 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4195 * poolInfo[idx].field_160) / totalAllocPoint != stor159:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if not stor159 * (block.timestamp * 0 / _4195 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4195 * poolInfo[idx].field_160) / totalAllocPoint:
                                                            _6215 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_6215] = 26
                                                            mem[_6215 + 32] = 'SafeMath: division by zero'
                                                            _6484 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _6484 + 68] = mem[idx + _6215 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_6484 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _6484 + -mem[64] + 100
                                                        if poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _4195 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4195 * poolInfo[idx].field_160) / totalAllocPoint / stor159 * (block.timestamp * 0 / _4195 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4195 * poolInfo[idx].field_160) / totalAllocPoint != poolInfo[idx].field_992:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _6483 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_6483] = 26
                                                        mem[_6483 + 32] = 'SafeMath: division by zero'
                                                        _6770 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        s = 0
                                                        while s < 26:
                                                            mem[s + _6770 + 68] = mem[s + _6483 + 32]
                                                            s = s + 32
                                                            continue 
                                                        mem[_6770 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _6770 + -mem[64] + 100
                                                    if 10000 * poolInfo[idx].field_1024 / poolInfo[idx].field_1024 != 10000:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not (block.timestamp * 0 / _4195 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4195 * poolInfo[idx].field_160) / totalAllocPoint:
                                                        _6214 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_6214] = 26
                                                        mem[_6214 + 32] = 'SafeMath: division by zero'
                                                        if not 10000 * poolInfo[idx].field_1024:
                                                            _6482 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _6482 + 68] = mem[idx + _6214 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_6482 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _6482 + -mem[64] + 100
                                                        if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                    else:
                                                        if stor159 * (block.timestamp * 0 / _4195 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4195 * poolInfo[idx].field_160) / totalAllocPoint / (block.timestamp * 0 / _4195 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4195 * poolInfo[idx].field_160) / totalAllocPoint != stor159:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if not stor159 * (block.timestamp * 0 / _4195 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4195 * poolInfo[idx].field_160) / totalAllocPoint:
                                                            _6481 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_6481] = 26
                                                            mem[_6481 + 32] = 'SafeMath: division by zero'
                                                            if not 10000 * poolInfo[idx].field_1024:
                                                                _6768 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                s = 0
                                                                while s < 26:
                                                                    mem[s + _6768 + 68] = mem[s + _6481 + 32]
                                                                    s = s + 32
                                                                    continue 
                                                                mem[_6768 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _6768 + -mem[64] + 100
                                                            if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                        else:
                                                            if poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _4195 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4195 * poolInfo[idx].field_160) / totalAllocPoint / stor159 * (block.timestamp * 0 / _4195 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4195 * poolInfo[idx].field_160) / totalAllocPoint != poolInfo[idx].field_992:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            _6767 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_6767] = 26
                                                            mem[_6767 + 32] = 'SafeMath: division by zero'
                                                            if not 10000 * poolInfo[idx].field_1024:
                                                                _7045 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _7045 + 68] = mem[idx + _6767 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_7045 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _7045 + -mem[64] + 100
                                                            if (poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _4195 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4195 * poolInfo[idx].field_160) / totalAllocPoint / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_512 += poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _4195 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4195 * poolInfo[idx].field_160) / totalAllocPoint / 10000 * poolInfo[idx].field_1024
                                        else:
                                            if (10000 * stor159 * (block.timestamp * 0 / _4195 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4195 * poolInfo[idx].field_160) / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _4195 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4195 * poolInfo[idx].field_160) / totalAllocPoint) / stor159 * (block.timestamp * 0 / _4195 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4195 * poolInfo[idx].field_160) / totalAllocPoint != -poolInfo[idx].field_992 + 10000:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _4810 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_4810] = 26
                                            mem[_4810 + 32] = 'SafeMath: division by zero'
                                            if not 10000 * poolInfo[idx].field_1280:
                                                _4901 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _4901 + 68] = mem[idx + _4810 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_4901 + 94] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _4901 + -mem[64] + 100
                                            if ((10000 * stor159 * (block.timestamp * 0 / _4195 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4195 * poolInfo[idx].field_160) / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _4195 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4195 * poolInfo[idx].field_160) / totalAllocPoint) / 10000 * poolInfo[idx].field_1280) + poolInfo[idx].field_256 < poolInfo[idx].field_256:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_256 += (10000 * stor159 * (block.timestamp * 0 / _4195 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4195 * poolInfo[idx].field_160) / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _4195 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4195 * poolInfo[idx].field_160) / totalAllocPoint) / 10000 * poolInfo[idx].field_1280
                                            if poolInfo[idx].field_992:
                                                if poolInfo[idx].field_1024:
                                                    if not poolInfo[idx].field_1024:
                                                        if not (block.timestamp * 0 / _4195 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4195 * poolInfo[idx].field_160) / totalAllocPoint:
                                                            _6213 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_6213] = 26
                                                            mem[_6213 + 32] = 'SafeMath: division by zero'
                                                            _6480 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _6480 + 68] = mem[idx + _6213 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_6480 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _6480 + -mem[64] + 100
                                                        if stor159 * (block.timestamp * 0 / _4195 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4195 * poolInfo[idx].field_160) / totalAllocPoint / (block.timestamp * 0 / _4195 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4195 * poolInfo[idx].field_160) / totalAllocPoint != stor159:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if not stor159 * (block.timestamp * 0 / _4195 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4195 * poolInfo[idx].field_160) / totalAllocPoint:
                                                            _6479 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_6479] = 26
                                                            mem[_6479 + 32] = 'SafeMath: division by zero'
                                                            _6765 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            s = 0
                                                            while s < 26:
                                                                mem[s + _6765 + 68] = mem[s + _6479 + 32]
                                                                s = s + 32
                                                                continue 
                                                            mem[_6765 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _6765 + -mem[64] + 100
                                                        if poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _4195 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4195 * poolInfo[idx].field_160) / totalAllocPoint / stor159 * (block.timestamp * 0 / _4195 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4195 * poolInfo[idx].field_160) / totalAllocPoint != poolInfo[idx].field_992:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _6764 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_6764] = 26
                                                        mem[_6764 + 32] = 'SafeMath: division by zero'
                                                        _7043 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _7043 + 68] = mem[idx + _6764 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_7043 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _7043 + -mem[64] + 100
                                                    if 10000 * poolInfo[idx].field_1024 / poolInfo[idx].field_1024 != 10000:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not (block.timestamp * 0 / _4195 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4195 * poolInfo[idx].field_160) / totalAllocPoint:
                                                        _6478 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_6478] = 26
                                                        mem[_6478 + 32] = 'SafeMath: division by zero'
                                                        if not 10000 * poolInfo[idx].field_1024:
                                                            _6763 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            s = 0
                                                            while s < 26:
                                                                mem[s + _6763 + 68] = mem[s + _6478 + 32]
                                                                s = s + 32
                                                                continue 
                                                            mem[_6763 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _6763 + -mem[64] + 100
                                                        if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                    else:
                                                        if stor159 * (block.timestamp * 0 / _4195 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4195 * poolInfo[idx].field_160) / totalAllocPoint / (block.timestamp * 0 / _4195 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4195 * poolInfo[idx].field_160) / totalAllocPoint != stor159:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if not stor159 * (block.timestamp * 0 / _4195 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4195 * poolInfo[idx].field_160) / totalAllocPoint:
                                                            _6762 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_6762] = 26
                                                            mem[_6762 + 32] = 'SafeMath: division by zero'
                                                            if not 10000 * poolInfo[idx].field_1024:
                                                                _7041 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _7041 + 68] = mem[idx + _6762 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_7041 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _7041 + -mem[64] + 100
                                                            if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                        else:
                                                            if poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _4195 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4195 * poolInfo[idx].field_160) / totalAllocPoint / stor159 * (block.timestamp * 0 / _4195 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4195 * poolInfo[idx].field_160) / totalAllocPoint != poolInfo[idx].field_992:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            _7040 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_7040] = 26
                                                            mem[_7040 + 32] = 'SafeMath: division by zero'
                                                            if not 10000 * poolInfo[idx].field_1024:
                                                                _7320 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _7320 + 68] = mem[idx + _7040 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_7320 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _7320 + -mem[64] + 100
                                                            if (poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _4195 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4195 * poolInfo[idx].field_160) / totalAllocPoint / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_512 += poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _4195 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4195 * poolInfo[idx].field_160) / totalAllocPoint / 10000 * poolInfo[idx].field_1024
                        else:
                            if (1000 * mem[_4166]) - (_4129 * mem[_4166]) - (_4121 * mem[_4166]) - (_4113 * mem[_4166]) / mem[_4166] != -_4129 + -_4121 + -_4113 + 1000:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _4181 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4181] = 26
                            mem[_4181 + 32] = 'SafeMath: division by zero'
                            require ext_code.size(address(MASTER_CHEF_V2Address))
                            staticcall address(MASTER_CHEF_V2Address).0x17caf6f1 with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _4194 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _4199 = mem[_4194]
                            require ext_code.size(address(MASTER_CHEF_V2Address))
                            staticcall address(MASTER_CHEF_V2Address).0x1526fe27 with:
                                    gas gas_remaining wei
                                   args MASTER_PID
                            mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _4209 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 128
                            _4214 = mem[64]
                            require mem[64] + 128 >= mem[64] and mem[64] + 128 <= test266151307()
                            mem[64] = mem[64] + 128
                            require mem[_4209] == mem[_4209 + 12 len 20]
                            mem[_4214] = mem[_4209]
                            mem[_4214 + 32] = mem[_4209 + 32]
                            mem[_4214 + 64] = mem[_4209 + 64]
                            mem[_4214 + 96] = mem[_4209 + 96]
                            _4233 = mem[_4214 + 32]
                            if not (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000:
                                _4240 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4240] = 26
                                mem[_4240 + 32] = 'SafeMath: division by zero'
                                if not _4199:
                                    _4248 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _4248 + 68] = mem[idx + _4240 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4248 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4248 + -mem[64] + 100
                                if not block.timestamp - poolInfo[idx].field_768:
                                    _4293 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4293] = 26
                                    mem[_4293 + 32] = 'SafeMath: division by zero'
                                    if not totalAllocPoint:
                                        _4308 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _4308 + 68] = mem[idx + _4293 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_4308 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _4308 + -mem[64] + 100
                                    if not poolInfo[idx].field_1280:
                                        if not 0 / totalAllocPoint:
                                            _4497 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_4497] = 26
                                            mem[_4497 + 32] = 'SafeMath: division by zero'
                                            _4544 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _4544 + 68] = mem[idx + _4497 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_4544 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _4544 + -mem[64] + 100
                                        if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not stor159 * 0 / totalAllocPoint:
                                            _4543 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_4543] = 26
                                            mem[_4543 + 32] = 'SafeMath: division by zero'
                                            _4615 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _4615 + 68] = mem[idx + _4543 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_4615 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _4615 + -mem[64] + 100
                                        if (10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint) / stor159 * 0 / totalAllocPoint != -poolInfo[idx].field_992 + 10000:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _4614 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_4614] = 26
                                        mem[_4614 + 32] = 'SafeMath: division by zero'
                                        _4709 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _4709 + 68] = mem[idx + _4614 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_4709 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _4709 + -mem[64] + 100
                                    if 10000 * poolInfo[idx].field_1280 / poolInfo[idx].field_1280 != 10000:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not 0 / totalAllocPoint:
                                        _4542 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_4542] = 26
                                        mem[_4542 + 32] = 'SafeMath: division by zero'
                                        if not 10000 * poolInfo[idx].field_1280:
                                            _4613 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _4613 + 68] = mem[idx + _4542 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_4613 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _4613 + -mem[64] + 100
                                        if (0 / 10000 * poolInfo[idx].field_1280) + poolInfo[idx].field_256 < poolInfo[idx].field_256:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_256 += 0 / 10000 * poolInfo[idx].field_1280
                                        if poolInfo[idx].field_992:
                                            if poolInfo[idx].field_1024:
                                                if not poolInfo[idx].field_1024:
                                                    if not 0 / totalAllocPoint:
                                                        _5748 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_5748] = 26
                                                        mem[_5748 + 32] = 'SafeMath: division by zero'
                                                        _5849 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _5849 + 68] = mem[idx + _5748 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_5849 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _5849 + -mem[64] + 100
                                                    if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not stor159 * 0 / totalAllocPoint:
                                                        _5848 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_5848] = 26
                                                        mem[_5848 + 32] = 'SafeMath: division by zero'
                                                        _5998 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _5998 + 68] = mem[idx + _5848 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_5998 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _5998 + -mem[64] + 100
                                                    if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    _5997 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_5997] = 26
                                                    mem[_5997 + 32] = 'SafeMath: division by zero'
                                                    _6211 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _6211 + 68] = mem[idx + _5997 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_6211 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _6211 + -mem[64] + 100
                                                if 10000 * poolInfo[idx].field_1024 / poolInfo[idx].field_1024 != 10000:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not 0 / totalAllocPoint:
                                                    _5847 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_5847] = 26
                                                    mem[_5847 + 32] = 'SafeMath: division by zero'
                                                    if not 10000 * poolInfo[idx].field_1024:
                                                        _5996 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _5996 + 68] = mem[idx + _5847 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_5996 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _5996 + -mem[64] + 100
                                                    if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                else:
                                                    if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not stor159 * 0 / totalAllocPoint:
                                                        _5995 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_5995] = 26
                                                        mem[_5995 + 32] = 'SafeMath: division by zero'
                                                        if not 10000 * poolInfo[idx].field_1024:
                                                            _6209 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _6209 + 68] = mem[idx + _5995 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_6209 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _6209 + -mem[64] + 100
                                                        if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                    else:
                                                        if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _6208 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_6208] = 26
                                                        mem[_6208 + 32] = 'SafeMath: division by zero'
                                                        if not 10000 * poolInfo[idx].field_1024:
                                                            _6475 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _6475 + 68] = mem[idx + _6208 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_6475 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _6475 + -mem[64] + 100
                                                        if (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_512 += poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024
                                    else:
                                        if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not stor159 * 0 / totalAllocPoint:
                                            _4612 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_4612] = 26
                                            mem[_4612 + 32] = 'SafeMath: division by zero'
                                            if not 10000 * poolInfo[idx].field_1280:
                                                _4707 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _4707 + 68] = mem[idx + _4612 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_4707 + 94] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _4707 + -mem[64] + 100
                                            if (0 / 10000 * poolInfo[idx].field_1280) + poolInfo[idx].field_256 < poolInfo[idx].field_256:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_256 += 0 / 10000 * poolInfo[idx].field_1280
                                            if poolInfo[idx].field_992:
                                                if poolInfo[idx].field_1024:
                                                    if not poolInfo[idx].field_1024:
                                                        if not 0 / totalAllocPoint:
                                                            _5846 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_5846] = 26
                                                            mem[_5846 + 32] = 'SafeMath: division by zero'
                                                            _5994 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _5994 + 68] = mem[idx + _5846 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_5994 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _5994 + -mem[64] + 100
                                                        if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if not stor159 * 0 / totalAllocPoint:
                                                            _5993 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_5993] = 26
                                                            mem[_5993 + 32] = 'SafeMath: division by zero'
                                                            _6206 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _6206 + 68] = mem[idx + _5993 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_6206 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _6206 + -mem[64] + 100
                                                        if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _6205 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_6205] = 26
                                                        mem[_6205 + 32] = 'SafeMath: division by zero'
                                                        _6473 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _6473 + 68] = mem[idx + _6205 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_6473 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _6473 + -mem[64] + 100
                                                    if 10000 * poolInfo[idx].field_1024 / poolInfo[idx].field_1024 != 10000:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not 0 / totalAllocPoint:
                                                        _5992 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_5992] = 26
                                                        mem[_5992 + 32] = 'SafeMath: division by zero'
                                                        if not 10000 * poolInfo[idx].field_1024:
                                                            _6204 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _6204 + 68] = mem[idx + _5992 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_6204 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _6204 + -mem[64] + 100
                                                        if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                    else:
                                                        if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if not stor159 * 0 / totalAllocPoint:
                                                            _6203 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_6203] = 26
                                                            mem[_6203 + 32] = 'SafeMath: division by zero'
                                                            if not 10000 * poolInfo[idx].field_1024:
                                                                _6471 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _6471 + 68] = mem[idx + _6203 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_6471 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _6471 + -mem[64] + 100
                                                            if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                        else:
                                                            if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            _6470 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_6470] = 26
                                                            mem[_6470 + 32] = 'SafeMath: division by zero'
                                                            if not 10000 * poolInfo[idx].field_1024:
                                                                _6757 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                s = 0
                                                                while s < 26:
                                                                    mem[s + _6757 + 68] = mem[s + _6470 + 32]
                                                                    s = s + 32
                                                                    continue 
                                                                mem[_6757 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _6757 + -mem[64] + 100
                                                            if (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_512 += poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024
                                        else:
                                            if (10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint) / stor159 * 0 / totalAllocPoint != -poolInfo[idx].field_992 + 10000:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _4706 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_4706] = 26
                                            mem[_4706 + 32] = 'SafeMath: division by zero'
                                            if not 10000 * poolInfo[idx].field_1280:
                                                _4807 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _4807 + 68] = mem[idx + _4706 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_4807 + 94] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _4807 + -mem[64] + 100
                                            if ((10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint) / 10000 * poolInfo[idx].field_1280) + poolInfo[idx].field_256 < poolInfo[idx].field_256:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_256 += (10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint) / 10000 * poolInfo[idx].field_1280
                                            if poolInfo[idx].field_992:
                                                if poolInfo[idx].field_1024:
                                                    if not poolInfo[idx].field_1024:
                                                        if not 0 / totalAllocPoint:
                                                            _5991 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_5991] = 26
                                                            mem[_5991 + 32] = 'SafeMath: division by zero'
                                                            _6202 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _6202 + 68] = mem[idx + _5991 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_6202 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _6202 + -mem[64] + 100
                                                        if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if not stor159 * 0 / totalAllocPoint:
                                                            _6201 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_6201] = 26
                                                            mem[_6201 + 32] = 'SafeMath: division by zero'
                                                            _6468 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _6468 + 68] = mem[idx + _6201 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_6468 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _6468 + -mem[64] + 100
                                                        if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _6467 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_6467] = 26
                                                        mem[_6467 + 32] = 'SafeMath: division by zero'
                                                        _6755 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        s = 0
                                                        while s < 26:
                                                            mem[s + _6755 + 68] = mem[s + _6467 + 32]
                                                            s = s + 32
                                                            continue 
                                                        mem[_6755 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _6755 + -mem[64] + 100
                                                    if 10000 * poolInfo[idx].field_1024 / poolInfo[idx].field_1024 != 10000:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not 0 / totalAllocPoint:
                                                        _6200 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_6200] = 26
                                                        mem[_6200 + 32] = 'SafeMath: division by zero'
                                                        if not 10000 * poolInfo[idx].field_1024:
                                                            _6466 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _6466 + 68] = mem[idx + _6200 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_6466 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _6466 + -mem[64] + 100
                                                        if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                    else:
                                                        if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if not stor159 * 0 / totalAllocPoint:
                                                            _6465 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_6465] = 26
                                                            mem[_6465 + 32] = 'SafeMath: division by zero'
                                                            if not 10000 * poolInfo[idx].field_1024:
                                                                _6753 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                s = 0
                                                                while s < 26:
                                                                    mem[s + _6753 + 68] = mem[s + _6465 + 32]
                                                                    s = s + 32
                                                                    continue 
                                                                mem[_6753 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _6753 + -mem[64] + 100
                                                            if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                        else:
                                                            if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            _6752 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_6752] = 26
                                                            mem[_6752 + 32] = 'SafeMath: division by zero'
                                                            if not 10000 * poolInfo[idx].field_1024:
                                                                _7031 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _7031 + 68] = mem[idx + _6752 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_7031 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _7031 + -mem[64] + 100
                                                            if (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_512 += poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024
                                else:
                                    if (block.timestamp * 0 / _4199) - (poolInfo[idx].field_768 * 0 / _4199) / block.timestamp - poolInfo[idx].field_768 != 0 / _4199:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not (block.timestamp * 0 / _4199) - (poolInfo[idx].field_768 * 0 / _4199):
                                        _4307 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_4307] = 26
                                        mem[_4307 + 32] = 'SafeMath: division by zero'
                                        if not totalAllocPoint:
                                            _4326 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _4326 + 68] = mem[idx + _4307 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_4326 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _4326 + -mem[64] + 100
                                        if not poolInfo[idx].field_1280:
                                            if not 0 / totalAllocPoint:
                                                _4541 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_4541] = 26
                                                mem[_4541 + 32] = 'SafeMath: division by zero'
                                                _4611 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _4611 + 68] = mem[idx + _4541 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_4611 + 94] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _4611 + -mem[64] + 100
                                            if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if not stor159 * 0 / totalAllocPoint:
                                                _4610 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_4610] = 26
                                                mem[_4610 + 32] = 'SafeMath: division by zero'
                                                _4704 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _4704 + 68] = mem[idx + _4610 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_4704 + 94] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _4704 + -mem[64] + 100
                                            if (10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint) / stor159 * 0 / totalAllocPoint != -poolInfo[idx].field_992 + 10000:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _4703 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_4703] = 26
                                            mem[_4703 + 32] = 'SafeMath: division by zero'
                                            _4805 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _4805 + 68] = mem[idx + _4703 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_4805 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _4805 + -mem[64] + 100
                                        if 10000 * poolInfo[idx].field_1280 / poolInfo[idx].field_1280 != 10000:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not 0 / totalAllocPoint:
                                            _4609 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_4609] = 26
                                            mem[_4609 + 32] = 'SafeMath: division by zero'
                                            if not 10000 * poolInfo[idx].field_1280:
                                                _4702 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _4702 + 68] = mem[idx + _4609 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_4702 + 94] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _4702 + -mem[64] + 100
                                            if (0 / 10000 * poolInfo[idx].field_1280) + poolInfo[idx].field_256 < poolInfo[idx].field_256:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_256 += 0 / 10000 * poolInfo[idx].field_1280
                                            if poolInfo[idx].field_992:
                                                if poolInfo[idx].field_1024:
                                                    if not poolInfo[idx].field_1024:
                                                        if not 0 / totalAllocPoint:
                                                            _5845 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_5845] = 26
                                                            mem[_5845 + 32] = 'SafeMath: division by zero'
                                                            _5990 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _5990 + 68] = mem[idx + _5845 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_5990 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _5990 + -mem[64] + 100
                                                        if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if not stor159 * 0 / totalAllocPoint:
                                                            _5989 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_5989] = 26
                                                            mem[_5989 + 32] = 'SafeMath: division by zero'
                                                            _6198 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _6198 + 68] = mem[idx + _5989 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_6198 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _6198 + -mem[64] + 100
                                                        if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _6197 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_6197] = 26
                                                        mem[_6197 + 32] = 'SafeMath: division by zero'
                                                        _6463 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _6463 + 68] = mem[idx + _6197 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_6463 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _6463 + -mem[64] + 100
                                                    if 10000 * poolInfo[idx].field_1024 / poolInfo[idx].field_1024 != 10000:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not 0 / totalAllocPoint:
                                                        _5988 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_5988] = 26
                                                        mem[_5988 + 32] = 'SafeMath: division by zero'
                                                        if not 10000 * poolInfo[idx].field_1024:
                                                            _6196 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _6196 + 68] = mem[idx + _5988 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_6196 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _6196 + -mem[64] + 100
                                                        if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                    else:
                                                        if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if not stor159 * 0 / totalAllocPoint:
                                                            _6195 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_6195] = 26
                                                            mem[_6195 + 32] = 'SafeMath: division by zero'
                                                            if not 10000 * poolInfo[idx].field_1024:
                                                                _6461 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _6461 + 68] = mem[idx + _6195 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_6461 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _6461 + -mem[64] + 100
                                                            if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                        else:
                                                            if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            _6460 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_6460] = 26
                                                            mem[_6460 + 32] = 'SafeMath: division by zero'
                                                            if not 10000 * poolInfo[idx].field_1024:
                                                                _6749 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                s = 0
                                                                while s < 26:
                                                                    mem[s + _6749 + 68] = mem[s + _6460 + 32]
                                                                    s = s + 32
                                                                    continue 
                                                                mem[_6749 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _6749 + -mem[64] + 100
                                                            if (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_512 += poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024
                                        else:
                                            if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if not stor159 * 0 / totalAllocPoint:
                                                _4701 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_4701] = 26
                                                mem[_4701 + 32] = 'SafeMath: division by zero'
                                                if not 10000 * poolInfo[idx].field_1280:
                                                    _4803 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _4803 + 68] = mem[idx + _4701 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_4803 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _4803 + -mem[64] + 100
                                                if (0 / 10000 * poolInfo[idx].field_1280) + poolInfo[idx].field_256 < poolInfo[idx].field_256:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_256 += 0 / 10000 * poolInfo[idx].field_1280
                                                if poolInfo[idx].field_992:
                                                    if poolInfo[idx].field_1024:
                                                        if not poolInfo[idx].field_1024:
                                                            if not 0 / totalAllocPoint:
                                                                _5987 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_5987] = 26
                                                                mem[_5987 + 32] = 'SafeMath: division by zero'
                                                                _6194 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _6194 + 68] = mem[idx + _5987 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_6194 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _6194 + -mem[64] + 100
                                                            if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            if not stor159 * 0 / totalAllocPoint:
                                                                _6193 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_6193] = 26
                                                                mem[_6193 + 32] = 'SafeMath: division by zero'
                                                                _6458 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _6458 + 68] = mem[idx + _6193 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_6458 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _6458 + -mem[64] + 100
                                                            if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            _6457 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_6457] = 26
                                                            mem[_6457 + 32] = 'SafeMath: division by zero'
                                                            _6747 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            s = 0
                                                            while s < 26:
                                                                mem[s + _6747 + 68] = mem[s + _6457 + 32]
                                                                s = s + 32
                                                                continue 
                                                            mem[_6747 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _6747 + -mem[64] + 100
                                                        if 10000 * poolInfo[idx].field_1024 / poolInfo[idx].field_1024 != 10000:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if not 0 / totalAllocPoint:
                                                            _6192 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_6192] = 26
                                                            mem[_6192 + 32] = 'SafeMath: division by zero'
                                                            if not 10000 * poolInfo[idx].field_1024:
                                                                _6456 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _6456 + 68] = mem[idx + _6192 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_6456 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _6456 + -mem[64] + 100
                                                            if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                        else:
                                                            if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            if not stor159 * 0 / totalAllocPoint:
                                                                _6455 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_6455] = 26
                                                                mem[_6455 + 32] = 'SafeMath: division by zero'
                                                                if not 10000 * poolInfo[idx].field_1024:
                                                                    _6745 = mem[64]
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 26
                                                                    s = 0
                                                                    while s < 26:
                                                                        mem[s + _6745 + 68] = mem[s + _6455 + 32]
                                                                        s = s + 32
                                                                        continue 
                                                                    mem[_6745 + 94] = 0
                                                                    revert with memory
                                                                      from mem[64]
                                                                       len _6745 + -mem[64] + 100
                                                                if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                            else:
                                                                if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                _6744 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_6744] = 26
                                                                mem[_6744 + 32] = 'SafeMath: division by zero'
                                                                if not 10000 * poolInfo[idx].field_1024:
                                                                    _7026 = mem[64]
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 26
                                                                    idx = 0
                                                                    while idx < 26:
                                                                        mem[idx + _7026 + 68] = mem[idx + _6744 + 32]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    mem[_7026 + 94] = 0
                                                                    revert with memory
                                                                      from mem[64]
                                                                       len _7026 + -mem[64] + 100
                                                                if (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_512 += poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024
                                            else:
                                                if (10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint) / stor159 * 0 / totalAllocPoint != -poolInfo[idx].field_992 + 10000:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _4802 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_4802] = 26
                                                mem[_4802 + 32] = 'SafeMath: division by zero'
                                                if not 10000 * poolInfo[idx].field_1280:
                                                    _4896 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _4896 + 68] = mem[idx + _4802 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_4896 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _4896 + -mem[64] + 100
                                                if ((10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint) / 10000 * poolInfo[idx].field_1280) + poolInfo[idx].field_256 < poolInfo[idx].field_256:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_256 += (10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint) / 10000 * poolInfo[idx].field_1280
                                                if poolInfo[idx].field_992:
                                                    if poolInfo[idx].field_1024:
                                                        if not poolInfo[idx].field_1024:
                                                            if not 0 / totalAllocPoint:
                                                                _6191 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_6191] = 26
                                                                mem[_6191 + 32] = 'SafeMath: division by zero'
                                                                _6454 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _6454 + 68] = mem[idx + _6191 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_6454 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _6454 + -mem[64] + 100
                                                            if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            if not stor159 * 0 / totalAllocPoint:
                                                                _6453 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_6453] = 26
                                                                mem[_6453 + 32] = 'SafeMath: division by zero'
                                                                _6742 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                s = 0
                                                                while s < 26:
                                                                    mem[s + _6742 + 68] = mem[s + _6453 + 32]
                                                                    s = s + 32
                                                                    continue 
                                                                mem[_6742 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _6742 + -mem[64] + 100
                                                            if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            _6741 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_6741] = 26
                                                            mem[_6741 + 32] = 'SafeMath: division by zero'
                                                            _7024 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _7024 + 68] = mem[idx + _6741 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_7024 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _7024 + -mem[64] + 100
                                                        if 10000 * poolInfo[idx].field_1024 / poolInfo[idx].field_1024 != 10000:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if not 0 / totalAllocPoint:
                                                            _6452 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_6452] = 26
                                                            mem[_6452 + 32] = 'SafeMath: division by zero'
                                                            if not 10000 * poolInfo[idx].field_1024:
                                                                _6740 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                s = 0
                                                                while s < 26:
                                                                    mem[s + _6740 + 68] = mem[s + _6452 + 32]
                                                                    s = s + 32
                                                                    continue 
                                                                mem[_6740 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _6740 + -mem[64] + 100
                                                            if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                        else:
                                                            if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            if not stor159 * 0 / totalAllocPoint:
                                                                _6739 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_6739] = 26
                                                                mem[_6739 + 32] = 'SafeMath: division by zero'
                                                                if not 10000 * poolInfo[idx].field_1024:
                                                                    _7022 = mem[64]
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 26
                                                                    idx = 0
                                                                    while idx < 26:
                                                                        mem[idx + _7022 + 68] = mem[idx + _6739 + 32]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    mem[_7022 + 94] = 0
                                                                    revert with memory
                                                                      from mem[64]
                                                                       len _7022 + -mem[64] + 100
                                                                if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                            else:
                                                                if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                _7021 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_7021] = 26
                                                                mem[_7021 + 32] = 'SafeMath: division by zero'
                                                                if not 10000 * poolInfo[idx].field_1024:
                                                                    _7298 = mem[64]
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 26
                                                                    idx = 0
                                                                    while idx < 26:
                                                                        mem[idx + _7298 + 68] = mem[idx + _7021 + 32]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    mem[_7298 + 94] = 0
                                                                    revert with memory
                                                                      from mem[64]
                                                                       len _7298 + -mem[64] + 100
                                                                if (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_512 += poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024
                                    else:
                                        if (block.timestamp * 0 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4199 * poolInfo[idx].field_160) / (block.timestamp * 0 / _4199) - (poolInfo[idx].field_768 * 0 / _4199) != poolInfo[idx].field_160:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _4325 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_4325] = 26
                                        mem[_4325 + 32] = 'SafeMath: division by zero'
                                        if not totalAllocPoint:
                                            _4343 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _4343 + 68] = mem[idx + _4325 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_4343 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _4343 + -mem[64] + 100
                                        if not poolInfo[idx].field_1280:
                                            if not (block.timestamp * 0 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4199 * poolInfo[idx].field_160) / totalAllocPoint:
                                                _4608 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_4608] = 26
                                                mem[_4608 + 32] = 'SafeMath: division by zero'
                                                _4700 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _4700 + 68] = mem[idx + _4608 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_4700 + 94] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _4700 + -mem[64] + 100
                                            if stor159 * (block.timestamp * 0 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4199 * poolInfo[idx].field_160) / totalAllocPoint / (block.timestamp * 0 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4199 * poolInfo[idx].field_160) / totalAllocPoint != stor159:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if not stor159 * (block.timestamp * 0 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4199 * poolInfo[idx].field_160) / totalAllocPoint:
                                                _4699 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_4699] = 26
                                                mem[_4699 + 32] = 'SafeMath: division by zero'
                                                _4800 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _4800 + 68] = mem[idx + _4699 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_4800 + 94] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _4800 + -mem[64] + 100
                                            if (10000 * stor159 * (block.timestamp * 0 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4199 * poolInfo[idx].field_160) / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4199 * poolInfo[idx].field_160) / totalAllocPoint) / stor159 * (block.timestamp * 0 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4199 * poolInfo[idx].field_160) / totalAllocPoint != -poolInfo[idx].field_992 + 10000:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _4799 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_4799] = 26
                                            mem[_4799 + 32] = 'SafeMath: division by zero'
                                            _4894 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _4894 + 68] = mem[idx + _4799 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_4894 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _4894 + -mem[64] + 100
                                        if 10000 * poolInfo[idx].field_1280 / poolInfo[idx].field_1280 != 10000:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not (block.timestamp * 0 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4199 * poolInfo[idx].field_160) / totalAllocPoint:
                                            _4698 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_4698] = 26
                                            mem[_4698 + 32] = 'SafeMath: division by zero'
                                            if not 10000 * poolInfo[idx].field_1280:
                                                _4798 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _4798 + 68] = mem[idx + _4698 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_4798 + 94] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _4798 + -mem[64] + 100
                                            if (0 / 10000 * poolInfo[idx].field_1280) + poolInfo[idx].field_256 < poolInfo[idx].field_256:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_256 += 0 / 10000 * poolInfo[idx].field_1280
                                            if poolInfo[idx].field_992:
                                                if poolInfo[idx].field_1024:
                                                    if not poolInfo[idx].field_1024:
                                                        if not (block.timestamp * 0 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4199 * poolInfo[idx].field_160) / totalAllocPoint:
                                                            _5986 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_5986] = 26
                                                            mem[_5986 + 32] = 'SafeMath: division by zero'
                                                            _6190 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _6190 + 68] = mem[idx + _5986 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_6190 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _6190 + -mem[64] + 100
                                                        if stor159 * (block.timestamp * 0 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4199 * poolInfo[idx].field_160) / totalAllocPoint / (block.timestamp * 0 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4199 * poolInfo[idx].field_160) / totalAllocPoint != stor159:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if not stor159 * (block.timestamp * 0 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4199 * poolInfo[idx].field_160) / totalAllocPoint:
                                                            _6189 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_6189] = 26
                                                            mem[_6189 + 32] = 'SafeMath: division by zero'
                                                            _6450 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _6450 + 68] = mem[idx + _6189 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_6450 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _6450 + -mem[64] + 100
                                                        if poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4199 * poolInfo[idx].field_160) / totalAllocPoint / stor159 * (block.timestamp * 0 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4199 * poolInfo[idx].field_160) / totalAllocPoint != poolInfo[idx].field_992:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _6449 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_6449] = 26
                                                        mem[_6449 + 32] = 'SafeMath: division by zero'
                                                        _6737 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        s = 0
                                                        while s < 26:
                                                            mem[s + _6737 + 68] = mem[s + _6449 + 32]
                                                            s = s + 32
                                                            continue 
                                                        mem[_6737 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _6737 + -mem[64] + 100
                                                    if 10000 * poolInfo[idx].field_1024 / poolInfo[idx].field_1024 != 10000:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not (block.timestamp * 0 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4199 * poolInfo[idx].field_160) / totalAllocPoint:
                                                        _6188 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_6188] = 26
                                                        mem[_6188 + 32] = 'SafeMath: division by zero'
                                                        if not 10000 * poolInfo[idx].field_1024:
                                                            _6448 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _6448 + 68] = mem[idx + _6188 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_6448 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _6448 + -mem[64] + 100
                                                        if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                    else:
                                                        if stor159 * (block.timestamp * 0 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4199 * poolInfo[idx].field_160) / totalAllocPoint / (block.timestamp * 0 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4199 * poolInfo[idx].field_160) / totalAllocPoint != stor159:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if not stor159 * (block.timestamp * 0 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4199 * poolInfo[idx].field_160) / totalAllocPoint:
                                                            _6447 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_6447] = 26
                                                            mem[_6447 + 32] = 'SafeMath: division by zero'
                                                            if not 10000 * poolInfo[idx].field_1024:
                                                                _6735 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                s = 0
                                                                while s < 26:
                                                                    mem[s + _6735 + 68] = mem[s + _6447 + 32]
                                                                    s = s + 32
                                                                    continue 
                                                                mem[_6735 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _6735 + -mem[64] + 100
                                                            if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                        else:
                                                            if poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4199 * poolInfo[idx].field_160) / totalAllocPoint / stor159 * (block.timestamp * 0 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4199 * poolInfo[idx].field_160) / totalAllocPoint != poolInfo[idx].field_992:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            _6734 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_6734] = 26
                                                            mem[_6734 + 32] = 'SafeMath: division by zero'
                                                            if not 10000 * poolInfo[idx].field_1024:
                                                                _7018 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _7018 + 68] = mem[idx + _6734 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_7018 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _7018 + -mem[64] + 100
                                                            if (poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4199 * poolInfo[idx].field_160) / totalAllocPoint / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_512 += poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4199 * poolInfo[idx].field_160) / totalAllocPoint / 10000 * poolInfo[idx].field_1024
                                        else:
                                            if stor159 * (block.timestamp * 0 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4199 * poolInfo[idx].field_160) / totalAllocPoint / (block.timestamp * 0 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4199 * poolInfo[idx].field_160) / totalAllocPoint != stor159:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if not stor159 * (block.timestamp * 0 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4199 * poolInfo[idx].field_160) / totalAllocPoint:
                                                _4797 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_4797] = 26
                                                mem[_4797 + 32] = 'SafeMath: division by zero'
                                                if not 10000 * poolInfo[idx].field_1280:
                                                    _4892 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _4892 + 68] = mem[idx + _4797 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_4892 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _4892 + -mem[64] + 100
                                                if (0 / 10000 * poolInfo[idx].field_1280) + poolInfo[idx].field_256 < poolInfo[idx].field_256:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_256 += 0 / 10000 * poolInfo[idx].field_1280
                                                if poolInfo[idx].field_992:
                                                    if poolInfo[idx].field_1024:
                                                        if not poolInfo[idx].field_1024:
                                                            if not (block.timestamp * 0 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4199 * poolInfo[idx].field_160) / totalAllocPoint:
                                                                _6187 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_6187] = 26
                                                                mem[_6187 + 32] = 'SafeMath: division by zero'
                                                                _6446 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _6446 + 68] = mem[idx + _6187 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_6446 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _6446 + -mem[64] + 100
                                                            if stor159 * (block.timestamp * 0 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4199 * poolInfo[idx].field_160) / totalAllocPoint / (block.timestamp * 0 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4199 * poolInfo[idx].field_160) / totalAllocPoint != stor159:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            if not stor159 * (block.timestamp * 0 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4199 * poolInfo[idx].field_160) / totalAllocPoint:
                                                                _6445 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_6445] = 26
                                                                mem[_6445 + 32] = 'SafeMath: division by zero'
                                                                _6732 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                s = 0
                                                                while s < 26:
                                                                    mem[s + _6732 + 68] = mem[s + _6445 + 32]
                                                                    s = s + 32
                                                                    continue 
                                                                mem[_6732 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _6732 + -mem[64] + 100
                                                            if poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4199 * poolInfo[idx].field_160) / totalAllocPoint / stor159 * (block.timestamp * 0 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4199 * poolInfo[idx].field_160) / totalAllocPoint != poolInfo[idx].field_992:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            _6731 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_6731] = 26
                                                            mem[_6731 + 32] = 'SafeMath: division by zero'
                                                            _7016 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _7016 + 68] = mem[idx + _6731 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_7016 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _7016 + -mem[64] + 100
                                                        if 10000 * poolInfo[idx].field_1024 / poolInfo[idx].field_1024 != 10000:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if not (block.timestamp * 0 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4199 * poolInfo[idx].field_160) / totalAllocPoint:
                                                            _6444 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_6444] = 26
                                                            mem[_6444 + 32] = 'SafeMath: division by zero'
                                                            if not 10000 * poolInfo[idx].field_1024:
                                                                _6730 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                s = 0
                                                                while s < 26:
                                                                    mem[s + _6730 + 68] = mem[s + _6444 + 32]
                                                                    s = s + 32
                                                                    continue 
                                                                mem[_6730 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _6730 + -mem[64] + 100
                                                            if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                        else:
                                                            if stor159 * (block.timestamp * 0 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4199 * poolInfo[idx].field_160) / totalAllocPoint / (block.timestamp * 0 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4199 * poolInfo[idx].field_160) / totalAllocPoint != stor159:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            if not stor159 * (block.timestamp * 0 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4199 * poolInfo[idx].field_160) / totalAllocPoint:
                                                                _6729 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_6729] = 26
                                                                mem[_6729 + 32] = 'SafeMath: division by zero'
                                                                if not 10000 * poolInfo[idx].field_1024:
                                                                    _7014 = mem[64]
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 26
                                                                    idx = 0
                                                                    while idx < 26:
                                                                        mem[idx + _7014 + 68] = mem[idx + _6729 + 32]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    mem[_7014 + 94] = 0
                                                                    revert with memory
                                                                      from mem[64]
                                                                       len _7014 + -mem[64] + 100
                                                                if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                            else:
                                                                if poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4199 * poolInfo[idx].field_160) / totalAllocPoint / stor159 * (block.timestamp * 0 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4199 * poolInfo[idx].field_160) / totalAllocPoint != poolInfo[idx].field_992:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                _7013 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_7013] = 26
                                                                mem[_7013 + 32] = 'SafeMath: division by zero'
                                                                if not 10000 * poolInfo[idx].field_1024:
                                                                    _7293 = mem[64]
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 26
                                                                    idx = 0
                                                                    while idx < 26:
                                                                        mem[idx + _7293 + 68] = mem[idx + _7013 + 32]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    mem[_7293 + 94] = 0
                                                                    revert with memory
                                                                      from mem[64]
                                                                       len _7293 + -mem[64] + 100
                                                                if (poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4199 * poolInfo[idx].field_160) / totalAllocPoint / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_512 += poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4199 * poolInfo[idx].field_160) / totalAllocPoint / 10000 * poolInfo[idx].field_1024
                                            else:
                                                if (10000 * stor159 * (block.timestamp * 0 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4199 * poolInfo[idx].field_160) / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4199 * poolInfo[idx].field_160) / totalAllocPoint) / stor159 * (block.timestamp * 0 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4199 * poolInfo[idx].field_160) / totalAllocPoint != -poolInfo[idx].field_992 + 10000:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _4891 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_4891] = 26
                                                mem[_4891 + 32] = 'SafeMath: division by zero'
                                                if not 10000 * poolInfo[idx].field_1280:
                                                    _4979 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _4979 + 68] = mem[idx + _4891 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_4979 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _4979 + -mem[64] + 100
                                                if ((10000 * stor159 * (block.timestamp * 0 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4199 * poolInfo[idx].field_160) / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4199 * poolInfo[idx].field_160) / totalAllocPoint) / 10000 * poolInfo[idx].field_1280) + poolInfo[idx].field_256 < poolInfo[idx].field_256:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_256 += (10000 * stor159 * (block.timestamp * 0 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4199 * poolInfo[idx].field_160) / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4199 * poolInfo[idx].field_160) / totalAllocPoint) / 10000 * poolInfo[idx].field_1280
                                                if poolInfo[idx].field_992:
                                                    if poolInfo[idx].field_1024:
                                                        if not poolInfo[idx].field_1024:
                                                            if not (block.timestamp * 0 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4199 * poolInfo[idx].field_160) / totalAllocPoint:
                                                                _6443 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_6443] = 26
                                                                mem[_6443 + 32] = 'SafeMath: division by zero'
                                                                _6728 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                s = 0
                                                                while s < 26:
                                                                    mem[s + _6728 + 68] = mem[s + _6443 + 32]
                                                                    s = s + 32
                                                                    continue 
                                                                mem[_6728 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _6728 + -mem[64] + 100
                                                            if stor159 * (block.timestamp * 0 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4199 * poolInfo[idx].field_160) / totalAllocPoint / (block.timestamp * 0 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4199 * poolInfo[idx].field_160) / totalAllocPoint != stor159:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            if not stor159 * (block.timestamp * 0 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4199 * poolInfo[idx].field_160) / totalAllocPoint:
                                                                _6727 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_6727] = 26
                                                                mem[_6727 + 32] = 'SafeMath: division by zero'
                                                                _7011 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _7011 + 68] = mem[idx + _6727 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_7011 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _7011 + -mem[64] + 100
                                                            if poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4199 * poolInfo[idx].field_160) / totalAllocPoint / stor159 * (block.timestamp * 0 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4199 * poolInfo[idx].field_160) / totalAllocPoint != poolInfo[idx].field_992:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            _7010 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_7010] = 26
                                                            mem[_7010 + 32] = 'SafeMath: division by zero'
                                                            _7291 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _7291 + 68] = mem[idx + _7010 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_7291 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _7291 + -mem[64] + 100
                                                        if 10000 * poolInfo[idx].field_1024 / poolInfo[idx].field_1024 != 10000:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if not (block.timestamp * 0 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4199 * poolInfo[idx].field_160) / totalAllocPoint:
                                                            _6726 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_6726] = 26
                                                            mem[_6726 + 32] = 'SafeMath: division by zero'
                                                            if not 10000 * poolInfo[idx].field_1024:
                                                                _7009 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _7009 + 68] = mem[idx + _6726 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_7009 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _7009 + -mem[64] + 100
                                                            if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                        else:
                                                            if stor159 * (block.timestamp * 0 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4199 * poolInfo[idx].field_160) / totalAllocPoint / (block.timestamp * 0 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4199 * poolInfo[idx].field_160) / totalAllocPoint != stor159:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            if not stor159 * (block.timestamp * 0 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4199 * poolInfo[idx].field_160) / totalAllocPoint:
                                                                _7008 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_7008] = 26
                                                                mem[_7008 + 32] = 'SafeMath: division by zero'
                                                                if not 10000 * poolInfo[idx].field_1024:
                                                                    _7289 = mem[64]
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 26
                                                                    idx = 0
                                                                    while idx < 26:
                                                                        mem[idx + _7289 + 68] = mem[idx + _7008 + 32]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    mem[_7289 + 94] = 0
                                                                    revert with memory
                                                                      from mem[64]
                                                                       len _7289 + -mem[64] + 100
                                                                if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                            else:
                                                                if poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4199 * poolInfo[idx].field_160) / totalAllocPoint / stor159 * (block.timestamp * 0 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4199 * poolInfo[idx].field_160) / totalAllocPoint != poolInfo[idx].field_992:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                _7288 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_7288] = 26
                                                                mem[_7288 + 32] = 'SafeMath: division by zero'
                                                                if not 10000 * poolInfo[idx].field_1024:
                                                                    _7585 = mem[64]
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 26
                                                                    idx = 0
                                                                    while idx < 26:
                                                                        mem[idx + _7585 + 68] = mem[idx + _7288 + 32]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    mem[_7585 + 94] = 0
                                                                    revert with memory
                                                                      from mem[64]
                                                                       len _7585 + -mem[64] + 100
                                                                if (poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4199 * poolInfo[idx].field_160) / totalAllocPoint / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_512 += poolInfo[idx].field_992 * stor159 * (block.timestamp * 0 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * 0 / _4199 * poolInfo[idx].field_160) / totalAllocPoint / 10000 * poolInfo[idx].field_1024
                            else:
                                if mem[_4214 + 32] * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 != mem[_4214 + 32]:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _4247 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4247] = 26
                                mem[_4247 + 32] = 'SafeMath: division by zero'
                                if not _4199:
                                    _4252 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _4252 + 68] = mem[idx + _4247 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4252 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4252 + -mem[64] + 100
                                if not block.timestamp - poolInfo[idx].field_768:
                                    _4306 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4306] = 26
                                    mem[_4306 + 32] = 'SafeMath: division by zero'
                                    if not totalAllocPoint:
                                        _4324 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _4324 + 68] = mem[idx + _4306 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_4324 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _4324 + -mem[64] + 100
                                    if not poolInfo[idx].field_1280:
                                        if not 0 / totalAllocPoint:
                                            _4540 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_4540] = 26
                                            mem[_4540 + 32] = 'SafeMath: division by zero'
                                            _4607 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _4607 + 68] = mem[idx + _4540 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_4607 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _4607 + -mem[64] + 100
                                        if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not stor159 * 0 / totalAllocPoint:
                                            _4606 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_4606] = 26
                                            mem[_4606 + 32] = 'SafeMath: division by zero'
                                            _4696 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _4696 + 68] = mem[idx + _4606 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_4696 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _4696 + -mem[64] + 100
                                        if (10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint) / stor159 * 0 / totalAllocPoint != -poolInfo[idx].field_992 + 10000:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _4695 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_4695] = 26
                                        mem[_4695 + 32] = 'SafeMath: division by zero'
                                        _4795 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _4795 + 68] = mem[idx + _4695 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_4795 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _4795 + -mem[64] + 100
                                    if 10000 * poolInfo[idx].field_1280 / poolInfo[idx].field_1280 != 10000:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not 0 / totalAllocPoint:
                                        _4605 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_4605] = 26
                                        mem[_4605 + 32] = 'SafeMath: division by zero'
                                        if not 10000 * poolInfo[idx].field_1280:
                                            _4694 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _4694 + 68] = mem[idx + _4605 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_4694 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _4694 + -mem[64] + 100
                                        if (0 / 10000 * poolInfo[idx].field_1280) + poolInfo[idx].field_256 < poolInfo[idx].field_256:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_256 += 0 / 10000 * poolInfo[idx].field_1280
                                        if poolInfo[idx].field_992:
                                            if poolInfo[idx].field_1024:
                                                if not poolInfo[idx].field_1024:
                                                    if not 0 / totalAllocPoint:
                                                        _5844 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_5844] = 26
                                                        mem[_5844 + 32] = 'SafeMath: division by zero'
                                                        _5985 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _5985 + 68] = mem[idx + _5844 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_5985 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _5985 + -mem[64] + 100
                                                    if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not stor159 * 0 / totalAllocPoint:
                                                        _5984 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_5984] = 26
                                                        mem[_5984 + 32] = 'SafeMath: division by zero'
                                                        _6185 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _6185 + 68] = mem[idx + _5984 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_6185 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _6185 + -mem[64] + 100
                                                    if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    _6184 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_6184] = 26
                                                    mem[_6184 + 32] = 'SafeMath: division by zero'
                                                    _6441 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _6441 + 68] = mem[idx + _6184 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_6441 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _6441 + -mem[64] + 100
                                                if 10000 * poolInfo[idx].field_1024 / poolInfo[idx].field_1024 != 10000:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not 0 / totalAllocPoint:
                                                    _5983 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_5983] = 26
                                                    mem[_5983 + 32] = 'SafeMath: division by zero'
                                                    if not 10000 * poolInfo[idx].field_1024:
                                                        _6183 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _6183 + 68] = mem[idx + _5983 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_6183 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _6183 + -mem[64] + 100
                                                    if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                else:
                                                    if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not stor159 * 0 / totalAllocPoint:
                                                        _6182 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_6182] = 26
                                                        mem[_6182 + 32] = 'SafeMath: division by zero'
                                                        if not 10000 * poolInfo[idx].field_1024:
                                                            _6439 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _6439 + 68] = mem[idx + _6182 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_6439 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _6439 + -mem[64] + 100
                                                        if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                    else:
                                                        if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _6438 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_6438] = 26
                                                        mem[_6438 + 32] = 'SafeMath: division by zero'
                                                        if not 10000 * poolInfo[idx].field_1024:
                                                            _6723 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            s = 0
                                                            while s < 26:
                                                                mem[s + _6723 + 68] = mem[s + _6438 + 32]
                                                                s = s + 32
                                                                continue 
                                                            mem[_6723 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _6723 + -mem[64] + 100
                                                        if (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_512 += poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024
                                    else:
                                        if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not stor159 * 0 / totalAllocPoint:
                                            _4693 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_4693] = 26
                                            mem[_4693 + 32] = 'SafeMath: division by zero'
                                            if not 10000 * poolInfo[idx].field_1280:
                                                _4793 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _4793 + 68] = mem[idx + _4693 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_4793 + 94] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _4793 + -mem[64] + 100
                                            if (0 / 10000 * poolInfo[idx].field_1280) + poolInfo[idx].field_256 < poolInfo[idx].field_256:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_256 += 0 / 10000 * poolInfo[idx].field_1280
                                            if poolInfo[idx].field_992:
                                                if poolInfo[idx].field_1024:
                                                    if not poolInfo[idx].field_1024:
                                                        if not 0 / totalAllocPoint:
                                                            _5982 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_5982] = 26
                                                            mem[_5982 + 32] = 'SafeMath: division by zero'
                                                            _6181 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _6181 + 68] = mem[idx + _5982 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_6181 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _6181 + -mem[64] + 100
                                                        if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if not stor159 * 0 / totalAllocPoint:
                                                            _6180 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_6180] = 26
                                                            mem[_6180 + 32] = 'SafeMath: division by zero'
                                                            _6436 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _6436 + 68] = mem[idx + _6180 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_6436 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _6436 + -mem[64] + 100
                                                        if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _6435 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_6435] = 26
                                                        mem[_6435 + 32] = 'SafeMath: division by zero'
                                                        _6721 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        s = 0
                                                        while s < 26:
                                                            mem[s + _6721 + 68] = mem[s + _6435 + 32]
                                                            s = s + 32
                                                            continue 
                                                        mem[_6721 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _6721 + -mem[64] + 100
                                                    if 10000 * poolInfo[idx].field_1024 / poolInfo[idx].field_1024 != 10000:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not 0 / totalAllocPoint:
                                                        _6179 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_6179] = 26
                                                        mem[_6179 + 32] = 'SafeMath: division by zero'
                                                        if not 10000 * poolInfo[idx].field_1024:
                                                            _6434 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _6434 + 68] = mem[idx + _6179 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_6434 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _6434 + -mem[64] + 100
                                                        if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                    else:
                                                        if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if not stor159 * 0 / totalAllocPoint:
                                                            _6433 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_6433] = 26
                                                            mem[_6433 + 32] = 'SafeMath: division by zero'
                                                            if not 10000 * poolInfo[idx].field_1024:
                                                                _6719 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                s = 0
                                                                while s < 26:
                                                                    mem[s + _6719 + 68] = mem[s + _6433 + 32]
                                                                    s = s + 32
                                                                    continue 
                                                                mem[_6719 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _6719 + -mem[64] + 100
                                                            if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                        else:
                                                            if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            _6718 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_6718] = 26
                                                            mem[_6718 + 32] = 'SafeMath: division by zero'
                                                            if not 10000 * poolInfo[idx].field_1024:
                                                                _7003 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _7003 + 68] = mem[idx + _6718 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_7003 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _7003 + -mem[64] + 100
                                                            if (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_512 += poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024
                                        else:
                                            if (10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint) / stor159 * 0 / totalAllocPoint != -poolInfo[idx].field_992 + 10000:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _4792 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_4792] = 26
                                            mem[_4792 + 32] = 'SafeMath: division by zero'
                                            if not 10000 * poolInfo[idx].field_1280:
                                                _4888 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _4888 + 68] = mem[idx + _4792 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_4888 + 94] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _4888 + -mem[64] + 100
                                            if ((10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint) / 10000 * poolInfo[idx].field_1280) + poolInfo[idx].field_256 < poolInfo[idx].field_256:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_256 += (10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint) / 10000 * poolInfo[idx].field_1280
                                            if poolInfo[idx].field_992:
                                                if poolInfo[idx].field_1024:
                                                    if not poolInfo[idx].field_1024:
                                                        if not 0 / totalAllocPoint:
                                                            _6178 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_6178] = 26
                                                            mem[_6178 + 32] = 'SafeMath: division by zero'
                                                            _6432 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _6432 + 68] = mem[idx + _6178 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_6432 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _6432 + -mem[64] + 100
                                                        if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if not stor159 * 0 / totalAllocPoint:
                                                            _6431 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_6431] = 26
                                                            mem[_6431 + 32] = 'SafeMath: division by zero'
                                                            _6716 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            s = 0
                                                            while s < 26:
                                                                mem[s + _6716 + 68] = mem[s + _6431 + 32]
                                                                s = s + 32
                                                                continue 
                                                            mem[_6716 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _6716 + -mem[64] + 100
                                                        if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _6715 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_6715] = 26
                                                        mem[_6715 + 32] = 'SafeMath: division by zero'
                                                        _7001 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _7001 + 68] = mem[idx + _6715 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_7001 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _7001 + -mem[64] + 100
                                                    if 10000 * poolInfo[idx].field_1024 / poolInfo[idx].field_1024 != 10000:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not 0 / totalAllocPoint:
                                                        _6430 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_6430] = 26
                                                        mem[_6430 + 32] = 'SafeMath: division by zero'
                                                        if not 10000 * poolInfo[idx].field_1024:
                                                            _6714 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            s = 0
                                                            while s < 26:
                                                                mem[s + _6714 + 68] = mem[s + _6430 + 32]
                                                                s = s + 32
                                                                continue 
                                                            mem[_6714 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _6714 + -mem[64] + 100
                                                        if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                    else:
                                                        if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if not stor159 * 0 / totalAllocPoint:
                                                            _6713 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_6713] = 26
                                                            mem[_6713 + 32] = 'SafeMath: division by zero'
                                                            if not 10000 * poolInfo[idx].field_1024:
                                                                _6999 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _6999 + 68] = mem[idx + _6713 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_6999 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _6999 + -mem[64] + 100
                                                            if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                        else:
                                                            if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            _6998 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_6998] = 26
                                                            mem[_6998 + 32] = 'SafeMath: division by zero'
                                                            if not 10000 * poolInfo[idx].field_1024:
                                                                _7279 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _7279 + 68] = mem[idx + _6998 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_7279 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _7279 + -mem[64] + 100
                                                            if (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_512 += poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024
                                else:
                                    if (block.timestamp * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199) - (poolInfo[idx].field_768 * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199) / block.timestamp - poolInfo[idx].field_768 != _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not (block.timestamp * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199) - (poolInfo[idx].field_768 * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199):
                                        _4323 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_4323] = 26
                                        mem[_4323 + 32] = 'SafeMath: division by zero'
                                        if not totalAllocPoint:
                                            _4341 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _4341 + 68] = mem[idx + _4323 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_4341 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _4341 + -mem[64] + 100
                                        if not poolInfo[idx].field_1280:
                                            if not 0 / totalAllocPoint:
                                                _4604 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_4604] = 26
                                                mem[_4604 + 32] = 'SafeMath: division by zero'
                                                _4692 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _4692 + 68] = mem[idx + _4604 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_4692 + 94] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _4692 + -mem[64] + 100
                                            if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if not stor159 * 0 / totalAllocPoint:
                                                _4691 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_4691] = 26
                                                mem[_4691 + 32] = 'SafeMath: division by zero'
                                                _4790 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _4790 + 68] = mem[idx + _4691 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_4790 + 94] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _4790 + -mem[64] + 100
                                            if (10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint) / stor159 * 0 / totalAllocPoint != -poolInfo[idx].field_992 + 10000:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _4789 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_4789] = 26
                                            mem[_4789 + 32] = 'SafeMath: division by zero'
                                            _4886 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _4886 + 68] = mem[idx + _4789 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_4886 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _4886 + -mem[64] + 100
                                        if 10000 * poolInfo[idx].field_1280 / poolInfo[idx].field_1280 != 10000:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not 0 / totalAllocPoint:
                                            _4690 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_4690] = 26
                                            mem[_4690 + 32] = 'SafeMath: division by zero'
                                            if not 10000 * poolInfo[idx].field_1280:
                                                _4788 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _4788 + 68] = mem[idx + _4690 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_4788 + 94] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _4788 + -mem[64] + 100
                                            if (0 / 10000 * poolInfo[idx].field_1280) + poolInfo[idx].field_256 < poolInfo[idx].field_256:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_256 += 0 / 10000 * poolInfo[idx].field_1280
                                            if poolInfo[idx].field_992:
                                                if poolInfo[idx].field_1024:
                                                    if not poolInfo[idx].field_1024:
                                                        if not 0 / totalAllocPoint:
                                                            _5981 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_5981] = 26
                                                            mem[_5981 + 32] = 'SafeMath: division by zero'
                                                            _6177 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _6177 + 68] = mem[idx + _5981 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_6177 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _6177 + -mem[64] + 100
                                                        if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if not stor159 * 0 / totalAllocPoint:
                                                            _6176 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_6176] = 26
                                                            mem[_6176 + 32] = 'SafeMath: division by zero'
                                                            _6428 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _6428 + 68] = mem[idx + _6176 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_6428 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _6428 + -mem[64] + 100
                                                        if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _6427 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_6427] = 26
                                                        mem[_6427 + 32] = 'SafeMath: division by zero'
                                                        _6711 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        s = 0
                                                        while s < 26:
                                                            mem[s + _6711 + 68] = mem[s + _6427 + 32]
                                                            s = s + 32
                                                            continue 
                                                        mem[_6711 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _6711 + -mem[64] + 100
                                                    if 10000 * poolInfo[idx].field_1024 / poolInfo[idx].field_1024 != 10000:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not 0 / totalAllocPoint:
                                                        _6175 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_6175] = 26
                                                        mem[_6175 + 32] = 'SafeMath: division by zero'
                                                        if not 10000 * poolInfo[idx].field_1024:
                                                            _6426 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _6426 + 68] = mem[idx + _6175 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_6426 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _6426 + -mem[64] + 100
                                                        if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                    else:
                                                        if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if not stor159 * 0 / totalAllocPoint:
                                                            _6425 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_6425] = 26
                                                            mem[_6425 + 32] = 'SafeMath: division by zero'
                                                            if not 10000 * poolInfo[idx].field_1024:
                                                                _6709 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                s = 0
                                                                while s < 26:
                                                                    mem[s + _6709 + 68] = mem[s + _6425 + 32]
                                                                    s = s + 32
                                                                    continue 
                                                                mem[_6709 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _6709 + -mem[64] + 100
                                                            if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                        else:
                                                            if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            _6708 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_6708] = 26
                                                            mem[_6708 + 32] = 'SafeMath: division by zero'
                                                            if not 10000 * poolInfo[idx].field_1024:
                                                                _6995 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _6995 + 68] = mem[idx + _6708 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_6995 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _6995 + -mem[64] + 100
                                                            if (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_512 += poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024
                                        else:
                                            if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if not stor159 * 0 / totalAllocPoint:
                                                _4787 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_4787] = 26
                                                mem[_4787 + 32] = 'SafeMath: division by zero'
                                                if not 10000 * poolInfo[idx].field_1280:
                                                    _4884 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _4884 + 68] = mem[idx + _4787 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_4884 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _4884 + -mem[64] + 100
                                                if (0 / 10000 * poolInfo[idx].field_1280) + poolInfo[idx].field_256 < poolInfo[idx].field_256:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_256 += 0 / 10000 * poolInfo[idx].field_1280
                                                if poolInfo[idx].field_992:
                                                    if poolInfo[idx].field_1024:
                                                        if not poolInfo[idx].field_1024:
                                                            if not 0 / totalAllocPoint:
                                                                _6174 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_6174] = 26
                                                                mem[_6174 + 32] = 'SafeMath: division by zero'
                                                                _6424 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _6424 + 68] = mem[idx + _6174 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_6424 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _6424 + -mem[64] + 100
                                                            if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            if not stor159 * 0 / totalAllocPoint:
                                                                _6423 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_6423] = 26
                                                                mem[_6423 + 32] = 'SafeMath: division by zero'
                                                                _6706 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                s = 0
                                                                while s < 26:
                                                                    mem[s + _6706 + 68] = mem[s + _6423 + 32]
                                                                    s = s + 32
                                                                    continue 
                                                                mem[_6706 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _6706 + -mem[64] + 100
                                                            if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            _6705 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_6705] = 26
                                                            mem[_6705 + 32] = 'SafeMath: division by zero'
                                                            _6993 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _6993 + 68] = mem[idx + _6705 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_6993 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _6993 + -mem[64] + 100
                                                        if 10000 * poolInfo[idx].field_1024 / poolInfo[idx].field_1024 != 10000:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if not 0 / totalAllocPoint:
                                                            _6422 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_6422] = 26
                                                            mem[_6422 + 32] = 'SafeMath: division by zero'
                                                            if not 10000 * poolInfo[idx].field_1024:
                                                                _6704 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                s = 0
                                                                while s < 26:
                                                                    mem[s + _6704 + 68] = mem[s + _6422 + 32]
                                                                    s = s + 32
                                                                    continue 
                                                                mem[_6704 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _6704 + -mem[64] + 100
                                                            if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                        else:
                                                            if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            if not stor159 * 0 / totalAllocPoint:
                                                                _6703 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_6703] = 26
                                                                mem[_6703 + 32] = 'SafeMath: division by zero'
                                                                if not 10000 * poolInfo[idx].field_1024:
                                                                    _6991 = mem[64]
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 26
                                                                    idx = 0
                                                                    while idx < 26:
                                                                        mem[idx + _6991 + 68] = mem[idx + _6703 + 32]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    mem[_6991 + 94] = 0
                                                                    revert with memory
                                                                      from mem[64]
                                                                       len _6991 + -mem[64] + 100
                                                                if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                            else:
                                                                if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                _6990 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_6990] = 26
                                                                mem[_6990 + 32] = 'SafeMath: division by zero'
                                                                if not 10000 * poolInfo[idx].field_1024:
                                                                    _7274 = mem[64]
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 26
                                                                    idx = 0
                                                                    while idx < 26:
                                                                        mem[idx + _7274 + 68] = mem[idx + _6990 + 32]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    mem[_7274 + 94] = 0
                                                                    revert with memory
                                                                      from mem[64]
                                                                       len _7274 + -mem[64] + 100
                                                                if (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_512 += poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024
                                            else:
                                                if (10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint) / stor159 * 0 / totalAllocPoint != -poolInfo[idx].field_992 + 10000:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _4883 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_4883] = 26
                                                mem[_4883 + 32] = 'SafeMath: division by zero'
                                                if not 10000 * poolInfo[idx].field_1280:
                                                    _4974 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _4974 + 68] = mem[idx + _4883 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_4974 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _4974 + -mem[64] + 100
                                                if ((10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint) / 10000 * poolInfo[idx].field_1280) + poolInfo[idx].field_256 < poolInfo[idx].field_256:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_256 += (10000 * stor159 * 0 / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint) / 10000 * poolInfo[idx].field_1280
                                                if poolInfo[idx].field_992:
                                                    if poolInfo[idx].field_1024:
                                                        if not poolInfo[idx].field_1024:
                                                            if not 0 / totalAllocPoint:
                                                                _6421 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_6421] = 26
                                                                mem[_6421 + 32] = 'SafeMath: division by zero'
                                                                _6702 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                s = 0
                                                                while s < 26:
                                                                    mem[s + _6702 + 68] = mem[s + _6421 + 32]
                                                                    s = s + 32
                                                                    continue 
                                                                mem[_6702 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _6702 + -mem[64] + 100
                                                            if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            if not stor159 * 0 / totalAllocPoint:
                                                                _6701 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_6701] = 26
                                                                mem[_6701 + 32] = 'SafeMath: division by zero'
                                                                _6988 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _6988 + 68] = mem[idx + _6701 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_6988 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _6988 + -mem[64] + 100
                                                            if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            _6987 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_6987] = 26
                                                            mem[_6987 + 32] = 'SafeMath: division by zero'
                                                            _7272 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _7272 + 68] = mem[idx + _6987 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_7272 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _7272 + -mem[64] + 100
                                                        if 10000 * poolInfo[idx].field_1024 / poolInfo[idx].field_1024 != 10000:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if not 0 / totalAllocPoint:
                                                            _6700 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_6700] = 26
                                                            mem[_6700 + 32] = 'SafeMath: division by zero'
                                                            if not 10000 * poolInfo[idx].field_1024:
                                                                _6986 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _6986 + 68] = mem[idx + _6700 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_6986 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _6986 + -mem[64] + 100
                                                            if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                        else:
                                                            if stor159 * 0 / totalAllocPoint / 0 / totalAllocPoint != stor159:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            if not stor159 * 0 / totalAllocPoint:
                                                                _6985 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_6985] = 26
                                                                mem[_6985 + 32] = 'SafeMath: division by zero'
                                                                if not 10000 * poolInfo[idx].field_1024:
                                                                    _7270 = mem[64]
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 26
                                                                    idx = 0
                                                                    while idx < 26:
                                                                        mem[idx + _7270 + 68] = mem[idx + _6985 + 32]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    mem[_7270 + 94] = 0
                                                                    revert with memory
                                                                      from mem[64]
                                                                       len _7270 + -mem[64] + 100
                                                                if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                            else:
                                                                if poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / stor159 * 0 / totalAllocPoint != poolInfo[idx].field_992:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                _7269 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_7269] = 26
                                                                mem[_7269 + 32] = 'SafeMath: division by zero'
                                                                if not 10000 * poolInfo[idx].field_1024:
                                                                    _7563 = mem[64]
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 26
                                                                    idx = 0
                                                                    while idx < 26:
                                                                        mem[idx + _7563 + 68] = mem[idx + _7269 + 32]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    mem[_7563 + 94] = 0
                                                                    revert with memory
                                                                      from mem[64]
                                                                       len _7563 + -mem[64] + 100
                                                                if (poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_512 += poolInfo[idx].field_992 * stor159 * 0 / totalAllocPoint / 10000 * poolInfo[idx].field_1024
                                    else:
                                        if (block.timestamp * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) / (block.timestamp * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199) - (poolInfo[idx].field_768 * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199) != poolInfo[idx].field_160:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _4340 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_4340] = 26
                                        mem[_4340 + 32] = 'SafeMath: division by zero'
                                        if not totalAllocPoint:
                                            _4354 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _4354 + 68] = mem[idx + _4340 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_4354 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _4354 + -mem[64] + 100
                                        if not poolInfo[idx].field_1280:
                                            if not (block.timestamp * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) / totalAllocPoint:
                                                _4689 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_4689] = 26
                                                mem[_4689 + 32] = 'SafeMath: division by zero'
                                                _4786 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _4786 + 68] = mem[idx + _4689 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_4786 + 94] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _4786 + -mem[64] + 100
                                            if stor159 * (block.timestamp * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) / totalAllocPoint / (block.timestamp * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) / totalAllocPoint != stor159:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if not stor159 * (block.timestamp * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) / totalAllocPoint:
                                                _4785 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_4785] = 26
                                                mem[_4785 + 32] = 'SafeMath: division by zero'
                                                _4881 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _4881 + 68] = mem[idx + _4785 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_4881 + 94] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _4881 + -mem[64] + 100
                                            if (10000 * stor159 * (block.timestamp * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * (block.timestamp * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) / totalAllocPoint) / stor159 * (block.timestamp * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) / totalAllocPoint != -poolInfo[idx].field_992 + 10000:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _4880 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_4880] = 26
                                            mem[_4880 + 32] = 'SafeMath: division by zero'
                                            _4972 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _4972 + 68] = mem[idx + _4880 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_4972 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _4972 + -mem[64] + 100
                                        if 10000 * poolInfo[idx].field_1280 / poolInfo[idx].field_1280 != 10000:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not (block.timestamp * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) / totalAllocPoint:
                                            _4784 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_4784] = 26
                                            mem[_4784 + 32] = 'SafeMath: division by zero'
                                            if not 10000 * poolInfo[idx].field_1280:
                                                _4879 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _4879 + 68] = mem[idx + _4784 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_4879 + 94] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _4879 + -mem[64] + 100
                                            if (0 / 10000 * poolInfo[idx].field_1280) + poolInfo[idx].field_256 < poolInfo[idx].field_256:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_256 += 0 / 10000 * poolInfo[idx].field_1280
                                            if poolInfo[idx].field_992:
                                                if poolInfo[idx].field_1024:
                                                    if not poolInfo[idx].field_1024:
                                                        if not (block.timestamp * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) / totalAllocPoint:
                                                            _6173 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_6173] = 26
                                                            mem[_6173 + 32] = 'SafeMath: division by zero'
                                                            _6420 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _6420 + 68] = mem[idx + _6173 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_6420 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _6420 + -mem[64] + 100
                                                        if stor159 * (block.timestamp * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) / totalAllocPoint / (block.timestamp * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) / totalAllocPoint != stor159:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if not stor159 * (block.timestamp * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) / totalAllocPoint:
                                                            _6419 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_6419] = 26
                                                            mem[_6419 + 32] = 'SafeMath: division by zero'
                                                            _6698 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            s = 0
                                                            while s < 26:
                                                                mem[s + _6698 + 68] = mem[s + _6419 + 32]
                                                                s = s + 32
                                                                continue 
                                                            mem[_6698 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _6698 + -mem[64] + 100
                                                        if poolInfo[idx].field_992 * stor159 * (block.timestamp * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) / totalAllocPoint / stor159 * (block.timestamp * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) / totalAllocPoint != poolInfo[idx].field_992:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _6697 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_6697] = 26
                                                        mem[_6697 + 32] = 'SafeMath: division by zero'
                                                        _6983 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _6983 + 68] = mem[idx + _6697 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_6983 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _6983 + -mem[64] + 100
                                                    if 10000 * poolInfo[idx].field_1024 / poolInfo[idx].field_1024 != 10000:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not (block.timestamp * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) / totalAllocPoint:
                                                        _6418 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_6418] = 26
                                                        mem[_6418 + 32] = 'SafeMath: division by zero'
                                                        if not 10000 * poolInfo[idx].field_1024:
                                                            _6696 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            s = 0
                                                            while s < 26:
                                                                mem[s + _6696 + 68] = mem[s + _6418 + 32]
                                                                s = s + 32
                                                                continue 
                                                            mem[_6696 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _6696 + -mem[64] + 100
                                                        if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                    else:
                                                        if stor159 * (block.timestamp * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) / totalAllocPoint / (block.timestamp * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) / totalAllocPoint != stor159:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if not stor159 * (block.timestamp * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) / totalAllocPoint:
                                                            _6695 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_6695] = 26
                                                            mem[_6695 + 32] = 'SafeMath: division by zero'
                                                            if not 10000 * poolInfo[idx].field_1024:
                                                                _6981 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _6981 + 68] = mem[idx + _6695 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_6981 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _6981 + -mem[64] + 100
                                                            if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                        else:
                                                            if poolInfo[idx].field_992 * stor159 * (block.timestamp * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) / totalAllocPoint / stor159 * (block.timestamp * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) / totalAllocPoint != poolInfo[idx].field_992:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            _6980 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_6980] = 26
                                                            mem[_6980 + 32] = 'SafeMath: division by zero'
                                                            if not 10000 * poolInfo[idx].field_1024:
                                                                _7266 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _7266 + 68] = mem[idx + _6980 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_7266 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _7266 + -mem[64] + 100
                                                            if (poolInfo[idx].field_992 * stor159 * (block.timestamp * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) / totalAllocPoint / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_512 += poolInfo[idx].field_992 * stor159 * (block.timestamp * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) / totalAllocPoint / 10000 * poolInfo[idx].field_1024
                                        else:
                                            if stor159 * (block.timestamp * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) / totalAllocPoint / (block.timestamp * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) / totalAllocPoint != stor159:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if not stor159 * (block.timestamp * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) / totalAllocPoint:
                                                _4878 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_4878] = 26
                                                mem[_4878 + 32] = 'SafeMath: division by zero'
                                                if not 10000 * poolInfo[idx].field_1280:
                                                    _4970 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _4970 + 68] = mem[idx + _4878 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_4970 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _4970 + -mem[64] + 100
                                                if (0 / 10000 * poolInfo[idx].field_1280) + poolInfo[idx].field_256 < poolInfo[idx].field_256:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_256 += 0 / 10000 * poolInfo[idx].field_1280
                                                if poolInfo[idx].field_992:
                                                    if poolInfo[idx].field_1024:
                                                        if not poolInfo[idx].field_1024:
                                                            if not (block.timestamp * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) / totalAllocPoint:
                                                                _6417 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_6417] = 26
                                                                mem[_6417 + 32] = 'SafeMath: division by zero'
                                                                _6694 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                s = 0
                                                                while s < 26:
                                                                    mem[s + _6694 + 68] = mem[s + _6417 + 32]
                                                                    s = s + 32
                                                                    continue 
                                                                mem[_6694 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _6694 + -mem[64] + 100
                                                            if stor159 * (block.timestamp * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) / totalAllocPoint / (block.timestamp * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) / totalAllocPoint != stor159:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            if not stor159 * (block.timestamp * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) / totalAllocPoint:
                                                                _6693 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_6693] = 26
                                                                mem[_6693 + 32] = 'SafeMath: division by zero'
                                                                _6978 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _6978 + 68] = mem[idx + _6693 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_6978 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _6978 + -mem[64] + 100
                                                            if poolInfo[idx].field_992 * stor159 * (block.timestamp * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) / totalAllocPoint / stor159 * (block.timestamp * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) / totalAllocPoint != poolInfo[idx].field_992:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            _6977 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_6977] = 26
                                                            mem[_6977 + 32] = 'SafeMath: division by zero'
                                                            _7264 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _7264 + 68] = mem[idx + _6977 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_7264 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _7264 + -mem[64] + 100
                                                        if 10000 * poolInfo[idx].field_1024 / poolInfo[idx].field_1024 != 10000:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if not (block.timestamp * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) / totalAllocPoint:
                                                            _6692 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_6692] = 26
                                                            mem[_6692 + 32] = 'SafeMath: division by zero'
                                                            if not 10000 * poolInfo[idx].field_1024:
                                                                _6976 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _6976 + 68] = mem[idx + _6692 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_6976 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _6976 + -mem[64] + 100
                                                            if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                        else:
                                                            if stor159 * (block.timestamp * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) / totalAllocPoint / (block.timestamp * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) / totalAllocPoint != stor159:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            if not stor159 * (block.timestamp * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) / totalAllocPoint:
                                                                _6975 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_6975] = 26
                                                                mem[_6975 + 32] = 'SafeMath: division by zero'
                                                                if not 10000 * poolInfo[idx].field_1024:
                                                                    _7262 = mem[64]
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 26
                                                                    idx = 0
                                                                    while idx < 26:
                                                                        mem[idx + _7262 + 68] = mem[idx + _6975 + 32]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    mem[_7262 + 94] = 0
                                                                    revert with memory
                                                                      from mem[64]
                                                                       len _7262 + -mem[64] + 100
                                                                if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                            else:
                                                                if poolInfo[idx].field_992 * stor159 * (block.timestamp * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) / totalAllocPoint / stor159 * (block.timestamp * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) / totalAllocPoint != poolInfo[idx].field_992:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                _7261 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_7261] = 26
                                                                mem[_7261 + 32] = 'SafeMath: division by zero'
                                                                if not 10000 * poolInfo[idx].field_1024:
                                                                    _7558 = mem[64]
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 26
                                                                    idx = 0
                                                                    while idx < 26:
                                                                        mem[idx + _7558 + 68] = mem[idx + _7261 + 32]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    mem[_7558 + 94] = 0
                                                                    revert with memory
                                                                      from mem[64]
                                                                       len _7558 + -mem[64] + 100
                                                                if (poolInfo[idx].field_992 * stor159 * (block.timestamp * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) / totalAllocPoint / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_512 += poolInfo[idx].field_992 * stor159 * (block.timestamp * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) / totalAllocPoint / 10000 * poolInfo[idx].field_1024
                                            else:
                                                if (10000 * stor159 * (block.timestamp * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * (block.timestamp * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) / totalAllocPoint) / stor159 * (block.timestamp * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) / totalAllocPoint != -poolInfo[idx].field_992 + 10000:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _4969 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_4969] = 26
                                                mem[_4969 + 32] = 'SafeMath: division by zero'
                                                if not 10000 * poolInfo[idx].field_1280:
                                                    _5065 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _5065 + 68] = mem[idx + _4969 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_5065 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _5065 + -mem[64] + 100
                                                if ((10000 * stor159 * (block.timestamp * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * (block.timestamp * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) / totalAllocPoint) / 10000 * poolInfo[idx].field_1280) + poolInfo[idx].field_256 < poolInfo[idx].field_256:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_256 += (10000 * stor159 * (block.timestamp * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) / totalAllocPoint) - (poolInfo[idx].field_992 * stor159 * (block.timestamp * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) / totalAllocPoint) / 10000 * poolInfo[idx].field_1280
                                                if poolInfo[idx].field_992:
                                                    if poolInfo[idx].field_1024:
                                                        if not poolInfo[idx].field_1024:
                                                            if not (block.timestamp * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) / totalAllocPoint:
                                                                _6691 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_6691] = 26
                                                                mem[_6691 + 32] = 'SafeMath: division by zero'
                                                                _6974 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _6974 + 68] = mem[idx + _6691 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_6974 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _6974 + -mem[64] + 100
                                                            if stor159 * (block.timestamp * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) / totalAllocPoint / (block.timestamp * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) / totalAllocPoint != stor159:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            if not stor159 * (block.timestamp * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) / totalAllocPoint:
                                                                _6973 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_6973] = 26
                                                                mem[_6973 + 32] = 'SafeMath: division by zero'
                                                                _7259 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _7259 + 68] = mem[idx + _6973 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_7259 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _7259 + -mem[64] + 100
                                                            if poolInfo[idx].field_992 * stor159 * (block.timestamp * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) / totalAllocPoint / stor159 * (block.timestamp * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) / totalAllocPoint != poolInfo[idx].field_992:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            _7258 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_7258] = 26
                                                            mem[_7258 + 32] = 'SafeMath: division by zero'
                                                            _7556 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _7556 + 68] = mem[idx + _7258 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_7556 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _7556 + -mem[64] + 100
                                                        if 10000 * poolInfo[idx].field_1024 / poolInfo[idx].field_1024 != 10000:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if not (block.timestamp * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) / totalAllocPoint:
                                                            _6972 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_6972] = 26
                                                            mem[_6972 + 32] = 'SafeMath: division by zero'
                                                            if not 10000 * poolInfo[idx].field_1024:
                                                                _7257 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _7257 + 68] = mem[idx + _6972 + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_7257 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _7257 + -mem[64] + 100
                                                            if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                        else:
                                                            if stor159 * (block.timestamp * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) / totalAllocPoint / (block.timestamp * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) / totalAllocPoint != stor159:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            if not stor159 * (block.timestamp * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) / totalAllocPoint:
                                                                _7256 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_7256] = 26
                                                                mem[_7256 + 32] = 'SafeMath: division by zero'
                                                                if not 10000 * poolInfo[idx].field_1024:
                                                                    _7554 = mem[64]
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 26
                                                                    idx = 0
                                                                    while idx < 26:
                                                                        mem[idx + _7554 + 68] = mem[idx + _7256 + 32]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    mem[_7554 + 94] = 0
                                                                    revert with memory
                                                                      from mem[64]
                                                                       len _7554 + -mem[64] + 100
                                                                if (0 / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_512 += 0 / 10000 * poolInfo[idx].field_1024
                                                            else:
                                                                if poolInfo[idx].field_992 * stor159 * (block.timestamp * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) / totalAllocPoint / stor159 * (block.timestamp * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) / totalAllocPoint != poolInfo[idx].field_992:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                _7553 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_7553] = 26
                                                                mem[_7553 + 32] = 'SafeMath: division by zero'
                                                                if not 10000 * poolInfo[idx].field_1024:
                                                                    _7863 = mem[64]
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 26
                                                                    idx = 0
                                                                    while idx < 26:
                                                                        mem[idx + _7863 + 68] = mem[idx + _7553 + 32]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    mem[_7863 + 94] = 0
                                                                    revert with memory
                                                                      from mem[64]
                                                                       len _7863 + -mem[64] + 100
                                                                if (poolInfo[idx].field_992 * stor159 * (block.timestamp * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) / totalAllocPoint / 10000 * poolInfo[idx].field_1024) + poolInfo[idx].field_512 < poolInfo[idx].field_512:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_512 += poolInfo[idx].field_992 * stor159 * (block.timestamp * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) - (poolInfo[idx].field_768 * _4233 * (1000 * _4169) - (_4129 * _4169) - (_4121 * _4169) - (_4113 * _4169) / 1000 / _4199 * poolInfo[idx].field_160) / totalAllocPoint / 10000 * poolInfo[idx].field_1024
                poolInfo[idx].field_768 = uint64(block.timestamp)
                mem[mem[64]] = uint64(block.timestamp)
                mem[mem[64] + 32] = poolInfo[idx].field_1280
                mem[mem[64] + 64] = poolInfo[idx].field_256
                mem[mem[64] + 96] = poolInfo[idx].field_512
                emit UpdatePool(block.timestamp << 192, poolInfo[idx].field_1280, poolInfo[idx].field_256, poolInfo[idx].field_512, idx);
            idx = idx + 1
            continue 
    if Mask(96, 0, arg1) + totalAllocPoint < totalAllocPoint:
        revert with 0, 'SafeMath: addition overflow'
    totalAllocPoint += Mask(96, 0, arg1)
    poolInfo.length++
    poolInfo[poolInfo.length].field_0 = address(arg3)
    poolInfo[poolInfo.length].field_160 = Mask(96, 0, arg1)
    poolInfo[poolInfo.length].field_256 = 0
    poolInfo[poolInfo.length].field_512 = 0
    poolInfo[poolInfo.length].field_768 = uint64(block.timestamp)
    poolInfo[poolInfo.length].field_832 = address(arg4)
    poolInfo[poolInfo.length].field_992 = uint32(arg2)
    poolInfo[poolInfo.length].field_1024 = 0
    poolInfo[poolInfo.length].field_1280 = 0
    emit 0xfa7db605: arg1 << 160, uint32(arg2), poolInfo.length - 1, address(arg3), address(arg4)
}



}

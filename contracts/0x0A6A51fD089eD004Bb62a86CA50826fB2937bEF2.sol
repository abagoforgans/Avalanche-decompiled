contract main {




// =====================  Runtime code  =====================


#
#  - sub_8706b531(?)
#  - tokenURI(uint256 arg1)
#
array of struct stor101;
array of struct stor102;
mapping of address ownerOf;
mapping of uint256 balanceOf;
mapping of address approved;
mapping of uint8 stor106;
address owner;
mapping of struct sub_79ba2fa2;
mapping of uint256 sub_2b1331a8;
uint256 numMinted;
mapping of struct sub_be75288d;
uint256 presaleStartTime;
uint256 presaleEndTime;
uint8 transfersEnabled; offset 160
address _signerAddress;
uint256 launchTime;
uint256 sub_f9caa583;
address stor210;
address stor211;
address stor212;
address stor213;
address stor214;
uint256 stor215;
uint8 paused;

function getApproved(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if not ownerOf[arg1]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: approved query for nonexistent token'
    return approved[arg1]
}

function totalSupply() payable {
    return numMinted
}

function presaleEndTime() payable {
    return presaleEndTime
}

function sub_2b1331a8(?) payable {
    require calldata.size - 4 >= 64
    require arg1 == address(arg1)
    return sub_2b1331a8[arg1][arg2]
}

function sub_30ec18c2(?) payable {
    require calldata.size - 4 >= 64
    require arg1 == address(arg1)
    return sub_2b1331a8[address(arg1)][arg2]
}

function paused() payable {
    return bool(paused)
}

function ownerOf(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if not ownerOf[arg1]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: owner query for nonexistent token'
    return ownerOf[arg1]
}

function balanceOf(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: balance query for the zero address'
    return balanceOf[address(arg1)]
}

function launchTime() payable {
    return launchTime
}

function sub_79ba2fa2(?) payable {
    require calldata.size - 4 >= 32
    return sub_79ba2fa2[arg1].field_512
}

function owner() payable {
    return owner
}

function presaleStartTime() payable {
    return presaleStartTime
}

function sub_be75288d(?) payable {
    require calldata.size - 4 >= 32
    return sub_be75288d[arg1].field_256
}

function transfersEnabled() payable {
    return bool(transfersEnabled)
}

function _signerAddress() payable {
    return _signerAddress
}

function numMinted() payable {
    return numMinted
}

function sub_e31ffb63(?) payable {
    require calldata.size - 4 >= 32
    return sub_be75288d[stor201[arg1].field_0].field_1024
}

function isApprovedForAll(address arg1, address arg2) payable {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require arg2 == arg2
    return bool(stor106[address(arg1)][address(arg2)])
}

function sub_f9caa583(?) payable {
    return sub_f9caa583
}

function _fallback() payable {
    revert
}

function renounceOwnership() payable {
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    owner = 0
    emit OwnershipTransferred(owner, 0);
}

function setLaunchTime(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    launchTime = arg1
}

function setBondDiscount(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    sub_f9caa583 = arg1
}

function sub_1593d8a5(?) payable {
    require calldata.size - 4 >= 64
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    sub_be75288d[arg1].field_256 = arg2
}

function sub_e345c564(?) payable {
    require calldata.size - 4 >= 64
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    sub_be75288d[arg1].field_512 = arg2
}

function sub_135ee927(?) payable {
    require calldata.size - 4 >= 64
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    sub_be75288d[arg1].field_1536 = arg2
}

function sub_72c0ab83(?) payable {
    require calldata.size - 4 >= 64
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    sub_be75288d[arg1].field_1024 = arg2
}

function sub_d010ad7f(?) payable {
    require calldata.size - 4 >= 64
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    sub_be75288d[arg1].field_1280 = arg2
}

function pause() payable {
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if paused:
        revert with 0, 'Pausable: paused'
    paused = 1
    emit Paused(msg.sender);
}

function setTreasuryAddress(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    stor213 = arg1
}

function sub_baabc801(?) payable {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    stor210 = address(arg1)
}

function sub_f3fd622f(?) payable {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    stor211 = address(arg1)
}

function setTeamWalletAddress(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    stor214 = arg1
}

function setLiquidityPairAddress(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    stor212 = arg1
}

function unpause() payable {
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not paused:
        revert with 0, 'Pausable: not paused'
    paused = 0
    emit Unpaused(msg.sender);
}

function sub_5c98f5e8(?) payable {
    require calldata.size - 4 >= 96
    require arg1 == address(arg1)
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    sub_2b1331a8[address(arg1)][arg2] = arg3
}

function setApprovalForAll(address arg1, bool arg2) payable {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require arg2 == arg2
    if msg.sender == arg1:
        revert with 0, 'ERC721: approve to caller'
    stor106[address(msg.sender)][address(arg1)] = uint8(arg2)
    emit ApprovalForAll(arg2, msg.sender, arg1);
}

function Sweep(address arg1, uint256 arg2) payable {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    call arg1 with:
       value arg2 wei
         gas gas_remaining wei
    if not ext_call.success:
        revert with 0, 'Failed to send AVAX'
}

function transferOwnership(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Ownable: new owner is the zero address'
    owner = arg1
    emit OwnershipTransferred(owner, arg1);
}

function supportsInterface(bytes4 arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == Mask(32, 224, arg1)
    if 0x80ac58cd00000000000000000000000000000000000000000000000000000000 == Mask(32, 224, arg1):
        return True
    if 0x5b5e139f00000000000000000000000000000000000000000000000000000000 == Mask(32, 224, arg1):
        return True
    return (Mask(32, 224, arg1) == 0x1ffc9a700000000000000000000000000000000000000000000000000000000)
}

function sub_b38344cf(?) payable {
    require ext_code.size(stor210)
    staticcall stor210.0x70a08231 with:
            gas gas_remaining wei
           args stor212
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_code.size(stor211)
    staticcall stor211.0x70a08231 with:
            gas gas_remaining wei
           args stor212
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if ext_call.return_data[0] <= 0:
        revert with 0, 'divison by zero error'
    if ext_call.return_data[0] > 0x14484bfeebc29f863424b06f3529a051a31be599:
        revert with 0, 17
    if not ext_call.return_data[0]:
        revert with 0, 18
    return (1000000000000 * 10^18 * ext_call.return_data[0] / ext_call.return_data[0])
}

function approve(address arg1, uint256 arg2) payable {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    if not ownerOf[arg2]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: owner query for nonexistent token'
    if arg1 == ownerOf[arg2]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: approval to current owner'
    if ownerOf[arg2] != msg.sender:
        if not stor106[stor103[arg2]][address(msg.sender)]:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        'ERC721: approve caller is not owner nor approved for all'
    approved[arg2] = arg1
    if not ownerOf[arg2]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: owner query for nonexistent token'
    emit Approval(ownerOf[arg2], arg1, arg2);
}

function sub_3a0a52e4(?) payable {
    require calldata.size - 4 >= 64
    require arg2 <= test266151307()
    require calldata.size > arg2 + 35
    if arg2.length > test266151307():
        revert with 0, 65
    if ceil32(ceil32(arg2.length)) + 97 < 96 or ceil32(ceil32(arg2.length)) + 97 > test266151307():
        revert with 0, 65
    require arg2 + arg2.length + 36 <= calldata.size
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if sub_be75288d[arg1].field_1792:
        if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
            revert with 0, 34
        if arg2.length:
            sub_be75288d[arg1][7][].field_0 = Array(len=arg2.length, data=arg2[all])
        else:
            sub_be75288d[arg1].field_1792 = 0
            idx = 0
            while (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 31 / 32 > idx:
                sub_be75288d[arg1][idx + 7].field_0 = 0
                idx = idx + 1
                continue 
    else:
        if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
            revert with 0, 34
        if arg2.length:
            sub_be75288d[arg1][7][].field_0 = Array(len=arg2.length, data=arg2[all])
        else:
            sub_be75288d[arg1].field_1792 = 0
            idx = 0
            while sub_be75288d[arg1].field_1793 + 31 / 32 > idx:
                sub_be75288d[arg1][idx + 7].field_0 = 0
                idx = idx + 1
                continue 
}

function sub_d83b2611(?) payable {
    require calldata.size - 4 >= 32
    require ext_code.size(stor210)
    staticcall stor210.0x70a08231 with:
            gas gas_remaining wei
           args stor212
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_code.size(stor211)
    staticcall stor211.0x70a08231 with:
            gas gas_remaining wei
           args stor212
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if ext_call.return_data[0] <= 0:
        revert with 0, 'divison by zero error'
    if ext_call.return_data[0] > 0x14484bfeebc29f863424b06f3529a051a31be599:
        revert with 0, 17
    if not ext_call.return_data[0]:
        revert with 0, 18
    if sub_be75288d[arg1].field_512 / 10^18 and 1000000000000 * 10^18 * ext_call.return_data[0] / ext_call.return_data[0] > -1 / sub_be75288d[arg1].field_512 / 10^18:
        revert with 0, 17
    if 100 < sub_f9caa583:
        revert with 0, 17
    if sub_be75288d[arg1].field_512 / 10^18 * 1000000000000 * 10^18 * ext_call.return_data[0] / ext_call.return_data[0] / 10^12 and -sub_f9caa583 + 100 > -1 / sub_be75288d[arg1].field_512 / 10^18 * 1000000000000 * 10^18 * ext_call.return_data[0] / ext_call.return_data[0] / 10^12:
        revert with 0, 17
    return ((100 * sub_be75288d[arg1].field_512 / 10^18 * 1000000000000 * 10^18 * ext_call.return_data[0] / ext_call.return_data[0] / 10^12) - (sub_f9caa583 * sub_be75288d[arg1].field_512 / 10^18 * 1000000000000 * 10^18 * ext_call.return_data[0] / ext_call.return_data[0] / 10^12) / 100)
}

function sub_d66fe70e(?) payable {
    require calldata.size - 4 >= 32
    require cd[4] <= test266151307()
    require cd[4] + 35 < calldata.size
    if ('cd', 4).length > test266151307():
        revert with 0, 65
    if ceil32(32 * ('cd', 4).length) + 97 < 96 or ceil32(32 * ('cd', 4).length) + 97 > test266151307():
        revert with 0, 65
    require calldata.size >= cd[4] + (32 * ('cd', 4).length) + 36
    s = cd[4] + 36
    t = 128
    idx = 0
    while idx < ('cd', 4).length:
        mem[t] = cd[s]
        s = s + 32
        t = t + 32
        idx = idx + 1
        continue 
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    idx = 0
    while idx < ('cd', 4).length:
        if idx >= ('cd', 4).length:
            revert with 0, 50
        if not ownerOf[mem[(32 * idx) + 128]]:
            revert with 0, 'ERC721: owner query for nonexistent token'
        if not ownerOf[mem[(32 * idx) + 128]]:
            revert with 0, 'ERC721: owner query for nonexistent token'
        approved[mem[(32 * idx) + 128]] = 0
        if not ownerOf[mem[(32 * idx) + 128]]:
            revert with 0, 'ERC721: owner query for nonexistent token'
        emit Approval(ownerOf[mem[(32 * idx) + 128]], 0, mem[(32 * idx) + 128]);
        if balanceOf[stor103[mem[(32 * idx) + 128]]] < 1:
            revert with 0, 17
        balanceOf[stor103[mem[(32 * idx) + 128]]]--
        ownerOf[mem[(32 * idx) + 128]] = 0
        emit Transfer(ownerOf[mem[(32 * idx) + 128]], 0, mem[(32 * idx) + 128]);
        mem[0] = sub_79ba2fa2[mem[(32 * idx) + 128]].field_0
        mem[32] = sha3(ownerOf[mem[(32 * idx) + 128]], 202)
        if sub_2b1331a8[stor103[mem[(32 * idx) + 128]]][stor201[mem[(32 * idx) + 128]].field_0] < 1:
            revert with 0, 17
        sub_2b1331a8[stor103[mem[(32 * idx) + 128]]][stor201[mem[(32 * idx) + 128]].field_0]--
        if idx == -1:
            revert with 0, 17
        idx = idx + 1
        continue 
}

function transferFrom(address arg1, address arg2, uint256 arg3) payable {
    require calldata.size - 4 >= 96
    require arg1 == arg1
    require arg2 == arg2
    if not ownerOf[arg3]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: operator query for nonexistent token'
    if not ownerOf[arg3]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: owner query for nonexistent token'
    if ownerOf[arg3] != msg.sender:
        if not ownerOf[arg3]:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: approved query for nonexistent token'
        if approved[arg3] != msg.sender:
            if not stor106[stor103[arg3]][address(msg.sender)]:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: transfer caller is not owner nor approved'
    if not ownerOf[arg3]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: owner query for nonexistent token'
    if ownerOf[arg3] != arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: transfer from incorrect owner'
    if not arg2:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: transfer to the zero address'
    if arg1:
        if arg2:
            if paused:
                revert with 0, 'Transfers not enabled yet'
    approved[arg3] = 0
    if not ownerOf[arg3]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: owner query for nonexistent token'
    emit Approval(ownerOf[arg3], 0, arg3);
    if balanceOf[address(arg1)] < 1:
        revert with 0, 17
    balanceOf[address(arg1)]--
    if balanceOf[address(arg2)] > -2:
        revert with 0, 17
    balanceOf[address(arg2)]++
    ownerOf[arg3] = arg2
    emit Transfer(arg1, arg2, arg3);
}

function safeTransferFrom(address arg1, address arg2, uint256 arg3) payable {
    require calldata.size - 4 >= 96
    require arg1 == arg1
    require arg2 == arg2
    if not ownerOf[arg3]:
        revert with 0, 'ERC721: operator query for nonexistent token'
    if not ownerOf[arg3]:
        revert with 0, 'ERC721: owner query for nonexistent token'
    if ownerOf[arg3] != msg.sender:
        if not ownerOf[arg3]:
            revert with 0, 'ERC721: approved query for nonexistent token'
        if approved[arg3] != msg.sender:
            if not stor106[stor103[arg3]][address(msg.sender)]:
                revert with 0, 'ERC721: transfer caller is not owner nor approved'
    if not ownerOf[arg3]:
        revert with 0, 'ERC721: owner query for nonexistent token'
    if ownerOf[arg3] != arg1:
        revert with 0, 'ERC721: transfer from incorrect owner'
    if not arg2:
        revert with 0, 'ERC721: transfer to the zero address'
    if arg1:
        if arg2:
            if paused:
                revert with 0, 'Transfers not enabled yet'
    approved[arg3] = 0
    if not ownerOf[arg3]:
        revert with 0, 'ERC721: owner query for nonexistent token'
    emit Approval(ownerOf[arg3], 0, arg3);
    if balanceOf[address(arg1)] < 1:
        revert with 0, 17
    balanceOf[address(arg1)]--
    if balanceOf[address(arg2)] > -2:
        revert with 0, 17
    balanceOf[address(arg2)]++
    ownerOf[arg3] = arg2
    emit Transfer(arg1, arg2, arg3);
    if ext_code.size(arg2):
        require ext_code.size(arg2)
        call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
             gas gas_remaining wei
            args 0, uint32(msg.sender), address(arg1), arg3, 128, 0
        if not ext_call.success:
            if not return_data.size:
                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
            if not return_data.size:
                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
        if Mask(32, 224, ext_call.return_data[0]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
}

function safeTransferFrom(address arg1, address arg2, uint256 arg3, bytes arg4) payable {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg2 == arg2
    require arg4 <= test266151307()
    require calldata.size > arg4 + 35
    if arg4.length > test266151307():
        revert with 0, 65
    if ceil32(ceil32(arg4.length)) + 97 < 96 or ceil32(ceil32(arg4.length)) + 97 > test266151307():
        revert with 0, 65
    require arg4 + arg4.length + 36 <= calldata.size
    if not ownerOf[arg3]:
        revert with 0, 'ERC721: operator query for nonexistent token'
    if not ownerOf[arg3]:
        revert with 0, 'ERC721: owner query for nonexistent token'
    if ownerOf[arg3] != msg.sender:
        if not ownerOf[arg3]:
            revert with 0, 'ERC721: approved query for nonexistent token'
        if approved[arg3] != msg.sender:
            if not stor106[stor103[arg3]][address(msg.sender)]:
                revert with 0, 'ERC721: transfer caller is not owner nor approved'
    if not ownerOf[arg3]:
        revert with 0, 'ERC721: owner query for nonexistent token'
    if ownerOf[arg3] != arg1:
        revert with 0, 'ERC721: transfer from incorrect owner'
    if not arg2:
        revert with 0, 'ERC721: transfer to the zero address'
    if arg1:
        if arg2:
            if paused:
                revert with 0, 'Transfers not enabled yet'
    approved[arg3] = 0
    if not ownerOf[arg3]:
        revert with 0, 'ERC721: owner query for nonexistent token'
    emit Approval(ownerOf[arg3], 0, arg3);
    if balanceOf[address(arg1)] < 1:
        revert with 0, 17
    balanceOf[address(arg1)]--
    if balanceOf[address(arg2)] > -2:
        revert with 0, 17
    balanceOf[address(arg2)]++
    ownerOf[arg3] = arg2
    emit Transfer(arg1, arg2, arg3);
    if ext_code.size(arg2):
        require ext_code.size(arg2)
        call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
             gas gas_remaining wei
            args msg.sender, address(arg1), arg3, Array(len=arg4.length, data=arg4[all])
        if not ext_call.success:
            if not return_data.size:
                if not arg4.length:
                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                revert with arg4[all]
            if not return_data.size:
                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
        if Mask(32, 224, ext_call.return_data[0]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
}

function name() payable {
    if bool(stor101.length):
        if bool(stor101.length) == uint255(stor101.length) * 0.5 < 32:
            revert with 0, 34
        if bool(stor101.length):
            if bool(stor101.length) == uint255(stor101.length) * 0.5 < 32:
                revert with 0, 34
            if Mask(256, -1, stor101.length):
                if 31 < uint255(stor101.length) * 0.5:
                    mem[128] = uint256(stor101.field_0)
                    idx = 128
                    s = 0
                    while (uint255(stor101.length) * 0.5) + 96 > idx:
                        mem[idx + 32] = stor101[s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    return Array(len=2 * Mask(256, -1, stor101.length), data=mem[128 len ceil32(uint255(stor101.length) * 0.5)])
                mem[128] = 256 * stor101.length.field_8
        else:
            if bool(stor101.length) == stor101.length.field_1 < 32:
                revert with 0, 34
            if stor101.length.field_1:
                if 31 < stor101.length.field_1:
                    mem[128] = uint256(stor101.field_0)
                    idx = 128
                    s = 0
                    while stor101.length.field_1 + 96 > idx:
                        mem[idx + 32] = stor101[s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    return Array(len=2 * Mask(256, -1, stor101.length), data=mem[128 len ceil32(uint255(stor101.length) * 0.5)])
                mem[128] = 256 * stor101.length.field_8
        mem[ceil32(uint255(stor101.length) * 0.5) + 192 len ceil32(uint255(stor101.length) * 0.5)] = mem[128 len ceil32(uint255(stor101.length) * 0.5)]
        if ceil32(uint255(stor101.length) * 0.5) > uint255(stor101.length) * 0.5:
            mem[(uint255(stor101.length) * 0.5) + ceil32(uint255(stor101.length) * 0.5) + 192] = 0
        return Array(len=2 * Mask(256, -1, stor101.length), data=mem[128 len ceil32(uint255(stor101.length) * 0.5)], mem[(2 * ceil32(uint255(stor101.length) * 0.5)) + 192 len 2 * ceil32(uint255(stor101.length) * 0.5)]), 
    if bool(stor101.length) == stor101.length.field_1 < 32:
        revert with 0, 34
    if bool(stor101.length):
        if bool(stor101.length) == uint255(stor101.length) * 0.5 < 32:
            revert with 0, 34
        if Mask(256, -1, stor101.length):
            if 31 < uint255(stor101.length) * 0.5:
                mem[128] = uint256(stor101.field_0)
                idx = 128
                s = 0
                while (uint255(stor101.length) * 0.5) + 96 > idx:
                    mem[idx + 32] = stor101[s].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
                return Array(len=stor101.length % 128, data=mem[128 len ceil32(stor101.length.field_1)])
            mem[128] = 256 * stor101.length.field_8
    else:
        if bool(stor101.length) == stor101.length.field_1 < 32:
            revert with 0, 34
        if stor101.length.field_1:
            if 31 < stor101.length.field_1:
                mem[128] = uint256(stor101.field_0)
                idx = 128
                s = 0
                while stor101.length.field_1 + 96 > idx:
                    mem[idx + 32] = stor101[s].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
                return Array(len=stor101.length % 128, data=mem[128 len ceil32(stor101.length.field_1)])
            mem[128] = 256 * stor101.length.field_8
    mem[ceil32(stor101.length.field_1) + 192 len ceil32(stor101.length.field_1)] = mem[128 len ceil32(stor101.length.field_1)]
    if ceil32(stor101.length.field_1) > stor101.length.field_1:
        mem[stor101.length.field_1 + ceil32(stor101.length.field_1) + 192] = 0
    return Array(len=stor101.length % 128, data=mem[128 len ceil32(stor101.length.field_1)], mem[(2 * ceil32(stor101.length.field_1)) + 192 len 2 * ceil32(stor101.length.field_1)]), 
}

function symbol() payable {
    if bool(stor102.length):
        if bool(stor102.length) == uint255(stor102.length) * 0.5 < 32:
            revert with 0, 34
        if bool(stor102.length):
            if bool(stor102.length) == uint255(stor102.length) * 0.5 < 32:
                revert with 0, 34
            if Mask(256, -1, stor102.length):
                if 31 < uint255(stor102.length) * 0.5:
                    mem[128] = uint256(stor102.field_0)
                    idx = 128
                    s = 0
                    while (uint255(stor102.length) * 0.5) + 96 > idx:
                        mem[idx + 32] = stor102[s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    return Array(len=2 * Mask(256, -1, stor102.length), data=mem[128 len ceil32(uint255(stor102.length) * 0.5)])
                mem[128] = 256 * stor102.length.field_8
        else:
            if bool(stor102.length) == stor102.length.field_1 < 32:
                revert with 0, 34
            if stor102.length.field_1:
                if 31 < stor102.length.field_1:
                    mem[128] = uint256(stor102.field_0)
                    idx = 128
                    s = 0
                    while stor102.length.field_1 + 96 > idx:
                        mem[idx + 32] = stor102[s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    return Array(len=2 * Mask(256, -1, stor102.length), data=mem[128 len ceil32(uint255(stor102.length) * 0.5)])
                mem[128] = 256 * stor102.length.field_8
        mem[ceil32(uint255(stor102.length) * 0.5) + 192 len ceil32(uint255(stor102.length) * 0.5)] = mem[128 len ceil32(uint255(stor102.length) * 0.5)]
        if ceil32(uint255(stor102.length) * 0.5) > uint255(stor102.length) * 0.5:
            mem[(uint255(stor102.length) * 0.5) + ceil32(uint255(stor102.length) * 0.5) + 192] = 0
        return Array(len=2 * Mask(256, -1, stor102.length), data=mem[128 len ceil32(uint255(stor102.length) * 0.5)], mem[(2 * ceil32(uint255(stor102.length) * 0.5)) + 192 len 2 * ceil32(uint255(stor102.length) * 0.5)]), 
    if bool(stor102.length) == stor102.length.field_1 < 32:
        revert with 0, 34
    if bool(stor102.length):
        if bool(stor102.length) == uint255(stor102.length) * 0.5 < 32:
            revert with 0, 34
        if Mask(256, -1, stor102.length):
            if 31 < uint255(stor102.length) * 0.5:
                mem[128] = uint256(stor102.field_0)
                idx = 128
                s = 0
                while (uint255(stor102.length) * 0.5) + 96 > idx:
                    mem[idx + 32] = stor102[s].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
                return Array(len=stor102.length % 128, data=mem[128 len ceil32(stor102.length.field_1)])
            mem[128] = 256 * stor102.length.field_8
    else:
        if bool(stor102.length) == stor102.length.field_1 < 32:
            revert with 0, 34
        if stor102.length.field_1:
            if 31 < stor102.length.field_1:
                mem[128] = uint256(stor102.field_0)
                idx = 128
                s = 0
                while stor102.length.field_1 + 96 > idx:
                    mem[idx + 32] = stor102[s].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
                return Array(len=stor102.length % 128, data=mem[128 len ceil32(stor102.length.field_1)])
            mem[128] = 256 * stor102.length.field_8
    mem[ceil32(stor102.length.field_1) + 192 len ceil32(stor102.length.field_1)] = mem[128 len ceil32(stor102.length.field_1)]
    if ceil32(stor102.length.field_1) > stor102.length.field_1:
        mem[stor102.length.field_1 + ceil32(stor102.length.field_1) + 192] = 0
    return Array(len=stor102.length % 128, data=mem[128 len ceil32(stor102.length.field_1)], mem[(2 * ceil32(stor102.length.field_1)) + 192 len 2 * ceil32(stor102.length.field_1)]), 
}

function sub_c35f6368(?) payable {
    require calldata.size - 4 >= 32
    if paused:
        revert with 0, 'Pausable: paused'
    if stor215 == 2:
        revert with 0, 'ReentrancyGuard: reentrant call'
    stor215 = 2
    if not ownerOf[arg1]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: owner query for nonexistent token'
    if ownerOf[arg1] != msg.sender:
        revert with 0, 'This is not your Node!'
    if this.address == msg.sender:
        revert with 0, 'Can't claim from the contract'
    if block.timestamp < launchTime:
        revert with 0, 'Not launched yet'
    if not launchTime:
        revert with 0, 'Not launched yet'
    if sub_79ba2fa2[arg1].field_512 >= launchTime:
        if 24 * 3600 > !sub_79ba2fa2[arg1].field_512:
            revert with 0, 17
        if block.timestamp <= sub_79ba2fa2[arg1].field_512 + (24 * 3600):
            revert with 0, 'Must wait 24h to claim reward'
        if block.timestamp < sub_79ba2fa2[arg1].field_512:
            revert with 0, 17
        if block.timestamp <= sub_79ba2fa2[arg1].field_768:
            if block.timestamp - sub_79ba2fa2[arg1].field_512 and sub_be75288d[stor201[arg1].field_0].field_1024 > -1 / block.timestamp - sub_79ba2fa2[arg1].field_512:
                revert with 0, 17
            if block.timestamp - sub_79ba2fa2[arg1].field_512 <= sub_be75288d[stor201[arg1].field_0].field_1280:
                if (block.timestamp * sub_be75288d[stor201[arg1].field_0].field_1024) - (sub_79ba2fa2[arg1].field_512 * sub_be75288d[stor201[arg1].field_0].field_1024) and sub_79ba2fa2[arg1].field_256 > -1 / (block.timestamp * sub_be75288d[stor201[arg1].field_0].field_1024) - (sub_79ba2fa2[arg1].field_512 * sub_be75288d[stor201[arg1].field_0].field_1024):
                    revert with 0, 17
                sub_79ba2fa2[arg1].field_512 = block.timestamp
                if (block.timestamp * sub_be75288d[stor201[arg1].field_0].field_1024) - (sub_79ba2fa2[arg1].field_512 * sub_be75288d[stor201[arg1].field_0].field_1024) < (block.timestamp * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_79ba2fa2[arg1].field_256) - (sub_79ba2fa2[arg1].field_512 * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_79ba2fa2[arg1].field_256) / 10000:
                    revert with 0, 17
                require ext_code.size(stor210)
                call stor210.0xa9059cbb with:
                     gas gas_remaining wei
                    args msg.sender, (block.timestamp * sub_be75288d[stor201[arg1].field_0].field_1024) - (sub_79ba2fa2[arg1].field_512 * sub_be75288d[stor201[arg1].field_0].field_1024) - ((block.timestamp * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_79ba2fa2[arg1].field_256) - (sub_79ba2fa2[arg1].field_512 * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_79ba2fa2[arg1].field_256) / 10000)
            else:
                if (block.timestamp * sub_be75288d[stor201[arg1].field_0].field_1024) - (sub_79ba2fa2[arg1].field_512 * sub_be75288d[stor201[arg1].field_0].field_1024) and sub_be75288d[stor201[arg1].field_0].field_1536 > -1 / (block.timestamp * sub_be75288d[stor201[arg1].field_0].field_1024) - (sub_79ba2fa2[arg1].field_512 * sub_be75288d[stor201[arg1].field_0].field_1024):
                    revert with 0, 17
                if (block.timestamp * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_be75288d[stor201[arg1].field_0].field_1536) - (sub_79ba2fa2[arg1].field_512 * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_be75288d[stor201[arg1].field_0].field_1536) / 100 and sub_79ba2fa2[arg1].field_256 > -1 / (block.timestamp * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_be75288d[stor201[arg1].field_0].field_1536) - (sub_79ba2fa2[arg1].field_512 * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_be75288d[stor201[arg1].field_0].field_1536) / 100:
                    revert with 0, 17
                sub_79ba2fa2[arg1].field_512 = block.timestamp
                if (block.timestamp * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_be75288d[stor201[arg1].field_0].field_1536) - (sub_79ba2fa2[arg1].field_512 * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_be75288d[stor201[arg1].field_0].field_1536) / 100 < (block.timestamp * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_be75288d[stor201[arg1].field_0].field_1536) - (sub_79ba2fa2[arg1].field_512 * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_be75288d[stor201[arg1].field_0].field_1536) / 100 * sub_79ba2fa2[arg1].field_256 / 10000:
                    revert with 0, 17
                require ext_code.size(stor210)
                call stor210.0xa9059cbb with:
                     gas gas_remaining wei
                    args msg.sender, ((block.timestamp * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_be75288d[stor201[arg1].field_0].field_1536) - (sub_79ba2fa2[arg1].field_512 * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_be75288d[stor201[arg1].field_0].field_1536) / 100) - ((block.timestamp * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_be75288d[stor201[arg1].field_0].field_1536) - (sub_79ba2fa2[arg1].field_512 * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_be75288d[stor201[arg1].field_0].field_1536) / 100 * sub_79ba2fa2[arg1].field_256 / 10000)
        else:
            if sub_79ba2fa2[arg1].field_768 < sub_79ba2fa2[arg1].field_512:
                revert with 0, 17
            if sub_79ba2fa2[arg1].field_768 - sub_79ba2fa2[arg1].field_512 <= 0:
                revert with 0, 'Maintenance is not up to date'
            if sub_79ba2fa2[arg1].field_768 - sub_79ba2fa2[arg1].field_512 and sub_be75288d[stor201[arg1].field_0].field_1024 > -1 / sub_79ba2fa2[arg1].field_768 - sub_79ba2fa2[arg1].field_512:
                revert with 0, 17
            if sub_79ba2fa2[arg1].field_768 - sub_79ba2fa2[arg1].field_512 <= sub_be75288d[stor201[arg1].field_0].field_1280:
                if (sub_79ba2fa2[arg1].field_768 * sub_be75288d[stor201[arg1].field_0].field_1024) - (sub_79ba2fa2[arg1].field_512 * sub_be75288d[stor201[arg1].field_0].field_1024) and sub_79ba2fa2[arg1].field_256 > -1 / (sub_79ba2fa2[arg1].field_768 * sub_be75288d[stor201[arg1].field_0].field_1024) - (sub_79ba2fa2[arg1].field_512 * sub_be75288d[stor201[arg1].field_0].field_1024):
                    revert with 0, 17
                sub_79ba2fa2[arg1].field_512 = block.timestamp
                if (sub_79ba2fa2[arg1].field_768 * sub_be75288d[stor201[arg1].field_0].field_1024) - (sub_79ba2fa2[arg1].field_512 * sub_be75288d[stor201[arg1].field_0].field_1024) < (sub_79ba2fa2[arg1].field_768 * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_79ba2fa2[arg1].field_256) - (sub_79ba2fa2[arg1].field_512 * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_79ba2fa2[arg1].field_256) / 10000:
                    revert with 0, 17
                require ext_code.size(stor210)
                call stor210.0xa9059cbb with:
                     gas gas_remaining wei
                    args msg.sender, (sub_79ba2fa2[arg1].field_768 * sub_be75288d[stor201[arg1].field_0].field_1024) - (sub_79ba2fa2[arg1].field_512 * sub_be75288d[stor201[arg1].field_0].field_1024) - ((sub_79ba2fa2[arg1].field_768 * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_79ba2fa2[arg1].field_256) - (sub_79ba2fa2[arg1].field_512 * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_79ba2fa2[arg1].field_256) / 10000)
            else:
                if (sub_79ba2fa2[arg1].field_768 * sub_be75288d[stor201[arg1].field_0].field_1024) - (sub_79ba2fa2[arg1].field_512 * sub_be75288d[stor201[arg1].field_0].field_1024) and sub_be75288d[stor201[arg1].field_0].field_1536 > -1 / (sub_79ba2fa2[arg1].field_768 * sub_be75288d[stor201[arg1].field_0].field_1024) - (sub_79ba2fa2[arg1].field_512 * sub_be75288d[stor201[arg1].field_0].field_1024):
                    revert with 0, 17
                if (sub_79ba2fa2[arg1].field_768 * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_be75288d[stor201[arg1].field_0].field_1536) - (sub_79ba2fa2[arg1].field_512 * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_be75288d[stor201[arg1].field_0].field_1536) / 100 and sub_79ba2fa2[arg1].field_256 > -1 / (sub_79ba2fa2[arg1].field_768 * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_be75288d[stor201[arg1].field_0].field_1536) - (sub_79ba2fa2[arg1].field_512 * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_be75288d[stor201[arg1].field_0].field_1536) / 100:
                    revert with 0, 17
                sub_79ba2fa2[arg1].field_512 = block.timestamp
                if (sub_79ba2fa2[arg1].field_768 * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_be75288d[stor201[arg1].field_0].field_1536) - (sub_79ba2fa2[arg1].field_512 * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_be75288d[stor201[arg1].field_0].field_1536) / 100 < (sub_79ba2fa2[arg1].field_768 * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_be75288d[stor201[arg1].field_0].field_1536) - (sub_79ba2fa2[arg1].field_512 * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_be75288d[stor201[arg1].field_0].field_1536) / 100 * sub_79ba2fa2[arg1].field_256 / 10000:
                    revert with 0, 17
                require ext_code.size(stor210)
                call stor210.0xa9059cbb with:
                     gas gas_remaining wei
                    args msg.sender, ((sub_79ba2fa2[arg1].field_768 * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_be75288d[stor201[arg1].field_0].field_1536) - (sub_79ba2fa2[arg1].field_512 * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_be75288d[stor201[arg1].field_0].field_1536) / 100) - ((sub_79ba2fa2[arg1].field_768 * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_be75288d[stor201[arg1].field_0].field_1536) - (sub_79ba2fa2[arg1].field_512 * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_be75288d[stor201[arg1].field_0].field_1536) / 100 * sub_79ba2fa2[arg1].field_256 / 10000)
    else:
        if 24 * 3600 > !launchTime:
            revert with 0, 17
        if block.timestamp <= launchTime + (24 * 3600):
            revert with 0, 'Must wait 24h to claim reward'
        if block.timestamp < launchTime:
            revert with 0, 17
        if block.timestamp <= sub_79ba2fa2[arg1].field_768:
            if block.timestamp - launchTime and sub_be75288d[stor201[arg1].field_0].field_1024 > -1 / block.timestamp - launchTime:
                revert with 0, 17
            if block.timestamp - launchTime <= sub_be75288d[stor201[arg1].field_0].field_1280:
                if (block.timestamp * sub_be75288d[stor201[arg1].field_0].field_1024) - (launchTime * sub_be75288d[stor201[arg1].field_0].field_1024) and sub_79ba2fa2[arg1].field_256 > -1 / (block.timestamp * sub_be75288d[stor201[arg1].field_0].field_1024) - (launchTime * sub_be75288d[stor201[arg1].field_0].field_1024):
                    revert with 0, 17
                sub_79ba2fa2[arg1].field_512 = block.timestamp
                if (block.timestamp * sub_be75288d[stor201[arg1].field_0].field_1024) - (launchTime * sub_be75288d[stor201[arg1].field_0].field_1024) < (block.timestamp * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_79ba2fa2[arg1].field_256) - (launchTime * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_79ba2fa2[arg1].field_256) / 10000:
                    revert with 0, 17
                require ext_code.size(stor210)
                call stor210.0xa9059cbb with:
                     gas gas_remaining wei
                    args msg.sender, (block.timestamp * sub_be75288d[stor201[arg1].field_0].field_1024) - (launchTime * sub_be75288d[stor201[arg1].field_0].field_1024) - ((block.timestamp * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_79ba2fa2[arg1].field_256) - (launchTime * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_79ba2fa2[arg1].field_256) / 10000)
            else:
                if (block.timestamp * sub_be75288d[stor201[arg1].field_0].field_1024) - (launchTime * sub_be75288d[stor201[arg1].field_0].field_1024) and sub_be75288d[stor201[arg1].field_0].field_1536 > -1 / (block.timestamp * sub_be75288d[stor201[arg1].field_0].field_1024) - (launchTime * sub_be75288d[stor201[arg1].field_0].field_1024):
                    revert with 0, 17
                if (block.timestamp * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_be75288d[stor201[arg1].field_0].field_1536) - (launchTime * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_be75288d[stor201[arg1].field_0].field_1536) / 100 and sub_79ba2fa2[arg1].field_256 > -1 / (block.timestamp * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_be75288d[stor201[arg1].field_0].field_1536) - (launchTime * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_be75288d[stor201[arg1].field_0].field_1536) / 100:
                    revert with 0, 17
                sub_79ba2fa2[arg1].field_512 = block.timestamp
                if (block.timestamp * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_be75288d[stor201[arg1].field_0].field_1536) - (launchTime * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_be75288d[stor201[arg1].field_0].field_1536) / 100 < (block.timestamp * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_be75288d[stor201[arg1].field_0].field_1536) - (launchTime * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_be75288d[stor201[arg1].field_0].field_1536) / 100 * sub_79ba2fa2[arg1].field_256 / 10000:
                    revert with 0, 17
                require ext_code.size(stor210)
                call stor210.0xa9059cbb with:
                     gas gas_remaining wei
                    args msg.sender, ((block.timestamp * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_be75288d[stor201[arg1].field_0].field_1536) - (launchTime * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_be75288d[stor201[arg1].field_0].field_1536) / 100) - ((block.timestamp * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_be75288d[stor201[arg1].field_0].field_1536) - (launchTime * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_be75288d[stor201[arg1].field_0].field_1536) / 100 * sub_79ba2fa2[arg1].field_256 / 10000)
        else:
            if sub_79ba2fa2[arg1].field_768 < launchTime:
                revert with 0, 17
            if sub_79ba2fa2[arg1].field_768 - launchTime <= 0:
                revert with 0, 'Maintenance is not up to date'
            if sub_79ba2fa2[arg1].field_768 - launchTime and sub_be75288d[stor201[arg1].field_0].field_1024 > -1 / sub_79ba2fa2[arg1].field_768 - launchTime:
                revert with 0, 17
            if sub_79ba2fa2[arg1].field_768 - launchTime <= sub_be75288d[stor201[arg1].field_0].field_1280:
                if (sub_79ba2fa2[arg1].field_768 * sub_be75288d[stor201[arg1].field_0].field_1024) - (launchTime * sub_be75288d[stor201[arg1].field_0].field_1024) and sub_79ba2fa2[arg1].field_256 > -1 / (sub_79ba2fa2[arg1].field_768 * sub_be75288d[stor201[arg1].field_0].field_1024) - (launchTime * sub_be75288d[stor201[arg1].field_0].field_1024):
                    revert with 0, 17
                sub_79ba2fa2[arg1].field_512 = block.timestamp
                if (sub_79ba2fa2[arg1].field_768 * sub_be75288d[stor201[arg1].field_0].field_1024) - (launchTime * sub_be75288d[stor201[arg1].field_0].field_1024) < (sub_79ba2fa2[arg1].field_768 * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_79ba2fa2[arg1].field_256) - (launchTime * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_79ba2fa2[arg1].field_256) / 10000:
                    revert with 0, 17
                require ext_code.size(stor210)
                call stor210.0xa9059cbb with:
                     gas gas_remaining wei
                    args msg.sender, (sub_79ba2fa2[arg1].field_768 * sub_be75288d[stor201[arg1].field_0].field_1024) - (launchTime * sub_be75288d[stor201[arg1].field_0].field_1024) - ((sub_79ba2fa2[arg1].field_768 * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_79ba2fa2[arg1].field_256) - (launchTime * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_79ba2fa2[arg1].field_256) / 10000)
            else:
                if (sub_79ba2fa2[arg1].field_768 * sub_be75288d[stor201[arg1].field_0].field_1024) - (launchTime * sub_be75288d[stor201[arg1].field_0].field_1024) and sub_be75288d[stor201[arg1].field_0].field_1536 > -1 / (sub_79ba2fa2[arg1].field_768 * sub_be75288d[stor201[arg1].field_0].field_1024) - (launchTime * sub_be75288d[stor201[arg1].field_0].field_1024):
                    revert with 0, 17
                if (sub_79ba2fa2[arg1].field_768 * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_be75288d[stor201[arg1].field_0].field_1536) - (launchTime * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_be75288d[stor201[arg1].field_0].field_1536) / 100 and sub_79ba2fa2[arg1].field_256 > -1 / (sub_79ba2fa2[arg1].field_768 * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_be75288d[stor201[arg1].field_0].field_1536) - (launchTime * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_be75288d[stor201[arg1].field_0].field_1536) / 100:
                    revert with 0, 17
                sub_79ba2fa2[arg1].field_512 = block.timestamp
                if (sub_79ba2fa2[arg1].field_768 * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_be75288d[stor201[arg1].field_0].field_1536) - (launchTime * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_be75288d[stor201[arg1].field_0].field_1536) / 100 < (sub_79ba2fa2[arg1].field_768 * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_be75288d[stor201[arg1].field_0].field_1536) - (launchTime * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_be75288d[stor201[arg1].field_0].field_1536) / 100 * sub_79ba2fa2[arg1].field_256 / 10000:
                    revert with 0, 17
                require ext_code.size(stor210)
                call stor210.0xa9059cbb with:
                     gas gas_remaining wei
                    args msg.sender, ((sub_79ba2fa2[arg1].field_768 * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_be75288d[stor201[arg1].field_0].field_1536) - (launchTime * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_be75288d[stor201[arg1].field_0].field_1536) / 100) - ((sub_79ba2fa2[arg1].field_768 * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_be75288d[stor201[arg1].field_0].field_1536) - (launchTime * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_be75288d[stor201[arg1].field_0].field_1536) / 100 * sub_79ba2fa2[arg1].field_256 / 10000)
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    stor215 = 1
}

function sub_cf37c49a(?) payable {
    require calldata.size - 4 >= 32
    if sub_be75288d[arg1].field_0:
        if sub_be75288d[arg1].field_0 == uint255(sub_be75288d[arg1].field_0) * 0.5 < 32:
            revert with 0, 34
        if sub_be75288d[arg1].field_0:
            if sub_be75288d[arg1].field_0 == uint255(sub_be75288d[arg1].field_0) * 0.5 < 32:
                revert with 0, 34
            if not Mask(256, -1, sub_be75288d[arg1].field_0):
                if sub_be75288d[arg1].field_1792:
                    if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                        revert with 0, 34
                    if sub_be75288d[arg1].field_1792:
                        if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                            if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                            if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                        else:
                            if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = 256 * sub_be75288d[arg1].field_1800
                            else:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160
                                s = 0
                                while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 128 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                            if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                            if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                    else:
                        if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                            revert with 0, 34
                        if not sub_be75288d[arg1].field_1793:
                            if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                            if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                        else:
                            if 31 >= sub_be75288d[arg1].field_1793:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = 256 * sub_be75288d[arg1].field_1800
                            else:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160
                                s = 0
                                while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + sub_be75288d[arg1].field_1793 + 128 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                            if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                            if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                    return Array(len=2 * Mask(256, -1, sub_be75288d[arg1].field_0), data=mem[128 len ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)], 2 * Mask(256, -1, sub_be75288d[arg1].field_1792), mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]), 
                           sub_be75288d[arg1].field_256,
                           sub_be75288d[arg1].field_512,
                           sub_be75288d[arg1].field_768,
                           sub_be75288d[arg1].field_1024,
                           sub_be75288d[arg1].field_1280,
                           sub_be75288d[arg1].field_1536,
                           ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 288
                if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                    revert with 0, 34
                if sub_be75288d[arg1].field_1792:
                    if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                        revert with 0, 34
                    if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                        if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                            mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793) + 448] = 0
                        mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 448] = sub_be75288d[arg1].field_1793
                        mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 480 len ceil32(sub_be75288d[arg1].field_1793)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(sub_be75288d[arg1].field_1793)]
                        if ceil32(sub_be75288d[arg1].field_1793) > sub_be75288d[arg1].field_1793:
                            mem[sub_be75288d[arg1].field_1793 + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 480] = 0
                    else:
                        if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                            mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = 256 * sub_be75288d[arg1].field_1800
                        else:
                            mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = sub_be75288d[arg1][7].field_0
                            idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160
                            s = 0
                            while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 128 > idx:
                                mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                        if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                            mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793) + 448] = 0
                        mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 448] = sub_be75288d[arg1].field_1793
                        mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 480 len ceil32(sub_be75288d[arg1].field_1793)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(sub_be75288d[arg1].field_1793)]
                        if ceil32(sub_be75288d[arg1].field_1793) > sub_be75288d[arg1].field_1793:
                            mem[sub_be75288d[arg1].field_1793 + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 480] = 0
                else:
                    if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                        revert with 0, 34
                    if not sub_be75288d[arg1].field_1793:
                        if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                            mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793) + 448] = 0
                        mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 448] = sub_be75288d[arg1].field_1793
                        mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 480 len ceil32(sub_be75288d[arg1].field_1793)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(sub_be75288d[arg1].field_1793)]
                        if ceil32(sub_be75288d[arg1].field_1793) > sub_be75288d[arg1].field_1793:
                            mem[sub_be75288d[arg1].field_1793 + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 480] = 0
                    else:
                        if 31 >= sub_be75288d[arg1].field_1793:
                            mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = 256 * sub_be75288d[arg1].field_1800
                        else:
                            mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = sub_be75288d[arg1][7].field_0
                            idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160
                            s = 0
                            while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + sub_be75288d[arg1].field_1793 + 128 > idx:
                                mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                        if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                            mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793) + 448] = 0
                        mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 448] = sub_be75288d[arg1].field_1793
                        mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 480 len ceil32(sub_be75288d[arg1].field_1793)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(sub_be75288d[arg1].field_1793)]
                        if ceil32(sub_be75288d[arg1].field_1793) > sub_be75288d[arg1].field_1793:
                            mem[sub_be75288d[arg1].field_1793 + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 480] = 0
            else:
                if 31 < uint255(sub_be75288d[arg1].field_0) * 0.5:
                    mem[128] = sub_be75288d[arg1].field_0
                    idx = 128
                    s = 0
                    while (uint255(sub_be75288d[arg1].field_0) * 0.5) + 96 > idx:
                        mem[idx + 32] = sub_be75288d[arg1][s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    if sub_be75288d[arg1].field_1792:
                        if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        if sub_be75288d[arg1].field_1792:
                            if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                                revert with 0, 34
                            if Mask(256, -1, sub_be75288d[arg1].field_1792):
                                if 31 < uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160
                                    s = 0
                                    while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 128 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                        mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                                    mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                                    return Array(len=2 * Mask(256, -1, sub_be75288d[arg1].field_0), data=mem[128 len ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)], uint255(sub_be75288d[arg1].field_1792) * 0.5, mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]), 
                                           sub_be75288d[arg1].field_256,
                                           sub_be75288d[arg1].field_512,
                                           sub_be75288d[arg1].field_768,
                                           sub_be75288d[arg1].field_1024,
                                           sub_be75288d[arg1].field_1280,
                                           sub_be75288d[arg1].field_1536,
                                           ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 288
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = 256 * sub_be75288d[arg1].field_1800
                        else:
                            if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                                revert with 0, 34
                            if sub_be75288d[arg1].field_1793:
                                if 31 < sub_be75288d[arg1].field_1793:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160
                                    s = 0
                                    while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + sub_be75288d[arg1].field_1793 + 128 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                        mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                                    mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                                    return Array(len=2 * Mask(256, -1, sub_be75288d[arg1].field_0), data=mem[128 len ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)], uint255(sub_be75288d[arg1].field_1792) * 0.5, mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]), 
                                           sub_be75288d[arg1].field_256,
                                           sub_be75288d[arg1].field_512,
                                           sub_be75288d[arg1].field_768,
                                           sub_be75288d[arg1].field_1024,
                                           sub_be75288d[arg1].field_1280,
                                           sub_be75288d[arg1].field_1536,
                                           ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 288
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = 256 * sub_be75288d[arg1].field_1800
                        if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                            mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                        mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                        mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                        if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                            mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                        return Array(len=2 * Mask(256, -1, sub_be75288d[arg1].field_0), data=mem[128 len ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)], 2 * Mask(256, -1, sub_be75288d[arg1].field_1792), mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]), 
                               sub_be75288d[arg1].field_256,
                               sub_be75288d[arg1].field_512,
                               sub_be75288d[arg1].field_768,
                               sub_be75288d[arg1].field_1024,
                               sub_be75288d[arg1].field_1280,
                               sub_be75288d[arg1].field_1536,
                               ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 288
                    if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                        revert with 0, 34
                    if sub_be75288d[arg1].field_1792:
                        if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        if Mask(256, -1, sub_be75288d[arg1].field_1792):
                            if 31 < uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160
                                s = 0
                                while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 128 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                    mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793) + 448] = 0
                                mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 448] = sub_be75288d[arg1].field_1793
                                return Array(len=2 * Mask(256, -1, sub_be75288d[arg1].field_0), data=mem[128 len ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)], sub_be75288d[arg1].field_1793, mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(sub_be75288d[arg1].field_1793)]), 
                                       sub_be75288d[arg1].field_256,
                                       sub_be75288d[arg1].field_512,
                                       sub_be75288d[arg1].field_768,
                                       sub_be75288d[arg1].field_1024,
                                       sub_be75288d[arg1].field_1280,
                                       sub_be75288d[arg1].field_1536,
                                       ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 288
                            mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = 256 * sub_be75288d[arg1].field_1800
                    else:
                        if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                            revert with 0, 34
                        if sub_be75288d[arg1].field_1793:
                            if 31 < sub_be75288d[arg1].field_1793:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160
                                s = 0
                                while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + sub_be75288d[arg1].field_1793 + 128 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                    mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793) + 448] = 0
                                mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 448] = sub_be75288d[arg1].field_1793
                                return Array(len=2 * Mask(256, -1, sub_be75288d[arg1].field_0), data=mem[128 len ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)], sub_be75288d[arg1].field_1793, mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(sub_be75288d[arg1].field_1793)]), 
                                       sub_be75288d[arg1].field_256,
                                       sub_be75288d[arg1].field_512,
                                       sub_be75288d[arg1].field_768,
                                       sub_be75288d[arg1].field_1024,
                                       sub_be75288d[arg1].field_1280,
                                       sub_be75288d[arg1].field_1536,
                                       ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 288
                            mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = 256 * sub_be75288d[arg1].field_1800
                    if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                        mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793) + 448] = 0
                    mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 448] = sub_be75288d[arg1].field_1793
                    mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 480 len ceil32(sub_be75288d[arg1].field_1793)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(sub_be75288d[arg1].field_1793)]
                    if ceil32(sub_be75288d[arg1].field_1793) > sub_be75288d[arg1].field_1793:
                        mem[sub_be75288d[arg1].field_1793 + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 480] = 0
                else:
                    mem[128] = 256 * sub_be75288d[arg1].field_8
                    if sub_be75288d[arg1].field_1792:
                        if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        if sub_be75288d[arg1].field_1792:
                            if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                                if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                    mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                                mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                                mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                                if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                            else:
                                if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = 256 * sub_be75288d[arg1].field_1800
                                else:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160
                                    s = 0
                                    while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 128 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                    mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                                mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                                mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                                if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                        else:
                            if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                                revert with 0, 34
                            if not sub_be75288d[arg1].field_1793:
                                if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                    mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                                mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                                mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                                if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                            else:
                                if 31 >= sub_be75288d[arg1].field_1793:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = 256 * sub_be75288d[arg1].field_1800
                                else:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160
                                    s = 0
                                    while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + sub_be75288d[arg1].field_1793 + 128 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                    mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                                mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                                mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                                if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                        return Array(len=2 * Mask(256, -1, sub_be75288d[arg1].field_0), data=mem[128 len ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)], 2 * Mask(256, -1, sub_be75288d[arg1].field_1792), mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]), 
                               sub_be75288d[arg1].field_256,
                               sub_be75288d[arg1].field_512,
                               sub_be75288d[arg1].field_768,
                               sub_be75288d[arg1].field_1024,
                               sub_be75288d[arg1].field_1280,
                               sub_be75288d[arg1].field_1536,
                               ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 288
                    if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                        revert with 0, 34
                    if sub_be75288d[arg1].field_1792:
                        if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                            if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793) + 448] = 0
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 448] = sub_be75288d[arg1].field_1793
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 480 len ceil32(sub_be75288d[arg1].field_1793)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(sub_be75288d[arg1].field_1793)]
                            if ceil32(sub_be75288d[arg1].field_1793) > sub_be75288d[arg1].field_1793:
                                mem[sub_be75288d[arg1].field_1793 + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 480] = 0
                        else:
                            if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = 256 * sub_be75288d[arg1].field_1800
                            else:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160
                                s = 0
                                while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 128 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                            if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793) + 448] = 0
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 448] = sub_be75288d[arg1].field_1793
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 480 len ceil32(sub_be75288d[arg1].field_1793)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(sub_be75288d[arg1].field_1793)]
                            if ceil32(sub_be75288d[arg1].field_1793) > sub_be75288d[arg1].field_1793:
                                mem[sub_be75288d[arg1].field_1793 + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 480] = 0
                    else:
                        if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                            revert with 0, 34
                        if not sub_be75288d[arg1].field_1793:
                            if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793) + 448] = 0
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 448] = sub_be75288d[arg1].field_1793
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 480 len ceil32(sub_be75288d[arg1].field_1793)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(sub_be75288d[arg1].field_1793)]
                            if ceil32(sub_be75288d[arg1].field_1793) > sub_be75288d[arg1].field_1793:
                                mem[sub_be75288d[arg1].field_1793 + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 480] = 0
                        else:
                            if 31 >= sub_be75288d[arg1].field_1793:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = 256 * sub_be75288d[arg1].field_1800
                            else:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160
                                s = 0
                                while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + sub_be75288d[arg1].field_1793 + 128 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                            if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793) + 448] = 0
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 448] = sub_be75288d[arg1].field_1793
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 480 len ceil32(sub_be75288d[arg1].field_1793)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(sub_be75288d[arg1].field_1793)]
                            if ceil32(sub_be75288d[arg1].field_1793) > sub_be75288d[arg1].field_1793:
                                mem[sub_be75288d[arg1].field_1793 + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 480] = 0
        else:
            if sub_be75288d[arg1].field_0 == sub_be75288d[arg1].field_1 < 32:
                revert with 0, 34
            if not sub_be75288d[arg1].field_1:
                if sub_be75288d[arg1].field_1792:
                    if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                        revert with 0, 34
                    if sub_be75288d[arg1].field_1792:
                        if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                            if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                            if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                        else:
                            if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = 256 * sub_be75288d[arg1].field_1800
                            else:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160
                                s = 0
                                while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 128 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                            if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                            if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                    else:
                        if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                            revert with 0, 34
                        if not sub_be75288d[arg1].field_1793:
                            if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                            if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                        else:
                            if 31 >= sub_be75288d[arg1].field_1793:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = 256 * sub_be75288d[arg1].field_1800
                            else:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160
                                s = 0
                                while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + sub_be75288d[arg1].field_1793 + 128 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                            if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                            if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                    return Array(len=2 * Mask(256, -1, sub_be75288d[arg1].field_0), data=mem[128 len ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)], 2 * Mask(256, -1, sub_be75288d[arg1].field_1792), mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]), 
                           sub_be75288d[arg1].field_256,
                           sub_be75288d[arg1].field_512,
                           sub_be75288d[arg1].field_768,
                           sub_be75288d[arg1].field_1024,
                           sub_be75288d[arg1].field_1280,
                           sub_be75288d[arg1].field_1536,
                           ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 288
                if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                    revert with 0, 34
                if sub_be75288d[arg1].field_1792:
                    if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                        revert with 0, 34
                    if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                        if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                            mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793) + 448] = 0
                        mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 448] = sub_be75288d[arg1].field_1793
                        mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 480 len ceil32(sub_be75288d[arg1].field_1793)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(sub_be75288d[arg1].field_1793)]
                        if ceil32(sub_be75288d[arg1].field_1793) > sub_be75288d[arg1].field_1793:
                            mem[sub_be75288d[arg1].field_1793 + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 480] = 0
                    else:
                        if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                            mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = 256 * sub_be75288d[arg1].field_1800
                        else:
                            mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = sub_be75288d[arg1][7].field_0
                            idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160
                            s = 0
                            while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 128 > idx:
                                mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                        if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                            mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793) + 448] = 0
                        mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 448] = sub_be75288d[arg1].field_1793
                        mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 480 len ceil32(sub_be75288d[arg1].field_1793)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(sub_be75288d[arg1].field_1793)]
                        if ceil32(sub_be75288d[arg1].field_1793) > sub_be75288d[arg1].field_1793:
                            mem[sub_be75288d[arg1].field_1793 + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 480] = 0
                else:
                    if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                        revert with 0, 34
                    if not sub_be75288d[arg1].field_1793:
                        if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                            mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793) + 448] = 0
                        mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 448] = sub_be75288d[arg1].field_1793
                        mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 480 len ceil32(sub_be75288d[arg1].field_1793)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(sub_be75288d[arg1].field_1793)]
                        if ceil32(sub_be75288d[arg1].field_1793) > sub_be75288d[arg1].field_1793:
                            mem[sub_be75288d[arg1].field_1793 + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 480] = 0
                    else:
                        if 31 >= sub_be75288d[arg1].field_1793:
                            mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = 256 * sub_be75288d[arg1].field_1800
                        else:
                            mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = sub_be75288d[arg1][7].field_0
                            idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160
                            s = 0
                            while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + sub_be75288d[arg1].field_1793 + 128 > idx:
                                mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                        if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                            mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793) + 448] = 0
                        mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 448] = sub_be75288d[arg1].field_1793
                        mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 480 len ceil32(sub_be75288d[arg1].field_1793)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(sub_be75288d[arg1].field_1793)]
                        if ceil32(sub_be75288d[arg1].field_1793) > sub_be75288d[arg1].field_1793:
                            mem[sub_be75288d[arg1].field_1793 + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 480] = 0
            else:
                if 31 < sub_be75288d[arg1].field_1:
                    mem[128] = sub_be75288d[arg1].field_0
                    idx = 128
                    s = 0
                    while sub_be75288d[arg1].field_1 + 96 > idx:
                        mem[idx + 32] = sub_be75288d[arg1][s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    if sub_be75288d[arg1].field_1792:
                        if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        if sub_be75288d[arg1].field_1792:
                            if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                                revert with 0, 34
                            if Mask(256, -1, sub_be75288d[arg1].field_1792):
                                if 31 < uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160
                                    s = 0
                                    while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 128 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                        mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                                    mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                                    return Array(len=2 * Mask(256, -1, sub_be75288d[arg1].field_0), data=mem[128 len ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)], uint255(sub_be75288d[arg1].field_1792) * 0.5, mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]), 
                                           sub_be75288d[arg1].field_256,
                                           sub_be75288d[arg1].field_512,
                                           sub_be75288d[arg1].field_768,
                                           sub_be75288d[arg1].field_1024,
                                           sub_be75288d[arg1].field_1280,
                                           sub_be75288d[arg1].field_1536,
                                           ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 288
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = 256 * sub_be75288d[arg1].field_1800
                        else:
                            if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                                revert with 0, 34
                            if sub_be75288d[arg1].field_1793:
                                if 31 < sub_be75288d[arg1].field_1793:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160
                                    s = 0
                                    while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + sub_be75288d[arg1].field_1793 + 128 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                        mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                                    mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                                    return Array(len=2 * Mask(256, -1, sub_be75288d[arg1].field_0), data=mem[128 len ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)], uint255(sub_be75288d[arg1].field_1792) * 0.5, mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]), 
                                           sub_be75288d[arg1].field_256,
                                           sub_be75288d[arg1].field_512,
                                           sub_be75288d[arg1].field_768,
                                           sub_be75288d[arg1].field_1024,
                                           sub_be75288d[arg1].field_1280,
                                           sub_be75288d[arg1].field_1536,
                                           ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 288
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = 256 * sub_be75288d[arg1].field_1800
                        if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                            mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                        mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                        mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                        if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                            mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                        return Array(len=2 * Mask(256, -1, sub_be75288d[arg1].field_0), data=mem[128 len ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)], 2 * Mask(256, -1, sub_be75288d[arg1].field_1792), mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]), 
                               sub_be75288d[arg1].field_256,
                               sub_be75288d[arg1].field_512,
                               sub_be75288d[arg1].field_768,
                               sub_be75288d[arg1].field_1024,
                               sub_be75288d[arg1].field_1280,
                               sub_be75288d[arg1].field_1536,
                               ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 288
                    if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                        revert with 0, 34
                    if sub_be75288d[arg1].field_1792:
                        if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        if Mask(256, -1, sub_be75288d[arg1].field_1792):
                            if 31 < uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160
                                s = 0
                                while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 128 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                    mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793) + 448] = 0
                                mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 448] = sub_be75288d[arg1].field_1793
                                return Array(len=2 * Mask(256, -1, sub_be75288d[arg1].field_0), data=mem[128 len ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)], sub_be75288d[arg1].field_1793, mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(sub_be75288d[arg1].field_1793)]), 
                                       sub_be75288d[arg1].field_256,
                                       sub_be75288d[arg1].field_512,
                                       sub_be75288d[arg1].field_768,
                                       sub_be75288d[arg1].field_1024,
                                       sub_be75288d[arg1].field_1280,
                                       sub_be75288d[arg1].field_1536,
                                       ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 288
                            mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = 256 * sub_be75288d[arg1].field_1800
                    else:
                        if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                            revert with 0, 34
                        if sub_be75288d[arg1].field_1793:
                            if 31 < sub_be75288d[arg1].field_1793:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160
                                s = 0
                                while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + sub_be75288d[arg1].field_1793 + 128 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                    mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793) + 448] = 0
                                mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 448] = sub_be75288d[arg1].field_1793
                                return Array(len=2 * Mask(256, -1, sub_be75288d[arg1].field_0), data=mem[128 len ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)], sub_be75288d[arg1].field_1793, mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(sub_be75288d[arg1].field_1793)]), 
                                       sub_be75288d[arg1].field_256,
                                       sub_be75288d[arg1].field_512,
                                       sub_be75288d[arg1].field_768,
                                       sub_be75288d[arg1].field_1024,
                                       sub_be75288d[arg1].field_1280,
                                       sub_be75288d[arg1].field_1536,
                                       ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 288
                            mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = 256 * sub_be75288d[arg1].field_1800
                    if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                        mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793) + 448] = 0
                    mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 448] = sub_be75288d[arg1].field_1793
                    mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 480 len ceil32(sub_be75288d[arg1].field_1793)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(sub_be75288d[arg1].field_1793)]
                    if ceil32(sub_be75288d[arg1].field_1793) > sub_be75288d[arg1].field_1793:
                        mem[sub_be75288d[arg1].field_1793 + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 480] = 0
                else:
                    mem[128] = 256 * sub_be75288d[arg1].field_8
                    if sub_be75288d[arg1].field_1792:
                        if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        if sub_be75288d[arg1].field_1792:
                            if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                                if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                    mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                                mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                                mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                                if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                            else:
                                if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = 256 * sub_be75288d[arg1].field_1800
                                else:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160
                                    s = 0
                                    while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 128 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                    mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                                mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                                mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                                if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                        else:
                            if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                                revert with 0, 34
                            if not sub_be75288d[arg1].field_1793:
                                if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                    mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                                mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                                mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                                if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                            else:
                                if 31 >= sub_be75288d[arg1].field_1793:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = 256 * sub_be75288d[arg1].field_1800
                                else:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160
                                    s = 0
                                    while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + sub_be75288d[arg1].field_1793 + 128 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                    mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                                mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                                mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                                if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                        return Array(len=2 * Mask(256, -1, sub_be75288d[arg1].field_0), data=mem[128 len ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)], 2 * Mask(256, -1, sub_be75288d[arg1].field_1792), mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]), 
                               sub_be75288d[arg1].field_256,
                               sub_be75288d[arg1].field_512,
                               sub_be75288d[arg1].field_768,
                               sub_be75288d[arg1].field_1024,
                               sub_be75288d[arg1].field_1280,
                               sub_be75288d[arg1].field_1536,
                               ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 288
                    if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                        revert with 0, 34
                    if sub_be75288d[arg1].field_1792:
                        if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                            if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793) + 448] = 0
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 448] = sub_be75288d[arg1].field_1793
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 480 len ceil32(sub_be75288d[arg1].field_1793)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(sub_be75288d[arg1].field_1793)]
                            if ceil32(sub_be75288d[arg1].field_1793) > sub_be75288d[arg1].field_1793:
                                mem[sub_be75288d[arg1].field_1793 + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 480] = 0
                        else:
                            if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = 256 * sub_be75288d[arg1].field_1800
                            else:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160
                                s = 0
                                while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 128 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                            if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793) + 448] = 0
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 448] = sub_be75288d[arg1].field_1793
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 480 len ceil32(sub_be75288d[arg1].field_1793)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(sub_be75288d[arg1].field_1793)]
                            if ceil32(sub_be75288d[arg1].field_1793) > sub_be75288d[arg1].field_1793:
                                mem[sub_be75288d[arg1].field_1793 + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 480] = 0
                    else:
                        if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                            revert with 0, 34
                        if not sub_be75288d[arg1].field_1793:
                            if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793) + 448] = 0
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 448] = sub_be75288d[arg1].field_1793
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 480 len ceil32(sub_be75288d[arg1].field_1793)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(sub_be75288d[arg1].field_1793)]
                            if ceil32(sub_be75288d[arg1].field_1793) > sub_be75288d[arg1].field_1793:
                                mem[sub_be75288d[arg1].field_1793 + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 480] = 0
                        else:
                            if 31 >= sub_be75288d[arg1].field_1793:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = 256 * sub_be75288d[arg1].field_1800
                            else:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160
                                s = 0
                                while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + sub_be75288d[arg1].field_1793 + 128 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                            if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793) + 448] = 0
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 448] = sub_be75288d[arg1].field_1793
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 480 len ceil32(sub_be75288d[arg1].field_1793)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(sub_be75288d[arg1].field_1793)]
                            if ceil32(sub_be75288d[arg1].field_1793) > sub_be75288d[arg1].field_1793:
                                mem[sub_be75288d[arg1].field_1793 + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793) + 480] = 0
        return Array(len=2 * Mask(256, -1, sub_be75288d[arg1].field_0), data=mem[128 len ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)], sub_be75288d[arg1].field_1792, mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(sub_be75288d[arg1].field_1793)]), 
               sub_be75288d[arg1].field_256,
               sub_be75288d[arg1].field_512,
               sub_be75288d[arg1].field_768,
               sub_be75288d[arg1].field_1024,
               sub_be75288d[arg1].field_1280,
               sub_be75288d[arg1].field_1536,
               ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 288
    if sub_be75288d[arg1].field_0 == sub_be75288d[arg1].field_1 < 32:
        revert with 0, 34
    if sub_be75288d[arg1].field_0:
        if sub_be75288d[arg1].field_0 == uint255(sub_be75288d[arg1].field_0) * 0.5 < 32:
            revert with 0, 34
        if not Mask(256, -1, sub_be75288d[arg1].field_0):
            if sub_be75288d[arg1].field_1792:
                if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                    revert with 0, 34
                if sub_be75288d[arg1].field_1792:
                    if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                        revert with 0, 34
                    if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                        if ceil32(sub_be75288d[arg1].field_1) > sub_be75288d[arg1].field_1:
                            mem[sub_be75288d[arg1].field_1 + ceil32(sub_be75288d[arg1].field_1) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(sub_be75288d[arg1].field_1) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                        if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                            mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                    else:
                        if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                            mem[ceil32(sub_be75288d[arg1].field_1) + 160] = 256 * sub_be75288d[arg1].field_1800
                        else:
                            mem[ceil32(sub_be75288d[arg1].field_1) + 160] = sub_be75288d[arg1][7].field_0
                            idx = ceil32(sub_be75288d[arg1].field_1) + 160
                            s = 0
                            while ceil32(sub_be75288d[arg1].field_1) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 128 > idx:
                                mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                        if ceil32(sub_be75288d[arg1].field_1) > sub_be75288d[arg1].field_1:
                            mem[sub_be75288d[arg1].field_1 + ceil32(sub_be75288d[arg1].field_1) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(sub_be75288d[arg1].field_1) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                        if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                            mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                else:
                    if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                        revert with 0, 34
                    if not sub_be75288d[arg1].field_1793:
                        if ceil32(sub_be75288d[arg1].field_1) > sub_be75288d[arg1].field_1:
                            mem[sub_be75288d[arg1].field_1 + ceil32(sub_be75288d[arg1].field_1) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(sub_be75288d[arg1].field_1) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                        if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                            mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                    else:
                        if 31 >= sub_be75288d[arg1].field_1793:
                            mem[ceil32(sub_be75288d[arg1].field_1) + 160] = 256 * sub_be75288d[arg1].field_1800
                        else:
                            mem[ceil32(sub_be75288d[arg1].field_1) + 160] = sub_be75288d[arg1][7].field_0
                            idx = ceil32(sub_be75288d[arg1].field_1) + 160
                            s = 0
                            while ceil32(sub_be75288d[arg1].field_1) + sub_be75288d[arg1].field_1793 + 128 > idx:
                                mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                        if ceil32(sub_be75288d[arg1].field_1) > sub_be75288d[arg1].field_1:
                            mem[sub_be75288d[arg1].field_1 + ceil32(sub_be75288d[arg1].field_1) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(sub_be75288d[arg1].field_1) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                        if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                            mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                return Array(len=sub_be75288d[arg1].field_0, data=mem[128 len ceil32(sub_be75288d[arg1].field_1)], 2 * Mask(256, -1, sub_be75288d[arg1].field_1792), mem[ceil32(sub_be75288d[arg1].field_1) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]), 
                       sub_be75288d[arg1].field_256,
                       sub_be75288d[arg1].field_512,
                       sub_be75288d[arg1].field_768,
                       sub_be75288d[arg1].field_1024,
                       sub_be75288d[arg1].field_1280,
                       sub_be75288d[arg1].field_1536,
                       ceil32(sub_be75288d[arg1].field_1) + 288
            if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                revert with 0, 34
            if sub_be75288d[arg1].field_1792:
                if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                    revert with 0, 34
                if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                    if ceil32(sub_be75288d[arg1].field_1) > sub_be75288d[arg1].field_1:
                        mem[sub_be75288d[arg1].field_1 + ceil32(sub_be75288d[arg1].field_1) + ceil32(sub_be75288d[arg1].field_1793) + 448] = 0
                    mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 448] = sub_be75288d[arg1].field_1793
                    mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 480 len ceil32(sub_be75288d[arg1].field_1793)] = mem[ceil32(sub_be75288d[arg1].field_1) + 160 len ceil32(sub_be75288d[arg1].field_1793)]
                    if ceil32(sub_be75288d[arg1].field_1793) > sub_be75288d[arg1].field_1793:
                        mem[sub_be75288d[arg1].field_1793 + (2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 480] = 0
                else:
                    if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                        mem[ceil32(sub_be75288d[arg1].field_1) + 160] = 256 * sub_be75288d[arg1].field_1800
                    else:
                        mem[ceil32(sub_be75288d[arg1].field_1) + 160] = sub_be75288d[arg1][7].field_0
                        idx = ceil32(sub_be75288d[arg1].field_1) + 160
                        s = 0
                        while ceil32(sub_be75288d[arg1].field_1) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 128 > idx:
                            mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                            idx = idx + 32
                            s = s + 1
                            continue 
                    if ceil32(sub_be75288d[arg1].field_1) > sub_be75288d[arg1].field_1:
                        mem[sub_be75288d[arg1].field_1 + ceil32(sub_be75288d[arg1].field_1) + ceil32(sub_be75288d[arg1].field_1793) + 448] = 0
                    mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 448] = sub_be75288d[arg1].field_1793
                    mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 480 len ceil32(sub_be75288d[arg1].field_1793)] = mem[ceil32(sub_be75288d[arg1].field_1) + 160 len ceil32(sub_be75288d[arg1].field_1793)]
                    if ceil32(sub_be75288d[arg1].field_1793) > sub_be75288d[arg1].field_1793:
                        mem[sub_be75288d[arg1].field_1793 + (2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 480] = 0
            else:
                if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                    revert with 0, 34
                if not sub_be75288d[arg1].field_1793:
                    if ceil32(sub_be75288d[arg1].field_1) > sub_be75288d[arg1].field_1:
                        mem[sub_be75288d[arg1].field_1 + ceil32(sub_be75288d[arg1].field_1) + ceil32(sub_be75288d[arg1].field_1793) + 448] = 0
                    mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 448] = sub_be75288d[arg1].field_1793
                    mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 480 len ceil32(sub_be75288d[arg1].field_1793)] = mem[ceil32(sub_be75288d[arg1].field_1) + 160 len ceil32(sub_be75288d[arg1].field_1793)]
                    if ceil32(sub_be75288d[arg1].field_1793) > sub_be75288d[arg1].field_1793:
                        mem[sub_be75288d[arg1].field_1793 + (2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 480] = 0
                else:
                    if 31 >= sub_be75288d[arg1].field_1793:
                        mem[ceil32(sub_be75288d[arg1].field_1) + 160] = 256 * sub_be75288d[arg1].field_1800
                    else:
                        mem[ceil32(sub_be75288d[arg1].field_1) + 160] = sub_be75288d[arg1][7].field_0
                        idx = ceil32(sub_be75288d[arg1].field_1) + 160
                        s = 0
                        while ceil32(sub_be75288d[arg1].field_1) + sub_be75288d[arg1].field_1793 + 128 > idx:
                            mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                            idx = idx + 32
                            s = s + 1
                            continue 
                    if ceil32(sub_be75288d[arg1].field_1) > sub_be75288d[arg1].field_1:
                        mem[sub_be75288d[arg1].field_1 + ceil32(sub_be75288d[arg1].field_1) + ceil32(sub_be75288d[arg1].field_1793) + 448] = 0
                    mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 448] = sub_be75288d[arg1].field_1793
                    mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 480 len ceil32(sub_be75288d[arg1].field_1793)] = mem[ceil32(sub_be75288d[arg1].field_1) + 160 len ceil32(sub_be75288d[arg1].field_1793)]
                    if ceil32(sub_be75288d[arg1].field_1793) > sub_be75288d[arg1].field_1793:
                        mem[sub_be75288d[arg1].field_1793 + (2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 480] = 0
        else:
            if 31 < uint255(sub_be75288d[arg1].field_0) * 0.5:
                mem[128] = sub_be75288d[arg1].field_0
                idx = 128
                s = 0
                while (uint255(sub_be75288d[arg1].field_0) * 0.5) + 96 > idx:
                    mem[idx + 32] = sub_be75288d[arg1][s].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
                if sub_be75288d[arg1].field_1792:
                    if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                        revert with 0, 34
                    if sub_be75288d[arg1].field_1792:
                        if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        if Mask(256, -1, sub_be75288d[arg1].field_1792):
                            if 31 < uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[ceil32(sub_be75288d[arg1].field_1) + 160] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(sub_be75288d[arg1].field_1) + 160
                                s = 0
                                while ceil32(sub_be75288d[arg1].field_1) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 128 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                if ceil32(sub_be75288d[arg1].field_1) > sub_be75288d[arg1].field_1:
                                    mem[sub_be75288d[arg1].field_1 + ceil32(sub_be75288d[arg1].field_1) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                                mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                                return Array(len=sub_be75288d[arg1].field_0, data=mem[128 len ceil32(sub_be75288d[arg1].field_1)], uint255(sub_be75288d[arg1].field_1792) * 0.5, mem[ceil32(sub_be75288d[arg1].field_1) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]), 
                                       sub_be75288d[arg1].field_256,
                                       sub_be75288d[arg1].field_512,
                                       sub_be75288d[arg1].field_768,
                                       sub_be75288d[arg1].field_1024,
                                       sub_be75288d[arg1].field_1280,
                                       sub_be75288d[arg1].field_1536,
                                       ceil32(sub_be75288d[arg1].field_1) + 288
                            mem[ceil32(sub_be75288d[arg1].field_1) + 160] = 256 * sub_be75288d[arg1].field_1800
                    else:
                        if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                            revert with 0, 34
                        if sub_be75288d[arg1].field_1793:
                            if 31 < sub_be75288d[arg1].field_1793:
                                mem[ceil32(sub_be75288d[arg1].field_1) + 160] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(sub_be75288d[arg1].field_1) + 160
                                s = 0
                                while ceil32(sub_be75288d[arg1].field_1) + sub_be75288d[arg1].field_1793 + 128 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                if ceil32(sub_be75288d[arg1].field_1) > sub_be75288d[arg1].field_1:
                                    mem[sub_be75288d[arg1].field_1 + ceil32(sub_be75288d[arg1].field_1) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                                mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                                return Array(len=sub_be75288d[arg1].field_0, data=mem[128 len ceil32(sub_be75288d[arg1].field_1)], uint255(sub_be75288d[arg1].field_1792) * 0.5, mem[ceil32(sub_be75288d[arg1].field_1) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]), 
                                       sub_be75288d[arg1].field_256,
                                       sub_be75288d[arg1].field_512,
                                       sub_be75288d[arg1].field_768,
                                       sub_be75288d[arg1].field_1024,
                                       sub_be75288d[arg1].field_1280,
                                       sub_be75288d[arg1].field_1536,
                                       ceil32(sub_be75288d[arg1].field_1) + 288
                            mem[ceil32(sub_be75288d[arg1].field_1) + 160] = 256 * sub_be75288d[arg1].field_1800
                    if ceil32(sub_be75288d[arg1].field_1) > sub_be75288d[arg1].field_1:
                        mem[sub_be75288d[arg1].field_1 + ceil32(sub_be75288d[arg1].field_1) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                    mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                    mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(sub_be75288d[arg1].field_1) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                    if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                        mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                    return Array(len=sub_be75288d[arg1].field_0, data=mem[128 len ceil32(sub_be75288d[arg1].field_1)], 2 * Mask(256, -1, sub_be75288d[arg1].field_1792), mem[ceil32(sub_be75288d[arg1].field_1) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]), 
                           sub_be75288d[arg1].field_256,
                           sub_be75288d[arg1].field_512,
                           sub_be75288d[arg1].field_768,
                           sub_be75288d[arg1].field_1024,
                           sub_be75288d[arg1].field_1280,
                           sub_be75288d[arg1].field_1536,
                           ceil32(sub_be75288d[arg1].field_1) + 288
                if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                    revert with 0, 34
                if sub_be75288d[arg1].field_1792:
                    if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                        revert with 0, 34
                    if Mask(256, -1, sub_be75288d[arg1].field_1792):
                        if 31 < uint255(sub_be75288d[arg1].field_1792) * 0.5:
                            mem[ceil32(sub_be75288d[arg1].field_1) + 160] = sub_be75288d[arg1][7].field_0
                            idx = ceil32(sub_be75288d[arg1].field_1) + 160
                            s = 0
                            while ceil32(sub_be75288d[arg1].field_1) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 128 > idx:
                                mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                            if ceil32(sub_be75288d[arg1].field_1) > sub_be75288d[arg1].field_1:
                                mem[sub_be75288d[arg1].field_1 + ceil32(sub_be75288d[arg1].field_1) + ceil32(sub_be75288d[arg1].field_1793) + 448] = 0
                            mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 448] = sub_be75288d[arg1].field_1793
                            return Array(len=sub_be75288d[arg1].field_0, data=mem[128 len ceil32(sub_be75288d[arg1].field_1)], sub_be75288d[arg1].field_1793, mem[ceil32(sub_be75288d[arg1].field_1) + 160 len ceil32(sub_be75288d[arg1].field_1793)]), 
                                   sub_be75288d[arg1].field_256,
                                   sub_be75288d[arg1].field_512,
                                   sub_be75288d[arg1].field_768,
                                   sub_be75288d[arg1].field_1024,
                                   sub_be75288d[arg1].field_1280,
                                   sub_be75288d[arg1].field_1536,
                                   ceil32(sub_be75288d[arg1].field_1) + 288
                        mem[ceil32(sub_be75288d[arg1].field_1) + 160] = 256 * sub_be75288d[arg1].field_1800
                else:
                    if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                        revert with 0, 34
                    if sub_be75288d[arg1].field_1793:
                        if 31 < sub_be75288d[arg1].field_1793:
                            mem[ceil32(sub_be75288d[arg1].field_1) + 160] = sub_be75288d[arg1][7].field_0
                            idx = ceil32(sub_be75288d[arg1].field_1) + 160
                            s = 0
                            while ceil32(sub_be75288d[arg1].field_1) + sub_be75288d[arg1].field_1793 + 128 > idx:
                                mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                            if ceil32(sub_be75288d[arg1].field_1) > sub_be75288d[arg1].field_1:
                                mem[sub_be75288d[arg1].field_1 + ceil32(sub_be75288d[arg1].field_1) + ceil32(sub_be75288d[arg1].field_1793) + 448] = 0
                            mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 448] = sub_be75288d[arg1].field_1793
                            return Array(len=sub_be75288d[arg1].field_0, data=mem[128 len ceil32(sub_be75288d[arg1].field_1)], sub_be75288d[arg1].field_1793, mem[ceil32(sub_be75288d[arg1].field_1) + 160 len ceil32(sub_be75288d[arg1].field_1793)]), 
                                   sub_be75288d[arg1].field_256,
                                   sub_be75288d[arg1].field_512,
                                   sub_be75288d[arg1].field_768,
                                   sub_be75288d[arg1].field_1024,
                                   sub_be75288d[arg1].field_1280,
                                   sub_be75288d[arg1].field_1536,
                                   ceil32(sub_be75288d[arg1].field_1) + 288
                        mem[ceil32(sub_be75288d[arg1].field_1) + 160] = 256 * sub_be75288d[arg1].field_1800
                if ceil32(sub_be75288d[arg1].field_1) > sub_be75288d[arg1].field_1:
                    mem[sub_be75288d[arg1].field_1 + ceil32(sub_be75288d[arg1].field_1) + ceil32(sub_be75288d[arg1].field_1793) + 448] = 0
                mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 448] = sub_be75288d[arg1].field_1793
                mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 480 len ceil32(sub_be75288d[arg1].field_1793)] = mem[ceil32(sub_be75288d[arg1].field_1) + 160 len ceil32(sub_be75288d[arg1].field_1793)]
                if ceil32(sub_be75288d[arg1].field_1793) > sub_be75288d[arg1].field_1793:
                    mem[sub_be75288d[arg1].field_1793 + (2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 480] = 0
            else:
                mem[128] = 256 * sub_be75288d[arg1].field_8
                if sub_be75288d[arg1].field_1792:
                    if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                        revert with 0, 34
                    if sub_be75288d[arg1].field_1792:
                        if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                            if ceil32(sub_be75288d[arg1].field_1) > sub_be75288d[arg1].field_1:
                                mem[sub_be75288d[arg1].field_1 + ceil32(sub_be75288d[arg1].field_1) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                            mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                            mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(sub_be75288d[arg1].field_1) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                            if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                        else:
                            if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[ceil32(sub_be75288d[arg1].field_1) + 160] = 256 * sub_be75288d[arg1].field_1800
                            else:
                                mem[ceil32(sub_be75288d[arg1].field_1) + 160] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(sub_be75288d[arg1].field_1) + 160
                                s = 0
                                while ceil32(sub_be75288d[arg1].field_1) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 128 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                            if ceil32(sub_be75288d[arg1].field_1) > sub_be75288d[arg1].field_1:
                                mem[sub_be75288d[arg1].field_1 + ceil32(sub_be75288d[arg1].field_1) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                            mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                            mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(sub_be75288d[arg1].field_1) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                            if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                    else:
                        if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                            revert with 0, 34
                        if not sub_be75288d[arg1].field_1793:
                            if ceil32(sub_be75288d[arg1].field_1) > sub_be75288d[arg1].field_1:
                                mem[sub_be75288d[arg1].field_1 + ceil32(sub_be75288d[arg1].field_1) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                            mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                            mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(sub_be75288d[arg1].field_1) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                            if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                        else:
                            if 31 >= sub_be75288d[arg1].field_1793:
                                mem[ceil32(sub_be75288d[arg1].field_1) + 160] = 256 * sub_be75288d[arg1].field_1800
                            else:
                                mem[ceil32(sub_be75288d[arg1].field_1) + 160] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(sub_be75288d[arg1].field_1) + 160
                                s = 0
                                while ceil32(sub_be75288d[arg1].field_1) + sub_be75288d[arg1].field_1793 + 128 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                            if ceil32(sub_be75288d[arg1].field_1) > sub_be75288d[arg1].field_1:
                                mem[sub_be75288d[arg1].field_1 + ceil32(sub_be75288d[arg1].field_1) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                            mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                            mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(sub_be75288d[arg1].field_1) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                            if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                    return Array(len=sub_be75288d[arg1].field_0, data=mem[128 len ceil32(sub_be75288d[arg1].field_1)], 2 * Mask(256, -1, sub_be75288d[arg1].field_1792), mem[ceil32(sub_be75288d[arg1].field_1) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]), 
                           sub_be75288d[arg1].field_256,
                           sub_be75288d[arg1].field_512,
                           sub_be75288d[arg1].field_768,
                           sub_be75288d[arg1].field_1024,
                           sub_be75288d[arg1].field_1280,
                           sub_be75288d[arg1].field_1536,
                           ceil32(sub_be75288d[arg1].field_1) + 288
                if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                    revert with 0, 34
                if sub_be75288d[arg1].field_1792:
                    if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                        revert with 0, 34
                    if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                        if ceil32(sub_be75288d[arg1].field_1) > sub_be75288d[arg1].field_1:
                            mem[sub_be75288d[arg1].field_1 + ceil32(sub_be75288d[arg1].field_1) + ceil32(sub_be75288d[arg1].field_1793) + 448] = 0
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 448] = sub_be75288d[arg1].field_1793
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 480 len ceil32(sub_be75288d[arg1].field_1793)] = mem[ceil32(sub_be75288d[arg1].field_1) + 160 len ceil32(sub_be75288d[arg1].field_1793)]
                        if ceil32(sub_be75288d[arg1].field_1793) > sub_be75288d[arg1].field_1793:
                            mem[sub_be75288d[arg1].field_1793 + (2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 480] = 0
                    else:
                        if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                            mem[ceil32(sub_be75288d[arg1].field_1) + 160] = 256 * sub_be75288d[arg1].field_1800
                        else:
                            mem[ceil32(sub_be75288d[arg1].field_1) + 160] = sub_be75288d[arg1][7].field_0
                            idx = ceil32(sub_be75288d[arg1].field_1) + 160
                            s = 0
                            while ceil32(sub_be75288d[arg1].field_1) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 128 > idx:
                                mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                        if ceil32(sub_be75288d[arg1].field_1) > sub_be75288d[arg1].field_1:
                            mem[sub_be75288d[arg1].field_1 + ceil32(sub_be75288d[arg1].field_1) + ceil32(sub_be75288d[arg1].field_1793) + 448] = 0
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 448] = sub_be75288d[arg1].field_1793
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 480 len ceil32(sub_be75288d[arg1].field_1793)] = mem[ceil32(sub_be75288d[arg1].field_1) + 160 len ceil32(sub_be75288d[arg1].field_1793)]
                        if ceil32(sub_be75288d[arg1].field_1793) > sub_be75288d[arg1].field_1793:
                            mem[sub_be75288d[arg1].field_1793 + (2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 480] = 0
                else:
                    if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                        revert with 0, 34
                    if not sub_be75288d[arg1].field_1793:
                        if ceil32(sub_be75288d[arg1].field_1) > sub_be75288d[arg1].field_1:
                            mem[sub_be75288d[arg1].field_1 + ceil32(sub_be75288d[arg1].field_1) + ceil32(sub_be75288d[arg1].field_1793) + 448] = 0
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 448] = sub_be75288d[arg1].field_1793
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 480 len ceil32(sub_be75288d[arg1].field_1793)] = mem[ceil32(sub_be75288d[arg1].field_1) + 160 len ceil32(sub_be75288d[arg1].field_1793)]
                        if ceil32(sub_be75288d[arg1].field_1793) > sub_be75288d[arg1].field_1793:
                            mem[sub_be75288d[arg1].field_1793 + (2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 480] = 0
                    else:
                        if 31 >= sub_be75288d[arg1].field_1793:
                            mem[ceil32(sub_be75288d[arg1].field_1) + 160] = 256 * sub_be75288d[arg1].field_1800
                        else:
                            mem[ceil32(sub_be75288d[arg1].field_1) + 160] = sub_be75288d[arg1][7].field_0
                            idx = ceil32(sub_be75288d[arg1].field_1) + 160
                            s = 0
                            while ceil32(sub_be75288d[arg1].field_1) + sub_be75288d[arg1].field_1793 + 128 > idx:
                                mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                        if ceil32(sub_be75288d[arg1].field_1) > sub_be75288d[arg1].field_1:
                            mem[sub_be75288d[arg1].field_1 + ceil32(sub_be75288d[arg1].field_1) + ceil32(sub_be75288d[arg1].field_1793) + 448] = 0
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 448] = sub_be75288d[arg1].field_1793
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 480 len ceil32(sub_be75288d[arg1].field_1793)] = mem[ceil32(sub_be75288d[arg1].field_1) + 160 len ceil32(sub_be75288d[arg1].field_1793)]
                        if ceil32(sub_be75288d[arg1].field_1793) > sub_be75288d[arg1].field_1793:
                            mem[sub_be75288d[arg1].field_1793 + (2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 480] = 0
    else:
        if sub_be75288d[arg1].field_0 == sub_be75288d[arg1].field_1 < 32:
            revert with 0, 34
        if not sub_be75288d[arg1].field_1:
            if sub_be75288d[arg1].field_1792:
                if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                    revert with 0, 34
                if sub_be75288d[arg1].field_1792:
                    if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                        revert with 0, 34
                    if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                        if ceil32(sub_be75288d[arg1].field_1) > sub_be75288d[arg1].field_1:
                            mem[sub_be75288d[arg1].field_1 + ceil32(sub_be75288d[arg1].field_1) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(sub_be75288d[arg1].field_1) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                        if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                            mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                    else:
                        if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                            mem[ceil32(sub_be75288d[arg1].field_1) + 160] = 256 * sub_be75288d[arg1].field_1800
                        else:
                            mem[ceil32(sub_be75288d[arg1].field_1) + 160] = sub_be75288d[arg1][7].field_0
                            idx = ceil32(sub_be75288d[arg1].field_1) + 160
                            s = 0
                            while ceil32(sub_be75288d[arg1].field_1) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 128 > idx:
                                mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                        if ceil32(sub_be75288d[arg1].field_1) > sub_be75288d[arg1].field_1:
                            mem[sub_be75288d[arg1].field_1 + ceil32(sub_be75288d[arg1].field_1) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(sub_be75288d[arg1].field_1) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                        if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                            mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                else:
                    if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                        revert with 0, 34
                    if not sub_be75288d[arg1].field_1793:
                        if ceil32(sub_be75288d[arg1].field_1) > sub_be75288d[arg1].field_1:
                            mem[sub_be75288d[arg1].field_1 + ceil32(sub_be75288d[arg1].field_1) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(sub_be75288d[arg1].field_1) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                        if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                            mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                    else:
                        if 31 >= sub_be75288d[arg1].field_1793:
                            mem[ceil32(sub_be75288d[arg1].field_1) + 160] = 256 * sub_be75288d[arg1].field_1800
                        else:
                            mem[ceil32(sub_be75288d[arg1].field_1) + 160] = sub_be75288d[arg1][7].field_0
                            idx = ceil32(sub_be75288d[arg1].field_1) + 160
                            s = 0
                            while ceil32(sub_be75288d[arg1].field_1) + sub_be75288d[arg1].field_1793 + 128 > idx:
                                mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                        if ceil32(sub_be75288d[arg1].field_1) > sub_be75288d[arg1].field_1:
                            mem[sub_be75288d[arg1].field_1 + ceil32(sub_be75288d[arg1].field_1) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(sub_be75288d[arg1].field_1) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                        if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                            mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                return Array(len=sub_be75288d[arg1].field_0, data=mem[128 len ceil32(sub_be75288d[arg1].field_1)], 2 * Mask(256, -1, sub_be75288d[arg1].field_1792), mem[ceil32(sub_be75288d[arg1].field_1) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]), 
                       sub_be75288d[arg1].field_256,
                       sub_be75288d[arg1].field_512,
                       sub_be75288d[arg1].field_768,
                       sub_be75288d[arg1].field_1024,
                       sub_be75288d[arg1].field_1280,
                       sub_be75288d[arg1].field_1536,
                       ceil32(sub_be75288d[arg1].field_1) + 288
            if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                revert with 0, 34
            if sub_be75288d[arg1].field_1792:
                if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                    revert with 0, 34
                if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                    if ceil32(sub_be75288d[arg1].field_1) > sub_be75288d[arg1].field_1:
                        mem[sub_be75288d[arg1].field_1 + ceil32(sub_be75288d[arg1].field_1) + ceil32(sub_be75288d[arg1].field_1793) + 448] = 0
                    mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 448] = sub_be75288d[arg1].field_1793
                    mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 480 len ceil32(sub_be75288d[arg1].field_1793)] = mem[ceil32(sub_be75288d[arg1].field_1) + 160 len ceil32(sub_be75288d[arg1].field_1793)]
                    if ceil32(sub_be75288d[arg1].field_1793) > sub_be75288d[arg1].field_1793:
                        mem[sub_be75288d[arg1].field_1793 + (2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 480] = 0
                else:
                    if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                        mem[ceil32(sub_be75288d[arg1].field_1) + 160] = 256 * sub_be75288d[arg1].field_1800
                    else:
                        mem[ceil32(sub_be75288d[arg1].field_1) + 160] = sub_be75288d[arg1][7].field_0
                        idx = ceil32(sub_be75288d[arg1].field_1) + 160
                        s = 0
                        while ceil32(sub_be75288d[arg1].field_1) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 128 > idx:
                            mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                            idx = idx + 32
                            s = s + 1
                            continue 
                    if ceil32(sub_be75288d[arg1].field_1) > sub_be75288d[arg1].field_1:
                        mem[sub_be75288d[arg1].field_1 + ceil32(sub_be75288d[arg1].field_1) + ceil32(sub_be75288d[arg1].field_1793) + 448] = 0
                    mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 448] = sub_be75288d[arg1].field_1793
                    mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 480 len ceil32(sub_be75288d[arg1].field_1793)] = mem[ceil32(sub_be75288d[arg1].field_1) + 160 len ceil32(sub_be75288d[arg1].field_1793)]
                    if ceil32(sub_be75288d[arg1].field_1793) > sub_be75288d[arg1].field_1793:
                        mem[sub_be75288d[arg1].field_1793 + (2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 480] = 0
            else:
                if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                    revert with 0, 34
                if not sub_be75288d[arg1].field_1793:
                    if ceil32(sub_be75288d[arg1].field_1) > sub_be75288d[arg1].field_1:
                        mem[sub_be75288d[arg1].field_1 + ceil32(sub_be75288d[arg1].field_1) + ceil32(sub_be75288d[arg1].field_1793) + 448] = 0
                    mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 448] = sub_be75288d[arg1].field_1793
                    mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 480 len ceil32(sub_be75288d[arg1].field_1793)] = mem[ceil32(sub_be75288d[arg1].field_1) + 160 len ceil32(sub_be75288d[arg1].field_1793)]
                    if ceil32(sub_be75288d[arg1].field_1793) > sub_be75288d[arg1].field_1793:
                        mem[sub_be75288d[arg1].field_1793 + (2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 480] = 0
                else:
                    if 31 >= sub_be75288d[arg1].field_1793:
                        mem[ceil32(sub_be75288d[arg1].field_1) + 160] = 256 * sub_be75288d[arg1].field_1800
                    else:
                        mem[ceil32(sub_be75288d[arg1].field_1) + 160] = sub_be75288d[arg1][7].field_0
                        idx = ceil32(sub_be75288d[arg1].field_1) + 160
                        s = 0
                        while ceil32(sub_be75288d[arg1].field_1) + sub_be75288d[arg1].field_1793 + 128 > idx:
                            mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                            idx = idx + 32
                            s = s + 1
                            continue 
                    if ceil32(sub_be75288d[arg1].field_1) > sub_be75288d[arg1].field_1:
                        mem[sub_be75288d[arg1].field_1 + ceil32(sub_be75288d[arg1].field_1) + ceil32(sub_be75288d[arg1].field_1793) + 448] = 0
                    mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 448] = sub_be75288d[arg1].field_1793
                    mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 480 len ceil32(sub_be75288d[arg1].field_1793)] = mem[ceil32(sub_be75288d[arg1].field_1) + 160 len ceil32(sub_be75288d[arg1].field_1793)]
                    if ceil32(sub_be75288d[arg1].field_1793) > sub_be75288d[arg1].field_1793:
                        mem[sub_be75288d[arg1].field_1793 + (2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 480] = 0
        else:
            if 31 < sub_be75288d[arg1].field_1:
                mem[128] = sub_be75288d[arg1].field_0
                idx = 128
                s = 0
                while sub_be75288d[arg1].field_1 + 96 > idx:
                    mem[idx + 32] = sub_be75288d[arg1][s].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
                if sub_be75288d[arg1].field_1792:
                    if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                        revert with 0, 34
                    if sub_be75288d[arg1].field_1792:
                        if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        if Mask(256, -1, sub_be75288d[arg1].field_1792):
                            if 31 < uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[ceil32(sub_be75288d[arg1].field_1) + 160] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(sub_be75288d[arg1].field_1) + 160
                                s = 0
                                while ceil32(sub_be75288d[arg1].field_1) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 128 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                if ceil32(sub_be75288d[arg1].field_1) > sub_be75288d[arg1].field_1:
                                    mem[sub_be75288d[arg1].field_1 + ceil32(sub_be75288d[arg1].field_1) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                                mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                                return Array(len=sub_be75288d[arg1].field_0, data=mem[128 len ceil32(sub_be75288d[arg1].field_1)], uint255(sub_be75288d[arg1].field_1792) * 0.5, mem[ceil32(sub_be75288d[arg1].field_1) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]), 
                                       sub_be75288d[arg1].field_256,
                                       sub_be75288d[arg1].field_512,
                                       sub_be75288d[arg1].field_768,
                                       sub_be75288d[arg1].field_1024,
                                       sub_be75288d[arg1].field_1280,
                                       sub_be75288d[arg1].field_1536,
                                       ceil32(sub_be75288d[arg1].field_1) + 288
                            mem[ceil32(sub_be75288d[arg1].field_1) + 160] = 256 * sub_be75288d[arg1].field_1800
                    else:
                        if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                            revert with 0, 34
                        if sub_be75288d[arg1].field_1793:
                            if 31 < sub_be75288d[arg1].field_1793:
                                mem[ceil32(sub_be75288d[arg1].field_1) + 160] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(sub_be75288d[arg1].field_1) + 160
                                s = 0
                                while ceil32(sub_be75288d[arg1].field_1) + sub_be75288d[arg1].field_1793 + 128 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                if ceil32(sub_be75288d[arg1].field_1) > sub_be75288d[arg1].field_1:
                                    mem[sub_be75288d[arg1].field_1 + ceil32(sub_be75288d[arg1].field_1) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                                mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                                return Array(len=sub_be75288d[arg1].field_0, data=mem[128 len ceil32(sub_be75288d[arg1].field_1)], uint255(sub_be75288d[arg1].field_1792) * 0.5, mem[ceil32(sub_be75288d[arg1].field_1) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]), 
                                       sub_be75288d[arg1].field_256,
                                       sub_be75288d[arg1].field_512,
                                       sub_be75288d[arg1].field_768,
                                       sub_be75288d[arg1].field_1024,
                                       sub_be75288d[arg1].field_1280,
                                       sub_be75288d[arg1].field_1536,
                                       ceil32(sub_be75288d[arg1].field_1) + 288
                            mem[ceil32(sub_be75288d[arg1].field_1) + 160] = 256 * sub_be75288d[arg1].field_1800
                    if ceil32(sub_be75288d[arg1].field_1) > sub_be75288d[arg1].field_1:
                        mem[sub_be75288d[arg1].field_1 + ceil32(sub_be75288d[arg1].field_1) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                    mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                    mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(sub_be75288d[arg1].field_1) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                    if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                        mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                    return Array(len=sub_be75288d[arg1].field_0, data=mem[128 len ceil32(sub_be75288d[arg1].field_1)], 2 * Mask(256, -1, sub_be75288d[arg1].field_1792), mem[ceil32(sub_be75288d[arg1].field_1) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]), 
                           sub_be75288d[arg1].field_256,
                           sub_be75288d[arg1].field_512,
                           sub_be75288d[arg1].field_768,
                           sub_be75288d[arg1].field_1024,
                           sub_be75288d[arg1].field_1280,
                           sub_be75288d[arg1].field_1536,
                           ceil32(sub_be75288d[arg1].field_1) + 288
                if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                    revert with 0, 34
                if sub_be75288d[arg1].field_1792:
                    if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                        revert with 0, 34
                    if Mask(256, -1, sub_be75288d[arg1].field_1792):
                        if 31 < uint255(sub_be75288d[arg1].field_1792) * 0.5:
                            mem[ceil32(sub_be75288d[arg1].field_1) + 160] = sub_be75288d[arg1][7].field_0
                            idx = ceil32(sub_be75288d[arg1].field_1) + 160
                            s = 0
                            while ceil32(sub_be75288d[arg1].field_1) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 128 > idx:
                                mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                            if ceil32(sub_be75288d[arg1].field_1) > sub_be75288d[arg1].field_1:
                                mem[sub_be75288d[arg1].field_1 + ceil32(sub_be75288d[arg1].field_1) + ceil32(sub_be75288d[arg1].field_1793) + 448] = 0
                            mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 448] = sub_be75288d[arg1].field_1793
                            return Array(len=sub_be75288d[arg1].field_0, data=mem[128 len ceil32(sub_be75288d[arg1].field_1)], sub_be75288d[arg1].field_1793, mem[ceil32(sub_be75288d[arg1].field_1) + 160 len ceil32(sub_be75288d[arg1].field_1793)]), 
                                   sub_be75288d[arg1].field_256,
                                   sub_be75288d[arg1].field_512,
                                   sub_be75288d[arg1].field_768,
                                   sub_be75288d[arg1].field_1024,
                                   sub_be75288d[arg1].field_1280,
                                   sub_be75288d[arg1].field_1536,
                                   ceil32(sub_be75288d[arg1].field_1) + 288
                        mem[ceil32(sub_be75288d[arg1].field_1) + 160] = 256 * sub_be75288d[arg1].field_1800
                else:
                    if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                        revert with 0, 34
                    if sub_be75288d[arg1].field_1793:
                        if 31 < sub_be75288d[arg1].field_1793:
                            mem[ceil32(sub_be75288d[arg1].field_1) + 160] = sub_be75288d[arg1][7].field_0
                            idx = ceil32(sub_be75288d[arg1].field_1) + 160
                            s = 0
                            while ceil32(sub_be75288d[arg1].field_1) + sub_be75288d[arg1].field_1793 + 128 > idx:
                                mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                            if ceil32(sub_be75288d[arg1].field_1) > sub_be75288d[arg1].field_1:
                                mem[sub_be75288d[arg1].field_1 + ceil32(sub_be75288d[arg1].field_1) + ceil32(sub_be75288d[arg1].field_1793) + 448] = 0
                            mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 448] = sub_be75288d[arg1].field_1793
                            return Array(len=sub_be75288d[arg1].field_0, data=mem[128 len ceil32(sub_be75288d[arg1].field_1)], sub_be75288d[arg1].field_1793, mem[ceil32(sub_be75288d[arg1].field_1) + 160 len ceil32(sub_be75288d[arg1].field_1793)]), 
                                   sub_be75288d[arg1].field_256,
                                   sub_be75288d[arg1].field_512,
                                   sub_be75288d[arg1].field_768,
                                   sub_be75288d[arg1].field_1024,
                                   sub_be75288d[arg1].field_1280,
                                   sub_be75288d[arg1].field_1536,
                                   ceil32(sub_be75288d[arg1].field_1) + 288
                        mem[ceil32(sub_be75288d[arg1].field_1) + 160] = 256 * sub_be75288d[arg1].field_1800
                if ceil32(sub_be75288d[arg1].field_1) > sub_be75288d[arg1].field_1:
                    mem[sub_be75288d[arg1].field_1 + ceil32(sub_be75288d[arg1].field_1) + ceil32(sub_be75288d[arg1].field_1793) + 448] = 0
                mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 448] = sub_be75288d[arg1].field_1793
                mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 480 len ceil32(sub_be75288d[arg1].field_1793)] = mem[ceil32(sub_be75288d[arg1].field_1) + 160 len ceil32(sub_be75288d[arg1].field_1793)]
                if ceil32(sub_be75288d[arg1].field_1793) > sub_be75288d[arg1].field_1793:
                    mem[sub_be75288d[arg1].field_1793 + (2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 480] = 0
            else:
                mem[128] = 256 * sub_be75288d[arg1].field_8
                if sub_be75288d[arg1].field_1792:
                    if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                        revert with 0, 34
                    if sub_be75288d[arg1].field_1792:
                        if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                            if ceil32(sub_be75288d[arg1].field_1) > sub_be75288d[arg1].field_1:
                                mem[sub_be75288d[arg1].field_1 + ceil32(sub_be75288d[arg1].field_1) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                            mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                            mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(sub_be75288d[arg1].field_1) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                            if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                        else:
                            if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[ceil32(sub_be75288d[arg1].field_1) + 160] = 256 * sub_be75288d[arg1].field_1800
                            else:
                                mem[ceil32(sub_be75288d[arg1].field_1) + 160] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(sub_be75288d[arg1].field_1) + 160
                                s = 0
                                while ceil32(sub_be75288d[arg1].field_1) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 128 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                            if ceil32(sub_be75288d[arg1].field_1) > sub_be75288d[arg1].field_1:
                                mem[sub_be75288d[arg1].field_1 + ceil32(sub_be75288d[arg1].field_1) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                            mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                            mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(sub_be75288d[arg1].field_1) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                            if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                    else:
                        if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                            revert with 0, 34
                        if not sub_be75288d[arg1].field_1793:
                            if ceil32(sub_be75288d[arg1].field_1) > sub_be75288d[arg1].field_1:
                                mem[sub_be75288d[arg1].field_1 + ceil32(sub_be75288d[arg1].field_1) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                            mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                            mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(sub_be75288d[arg1].field_1) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                            if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                        else:
                            if 31 >= sub_be75288d[arg1].field_1793:
                                mem[ceil32(sub_be75288d[arg1].field_1) + 160] = 256 * sub_be75288d[arg1].field_1800
                            else:
                                mem[ceil32(sub_be75288d[arg1].field_1) + 160] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(sub_be75288d[arg1].field_1) + 160
                                s = 0
                                while ceil32(sub_be75288d[arg1].field_1) + sub_be75288d[arg1].field_1793 + 128 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                            if ceil32(sub_be75288d[arg1].field_1) > sub_be75288d[arg1].field_1:
                                mem[sub_be75288d[arg1].field_1 + ceil32(sub_be75288d[arg1].field_1) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                            mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                            mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(sub_be75288d[arg1].field_1) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                            if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                    return Array(len=sub_be75288d[arg1].field_0, data=mem[128 len ceil32(sub_be75288d[arg1].field_1)], 2 * Mask(256, -1, sub_be75288d[arg1].field_1792), mem[ceil32(sub_be75288d[arg1].field_1) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]), 
                           sub_be75288d[arg1].field_256,
                           sub_be75288d[arg1].field_512,
                           sub_be75288d[arg1].field_768,
                           sub_be75288d[arg1].field_1024,
                           sub_be75288d[arg1].field_1280,
                           sub_be75288d[arg1].field_1536,
                           ceil32(sub_be75288d[arg1].field_1) + 288
                if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                    revert with 0, 34
                if sub_be75288d[arg1].field_1792:
                    if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                        revert with 0, 34
                    if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                        if ceil32(sub_be75288d[arg1].field_1) > sub_be75288d[arg1].field_1:
                            mem[sub_be75288d[arg1].field_1 + ceil32(sub_be75288d[arg1].field_1) + ceil32(sub_be75288d[arg1].field_1793) + 448] = 0
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 448] = sub_be75288d[arg1].field_1793
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 480 len ceil32(sub_be75288d[arg1].field_1793)] = mem[ceil32(sub_be75288d[arg1].field_1) + 160 len ceil32(sub_be75288d[arg1].field_1793)]
                        if ceil32(sub_be75288d[arg1].field_1793) > sub_be75288d[arg1].field_1793:
                            mem[sub_be75288d[arg1].field_1793 + (2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 480] = 0
                    else:
                        if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                            mem[ceil32(sub_be75288d[arg1].field_1) + 160] = 256 * sub_be75288d[arg1].field_1800
                        else:
                            mem[ceil32(sub_be75288d[arg1].field_1) + 160] = sub_be75288d[arg1][7].field_0
                            idx = ceil32(sub_be75288d[arg1].field_1) + 160
                            s = 0
                            while ceil32(sub_be75288d[arg1].field_1) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 128 > idx:
                                mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                        if ceil32(sub_be75288d[arg1].field_1) > sub_be75288d[arg1].field_1:
                            mem[sub_be75288d[arg1].field_1 + ceil32(sub_be75288d[arg1].field_1) + ceil32(sub_be75288d[arg1].field_1793) + 448] = 0
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 448] = sub_be75288d[arg1].field_1793
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 480 len ceil32(sub_be75288d[arg1].field_1793)] = mem[ceil32(sub_be75288d[arg1].field_1) + 160 len ceil32(sub_be75288d[arg1].field_1793)]
                        if ceil32(sub_be75288d[arg1].field_1793) > sub_be75288d[arg1].field_1793:
                            mem[sub_be75288d[arg1].field_1793 + (2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 480] = 0
                else:
                    if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                        revert with 0, 34
                    if not sub_be75288d[arg1].field_1793:
                        if ceil32(sub_be75288d[arg1].field_1) > sub_be75288d[arg1].field_1:
                            mem[sub_be75288d[arg1].field_1 + ceil32(sub_be75288d[arg1].field_1) + ceil32(sub_be75288d[arg1].field_1793) + 448] = 0
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 448] = sub_be75288d[arg1].field_1793
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 480 len ceil32(sub_be75288d[arg1].field_1793)] = mem[ceil32(sub_be75288d[arg1].field_1) + 160 len ceil32(sub_be75288d[arg1].field_1793)]
                        if ceil32(sub_be75288d[arg1].field_1793) > sub_be75288d[arg1].field_1793:
                            mem[sub_be75288d[arg1].field_1793 + (2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 480] = 0
                    else:
                        if 31 >= sub_be75288d[arg1].field_1793:
                            mem[ceil32(sub_be75288d[arg1].field_1) + 160] = 256 * sub_be75288d[arg1].field_1800
                        else:
                            mem[ceil32(sub_be75288d[arg1].field_1) + 160] = sub_be75288d[arg1][7].field_0
                            idx = ceil32(sub_be75288d[arg1].field_1) + 160
                            s = 0
                            while ceil32(sub_be75288d[arg1].field_1) + sub_be75288d[arg1].field_1793 + 128 > idx:
                                mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                        if ceil32(sub_be75288d[arg1].field_1) > sub_be75288d[arg1].field_1:
                            mem[sub_be75288d[arg1].field_1 + ceil32(sub_be75288d[arg1].field_1) + ceil32(sub_be75288d[arg1].field_1793) + 448] = 0
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 448] = sub_be75288d[arg1].field_1793
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 480 len ceil32(sub_be75288d[arg1].field_1793)] = mem[ceil32(sub_be75288d[arg1].field_1) + 160 len ceil32(sub_be75288d[arg1].field_1793)]
                        if ceil32(sub_be75288d[arg1].field_1793) > sub_be75288d[arg1].field_1793:
                            mem[sub_be75288d[arg1].field_1793 + (2 * ceil32(sub_be75288d[arg1].field_1)) + ceil32(sub_be75288d[arg1].field_1793) + 480] = 0
    return Array(len=sub_be75288d[arg1].field_0, data=mem[128 len ceil32(sub_be75288d[arg1].field_1)], sub_be75288d[arg1].field_1792, mem[ceil32(sub_be75288d[arg1].field_1) + 160 len ceil32(sub_be75288d[arg1].field_1793)]), 
           sub_be75288d[arg1].field_256,
           sub_be75288d[arg1].field_512,
           sub_be75288d[arg1].field_768,
           sub_be75288d[arg1].field_1024,
           sub_be75288d[arg1].field_1280,
           sub_be75288d[arg1].field_1536,
           ceil32(sub_be75288d[arg1].field_1) + 288
}

function sub_d871fea2(?) payable {
    require calldata.size - 4 >= 96
    require arg3 == address(arg3)
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if sub_be75288d[arg1].field_0:
        if sub_be75288d[arg1].field_0 == uint255(sub_be75288d[arg1].field_0) * 0.5 < 32:
            revert with 0, 34
        mem[352] = uint255(sub_be75288d[arg1].field_0) * 0.5
        if sub_be75288d[arg1].field_0:
            if sub_be75288d[arg1].field_0 == uint255(sub_be75288d[arg1].field_0) * 0.5 < 32:
                revert with 0, 34
            if not Mask(256, -1, sub_be75288d[arg1].field_0):
                mem[96] = 352
                mem[128] = sub_be75288d[arg1].field_256
                mem[160] = sub_be75288d[arg1].field_512
                mem[192] = sub_be75288d[arg1].field_768
                mem[224] = sub_be75288d[arg1].field_1024
                mem[256] = sub_be75288d[arg1].field_1280
                mem[288] = sub_be75288d[arg1].field_1536
                if sub_be75288d[arg1].field_1792:
                    if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                        revert with 0, 34
                    mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416
                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                    if sub_be75288d[arg1].field_1792:
                        if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                            mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                            if arg1 >= 4:
                                revert with 0, 'Invalid tier'
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                revert with 0, 'Too many nodes of this tier'
                            if arg2 <= 0:
                                revert with 0, 'Must create at least one'
                            mem[0] = arg1
                            mem[32] = sha3(address(arg3), 202)
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            sub_2b1331a8[address(arg3)][arg1] += arg2
                            idx = 0
                            while idx < arg2:
                                if numMinted > -2:
                                    revert with 0, 17
                                numMinted++
                                _10179 = mem[64]
                                mem[64] = mem[64] + 32
                                mem[_10179] = 0
                                if not address(arg3):
                                    revert with 0, 'ERC721: mint to the zero address'
                                if ownerOf[stor203]:
                                    revert with 0, 'ERC721: token already minted'
                                if balanceOf[address(arg3)] > -2:
                                    revert with 0, 17
                                balanceOf[address(arg3)]++
                                mem[0] = numMinted
                                mem[32] = 103
                                ownerOf[stor203] = address(arg3)
                                emit Transfer(0, address(arg3), numMinted);
                                if not ext_code.size(address(arg3)):
                                    _11815 = mem[64]
                                    mem[64] = mem[64] + 128
                                    mem[_11815] = arg1
                                    mem[_11815 + 32] = 1000
                                    mem[_11815 + 64] = block.timestamp
                                    if 720 * 24 * 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[_11815 + 96] = block.timestamp + (720 * 24 * 3600)
                                else:
                                    mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = 0
                                    mem[mem[64] + 68] = numMinted
                                    mem[mem[64] + 100] = 128
                                    mem[mem[64] + 132] = 0
                                    s = 0
                                    while s < 0:
                                        mem[s + mem[64] + 164] = mem[s + _10179 + 32]
                                        s = s + 32
                                        continue 
                                    require ext_code.size(address(arg3))
                                    call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args msg.sender, 0, numMinted, 128, 0
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        if not return_data.size:
                                            if not mem[96]:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        if not return_data.size:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _19611 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_19611] == Mask(32, 224, mem[_19611])
                                    if Mask(32, 224, mem[_19611]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    _21771 = mem[64]
                                    mem[64] = mem[64] + 128
                                    mem[_21771] = arg1
                                    mem[_21771 + 32] = 1000
                                    mem[_21771 + 64] = block.timestamp
                                    if 720 * 24 * 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[_21771 + 96] = block.timestamp + (720 * 24 * 3600)
                                mem[0] = numMinted
                                mem[32] = 201
                                sub_79ba2fa2[stor203].field_0 = arg1
                                sub_79ba2fa2[stor203].field_256 = 1000
                                sub_79ba2fa2[stor203].field_512 = block.timestamp
                                sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * sub_be75288d[arg1].field_1800
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _10180 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_10180] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _11816 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_11816] = arg1
                                        mem[_11816 + 32] = 1000
                                        mem[_11816 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_11816 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _10180 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _19613 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_19613] == Mask(32, 224, mem[_19613])
                                        if Mask(32, 224, mem[_19613]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _21776 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_21776] = arg1
                                        mem[_21776 + 32] = 1000
                                        mem[_21776 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_21776 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                s = 0
                                while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _19421 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_19421] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _22875 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_22875] = arg1
                                        mem[_22875 + 32] = 1000
                                        mem[_22875 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_22875 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _19421 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _26923 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_26923] == Mask(32, 224, mem[_26923])
                                        if Mask(32, 224, mem[_26923]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _28587 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_28587] = arg1
                                        mem[_28587 + 32] = 1000
                                        mem[_28587 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_28587 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                    else:
                        if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                            revert with 0, 34
                        if not sub_be75288d[arg1].field_1793:
                            mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                            if arg1 >= 4:
                                revert with 0, 'Invalid tier'
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                revert with 0, 'Too many nodes of this tier'
                            if arg2 <= 0:
                                revert with 0, 'Must create at least one'
                            mem[0] = arg1
                            mem[32] = sha3(address(arg3), 202)
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            sub_2b1331a8[address(arg3)][arg1] += arg2
                            idx = 0
                            while idx < arg2:
                                if numMinted > -2:
                                    revert with 0, 17
                                numMinted++
                                _10181 = mem[64]
                                mem[64] = mem[64] + 32
                                mem[_10181] = 0
                                if not address(arg3):
                                    revert with 0, 'ERC721: mint to the zero address'
                                if ownerOf[stor203]:
                                    revert with 0, 'ERC721: token already minted'
                                if balanceOf[address(arg3)] > -2:
                                    revert with 0, 17
                                balanceOf[address(arg3)]++
                                mem[0] = numMinted
                                mem[32] = 103
                                ownerOf[stor203] = address(arg3)
                                emit Transfer(0, address(arg3), numMinted);
                                if not ext_code.size(address(arg3)):
                                    _11817 = mem[64]
                                    mem[64] = mem[64] + 128
                                    mem[_11817] = arg1
                                    mem[_11817 + 32] = 1000
                                    mem[_11817 + 64] = block.timestamp
                                    if 720 * 24 * 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[_11817 + 96] = block.timestamp + (720 * 24 * 3600)
                                else:
                                    mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = 0
                                    mem[mem[64] + 68] = numMinted
                                    mem[mem[64] + 100] = 128
                                    mem[mem[64] + 132] = 0
                                    s = 0
                                    while s < 0:
                                        mem[s + mem[64] + 164] = mem[s + _10181 + 32]
                                        s = s + 32
                                        continue 
                                    require ext_code.size(address(arg3))
                                    call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args msg.sender, 0, numMinted, 128, 0
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        if not return_data.size:
                                            if not mem[96]:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        if not return_data.size:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _19615 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_19615] == Mask(32, 224, mem[_19615])
                                    if Mask(32, 224, mem[_19615]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    _21780 = mem[64]
                                    mem[64] = mem[64] + 128
                                    mem[_21780] = arg1
                                    mem[_21780 + 32] = 1000
                                    mem[_21780 + 64] = block.timestamp
                                    if 720 * 24 * 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[_21780 + 96] = block.timestamp + (720 * 24 * 3600)
                                mem[0] = numMinted
                                mem[32] = 201
                                sub_79ba2fa2[stor203].field_0 = arg1
                                sub_79ba2fa2[stor203].field_256 = 1000
                                sub_79ba2fa2[stor203].field_512 = block.timestamp
                                sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            if 31 >= sub_be75288d[arg1].field_1793:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * sub_be75288d[arg1].field_1800
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _10182 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_10182] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _11818 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_11818] = arg1
                                        mem[_11818 + 32] = 1000
                                        mem[_11818 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_11818 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _10182 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _19617 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_19617] == Mask(32, 224, mem[_19617])
                                        if Mask(32, 224, mem[_19617]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _21785 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_21785] = arg1
                                        mem[_21785 + 32] = 1000
                                        mem[_21785 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_21785 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                s = 0
                                while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + sub_be75288d[arg1].field_1793 + 384 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _19426 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_19426] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _22876 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_22876] = arg1
                                        mem[_22876 + 32] = 1000
                                        mem[_22876 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_22876 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _19426 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _26925 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_26925] == Mask(32, 224, mem[_26925])
                                        if Mask(32, 224, mem[_26925]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _28591 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_28591] = arg1
                                        mem[_28591 + 32] = 1000
                                        mem[_28591 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_28591 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                else:
                    if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                        revert with 0, 34
                    mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793) + 416
                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384] = sub_be75288d[arg1].field_1793
                    if sub_be75288d[arg1].field_1792:
                        if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                            mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                            if arg1 >= 4:
                                revert with 0, 'Invalid tier'
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                revert with 0, 'Too many nodes of this tier'
                            if arg2 <= 0:
                                revert with 0, 'Must create at least one'
                            mem[0] = arg1
                            mem[32] = sha3(address(arg3), 202)
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            sub_2b1331a8[address(arg3)][arg1] += arg2
                            idx = 0
                            while idx < arg2:
                                if numMinted > -2:
                                    revert with 0, 17
                                numMinted++
                                _10183 = mem[64]
                                mem[64] = mem[64] + 32
                                mem[_10183] = 0
                                if not address(arg3):
                                    revert with 0, 'ERC721: mint to the zero address'
                                if ownerOf[stor203]:
                                    revert with 0, 'ERC721: token already minted'
                                if balanceOf[address(arg3)] > -2:
                                    revert with 0, 17
                                balanceOf[address(arg3)]++
                                mem[0] = numMinted
                                mem[32] = 103
                                ownerOf[stor203] = address(arg3)
                                emit Transfer(0, address(arg3), numMinted);
                                if not ext_code.size(address(arg3)):
                                    _11819 = mem[64]
                                    mem[64] = mem[64] + 128
                                    mem[_11819] = arg1
                                    mem[_11819 + 32] = 1000
                                    mem[_11819 + 64] = block.timestamp
                                    if 720 * 24 * 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[_11819 + 96] = block.timestamp + (720 * 24 * 3600)
                                else:
                                    mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = 0
                                    mem[mem[64] + 68] = numMinted
                                    mem[mem[64] + 100] = 128
                                    mem[mem[64] + 132] = 0
                                    s = 0
                                    while s < 0:
                                        mem[s + mem[64] + 164] = mem[s + _10183 + 32]
                                        s = s + 32
                                        continue 
                                    require ext_code.size(address(arg3))
                                    call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args msg.sender, 0, numMinted, 128, 0
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        if not return_data.size:
                                            if not mem[96]:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        if not return_data.size:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _19619 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_19619] == Mask(32, 224, mem[_19619])
                                    if Mask(32, 224, mem[_19619]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    _21789 = mem[64]
                                    mem[64] = mem[64] + 128
                                    mem[_21789] = arg1
                                    mem[_21789 + 32] = 1000
                                    mem[_21789 + 64] = block.timestamp
                                    if 720 * 24 * 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[_21789 + 96] = block.timestamp + (720 * 24 * 3600)
                                mem[0] = numMinted
                                mem[32] = 201
                                sub_79ba2fa2[stor203].field_0 = arg1
                                sub_79ba2fa2[stor203].field_256 = 1000
                                sub_79ba2fa2[stor203].field_512 = block.timestamp
                                sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * sub_be75288d[arg1].field_1800
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _10184 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_10184] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _11820 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_11820] = arg1
                                        mem[_11820 + 32] = 1000
                                        mem[_11820 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_11820 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _10184 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _19621 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_19621] == Mask(32, 224, mem[_19621])
                                        if Mask(32, 224, mem[_19621]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _21794 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_21794] = arg1
                                        mem[_21794 + 32] = 1000
                                        mem[_21794 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_21794 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                s = 0
                                while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _19431 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_19431] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _22877 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_22877] = arg1
                                        mem[_22877 + 32] = 1000
                                        mem[_22877 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_22877 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _19431 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _26927 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_26927] == Mask(32, 224, mem[_26927])
                                        if Mask(32, 224, mem[_26927]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _28595 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_28595] = arg1
                                        mem[_28595 + 32] = 1000
                                        mem[_28595 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_28595 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                    else:
                        if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                            revert with 0, 34
                        if not sub_be75288d[arg1].field_1793:
                            mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                            if arg1 >= 4:
                                revert with 0, 'Invalid tier'
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                revert with 0, 'Too many nodes of this tier'
                            if arg2 <= 0:
                                revert with 0, 'Must create at least one'
                            mem[0] = arg1
                            mem[32] = sha3(address(arg3), 202)
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            sub_2b1331a8[address(arg3)][arg1] += arg2
                            idx = 0
                            while idx < arg2:
                                if numMinted > -2:
                                    revert with 0, 17
                                numMinted++
                                _10185 = mem[64]
                                mem[64] = mem[64] + 32
                                mem[_10185] = 0
                                if not address(arg3):
                                    revert with 0, 'ERC721: mint to the zero address'
                                if ownerOf[stor203]:
                                    revert with 0, 'ERC721: token already minted'
                                if balanceOf[address(arg3)] > -2:
                                    revert with 0, 17
                                balanceOf[address(arg3)]++
                                mem[0] = numMinted
                                mem[32] = 103
                                ownerOf[stor203] = address(arg3)
                                emit Transfer(0, address(arg3), numMinted);
                                if not ext_code.size(address(arg3)):
                                    _11821 = mem[64]
                                    mem[64] = mem[64] + 128
                                    mem[_11821] = arg1
                                    mem[_11821 + 32] = 1000
                                    mem[_11821 + 64] = block.timestamp
                                    if 720 * 24 * 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[_11821 + 96] = block.timestamp + (720 * 24 * 3600)
                                else:
                                    mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = 0
                                    mem[mem[64] + 68] = numMinted
                                    mem[mem[64] + 100] = 128
                                    mem[mem[64] + 132] = 0
                                    s = 0
                                    while s < 0:
                                        mem[s + mem[64] + 164] = mem[s + _10185 + 32]
                                        s = s + 32
                                        continue 
                                    require ext_code.size(address(arg3))
                                    call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args msg.sender, 0, numMinted, 128, 0
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        if not return_data.size:
                                            if not mem[96]:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        if not return_data.size:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _19623 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_19623] == Mask(32, 224, mem[_19623])
                                    if Mask(32, 224, mem[_19623]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    _21798 = mem[64]
                                    mem[64] = mem[64] + 128
                                    mem[_21798] = arg1
                                    mem[_21798 + 32] = 1000
                                    mem[_21798 + 64] = block.timestamp
                                    if 720 * 24 * 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[_21798 + 96] = block.timestamp + (720 * 24 * 3600)
                                mem[0] = numMinted
                                mem[32] = 201
                                sub_79ba2fa2[stor203].field_0 = arg1
                                sub_79ba2fa2[stor203].field_256 = 1000
                                sub_79ba2fa2[stor203].field_512 = block.timestamp
                                sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            if 31 >= sub_be75288d[arg1].field_1793:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * sub_be75288d[arg1].field_1800
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _10186 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_10186] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _11822 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_11822] = arg1
                                        mem[_11822 + 32] = 1000
                                        mem[_11822 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_11822 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _10186 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _19625 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_19625] == Mask(32, 224, mem[_19625])
                                        if Mask(32, 224, mem[_19625]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _21803 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_21803] = arg1
                                        mem[_21803 + 32] = 1000
                                        mem[_21803 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_21803 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                s = 0
                                while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + sub_be75288d[arg1].field_1793 + 384 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _19436 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_19436] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _22878 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_22878] = arg1
                                        mem[_22878 + 32] = 1000
                                        mem[_22878 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_22878 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _19436 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _26929 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_26929] == Mask(32, 224, mem[_26929])
                                        if Mask(32, 224, mem[_26929]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _28599 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_28599] = arg1
                                        mem[_28599 + 32] = 1000
                                        mem[_28599 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_28599 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
            else:
                if 31 >= uint255(sub_be75288d[arg1].field_0) * 0.5:
                    mem[384] = 256 * sub_be75288d[arg1].field_8
                    mem[96] = 352
                    mem[128] = sub_be75288d[arg1].field_256
                    mem[160] = sub_be75288d[arg1].field_512
                    mem[192] = sub_be75288d[arg1].field_768
                    mem[224] = sub_be75288d[arg1].field_1024
                    mem[256] = sub_be75288d[arg1].field_1280
                    mem[288] = sub_be75288d[arg1].field_1536
                    if sub_be75288d[arg1].field_1792:
                        if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416
                        mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                        if sub_be75288d[arg1].field_1792:
                            if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _10187 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_10187] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _11824 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_11824] = arg1
                                        mem[_11824 + 32] = 1000
                                        mem[_11824 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_11824 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _10187 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _19631 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_19631] == Mask(32, 224, mem[_19631])
                                        if Mask(32, 224, mem[_19631]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _21823 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_21823] = arg1
                                        mem[_21823 + 32] = 1000
                                        mem[_21823 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_21823 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * sub_be75288d[arg1].field_1800
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _10188 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_10188] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _11825 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_11825] = arg1
                                            mem[_11825 + 32] = 1000
                                            mem[_11825 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_11825 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _10188 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _19633 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_19633] == Mask(32, 224, mem[_19633])
                                            if Mask(32, 224, mem[_19633]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _21828 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_21828] = arg1
                                            mem[_21828 + 32] = 1000
                                            mem[_21828 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_21828 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                    s = 0
                                    while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _19449 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_19449] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _22887 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_22887] = arg1
                                            mem[_22887 + 32] = 1000
                                            mem[_22887 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_22887 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _19449 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _26947 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_26947] == Mask(32, 224, mem[_26947])
                                            if Mask(32, 224, mem[_26947]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _28639 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_28639] = arg1
                                            mem[_28639 + 32] = 1000
                                            mem[_28639 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_28639 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                        else:
                            if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                                revert with 0, 34
                            if not sub_be75288d[arg1].field_1793:
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _10189 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_10189] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _11826 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_11826] = arg1
                                        mem[_11826 + 32] = 1000
                                        mem[_11826 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_11826 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _10189 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _19635 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_19635] == Mask(32, 224, mem[_19635])
                                        if Mask(32, 224, mem[_19635]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _21832 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_21832] = arg1
                                        mem[_21832 + 32] = 1000
                                        mem[_21832 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_21832 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= sub_be75288d[arg1].field_1793:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * sub_be75288d[arg1].field_1800
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _10190 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_10190] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _11827 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_11827] = arg1
                                            mem[_11827 + 32] = 1000
                                            mem[_11827 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_11827 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _10190 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _19637 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_19637] == Mask(32, 224, mem[_19637])
                                            if Mask(32, 224, mem[_19637]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _21837 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_21837] = arg1
                                            mem[_21837 + 32] = 1000
                                            mem[_21837 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_21837 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                    s = 0
                                    while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + sub_be75288d[arg1].field_1793 + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _19454 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_19454] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _22888 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_22888] = arg1
                                            mem[_22888 + 32] = 1000
                                            mem[_22888 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_22888 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _19454 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _26949 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_26949] == Mask(32, 224, mem[_26949])
                                            if Mask(32, 224, mem[_26949]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _28643 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_28643] = arg1
                                            mem[_28643 + 32] = 1000
                                            mem[_28643 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_28643 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                    else:
                        if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                            revert with 0, 34
                        mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793) + 416
                        mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384] = sub_be75288d[arg1].field_1793
                        if sub_be75288d[arg1].field_1792:
                            if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _10191 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_10191] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _11828 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_11828] = arg1
                                        mem[_11828 + 32] = 1000
                                        mem[_11828 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_11828 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _10191 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _19639 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_19639] == Mask(32, 224, mem[_19639])
                                        if Mask(32, 224, mem[_19639]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _21841 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_21841] = arg1
                                        mem[_21841 + 32] = 1000
                                        mem[_21841 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_21841 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * sub_be75288d[arg1].field_1800
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _10192 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_10192] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _11829 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_11829] = arg1
                                            mem[_11829 + 32] = 1000
                                            mem[_11829 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_11829 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _10192 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _19641 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_19641] == Mask(32, 224, mem[_19641])
                                            if Mask(32, 224, mem[_19641]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _21846 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_21846] = arg1
                                            mem[_21846 + 32] = 1000
                                            mem[_21846 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_21846 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                    s = 0
                                    while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _19459 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_19459] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _22889 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_22889] = arg1
                                            mem[_22889 + 32] = 1000
                                            mem[_22889 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_22889 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _19459 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _26951 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_26951] == Mask(32, 224, mem[_26951])
                                            if Mask(32, 224, mem[_26951]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _28647 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_28647] = arg1
                                            mem[_28647 + 32] = 1000
                                            mem[_28647 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_28647 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                        else:
                            if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                                revert with 0, 34
                            if not sub_be75288d[arg1].field_1793:
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _10193 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_10193] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _11830 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_11830] = arg1
                                        mem[_11830 + 32] = 1000
                                        mem[_11830 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_11830 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _10193 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _19643 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_19643] == Mask(32, 224, mem[_19643])
                                        if Mask(32, 224, mem[_19643]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _21850 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_21850] = arg1
                                        mem[_21850 + 32] = 1000
                                        mem[_21850 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_21850 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= sub_be75288d[arg1].field_1793:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * sub_be75288d[arg1].field_1800
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _10194 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_10194] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _11831 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_11831] = arg1
                                            mem[_11831 + 32] = 1000
                                            mem[_11831 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_11831 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _10194 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _19645 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_19645] == Mask(32, 224, mem[_19645])
                                            if Mask(32, 224, mem[_19645]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _21855 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_21855] = arg1
                                            mem[_21855 + 32] = 1000
                                            mem[_21855 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_21855 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                    s = 0
                                    while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + sub_be75288d[arg1].field_1793 + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _19464 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_19464] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _22890 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_22890] = arg1
                                            mem[_22890 + 32] = 1000
                                            mem[_22890 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_22890 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _19464 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _26953 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_26953] == Mask(32, 224, mem[_26953])
                                            if Mask(32, 224, mem[_26953]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _28651 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_28651] = arg1
                                            mem[_28651 + 32] = 1000
                                            mem[_28651 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_28651 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                else:
                    mem[384] = sub_be75288d[arg1].field_0
                    idx = 384
                    s = 0
                    while (uint255(sub_be75288d[arg1].field_0) * 0.5) + 352 > idx:
                        mem[idx + 32] = sub_be75288d[arg1][s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    mem[96] = 352
                    mem[128] = sub_be75288d[arg1].field_256
                    mem[160] = sub_be75288d[arg1].field_512
                    mem[192] = sub_be75288d[arg1].field_768
                    mem[224] = sub_be75288d[arg1].field_1024
                    mem[256] = sub_be75288d[arg1].field_1280
                    mem[288] = sub_be75288d[arg1].field_1536
                    if sub_be75288d[arg1].field_1792:
                        if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416
                        mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                        if sub_be75288d[arg1].field_1792:
                            if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _19439 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_19439] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _22879 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_22879] = arg1
                                        mem[_22879 + 32] = 1000
                                        mem[_22879 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_22879 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _19439 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _26931 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_26931] == Mask(32, 224, mem[_26931])
                                        if Mask(32, 224, mem[_26931]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _28603 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_28603] = arg1
                                        mem[_28603 + 32] = 1000
                                        mem[_28603 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_28603 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * sub_be75288d[arg1].field_1800
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _19440 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_19440] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _22880 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_22880] = arg1
                                            mem[_22880 + 32] = 1000
                                            mem[_22880 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_22880 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _19440 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _26933 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_26933] == Mask(32, 224, mem[_26933])
                                            if Mask(32, 224, mem[_26933]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _28608 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_28608] = arg1
                                            mem[_28608 + 32] = 1000
                                            mem[_28608 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_28608 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                    s = 0
                                    while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _26789 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_26789] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _29515 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_29515] = arg1
                                            mem[_29515 + 32] = 1000
                                            mem[_29515 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_29515 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _26789 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _30315 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_30315] == Mask(32, 224, mem[_30315])
                                            if Mask(32, 224, mem[_30315]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _30699 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_30699] = arg1
                                            mem[_30699 + 32] = 1000
                                            mem[_30699 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_30699 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                        else:
                            if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                                revert with 0, 34
                            if not sub_be75288d[arg1].field_1793:
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _19441 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_19441] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _22881 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_22881] = arg1
                                        mem[_22881 + 32] = 1000
                                        mem[_22881 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_22881 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _19441 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _26935 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_26935] == Mask(32, 224, mem[_26935])
                                        if Mask(32, 224, mem[_26935]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _28612 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_28612] = arg1
                                        mem[_28612 + 32] = 1000
                                        mem[_28612 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_28612 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= sub_be75288d[arg1].field_1793:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * sub_be75288d[arg1].field_1800
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _19442 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_19442] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _22882 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_22882] = arg1
                                            mem[_22882 + 32] = 1000
                                            mem[_22882 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_22882 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _19442 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _26937 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_26937] == Mask(32, 224, mem[_26937])
                                            if Mask(32, 224, mem[_26937]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _28617 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_28617] = arg1
                                            mem[_28617 + 32] = 1000
                                            mem[_28617 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_28617 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                    s = 0
                                    while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + sub_be75288d[arg1].field_1793 + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _26794 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_26794] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _29516 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_29516] = arg1
                                            mem[_29516 + 32] = 1000
                                            mem[_29516 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_29516 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _26794 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _30317 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_30317] == Mask(32, 224, mem[_30317])
                                            if Mask(32, 224, mem[_30317]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _30703 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_30703] = arg1
                                            mem[_30703 + 32] = 1000
                                            mem[_30703 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_30703 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                    else:
                        if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                            revert with 0, 34
                        mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793) + 416
                        mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384] = sub_be75288d[arg1].field_1793
                        if sub_be75288d[arg1].field_1792:
                            if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _19443 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_19443] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _22883 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_22883] = arg1
                                        mem[_22883 + 32] = 1000
                                        mem[_22883 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_22883 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _19443 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _26939 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_26939] == Mask(32, 224, mem[_26939])
                                        if Mask(32, 224, mem[_26939]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _28621 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_28621] = arg1
                                        mem[_28621 + 32] = 1000
                                        mem[_28621 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_28621 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * sub_be75288d[arg1].field_1800
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _19444 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_19444] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _22884 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_22884] = arg1
                                            mem[_22884 + 32] = 1000
                                            mem[_22884 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_22884 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _19444 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _26941 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_26941] == Mask(32, 224, mem[_26941])
                                            if Mask(32, 224, mem[_26941]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _28626 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_28626] = arg1
                                            mem[_28626 + 32] = 1000
                                            mem[_28626 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_28626 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                    s = 0
                                    while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _26799 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_26799] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _29517 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_29517] = arg1
                                            mem[_29517 + 32] = 1000
                                            mem[_29517 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_29517 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _26799 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _30319 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_30319] == Mask(32, 224, mem[_30319])
                                            if Mask(32, 224, mem[_30319]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _30707 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_30707] = arg1
                                            mem[_30707 + 32] = 1000
                                            mem[_30707 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_30707 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                        else:
                            if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                                revert with 0, 34
                            if not sub_be75288d[arg1].field_1793:
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _19445 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_19445] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _22885 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_22885] = arg1
                                        mem[_22885 + 32] = 1000
                                        mem[_22885 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_22885 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _19445 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _26943 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_26943] == Mask(32, 224, mem[_26943])
                                        if Mask(32, 224, mem[_26943]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _28630 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_28630] = arg1
                                        mem[_28630 + 32] = 1000
                                        mem[_28630 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_28630 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= sub_be75288d[arg1].field_1793:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * sub_be75288d[arg1].field_1800
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _19446 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_19446] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _22886 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_22886] = arg1
                                            mem[_22886 + 32] = 1000
                                            mem[_22886 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_22886 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _19446 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _26945 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_26945] == Mask(32, 224, mem[_26945])
                                            if Mask(32, 224, mem[_26945]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _28635 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_28635] = arg1
                                            mem[_28635 + 32] = 1000
                                            mem[_28635 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_28635 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                    s = 0
                                    while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + sub_be75288d[arg1].field_1793 + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _26804 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_26804] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _29518 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_29518] = arg1
                                            mem[_29518 + 32] = 1000
                                            mem[_29518 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_29518 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _26804 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _30321 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_30321] == Mask(32, 224, mem[_30321])
                                            if Mask(32, 224, mem[_30321]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _30711 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_30711] = arg1
                                            mem[_30711 + 32] = 1000
                                            mem[_30711 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_30711 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
        else:
            if sub_be75288d[arg1].field_0 == sub_be75288d[arg1].field_1 < 32:
                revert with 0, 34
            if not sub_be75288d[arg1].field_1:
                mem[96] = 352
                mem[128] = sub_be75288d[arg1].field_256
                mem[160] = sub_be75288d[arg1].field_512
                mem[192] = sub_be75288d[arg1].field_768
                mem[224] = sub_be75288d[arg1].field_1024
                mem[256] = sub_be75288d[arg1].field_1280
                mem[288] = sub_be75288d[arg1].field_1536
                if sub_be75288d[arg1].field_1792:
                    if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                        revert with 0, 34
                    mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416
                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                    if sub_be75288d[arg1].field_1792:
                        if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                            mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                            if arg1 >= 4:
                                revert with 0, 'Invalid tier'
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                revert with 0, 'Too many nodes of this tier'
                            if arg2 <= 0:
                                revert with 0, 'Must create at least one'
                            mem[0] = arg1
                            mem[32] = sha3(address(arg3), 202)
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            sub_2b1331a8[address(arg3)][arg1] += arg2
                            idx = 0
                            while idx < arg2:
                                if numMinted > -2:
                                    revert with 0, 17
                                numMinted++
                                _10195 = mem[64]
                                mem[64] = mem[64] + 32
                                mem[_10195] = 0
                                if not address(arg3):
                                    revert with 0, 'ERC721: mint to the zero address'
                                if ownerOf[stor203]:
                                    revert with 0, 'ERC721: token already minted'
                                if balanceOf[address(arg3)] > -2:
                                    revert with 0, 17
                                balanceOf[address(arg3)]++
                                mem[0] = numMinted
                                mem[32] = 103
                                ownerOf[stor203] = address(arg3)
                                emit Transfer(0, address(arg3), numMinted);
                                if not ext_code.size(address(arg3)):
                                    _11832 = mem[64]
                                    mem[64] = mem[64] + 128
                                    mem[_11832] = arg1
                                    mem[_11832 + 32] = 1000
                                    mem[_11832 + 64] = block.timestamp
                                    if 720 * 24 * 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[_11832 + 96] = block.timestamp + (720 * 24 * 3600)
                                else:
                                    mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = 0
                                    mem[mem[64] + 68] = numMinted
                                    mem[mem[64] + 100] = 128
                                    mem[mem[64] + 132] = 0
                                    s = 0
                                    while s < 0:
                                        mem[s + mem[64] + 164] = mem[s + _10195 + 32]
                                        s = s + 32
                                        continue 
                                    require ext_code.size(address(arg3))
                                    call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args msg.sender, 0, numMinted, 128, 0
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        if not return_data.size:
                                            if not mem[96]:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        if not return_data.size:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _19647 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_19647] == Mask(32, 224, mem[_19647])
                                    if Mask(32, 224, mem[_19647]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    _21859 = mem[64]
                                    mem[64] = mem[64] + 128
                                    mem[_21859] = arg1
                                    mem[_21859 + 32] = 1000
                                    mem[_21859 + 64] = block.timestamp
                                    if 720 * 24 * 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[_21859 + 96] = block.timestamp + (720 * 24 * 3600)
                                mem[0] = numMinted
                                mem[32] = 201
                                sub_79ba2fa2[stor203].field_0 = arg1
                                sub_79ba2fa2[stor203].field_256 = 1000
                                sub_79ba2fa2[stor203].field_512 = block.timestamp
                                sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * sub_be75288d[arg1].field_1800
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _10196 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_10196] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _11833 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_11833] = arg1
                                        mem[_11833 + 32] = 1000
                                        mem[_11833 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_11833 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _10196 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _19649 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_19649] == Mask(32, 224, mem[_19649])
                                        if Mask(32, 224, mem[_19649]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _21864 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_21864] = arg1
                                        mem[_21864 + 32] = 1000
                                        mem[_21864 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_21864 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                s = 0
                                while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _19469 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_19469] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _22891 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_22891] = arg1
                                        mem[_22891 + 32] = 1000
                                        mem[_22891 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_22891 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _19469 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _26955 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_26955] == Mask(32, 224, mem[_26955])
                                        if Mask(32, 224, mem[_26955]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _28655 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_28655] = arg1
                                        mem[_28655 + 32] = 1000
                                        mem[_28655 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_28655 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                    else:
                        if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                            revert with 0, 34
                        if not sub_be75288d[arg1].field_1793:
                            mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                            if arg1 >= 4:
                                revert with 0, 'Invalid tier'
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                revert with 0, 'Too many nodes of this tier'
                            if arg2 <= 0:
                                revert with 0, 'Must create at least one'
                            mem[0] = arg1
                            mem[32] = sha3(address(arg3), 202)
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            sub_2b1331a8[address(arg3)][arg1] += arg2
                            idx = 0
                            while idx < arg2:
                                if numMinted > -2:
                                    revert with 0, 17
                                numMinted++
                                _10197 = mem[64]
                                mem[64] = mem[64] + 32
                                mem[_10197] = 0
                                if not address(arg3):
                                    revert with 0, 'ERC721: mint to the zero address'
                                if ownerOf[stor203]:
                                    revert with 0, 'ERC721: token already minted'
                                if balanceOf[address(arg3)] > -2:
                                    revert with 0, 17
                                balanceOf[address(arg3)]++
                                mem[0] = numMinted
                                mem[32] = 103
                                ownerOf[stor203] = address(arg3)
                                emit Transfer(0, address(arg3), numMinted);
                                if not ext_code.size(address(arg3)):
                                    _11834 = mem[64]
                                    mem[64] = mem[64] + 128
                                    mem[_11834] = arg1
                                    mem[_11834 + 32] = 1000
                                    mem[_11834 + 64] = block.timestamp
                                    if 720 * 24 * 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[_11834 + 96] = block.timestamp + (720 * 24 * 3600)
                                else:
                                    mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = 0
                                    mem[mem[64] + 68] = numMinted
                                    mem[mem[64] + 100] = 128
                                    mem[mem[64] + 132] = 0
                                    s = 0
                                    while s < 0:
                                        mem[s + mem[64] + 164] = mem[s + _10197 + 32]
                                        s = s + 32
                                        continue 
                                    require ext_code.size(address(arg3))
                                    call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args msg.sender, 0, numMinted, 128, 0
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        if not return_data.size:
                                            if not mem[96]:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        if not return_data.size:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _19651 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_19651] == Mask(32, 224, mem[_19651])
                                    if Mask(32, 224, mem[_19651]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    _21868 = mem[64]
                                    mem[64] = mem[64] + 128
                                    mem[_21868] = arg1
                                    mem[_21868 + 32] = 1000
                                    mem[_21868 + 64] = block.timestamp
                                    if 720 * 24 * 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[_21868 + 96] = block.timestamp + (720 * 24 * 3600)
                                mem[0] = numMinted
                                mem[32] = 201
                                sub_79ba2fa2[stor203].field_0 = arg1
                                sub_79ba2fa2[stor203].field_256 = 1000
                                sub_79ba2fa2[stor203].field_512 = block.timestamp
                                sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            if 31 >= sub_be75288d[arg1].field_1793:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * sub_be75288d[arg1].field_1800
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _10198 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_10198] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _11835 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_11835] = arg1
                                        mem[_11835 + 32] = 1000
                                        mem[_11835 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_11835 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _10198 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _19653 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_19653] == Mask(32, 224, mem[_19653])
                                        if Mask(32, 224, mem[_19653]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _21873 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_21873] = arg1
                                        mem[_21873 + 32] = 1000
                                        mem[_21873 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_21873 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                s = 0
                                while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + sub_be75288d[arg1].field_1793 + 384 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _19474 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_19474] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _22892 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_22892] = arg1
                                        mem[_22892 + 32] = 1000
                                        mem[_22892 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_22892 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _19474 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _26957 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_26957] == Mask(32, 224, mem[_26957])
                                        if Mask(32, 224, mem[_26957]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _28659 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_28659] = arg1
                                        mem[_28659 + 32] = 1000
                                        mem[_28659 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_28659 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                else:
                    if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                        revert with 0, 34
                    mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793) + 416
                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384] = sub_be75288d[arg1].field_1793
                    if sub_be75288d[arg1].field_1792:
                        if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                            mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                            if arg1 >= 4:
                                revert with 0, 'Invalid tier'
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                revert with 0, 'Too many nodes of this tier'
                            if arg2 <= 0:
                                revert with 0, 'Must create at least one'
                            mem[0] = arg1
                            mem[32] = sha3(address(arg3), 202)
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            sub_2b1331a8[address(arg3)][arg1] += arg2
                            idx = 0
                            while idx < arg2:
                                if numMinted > -2:
                                    revert with 0, 17
                                numMinted++
                                _10199 = mem[64]
                                mem[64] = mem[64] + 32
                                mem[_10199] = 0
                                if not address(arg3):
                                    revert with 0, 'ERC721: mint to the zero address'
                                if ownerOf[stor203]:
                                    revert with 0, 'ERC721: token already minted'
                                if balanceOf[address(arg3)] > -2:
                                    revert with 0, 17
                                balanceOf[address(arg3)]++
                                mem[0] = numMinted
                                mem[32] = 103
                                ownerOf[stor203] = address(arg3)
                                emit Transfer(0, address(arg3), numMinted);
                                if not ext_code.size(address(arg3)):
                                    _11836 = mem[64]
                                    mem[64] = mem[64] + 128
                                    mem[_11836] = arg1
                                    mem[_11836 + 32] = 1000
                                    mem[_11836 + 64] = block.timestamp
                                    if 720 * 24 * 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[_11836 + 96] = block.timestamp + (720 * 24 * 3600)
                                else:
                                    mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = 0
                                    mem[mem[64] + 68] = numMinted
                                    mem[mem[64] + 100] = 128
                                    mem[mem[64] + 132] = 0
                                    s = 0
                                    while s < 0:
                                        mem[s + mem[64] + 164] = mem[s + _10199 + 32]
                                        s = s + 32
                                        continue 
                                    require ext_code.size(address(arg3))
                                    call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args msg.sender, 0, numMinted, 128, 0
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        if not return_data.size:
                                            if not mem[96]:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        if not return_data.size:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _19655 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_19655] == Mask(32, 224, mem[_19655])
                                    if Mask(32, 224, mem[_19655]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    _21877 = mem[64]
                                    mem[64] = mem[64] + 128
                                    mem[_21877] = arg1
                                    mem[_21877 + 32] = 1000
                                    mem[_21877 + 64] = block.timestamp
                                    if 720 * 24 * 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[_21877 + 96] = block.timestamp + (720 * 24 * 3600)
                                mem[0] = numMinted
                                mem[32] = 201
                                sub_79ba2fa2[stor203].field_0 = arg1
                                sub_79ba2fa2[stor203].field_256 = 1000
                                sub_79ba2fa2[stor203].field_512 = block.timestamp
                                sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * sub_be75288d[arg1].field_1800
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _10200 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_10200] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _11837 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_11837] = arg1
                                        mem[_11837 + 32] = 1000
                                        mem[_11837 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_11837 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _10200 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _19657 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_19657] == Mask(32, 224, mem[_19657])
                                        if Mask(32, 224, mem[_19657]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _21882 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_21882] = arg1
                                        mem[_21882 + 32] = 1000
                                        mem[_21882 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_21882 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                s = 0
                                while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _19479 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_19479] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _22893 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_22893] = arg1
                                        mem[_22893 + 32] = 1000
                                        mem[_22893 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_22893 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _19479 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _26959 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_26959] == Mask(32, 224, mem[_26959])
                                        if Mask(32, 224, mem[_26959]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _28663 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_28663] = arg1
                                        mem[_28663 + 32] = 1000
                                        mem[_28663 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_28663 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                    else:
                        if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                            revert with 0, 34
                        if not sub_be75288d[arg1].field_1793:
                            mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                            if arg1 >= 4:
                                revert with 0, 'Invalid tier'
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                revert with 0, 'Too many nodes of this tier'
                            if arg2 <= 0:
                                revert with 0, 'Must create at least one'
                            mem[0] = arg1
                            mem[32] = sha3(address(arg3), 202)
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            sub_2b1331a8[address(arg3)][arg1] += arg2
                            idx = 0
                            while idx < arg2:
                                if numMinted > -2:
                                    revert with 0, 17
                                numMinted++
                                _10201 = mem[64]
                                mem[64] = mem[64] + 32
                                mem[_10201] = 0
                                if not address(arg3):
                                    revert with 0, 'ERC721: mint to the zero address'
                                if ownerOf[stor203]:
                                    revert with 0, 'ERC721: token already minted'
                                if balanceOf[address(arg3)] > -2:
                                    revert with 0, 17
                                balanceOf[address(arg3)]++
                                mem[0] = numMinted
                                mem[32] = 103
                                ownerOf[stor203] = address(arg3)
                                emit Transfer(0, address(arg3), numMinted);
                                if not ext_code.size(address(arg3)):
                                    _11838 = mem[64]
                                    mem[64] = mem[64] + 128
                                    mem[_11838] = arg1
                                    mem[_11838 + 32] = 1000
                                    mem[_11838 + 64] = block.timestamp
                                    if 720 * 24 * 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[_11838 + 96] = block.timestamp + (720 * 24 * 3600)
                                else:
                                    mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = 0
                                    mem[mem[64] + 68] = numMinted
                                    mem[mem[64] + 100] = 128
                                    mem[mem[64] + 132] = 0
                                    s = 0
                                    while s < 0:
                                        mem[s + mem[64] + 164] = mem[s + _10201 + 32]
                                        s = s + 32
                                        continue 
                                    require ext_code.size(address(arg3))
                                    call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args msg.sender, 0, numMinted, 128, 0
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        if not return_data.size:
                                            if not mem[96]:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        if not return_data.size:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _19659 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_19659] == Mask(32, 224, mem[_19659])
                                    if Mask(32, 224, mem[_19659]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    _21886 = mem[64]
                                    mem[64] = mem[64] + 128
                                    mem[_21886] = arg1
                                    mem[_21886 + 32] = 1000
                                    mem[_21886 + 64] = block.timestamp
                                    if 720 * 24 * 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[_21886 + 96] = block.timestamp + (720 * 24 * 3600)
                                mem[0] = numMinted
                                mem[32] = 201
                                sub_79ba2fa2[stor203].field_0 = arg1
                                sub_79ba2fa2[stor203].field_256 = 1000
                                sub_79ba2fa2[stor203].field_512 = block.timestamp
                                sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            if 31 >= sub_be75288d[arg1].field_1793:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * sub_be75288d[arg1].field_1800
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _10202 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_10202] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _11839 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_11839] = arg1
                                        mem[_11839 + 32] = 1000
                                        mem[_11839 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_11839 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _10202 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _19661 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_19661] == Mask(32, 224, mem[_19661])
                                        if Mask(32, 224, mem[_19661]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _21891 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_21891] = arg1
                                        mem[_21891 + 32] = 1000
                                        mem[_21891 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_21891 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                s = 0
                                while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + sub_be75288d[arg1].field_1793 + 384 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _19484 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_19484] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _22894 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_22894] = arg1
                                        mem[_22894 + 32] = 1000
                                        mem[_22894 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_22894 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _19484 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _26961 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_26961] == Mask(32, 224, mem[_26961])
                                        if Mask(32, 224, mem[_26961]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _28667 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_28667] = arg1
                                        mem[_28667 + 32] = 1000
                                        mem[_28667 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_28667 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
            else:
                if 31 >= sub_be75288d[arg1].field_1:
                    mem[384] = 256 * sub_be75288d[arg1].field_8
                    mem[96] = 352
                    mem[128] = sub_be75288d[arg1].field_256
                    mem[160] = sub_be75288d[arg1].field_512
                    mem[192] = sub_be75288d[arg1].field_768
                    mem[224] = sub_be75288d[arg1].field_1024
                    mem[256] = sub_be75288d[arg1].field_1280
                    mem[288] = sub_be75288d[arg1].field_1536
                    if sub_be75288d[arg1].field_1792:
                        if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416
                        mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                        if sub_be75288d[arg1].field_1792:
                            if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _10203 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_10203] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _11841 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_11841] = arg1
                                        mem[_11841 + 32] = 1000
                                        mem[_11841 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_11841 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _10203 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _19667 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_19667] == Mask(32, 224, mem[_19667])
                                        if Mask(32, 224, mem[_19667]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _21911 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_21911] = arg1
                                        mem[_21911 + 32] = 1000
                                        mem[_21911 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_21911 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * sub_be75288d[arg1].field_1800
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _10204 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_10204] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _11842 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_11842] = arg1
                                            mem[_11842 + 32] = 1000
                                            mem[_11842 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_11842 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _10204 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _19669 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_19669] == Mask(32, 224, mem[_19669])
                                            if Mask(32, 224, mem[_19669]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _21916 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_21916] = arg1
                                            mem[_21916 + 32] = 1000
                                            mem[_21916 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_21916 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                    s = 0
                                    while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _19497 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_19497] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _22903 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_22903] = arg1
                                            mem[_22903 + 32] = 1000
                                            mem[_22903 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_22903 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _19497 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _26979 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_26979] == Mask(32, 224, mem[_26979])
                                            if Mask(32, 224, mem[_26979]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _28707 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_28707] = arg1
                                            mem[_28707 + 32] = 1000
                                            mem[_28707 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_28707 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                        else:
                            if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                                revert with 0, 34
                            if not sub_be75288d[arg1].field_1793:
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _10205 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_10205] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _11843 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_11843] = arg1
                                        mem[_11843 + 32] = 1000
                                        mem[_11843 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_11843 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _10205 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _19671 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_19671] == Mask(32, 224, mem[_19671])
                                        if Mask(32, 224, mem[_19671]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _21920 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_21920] = arg1
                                        mem[_21920 + 32] = 1000
                                        mem[_21920 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_21920 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= sub_be75288d[arg1].field_1793:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * sub_be75288d[arg1].field_1800
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _10206 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_10206] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _11844 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_11844] = arg1
                                            mem[_11844 + 32] = 1000
                                            mem[_11844 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_11844 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _10206 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _19673 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_19673] == Mask(32, 224, mem[_19673])
                                            if Mask(32, 224, mem[_19673]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _21925 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_21925] = arg1
                                            mem[_21925 + 32] = 1000
                                            mem[_21925 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_21925 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                    s = 0
                                    while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + sub_be75288d[arg1].field_1793 + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _19502 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_19502] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _22904 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_22904] = arg1
                                            mem[_22904 + 32] = 1000
                                            mem[_22904 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_22904 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _19502 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _26981 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_26981] == Mask(32, 224, mem[_26981])
                                            if Mask(32, 224, mem[_26981]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _28711 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_28711] = arg1
                                            mem[_28711 + 32] = 1000
                                            mem[_28711 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_28711 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                    else:
                        if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                            revert with 0, 34
                        mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793) + 416
                        mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384] = sub_be75288d[arg1].field_1793
                        if sub_be75288d[arg1].field_1792:
                            if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _10207 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_10207] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _11845 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_11845] = arg1
                                        mem[_11845 + 32] = 1000
                                        mem[_11845 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_11845 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _10207 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _19675 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_19675] == Mask(32, 224, mem[_19675])
                                        if Mask(32, 224, mem[_19675]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _21929 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_21929] = arg1
                                        mem[_21929 + 32] = 1000
                                        mem[_21929 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_21929 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * sub_be75288d[arg1].field_1800
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _10208 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_10208] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _11846 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_11846] = arg1
                                            mem[_11846 + 32] = 1000
                                            mem[_11846 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_11846 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _10208 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _19677 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_19677] == Mask(32, 224, mem[_19677])
                                            if Mask(32, 224, mem[_19677]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _21934 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_21934] = arg1
                                            mem[_21934 + 32] = 1000
                                            mem[_21934 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_21934 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                    s = 0
                                    while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _19507 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_19507] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _22905 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_22905] = arg1
                                            mem[_22905 + 32] = 1000
                                            mem[_22905 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_22905 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _19507 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _26983 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_26983] == Mask(32, 224, mem[_26983])
                                            if Mask(32, 224, mem[_26983]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _28715 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_28715] = arg1
                                            mem[_28715 + 32] = 1000
                                            mem[_28715 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_28715 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                        else:
                            if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                                revert with 0, 34
                            if not sub_be75288d[arg1].field_1793:
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _10209 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_10209] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _11847 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_11847] = arg1
                                        mem[_11847 + 32] = 1000
                                        mem[_11847 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_11847 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _10209 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _19679 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_19679] == Mask(32, 224, mem[_19679])
                                        if Mask(32, 224, mem[_19679]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _21938 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_21938] = arg1
                                        mem[_21938 + 32] = 1000
                                        mem[_21938 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_21938 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= sub_be75288d[arg1].field_1793:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * sub_be75288d[arg1].field_1800
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _10210 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_10210] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _11848 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_11848] = arg1
                                            mem[_11848 + 32] = 1000
                                            mem[_11848 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_11848 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _10210 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _19681 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_19681] == Mask(32, 224, mem[_19681])
                                            if Mask(32, 224, mem[_19681]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _21943 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_21943] = arg1
                                            mem[_21943 + 32] = 1000
                                            mem[_21943 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_21943 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                    s = 0
                                    while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + sub_be75288d[arg1].field_1793 + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _19512 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_19512] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _22906 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_22906] = arg1
                                            mem[_22906 + 32] = 1000
                                            mem[_22906 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_22906 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _19512 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _26985 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_26985] == Mask(32, 224, mem[_26985])
                                            if Mask(32, 224, mem[_26985]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _28719 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_28719] = arg1
                                            mem[_28719 + 32] = 1000
                                            mem[_28719 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_28719 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                else:
                    mem[384] = sub_be75288d[arg1].field_0
                    idx = 384
                    s = 0
                    while sub_be75288d[arg1].field_1 + 352 > idx:
                        mem[idx + 32] = sub_be75288d[arg1][s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    mem[96] = 352
                    mem[128] = sub_be75288d[arg1].field_256
                    mem[160] = sub_be75288d[arg1].field_512
                    mem[192] = sub_be75288d[arg1].field_768
                    mem[224] = sub_be75288d[arg1].field_1024
                    mem[256] = sub_be75288d[arg1].field_1280
                    mem[288] = sub_be75288d[arg1].field_1536
                    if sub_be75288d[arg1].field_1792:
                        if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416
                        mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                        if sub_be75288d[arg1].field_1792:
                            if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _19487 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_19487] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _22895 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_22895] = arg1
                                        mem[_22895 + 32] = 1000
                                        mem[_22895 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_22895 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _19487 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _26963 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_26963] == Mask(32, 224, mem[_26963])
                                        if Mask(32, 224, mem[_26963]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _28671 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_28671] = arg1
                                        mem[_28671 + 32] = 1000
                                        mem[_28671 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_28671 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * sub_be75288d[arg1].field_1800
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _19488 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_19488] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _22896 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_22896] = arg1
                                            mem[_22896 + 32] = 1000
                                            mem[_22896 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_22896 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _19488 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _26965 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_26965] == Mask(32, 224, mem[_26965])
                                            if Mask(32, 224, mem[_26965]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _28676 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_28676] = arg1
                                            mem[_28676 + 32] = 1000
                                            mem[_28676 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_28676 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                    s = 0
                                    while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _26825 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_26825] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _29519 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_29519] = arg1
                                            mem[_29519 + 32] = 1000
                                            mem[_29519 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_29519 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _26825 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _30323 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_30323] == Mask(32, 224, mem[_30323])
                                            if Mask(32, 224, mem[_30323]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _30715 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_30715] = arg1
                                            mem[_30715 + 32] = 1000
                                            mem[_30715 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_30715 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                        else:
                            if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                                revert with 0, 34
                            if not sub_be75288d[arg1].field_1793:
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _19489 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_19489] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _22897 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_22897] = arg1
                                        mem[_22897 + 32] = 1000
                                        mem[_22897 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_22897 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _19489 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _26967 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_26967] == Mask(32, 224, mem[_26967])
                                        if Mask(32, 224, mem[_26967]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _28680 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_28680] = arg1
                                        mem[_28680 + 32] = 1000
                                        mem[_28680 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_28680 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= sub_be75288d[arg1].field_1793:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * sub_be75288d[arg1].field_1800
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _19490 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_19490] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _22898 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_22898] = arg1
                                            mem[_22898 + 32] = 1000
                                            mem[_22898 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_22898 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _19490 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _26969 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_26969] == Mask(32, 224, mem[_26969])
                                            if Mask(32, 224, mem[_26969]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _28685 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_28685] = arg1
                                            mem[_28685 + 32] = 1000
                                            mem[_28685 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_28685 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                    s = 0
                                    while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + sub_be75288d[arg1].field_1793 + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _26830 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_26830] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _29520 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_29520] = arg1
                                            mem[_29520 + 32] = 1000
                                            mem[_29520 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_29520 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _26830 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _30325 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_30325] == Mask(32, 224, mem[_30325])
                                            if Mask(32, 224, mem[_30325]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _30719 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_30719] = arg1
                                            mem[_30719 + 32] = 1000
                                            mem[_30719 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_30719 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                    else:
                        if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                            revert with 0, 34
                        mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793) + 416
                        mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384] = sub_be75288d[arg1].field_1793
                        if sub_be75288d[arg1].field_1792:
                            if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _19491 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_19491] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _22899 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_22899] = arg1
                                        mem[_22899 + 32] = 1000
                                        mem[_22899 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_22899 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _19491 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _26971 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_26971] == Mask(32, 224, mem[_26971])
                                        if Mask(32, 224, mem[_26971]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _28689 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_28689] = arg1
                                        mem[_28689 + 32] = 1000
                                        mem[_28689 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_28689 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * sub_be75288d[arg1].field_1800
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _19492 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_19492] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _22900 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_22900] = arg1
                                            mem[_22900 + 32] = 1000
                                            mem[_22900 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_22900 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _19492 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _26973 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_26973] == Mask(32, 224, mem[_26973])
                                            if Mask(32, 224, mem[_26973]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _28694 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_28694] = arg1
                                            mem[_28694 + 32] = 1000
                                            mem[_28694 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_28694 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                    s = 0
                                    while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _26835 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_26835] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _29521 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_29521] = arg1
                                            mem[_29521 + 32] = 1000
                                            mem[_29521 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_29521 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _26835 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _30327 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_30327] == Mask(32, 224, mem[_30327])
                                            if Mask(32, 224, mem[_30327]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _30723 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_30723] = arg1
                                            mem[_30723 + 32] = 1000
                                            mem[_30723 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_30723 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                        else:
                            if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                                revert with 0, 34
                            if not sub_be75288d[arg1].field_1793:
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _19493 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_19493] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _22901 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_22901] = arg1
                                        mem[_22901 + 32] = 1000
                                        mem[_22901 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_22901 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _19493 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _26975 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_26975] == Mask(32, 224, mem[_26975])
                                        if Mask(32, 224, mem[_26975]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _28698 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_28698] = arg1
                                        mem[_28698 + 32] = 1000
                                        mem[_28698 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_28698 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= sub_be75288d[arg1].field_1793:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * sub_be75288d[arg1].field_1800
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _19494 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_19494] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _22902 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_22902] = arg1
                                            mem[_22902 + 32] = 1000
                                            mem[_22902 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_22902 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _19494 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _26977 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_26977] == Mask(32, 224, mem[_26977])
                                            if Mask(32, 224, mem[_26977]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _28703 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_28703] = arg1
                                            mem[_28703 + 32] = 1000
                                            mem[_28703 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_28703 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                    s = 0
                                    while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + sub_be75288d[arg1].field_1793 + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _26840 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_26840] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _29522 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_29522] = arg1
                                            mem[_29522 + 32] = 1000
                                            mem[_29522 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_29522 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _26840 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _30329 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_30329] == Mask(32, 224, mem[_30329])
                                            if Mask(32, 224, mem[_30329]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _30727 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_30727] = arg1
                                            mem[_30727 + 32] = 1000
                                            mem[_30727 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_30727 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
    else:
        if sub_be75288d[arg1].field_0 == sub_be75288d[arg1].field_1 < 32:
            revert with 0, 34
        mem[352] = sub_be75288d[arg1].field_1
        if sub_be75288d[arg1].field_0:
            if sub_be75288d[arg1].field_0 == uint255(sub_be75288d[arg1].field_0) * 0.5 < 32:
                revert with 0, 34
            if not Mask(256, -1, sub_be75288d[arg1].field_0):
                mem[96] = 352
                mem[128] = sub_be75288d[arg1].field_256
                mem[160] = sub_be75288d[arg1].field_512
                mem[192] = sub_be75288d[arg1].field_768
                mem[224] = sub_be75288d[arg1].field_1024
                mem[256] = sub_be75288d[arg1].field_1280
                mem[288] = sub_be75288d[arg1].field_1536
                if sub_be75288d[arg1].field_1792:
                    if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                        revert with 0, 34
                    mem[64] = ceil32(sub_be75288d[arg1].field_1) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416
                    mem[ceil32(sub_be75288d[arg1].field_1) + 384] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                    if sub_be75288d[arg1].field_1792:
                        if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                            mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                            if arg1 >= 4:
                                revert with 0, 'Invalid tier'
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                revert with 0, 'Too many nodes of this tier'
                            if arg2 <= 0:
                                revert with 0, 'Must create at least one'
                            mem[0] = arg1
                            mem[32] = sha3(address(arg3), 202)
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            sub_2b1331a8[address(arg3)][arg1] += arg2
                            idx = 0
                            while idx < arg2:
                                if numMinted > -2:
                                    revert with 0, 17
                                numMinted++
                                _10211 = mem[64]
                                mem[64] = mem[64] + 32
                                mem[_10211] = 0
                                if not address(arg3):
                                    revert with 0, 'ERC721: mint to the zero address'
                                if ownerOf[stor203]:
                                    revert with 0, 'ERC721: token already minted'
                                if balanceOf[address(arg3)] > -2:
                                    revert with 0, 17
                                balanceOf[address(arg3)]++
                                mem[0] = numMinted
                                mem[32] = 103
                                ownerOf[stor203] = address(arg3)
                                emit Transfer(0, address(arg3), numMinted);
                                if not ext_code.size(address(arg3)):
                                    _11849 = mem[64]
                                    mem[64] = mem[64] + 128
                                    mem[_11849] = arg1
                                    mem[_11849 + 32] = 1000
                                    mem[_11849 + 64] = block.timestamp
                                    if 720 * 24 * 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[_11849 + 96] = block.timestamp + (720 * 24 * 3600)
                                else:
                                    mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = 0
                                    mem[mem[64] + 68] = numMinted
                                    mem[mem[64] + 100] = 128
                                    mem[mem[64] + 132] = 0
                                    s = 0
                                    while s < 0:
                                        mem[s + mem[64] + 164] = mem[s + _10211 + 32]
                                        s = s + 32
                                        continue 
                                    require ext_code.size(address(arg3))
                                    call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args msg.sender, 0, numMinted, 128, 0
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        if not return_data.size:
                                            if not mem[96]:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        if not return_data.size:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _19683 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_19683] == Mask(32, 224, mem[_19683])
                                    if Mask(32, 224, mem[_19683]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    _21947 = mem[64]
                                    mem[64] = mem[64] + 128
                                    mem[_21947] = arg1
                                    mem[_21947 + 32] = 1000
                                    mem[_21947 + 64] = block.timestamp
                                    if 720 * 24 * 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[_21947 + 96] = block.timestamp + (720 * 24 * 3600)
                                mem[0] = numMinted
                                mem[32] = 201
                                sub_79ba2fa2[stor203].field_0 = arg1
                                sub_79ba2fa2[stor203].field_256 = 1000
                                sub_79ba2fa2[stor203].field_512 = block.timestamp
                                sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[ceil32(sub_be75288d[arg1].field_1) + 416] = 256 * sub_be75288d[arg1].field_1800
                                mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _10212 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_10212] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _11850 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_11850] = arg1
                                        mem[_11850 + 32] = 1000
                                        mem[_11850 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_11850 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _10212 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _19685 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_19685] == Mask(32, 224, mem[_19685])
                                        if Mask(32, 224, mem[_19685]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _21952 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_21952] = arg1
                                        mem[_21952 + 32] = 1000
                                        mem[_21952 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_21952 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[ceil32(sub_be75288d[arg1].field_1) + 416] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(sub_be75288d[arg1].field_1) + 416
                                s = 0
                                while ceil32(sub_be75288d[arg1].field_1) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _19517 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_19517] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _22907 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_22907] = arg1
                                        mem[_22907 + 32] = 1000
                                        mem[_22907 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_22907 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _19517 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _26987 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_26987] == Mask(32, 224, mem[_26987])
                                        if Mask(32, 224, mem[_26987]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _28723 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_28723] = arg1
                                        mem[_28723 + 32] = 1000
                                        mem[_28723 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_28723 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                    else:
                        if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                            revert with 0, 34
                        if not sub_be75288d[arg1].field_1793:
                            mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                            if arg1 >= 4:
                                revert with 0, 'Invalid tier'
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                revert with 0, 'Too many nodes of this tier'
                            if arg2 <= 0:
                                revert with 0, 'Must create at least one'
                            mem[0] = arg1
                            mem[32] = sha3(address(arg3), 202)
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            sub_2b1331a8[address(arg3)][arg1] += arg2
                            idx = 0
                            while idx < arg2:
                                if numMinted > -2:
                                    revert with 0, 17
                                numMinted++
                                _10213 = mem[64]
                                mem[64] = mem[64] + 32
                                mem[_10213] = 0
                                if not address(arg3):
                                    revert with 0, 'ERC721: mint to the zero address'
                                if ownerOf[stor203]:
                                    revert with 0, 'ERC721: token already minted'
                                if balanceOf[address(arg3)] > -2:
                                    revert with 0, 17
                                balanceOf[address(arg3)]++
                                mem[0] = numMinted
                                mem[32] = 103
                                ownerOf[stor203] = address(arg3)
                                emit Transfer(0, address(arg3), numMinted);
                                if not ext_code.size(address(arg3)):
                                    _11851 = mem[64]
                                    mem[64] = mem[64] + 128
                                    mem[_11851] = arg1
                                    mem[_11851 + 32] = 1000
                                    mem[_11851 + 64] = block.timestamp
                                    if 720 * 24 * 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[_11851 + 96] = block.timestamp + (720 * 24 * 3600)
                                else:
                                    mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = 0
                                    mem[mem[64] + 68] = numMinted
                                    mem[mem[64] + 100] = 128
                                    mem[mem[64] + 132] = 0
                                    s = 0
                                    while s < 0:
                                        mem[s + mem[64] + 164] = mem[s + _10213 + 32]
                                        s = s + 32
                                        continue 
                                    require ext_code.size(address(arg3))
                                    call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args msg.sender, 0, numMinted, 128, 0
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        if not return_data.size:
                                            if not mem[96]:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        if not return_data.size:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _19687 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_19687] == Mask(32, 224, mem[_19687])
                                    if Mask(32, 224, mem[_19687]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    _21956 = mem[64]
                                    mem[64] = mem[64] + 128
                                    mem[_21956] = arg1
                                    mem[_21956 + 32] = 1000
                                    mem[_21956 + 64] = block.timestamp
                                    if 720 * 24 * 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[_21956 + 96] = block.timestamp + (720 * 24 * 3600)
                                mem[0] = numMinted
                                mem[32] = 201
                                sub_79ba2fa2[stor203].field_0 = arg1
                                sub_79ba2fa2[stor203].field_256 = 1000
                                sub_79ba2fa2[stor203].field_512 = block.timestamp
                                sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            if 31 >= sub_be75288d[arg1].field_1793:
                                mem[ceil32(sub_be75288d[arg1].field_1) + 416] = 256 * sub_be75288d[arg1].field_1800
                                mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _10214 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_10214] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _11852 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_11852] = arg1
                                        mem[_11852 + 32] = 1000
                                        mem[_11852 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_11852 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _10214 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _19689 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_19689] == Mask(32, 224, mem[_19689])
                                        if Mask(32, 224, mem[_19689]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _21961 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_21961] = arg1
                                        mem[_21961 + 32] = 1000
                                        mem[_21961 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_21961 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[ceil32(sub_be75288d[arg1].field_1) + 416] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(sub_be75288d[arg1].field_1) + 416
                                s = 0
                                while ceil32(sub_be75288d[arg1].field_1) + sub_be75288d[arg1].field_1793 + 384 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _19522 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_19522] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _22908 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_22908] = arg1
                                        mem[_22908 + 32] = 1000
                                        mem[_22908 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_22908 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _19522 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _26989 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_26989] == Mask(32, 224, mem[_26989])
                                        if Mask(32, 224, mem[_26989]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _28727 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_28727] = arg1
                                        mem[_28727 + 32] = 1000
                                        mem[_28727 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_28727 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                else:
                    if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                        revert with 0, 34
                    mem[64] = ceil32(sub_be75288d[arg1].field_1) + ceil32(sub_be75288d[arg1].field_1793) + 416
                    mem[ceil32(sub_be75288d[arg1].field_1) + 384] = sub_be75288d[arg1].field_1793
                    if sub_be75288d[arg1].field_1792:
                        if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                            mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                            if arg1 >= 4:
                                revert with 0, 'Invalid tier'
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                revert with 0, 'Too many nodes of this tier'
                            if arg2 <= 0:
                                revert with 0, 'Must create at least one'
                            mem[0] = arg1
                            mem[32] = sha3(address(arg3), 202)
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            sub_2b1331a8[address(arg3)][arg1] += arg2
                            idx = 0
                            while idx < arg2:
                                if numMinted > -2:
                                    revert with 0, 17
                                numMinted++
                                _10215 = mem[64]
                                mem[64] = mem[64] + 32
                                mem[_10215] = 0
                                if not address(arg3):
                                    revert with 0, 'ERC721: mint to the zero address'
                                if ownerOf[stor203]:
                                    revert with 0, 'ERC721: token already minted'
                                if balanceOf[address(arg3)] > -2:
                                    revert with 0, 17
                                balanceOf[address(arg3)]++
                                mem[0] = numMinted
                                mem[32] = 103
                                ownerOf[stor203] = address(arg3)
                                emit Transfer(0, address(arg3), numMinted);
                                if not ext_code.size(address(arg3)):
                                    _11853 = mem[64]
                                    mem[64] = mem[64] + 128
                                    mem[_11853] = arg1
                                    mem[_11853 + 32] = 1000
                                    mem[_11853 + 64] = block.timestamp
                                    if 720 * 24 * 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[_11853 + 96] = block.timestamp + (720 * 24 * 3600)
                                else:
                                    mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = 0
                                    mem[mem[64] + 68] = numMinted
                                    mem[mem[64] + 100] = 128
                                    mem[mem[64] + 132] = 0
                                    s = 0
                                    while s < 0:
                                        mem[s + mem[64] + 164] = mem[s + _10215 + 32]
                                        s = s + 32
                                        continue 
                                    require ext_code.size(address(arg3))
                                    call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args msg.sender, 0, numMinted, 128, 0
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        if not return_data.size:
                                            if not mem[96]:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        if not return_data.size:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _19691 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_19691] == Mask(32, 224, mem[_19691])
                                    if Mask(32, 224, mem[_19691]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    _21965 = mem[64]
                                    mem[64] = mem[64] + 128
                                    mem[_21965] = arg1
                                    mem[_21965 + 32] = 1000
                                    mem[_21965 + 64] = block.timestamp
                                    if 720 * 24 * 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[_21965 + 96] = block.timestamp + (720 * 24 * 3600)
                                mem[0] = numMinted
                                mem[32] = 201
                                sub_79ba2fa2[stor203].field_0 = arg1
                                sub_79ba2fa2[stor203].field_256 = 1000
                                sub_79ba2fa2[stor203].field_512 = block.timestamp
                                sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[ceil32(sub_be75288d[arg1].field_1) + 416] = 256 * sub_be75288d[arg1].field_1800
                                mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _10216 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_10216] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _11854 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_11854] = arg1
                                        mem[_11854 + 32] = 1000
                                        mem[_11854 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_11854 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _10216 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _19693 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_19693] == Mask(32, 224, mem[_19693])
                                        if Mask(32, 224, mem[_19693]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _21970 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_21970] = arg1
                                        mem[_21970 + 32] = 1000
                                        mem[_21970 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_21970 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[ceil32(sub_be75288d[arg1].field_1) + 416] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(sub_be75288d[arg1].field_1) + 416
                                s = 0
                                while ceil32(sub_be75288d[arg1].field_1) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _19527 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_19527] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _22909 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_22909] = arg1
                                        mem[_22909 + 32] = 1000
                                        mem[_22909 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_22909 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _19527 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _26991 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_26991] == Mask(32, 224, mem[_26991])
                                        if Mask(32, 224, mem[_26991]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _28731 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_28731] = arg1
                                        mem[_28731 + 32] = 1000
                                        mem[_28731 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_28731 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                    else:
                        if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                            revert with 0, 34
                        if not sub_be75288d[arg1].field_1793:
                            mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                            if arg1 >= 4:
                                revert with 0, 'Invalid tier'
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                revert with 0, 'Too many nodes of this tier'
                            if arg2 <= 0:
                                revert with 0, 'Must create at least one'
                            mem[0] = arg1
                            mem[32] = sha3(address(arg3), 202)
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            sub_2b1331a8[address(arg3)][arg1] += arg2
                            idx = 0
                            while idx < arg2:
                                if numMinted > -2:
                                    revert with 0, 17
                                numMinted++
                                _10217 = mem[64]
                                mem[64] = mem[64] + 32
                                mem[_10217] = 0
                                if not address(arg3):
                                    revert with 0, 'ERC721: mint to the zero address'
                                if ownerOf[stor203]:
                                    revert with 0, 'ERC721: token already minted'
                                if balanceOf[address(arg3)] > -2:
                                    revert with 0, 17
                                balanceOf[address(arg3)]++
                                mem[0] = numMinted
                                mem[32] = 103
                                ownerOf[stor203] = address(arg3)
                                emit Transfer(0, address(arg3), numMinted);
                                if not ext_code.size(address(arg3)):
                                    _11855 = mem[64]
                                    mem[64] = mem[64] + 128
                                    mem[_11855] = arg1
                                    mem[_11855 + 32] = 1000
                                    mem[_11855 + 64] = block.timestamp
                                    if 720 * 24 * 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[_11855 + 96] = block.timestamp + (720 * 24 * 3600)
                                else:
                                    mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = 0
                                    mem[mem[64] + 68] = numMinted
                                    mem[mem[64] + 100] = 128
                                    mem[mem[64] + 132] = 0
                                    s = 0
                                    while s < 0:
                                        mem[s + mem[64] + 164] = mem[s + _10217 + 32]
                                        s = s + 32
                                        continue 
                                    require ext_code.size(address(arg3))
                                    call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args msg.sender, 0, numMinted, 128, 0
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        if not return_data.size:
                                            if not mem[96]:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        if not return_data.size:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _19695 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_19695] == Mask(32, 224, mem[_19695])
                                    if Mask(32, 224, mem[_19695]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    _21974 = mem[64]
                                    mem[64] = mem[64] + 128
                                    mem[_21974] = arg1
                                    mem[_21974 + 32] = 1000
                                    mem[_21974 + 64] = block.timestamp
                                    if 720 * 24 * 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[_21974 + 96] = block.timestamp + (720 * 24 * 3600)
                                mem[0] = numMinted
                                mem[32] = 201
                                sub_79ba2fa2[stor203].field_0 = arg1
                                sub_79ba2fa2[stor203].field_256 = 1000
                                sub_79ba2fa2[stor203].field_512 = block.timestamp
                                sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            if 31 >= sub_be75288d[arg1].field_1793:
                                mem[ceil32(sub_be75288d[arg1].field_1) + 416] = 256 * sub_be75288d[arg1].field_1800
                                mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _10218 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_10218] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _11856 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_11856] = arg1
                                        mem[_11856 + 32] = 1000
                                        mem[_11856 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_11856 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _10218 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _19697 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_19697] == Mask(32, 224, mem[_19697])
                                        if Mask(32, 224, mem[_19697]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _21979 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_21979] = arg1
                                        mem[_21979 + 32] = 1000
                                        mem[_21979 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_21979 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[ceil32(sub_be75288d[arg1].field_1) + 416] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(sub_be75288d[arg1].field_1) + 416
                                s = 0
                                while ceil32(sub_be75288d[arg1].field_1) + sub_be75288d[arg1].field_1793 + 384 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _19532 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_19532] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _22910 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_22910] = arg1
                                        mem[_22910 + 32] = 1000
                                        mem[_22910 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_22910 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _19532 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _26993 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_26993] == Mask(32, 224, mem[_26993])
                                        if Mask(32, 224, mem[_26993]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _28735 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_28735] = arg1
                                        mem[_28735 + 32] = 1000
                                        mem[_28735 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_28735 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
            else:
                if 31 >= uint255(sub_be75288d[arg1].field_0) * 0.5:
                    mem[384] = 256 * sub_be75288d[arg1].field_8
                    mem[96] = 352
                    mem[128] = sub_be75288d[arg1].field_256
                    mem[160] = sub_be75288d[arg1].field_512
                    mem[192] = sub_be75288d[arg1].field_768
                    mem[224] = sub_be75288d[arg1].field_1024
                    mem[256] = sub_be75288d[arg1].field_1280
                    mem[288] = sub_be75288d[arg1].field_1536
                    if sub_be75288d[arg1].field_1792:
                        if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        mem[64] = ceil32(sub_be75288d[arg1].field_1) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416
                        mem[ceil32(sub_be75288d[arg1].field_1) + 384] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                        if sub_be75288d[arg1].field_1792:
                            if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                                mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _10219 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_10219] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _11858 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_11858] = arg1
                                        mem[_11858 + 32] = 1000
                                        mem[_11858 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_11858 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _10219 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _19703 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_19703] == Mask(32, 224, mem[_19703])
                                        if Mask(32, 224, mem[_19703]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _21999 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_21999] = arg1
                                        mem[_21999 + 32] = 1000
                                        mem[_21999 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_21999 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[ceil32(sub_be75288d[arg1].field_1) + 416] = 256 * sub_be75288d[arg1].field_1800
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _10220 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_10220] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _11859 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_11859] = arg1
                                            mem[_11859 + 32] = 1000
                                            mem[_11859 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_11859 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _10220 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _19705 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_19705] == Mask(32, 224, mem[_19705])
                                            if Mask(32, 224, mem[_19705]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _22004 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_22004] = arg1
                                            mem[_22004 + 32] = 1000
                                            mem[_22004 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_22004 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(sub_be75288d[arg1].field_1) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(sub_be75288d[arg1].field_1) + 416
                                    s = 0
                                    while ceil32(sub_be75288d[arg1].field_1) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _19545 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_19545] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _22919 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_22919] = arg1
                                            mem[_22919 + 32] = 1000
                                            mem[_22919 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_22919 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _19545 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _27011 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_27011] == Mask(32, 224, mem[_27011])
                                            if Mask(32, 224, mem[_27011]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _28775 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_28775] = arg1
                                            mem[_28775 + 32] = 1000
                                            mem[_28775 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_28775 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                        else:
                            if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                                revert with 0, 34
                            if not sub_be75288d[arg1].field_1793:
                                mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _10221 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_10221] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _11860 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_11860] = arg1
                                        mem[_11860 + 32] = 1000
                                        mem[_11860 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_11860 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _10221 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _19707 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_19707] == Mask(32, 224, mem[_19707])
                                        if Mask(32, 224, mem[_19707]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _22008 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_22008] = arg1
                                        mem[_22008 + 32] = 1000
                                        mem[_22008 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_22008 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= sub_be75288d[arg1].field_1793:
                                    mem[ceil32(sub_be75288d[arg1].field_1) + 416] = 256 * sub_be75288d[arg1].field_1800
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _10222 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_10222] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _11861 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_11861] = arg1
                                            mem[_11861 + 32] = 1000
                                            mem[_11861 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_11861 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _10222 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _19709 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_19709] == Mask(32, 224, mem[_19709])
                                            if Mask(32, 224, mem[_19709]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _22013 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_22013] = arg1
                                            mem[_22013 + 32] = 1000
                                            mem[_22013 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_22013 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(sub_be75288d[arg1].field_1) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(sub_be75288d[arg1].field_1) + 416
                                    s = 0
                                    while ceil32(sub_be75288d[arg1].field_1) + sub_be75288d[arg1].field_1793 + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _19550 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_19550] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _22920 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_22920] = arg1
                                            mem[_22920 + 32] = 1000
                                            mem[_22920 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_22920 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _19550 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _27013 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_27013] == Mask(32, 224, mem[_27013])
                                            if Mask(32, 224, mem[_27013]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _28779 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_28779] = arg1
                                            mem[_28779 + 32] = 1000
                                            mem[_28779 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_28779 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                    else:
                        if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                            revert with 0, 34
                        mem[64] = ceil32(sub_be75288d[arg1].field_1) + ceil32(sub_be75288d[arg1].field_1793) + 416
                        mem[ceil32(sub_be75288d[arg1].field_1) + 384] = sub_be75288d[arg1].field_1793
                        if sub_be75288d[arg1].field_1792:
                            if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                                mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _10223 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_10223] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _11862 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_11862] = arg1
                                        mem[_11862 + 32] = 1000
                                        mem[_11862 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_11862 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _10223 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _19711 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_19711] == Mask(32, 224, mem[_19711])
                                        if Mask(32, 224, mem[_19711]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _22017 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_22017] = arg1
                                        mem[_22017 + 32] = 1000
                                        mem[_22017 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_22017 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[ceil32(sub_be75288d[arg1].field_1) + 416] = 256 * sub_be75288d[arg1].field_1800
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _10224 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_10224] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _11863 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_11863] = arg1
                                            mem[_11863 + 32] = 1000
                                            mem[_11863 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_11863 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _10224 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _19713 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_19713] == Mask(32, 224, mem[_19713])
                                            if Mask(32, 224, mem[_19713]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _22022 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_22022] = arg1
                                            mem[_22022 + 32] = 1000
                                            mem[_22022 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_22022 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(sub_be75288d[arg1].field_1) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(sub_be75288d[arg1].field_1) + 416
                                    s = 0
                                    while ceil32(sub_be75288d[arg1].field_1) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _19555 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_19555] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _22921 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_22921] = arg1
                                            mem[_22921 + 32] = 1000
                                            mem[_22921 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_22921 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _19555 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _27015 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_27015] == Mask(32, 224, mem[_27015])
                                            if Mask(32, 224, mem[_27015]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _28783 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_28783] = arg1
                                            mem[_28783 + 32] = 1000
                                            mem[_28783 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_28783 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                        else:
                            if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                                revert with 0, 34
                            if not sub_be75288d[arg1].field_1793:
                                mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _10225 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_10225] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _11864 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_11864] = arg1
                                        mem[_11864 + 32] = 1000
                                        mem[_11864 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_11864 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _10225 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _19715 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_19715] == Mask(32, 224, mem[_19715])
                                        if Mask(32, 224, mem[_19715]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _22026 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_22026] = arg1
                                        mem[_22026 + 32] = 1000
                                        mem[_22026 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_22026 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= sub_be75288d[arg1].field_1793:
                                    mem[ceil32(sub_be75288d[arg1].field_1) + 416] = 256 * sub_be75288d[arg1].field_1800
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _10226 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_10226] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _11865 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_11865] = arg1
                                            mem[_11865 + 32] = 1000
                                            mem[_11865 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_11865 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _10226 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _19717 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_19717] == Mask(32, 224, mem[_19717])
                                            if Mask(32, 224, mem[_19717]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _22031 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_22031] = arg1
                                            mem[_22031 + 32] = 1000
                                            mem[_22031 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_22031 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(sub_be75288d[arg1].field_1) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(sub_be75288d[arg1].field_1) + 416
                                    s = 0
                                    while ceil32(sub_be75288d[arg1].field_1) + sub_be75288d[arg1].field_1793 + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _19560 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_19560] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _22922 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_22922] = arg1
                                            mem[_22922 + 32] = 1000
                                            mem[_22922 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_22922 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _19560 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _27017 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_27017] == Mask(32, 224, mem[_27017])
                                            if Mask(32, 224, mem[_27017]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _28787 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_28787] = arg1
                                            mem[_28787 + 32] = 1000
                                            mem[_28787 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_28787 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                else:
                    mem[384] = sub_be75288d[arg1].field_0
                    idx = 384
                    s = 0
                    while (uint255(sub_be75288d[arg1].field_0) * 0.5) + 352 > idx:
                        mem[idx + 32] = sub_be75288d[arg1][s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    mem[96] = 352
                    mem[128] = sub_be75288d[arg1].field_256
                    mem[160] = sub_be75288d[arg1].field_512
                    mem[192] = sub_be75288d[arg1].field_768
                    mem[224] = sub_be75288d[arg1].field_1024
                    mem[256] = sub_be75288d[arg1].field_1280
                    mem[288] = sub_be75288d[arg1].field_1536
                    if sub_be75288d[arg1].field_1792:
                        if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        mem[64] = ceil32(sub_be75288d[arg1].field_1) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416
                        mem[ceil32(sub_be75288d[arg1].field_1) + 384] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                        if sub_be75288d[arg1].field_1792:
                            if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                                mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _19535 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_19535] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _22911 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_22911] = arg1
                                        mem[_22911 + 32] = 1000
                                        mem[_22911 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_22911 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _19535 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _26995 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_26995] == Mask(32, 224, mem[_26995])
                                        if Mask(32, 224, mem[_26995]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _28739 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_28739] = arg1
                                        mem[_28739 + 32] = 1000
                                        mem[_28739 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_28739 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[ceil32(sub_be75288d[arg1].field_1) + 416] = 256 * sub_be75288d[arg1].field_1800
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _19536 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_19536] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _22912 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_22912] = arg1
                                            mem[_22912 + 32] = 1000
                                            mem[_22912 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_22912 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _19536 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _26997 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_26997] == Mask(32, 224, mem[_26997])
                                            if Mask(32, 224, mem[_26997]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _28744 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_28744] = arg1
                                            mem[_28744 + 32] = 1000
                                            mem[_28744 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_28744 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(sub_be75288d[arg1].field_1) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(sub_be75288d[arg1].field_1) + 416
                                    s = 0
                                    while ceil32(sub_be75288d[arg1].field_1) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _26861 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_26861] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _29523 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_29523] = arg1
                                            mem[_29523 + 32] = 1000
                                            mem[_29523 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_29523 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _26861 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _30331 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_30331] == Mask(32, 224, mem[_30331])
                                            if Mask(32, 224, mem[_30331]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _30731 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_30731] = arg1
                                            mem[_30731 + 32] = 1000
                                            mem[_30731 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_30731 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                        else:
                            if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                                revert with 0, 34
                            if not sub_be75288d[arg1].field_1793:
                                mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _19537 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_19537] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _22913 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_22913] = arg1
                                        mem[_22913 + 32] = 1000
                                        mem[_22913 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_22913 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _19537 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _26999 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_26999] == Mask(32, 224, mem[_26999])
                                        if Mask(32, 224, mem[_26999]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _28748 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_28748] = arg1
                                        mem[_28748 + 32] = 1000
                                        mem[_28748 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_28748 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= sub_be75288d[arg1].field_1793:
                                    mem[ceil32(sub_be75288d[arg1].field_1) + 416] = 256 * sub_be75288d[arg1].field_1800
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _19538 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_19538] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _22914 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_22914] = arg1
                                            mem[_22914 + 32] = 1000
                                            mem[_22914 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_22914 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _19538 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _27001 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_27001] == Mask(32, 224, mem[_27001])
                                            if Mask(32, 224, mem[_27001]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _28753 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_28753] = arg1
                                            mem[_28753 + 32] = 1000
                                            mem[_28753 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_28753 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(sub_be75288d[arg1].field_1) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(sub_be75288d[arg1].field_1) + 416
                                    s = 0
                                    while ceil32(sub_be75288d[arg1].field_1) + sub_be75288d[arg1].field_1793 + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _26866 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_26866] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _29524 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_29524] = arg1
                                            mem[_29524 + 32] = 1000
                                            mem[_29524 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_29524 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _26866 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _30333 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_30333] == Mask(32, 224, mem[_30333])
                                            if Mask(32, 224, mem[_30333]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _30735 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_30735] = arg1
                                            mem[_30735 + 32] = 1000
                                            mem[_30735 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_30735 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                    else:
                        if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                            revert with 0, 34
                        mem[64] = ceil32(sub_be75288d[arg1].field_1) + ceil32(sub_be75288d[arg1].field_1793) + 416
                        mem[ceil32(sub_be75288d[arg1].field_1) + 384] = sub_be75288d[arg1].field_1793
                        if sub_be75288d[arg1].field_1792:
                            if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                                mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _19539 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_19539] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _22915 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_22915] = arg1
                                        mem[_22915 + 32] = 1000
                                        mem[_22915 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_22915 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _19539 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _27003 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_27003] == Mask(32, 224, mem[_27003])
                                        if Mask(32, 224, mem[_27003]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _28757 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_28757] = arg1
                                        mem[_28757 + 32] = 1000
                                        mem[_28757 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_28757 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[ceil32(sub_be75288d[arg1].field_1) + 416] = 256 * sub_be75288d[arg1].field_1800
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _19540 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_19540] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _22916 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_22916] = arg1
                                            mem[_22916 + 32] = 1000
                                            mem[_22916 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_22916 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _19540 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _27005 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_27005] == Mask(32, 224, mem[_27005])
                                            if Mask(32, 224, mem[_27005]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _28762 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_28762] = arg1
                                            mem[_28762 + 32] = 1000
                                            mem[_28762 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_28762 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(sub_be75288d[arg1].field_1) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(sub_be75288d[arg1].field_1) + 416
                                    s = 0
                                    while ceil32(sub_be75288d[arg1].field_1) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _26871 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_26871] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _29525 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_29525] = arg1
                                            mem[_29525 + 32] = 1000
                                            mem[_29525 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_29525 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _26871 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _30335 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_30335] == Mask(32, 224, mem[_30335])
                                            if Mask(32, 224, mem[_30335]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _30739 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_30739] = arg1
                                            mem[_30739 + 32] = 1000
                                            mem[_30739 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_30739 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                        else:
                            if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                                revert with 0, 34
                            if not sub_be75288d[arg1].field_1793:
                                mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _19541 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_19541] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _22917 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_22917] = arg1
                                        mem[_22917 + 32] = 1000
                                        mem[_22917 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_22917 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _19541 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _27007 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_27007] == Mask(32, 224, mem[_27007])
                                        if Mask(32, 224, mem[_27007]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _28766 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_28766] = arg1
                                        mem[_28766 + 32] = 1000
                                        mem[_28766 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_28766 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= sub_be75288d[arg1].field_1793:
                                    mem[ceil32(sub_be75288d[arg1].field_1) + 416] = 256 * sub_be75288d[arg1].field_1800
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _19542 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_19542] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _22918 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_22918] = arg1
                                            mem[_22918 + 32] = 1000
                                            mem[_22918 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_22918 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _19542 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _27009 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_27009] == Mask(32, 224, mem[_27009])
                                            if Mask(32, 224, mem[_27009]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _28771 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_28771] = arg1
                                            mem[_28771 + 32] = 1000
                                            mem[_28771 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_28771 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(sub_be75288d[arg1].field_1) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(sub_be75288d[arg1].field_1) + 416
                                    s = 0
                                    while ceil32(sub_be75288d[arg1].field_1) + sub_be75288d[arg1].field_1793 + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _26876 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_26876] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _29526 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_29526] = arg1
                                            mem[_29526 + 32] = 1000
                                            mem[_29526 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_29526 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _26876 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _30337 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_30337] == Mask(32, 224, mem[_30337])
                                            if Mask(32, 224, mem[_30337]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _30743 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_30743] = arg1
                                            mem[_30743 + 32] = 1000
                                            mem[_30743 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_30743 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
        else:
            if sub_be75288d[arg1].field_0 == sub_be75288d[arg1].field_1 < 32:
                revert with 0, 34
            if not sub_be75288d[arg1].field_1:
                mem[96] = 352
                mem[128] = sub_be75288d[arg1].field_256
                mem[160] = sub_be75288d[arg1].field_512
                mem[192] = sub_be75288d[arg1].field_768
                mem[224] = sub_be75288d[arg1].field_1024
                mem[256] = sub_be75288d[arg1].field_1280
                mem[288] = sub_be75288d[arg1].field_1536
                if sub_be75288d[arg1].field_1792:
                    if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                        revert with 0, 34
                    mem[64] = ceil32(sub_be75288d[arg1].field_1) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416
                    mem[ceil32(sub_be75288d[arg1].field_1) + 384] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                    if sub_be75288d[arg1].field_1792:
                        if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                            mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                            if arg1 >= 4:
                                revert with 0, 'Invalid tier'
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                revert with 0, 'Too many nodes of this tier'
                            if arg2 <= 0:
                                revert with 0, 'Must create at least one'
                            mem[0] = arg1
                            mem[32] = sha3(address(arg3), 202)
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            sub_2b1331a8[address(arg3)][arg1] += arg2
                            idx = 0
                            while idx < arg2:
                                if numMinted > -2:
                                    revert with 0, 17
                                numMinted++
                                _10227 = mem[64]
                                mem[64] = mem[64] + 32
                                mem[_10227] = 0
                                if not address(arg3):
                                    revert with 0, 'ERC721: mint to the zero address'
                                if ownerOf[stor203]:
                                    revert with 0, 'ERC721: token already minted'
                                if balanceOf[address(arg3)] > -2:
                                    revert with 0, 17
                                balanceOf[address(arg3)]++
                                mem[0] = numMinted
                                mem[32] = 103
                                ownerOf[stor203] = address(arg3)
                                emit Transfer(0, address(arg3), numMinted);
                                if not ext_code.size(address(arg3)):
                                    _11866 = mem[64]
                                    mem[64] = mem[64] + 128
                                    mem[_11866] = arg1
                                    mem[_11866 + 32] = 1000
                                    mem[_11866 + 64] = block.timestamp
                                    if 720 * 24 * 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[_11866 + 96] = block.timestamp + (720 * 24 * 3600)
                                else:
                                    mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = 0
                                    mem[mem[64] + 68] = numMinted
                                    mem[mem[64] + 100] = 128
                                    mem[mem[64] + 132] = 0
                                    s = 0
                                    while s < 0:
                                        mem[s + mem[64] + 164] = mem[s + _10227 + 32]
                                        s = s + 32
                                        continue 
                                    require ext_code.size(address(arg3))
                                    call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args msg.sender, 0, numMinted, 128, 0
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        if not return_data.size:
                                            if not mem[96]:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        if not return_data.size:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _19719 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_19719] == Mask(32, 224, mem[_19719])
                                    if Mask(32, 224, mem[_19719]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    _22035 = mem[64]
                                    mem[64] = mem[64] + 128
                                    mem[_22035] = arg1
                                    mem[_22035 + 32] = 1000
                                    mem[_22035 + 64] = block.timestamp
                                    if 720 * 24 * 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[_22035 + 96] = block.timestamp + (720 * 24 * 3600)
                                mem[0] = numMinted
                                mem[32] = 201
                                sub_79ba2fa2[stor203].field_0 = arg1
                                sub_79ba2fa2[stor203].field_256 = 1000
                                sub_79ba2fa2[stor203].field_512 = block.timestamp
                                sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[ceil32(sub_be75288d[arg1].field_1) + 416] = 256 * sub_be75288d[arg1].field_1800
                                mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _10228 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_10228] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _11867 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_11867] = arg1
                                        mem[_11867 + 32] = 1000
                                        mem[_11867 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_11867 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _10228 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _19721 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_19721] == Mask(32, 224, mem[_19721])
                                        if Mask(32, 224, mem[_19721]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _22040 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_22040] = arg1
                                        mem[_22040 + 32] = 1000
                                        mem[_22040 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_22040 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[ceil32(sub_be75288d[arg1].field_1) + 416] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(sub_be75288d[arg1].field_1) + 416
                                s = 0
                                while ceil32(sub_be75288d[arg1].field_1) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _19565 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_19565] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _22923 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_22923] = arg1
                                        mem[_22923 + 32] = 1000
                                        mem[_22923 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_22923 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _19565 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _27019 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_27019] == Mask(32, 224, mem[_27019])
                                        if Mask(32, 224, mem[_27019]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _28791 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_28791] = arg1
                                        mem[_28791 + 32] = 1000
                                        mem[_28791 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_28791 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                    else:
                        if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                            revert with 0, 34
                        if not sub_be75288d[arg1].field_1793:
                            mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                            if arg1 >= 4:
                                revert with 0, 'Invalid tier'
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                revert with 0, 'Too many nodes of this tier'
                            if arg2 <= 0:
                                revert with 0, 'Must create at least one'
                            mem[0] = arg1
                            mem[32] = sha3(address(arg3), 202)
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            sub_2b1331a8[address(arg3)][arg1] += arg2
                            idx = 0
                            while idx < arg2:
                                if numMinted > -2:
                                    revert with 0, 17
                                numMinted++
                                _10229 = mem[64]
                                mem[64] = mem[64] + 32
                                mem[_10229] = 0
                                if not address(arg3):
                                    revert with 0, 'ERC721: mint to the zero address'
                                if ownerOf[stor203]:
                                    revert with 0, 'ERC721: token already minted'
                                if balanceOf[address(arg3)] > -2:
                                    revert with 0, 17
                                balanceOf[address(arg3)]++
                                mem[0] = numMinted
                                mem[32] = 103
                                ownerOf[stor203] = address(arg3)
                                emit Transfer(0, address(arg3), numMinted);
                                if not ext_code.size(address(arg3)):
                                    _11868 = mem[64]
                                    mem[64] = mem[64] + 128
                                    mem[_11868] = arg1
                                    mem[_11868 + 32] = 1000
                                    mem[_11868 + 64] = block.timestamp
                                    if 720 * 24 * 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[_11868 + 96] = block.timestamp + (720 * 24 * 3600)
                                else:
                                    mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = 0
                                    mem[mem[64] + 68] = numMinted
                                    mem[mem[64] + 100] = 128
                                    mem[mem[64] + 132] = 0
                                    s = 0
                                    while s < 0:
                                        mem[s + mem[64] + 164] = mem[s + _10229 + 32]
                                        s = s + 32
                                        continue 
                                    require ext_code.size(address(arg3))
                                    call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args msg.sender, 0, numMinted, 128, 0
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        if not return_data.size:
                                            if not mem[96]:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        if not return_data.size:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _19723 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_19723] == Mask(32, 224, mem[_19723])
                                    if Mask(32, 224, mem[_19723]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    _22044 = mem[64]
                                    mem[64] = mem[64] + 128
                                    mem[_22044] = arg1
                                    mem[_22044 + 32] = 1000
                                    mem[_22044 + 64] = block.timestamp
                                    if 720 * 24 * 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[_22044 + 96] = block.timestamp + (720 * 24 * 3600)
                                mem[0] = numMinted
                                mem[32] = 201
                                sub_79ba2fa2[stor203].field_0 = arg1
                                sub_79ba2fa2[stor203].field_256 = 1000
                                sub_79ba2fa2[stor203].field_512 = block.timestamp
                                sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            if 31 >= sub_be75288d[arg1].field_1793:
                                mem[ceil32(sub_be75288d[arg1].field_1) + 416] = 256 * sub_be75288d[arg1].field_1800
                                mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _10230 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_10230] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _11869 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_11869] = arg1
                                        mem[_11869 + 32] = 1000
                                        mem[_11869 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_11869 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _10230 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _19725 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_19725] == Mask(32, 224, mem[_19725])
                                        if Mask(32, 224, mem[_19725]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _22049 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_22049] = arg1
                                        mem[_22049 + 32] = 1000
                                        mem[_22049 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_22049 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[ceil32(sub_be75288d[arg1].field_1) + 416] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(sub_be75288d[arg1].field_1) + 416
                                s = 0
                                while ceil32(sub_be75288d[arg1].field_1) + sub_be75288d[arg1].field_1793 + 384 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _19570 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_19570] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _22924 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_22924] = arg1
                                        mem[_22924 + 32] = 1000
                                        mem[_22924 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_22924 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _19570 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _27021 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_27021] == Mask(32, 224, mem[_27021])
                                        if Mask(32, 224, mem[_27021]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _28795 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_28795] = arg1
                                        mem[_28795 + 32] = 1000
                                        mem[_28795 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_28795 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                else:
                    if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                        revert with 0, 34
                    mem[64] = ceil32(sub_be75288d[arg1].field_1) + ceil32(sub_be75288d[arg1].field_1793) + 416
                    mem[ceil32(sub_be75288d[arg1].field_1) + 384] = sub_be75288d[arg1].field_1793
                    if sub_be75288d[arg1].field_1792:
                        if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                            mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                            if arg1 >= 4:
                                revert with 0, 'Invalid tier'
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                revert with 0, 'Too many nodes of this tier'
                            if arg2 <= 0:
                                revert with 0, 'Must create at least one'
                            mem[0] = arg1
                            mem[32] = sha3(address(arg3), 202)
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            sub_2b1331a8[address(arg3)][arg1] += arg2
                            idx = 0
                            while idx < arg2:
                                if numMinted > -2:
                                    revert with 0, 17
                                numMinted++
                                _10231 = mem[64]
                                mem[64] = mem[64] + 32
                                mem[_10231] = 0
                                if not address(arg3):
                                    revert with 0, 'ERC721: mint to the zero address'
                                if ownerOf[stor203]:
                                    revert with 0, 'ERC721: token already minted'
                                if balanceOf[address(arg3)] > -2:
                                    revert with 0, 17
                                balanceOf[address(arg3)]++
                                mem[0] = numMinted
                                mem[32] = 103
                                ownerOf[stor203] = address(arg3)
                                emit Transfer(0, address(arg3), numMinted);
                                if not ext_code.size(address(arg3)):
                                    _11870 = mem[64]
                                    mem[64] = mem[64] + 128
                                    mem[_11870] = arg1
                                    mem[_11870 + 32] = 1000
                                    mem[_11870 + 64] = block.timestamp
                                    if 720 * 24 * 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[_11870 + 96] = block.timestamp + (720 * 24 * 3600)
                                else:
                                    mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = 0
                                    mem[mem[64] + 68] = numMinted
                                    mem[mem[64] + 100] = 128
                                    mem[mem[64] + 132] = 0
                                    s = 0
                                    while s < 0:
                                        mem[s + mem[64] + 164] = mem[s + _10231 + 32]
                                        s = s + 32
                                        continue 
                                    require ext_code.size(address(arg3))
                                    call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args msg.sender, 0, numMinted, 128, 0
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        if not return_data.size:
                                            if not mem[96]:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        if not return_data.size:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _19727 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_19727] == Mask(32, 224, mem[_19727])
                                    if Mask(32, 224, mem[_19727]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    _22053 = mem[64]
                                    mem[64] = mem[64] + 128
                                    mem[_22053] = arg1
                                    mem[_22053 + 32] = 1000
                                    mem[_22053 + 64] = block.timestamp
                                    if 720 * 24 * 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[_22053 + 96] = block.timestamp + (720 * 24 * 3600)
                                mem[0] = numMinted
                                mem[32] = 201
                                sub_79ba2fa2[stor203].field_0 = arg1
                                sub_79ba2fa2[stor203].field_256 = 1000
                                sub_79ba2fa2[stor203].field_512 = block.timestamp
                                sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[ceil32(sub_be75288d[arg1].field_1) + 416] = 256 * sub_be75288d[arg1].field_1800
                                mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _10232 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_10232] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _11871 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_11871] = arg1
                                        mem[_11871 + 32] = 1000
                                        mem[_11871 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_11871 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _10232 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _19729 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_19729] == Mask(32, 224, mem[_19729])
                                        if Mask(32, 224, mem[_19729]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _22058 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_22058] = arg1
                                        mem[_22058 + 32] = 1000
                                        mem[_22058 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_22058 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[ceil32(sub_be75288d[arg1].field_1) + 416] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(sub_be75288d[arg1].field_1) + 416
                                s = 0
                                while ceil32(sub_be75288d[arg1].field_1) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _19575 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_19575] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _22925 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_22925] = arg1
                                        mem[_22925 + 32] = 1000
                                        mem[_22925 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_22925 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _19575 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _27023 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_27023] == Mask(32, 224, mem[_27023])
                                        if Mask(32, 224, mem[_27023]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _28799 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_28799] = arg1
                                        mem[_28799 + 32] = 1000
                                        mem[_28799 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_28799 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                    else:
                        if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                            revert with 0, 34
                        if not sub_be75288d[arg1].field_1793:
                            mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                            if arg1 >= 4:
                                revert with 0, 'Invalid tier'
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                revert with 0, 'Too many nodes of this tier'
                            if arg2 <= 0:
                                revert with 0, 'Must create at least one'
                            mem[0] = arg1
                            mem[32] = sha3(address(arg3), 202)
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            sub_2b1331a8[address(arg3)][arg1] += arg2
                            idx = 0
                            while idx < arg2:
                                if numMinted > -2:
                                    revert with 0, 17
                                numMinted++
                                _10233 = mem[64]
                                mem[64] = mem[64] + 32
                                mem[_10233] = 0
                                if not address(arg3):
                                    revert with 0, 'ERC721: mint to the zero address'
                                if ownerOf[stor203]:
                                    revert with 0, 'ERC721: token already minted'
                                if balanceOf[address(arg3)] > -2:
                                    revert with 0, 17
                                balanceOf[address(arg3)]++
                                mem[0] = numMinted
                                mem[32] = 103
                                ownerOf[stor203] = address(arg3)
                                emit Transfer(0, address(arg3), numMinted);
                                if not ext_code.size(address(arg3)):
                                    _11872 = mem[64]
                                    mem[64] = mem[64] + 128
                                    mem[_11872] = arg1
                                    mem[_11872 + 32] = 1000
                                    mem[_11872 + 64] = block.timestamp
                                    if 720 * 24 * 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[_11872 + 96] = block.timestamp + (720 * 24 * 3600)
                                else:
                                    mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = 0
                                    mem[mem[64] + 68] = numMinted
                                    mem[mem[64] + 100] = 128
                                    mem[mem[64] + 132] = 0
                                    s = 0
                                    while s < 0:
                                        mem[s + mem[64] + 164] = mem[s + _10233 + 32]
                                        s = s + 32
                                        continue 
                                    require ext_code.size(address(arg3))
                                    call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args msg.sender, 0, numMinted, 128, 0
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        if not return_data.size:
                                            if not mem[96]:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        if not return_data.size:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _19731 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_19731] == Mask(32, 224, mem[_19731])
                                    if Mask(32, 224, mem[_19731]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    _22062 = mem[64]
                                    mem[64] = mem[64] + 128
                                    mem[_22062] = arg1
                                    mem[_22062 + 32] = 1000
                                    mem[_22062 + 64] = block.timestamp
                                    if 720 * 24 * 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[_22062 + 96] = block.timestamp + (720 * 24 * 3600)
                                mem[0] = numMinted
                                mem[32] = 201
                                sub_79ba2fa2[stor203].field_0 = arg1
                                sub_79ba2fa2[stor203].field_256 = 1000
                                sub_79ba2fa2[stor203].field_512 = block.timestamp
                                sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            if 31 >= sub_be75288d[arg1].field_1793:
                                mem[ceil32(sub_be75288d[arg1].field_1) + 416] = 256 * sub_be75288d[arg1].field_1800
                                mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _10234 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_10234] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _11873 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_11873] = arg1
                                        mem[_11873 + 32] = 1000
                                        mem[_11873 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_11873 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _10234 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _19733 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_19733] == Mask(32, 224, mem[_19733])
                                        if Mask(32, 224, mem[_19733]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _22067 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_22067] = arg1
                                        mem[_22067 + 32] = 1000
                                        mem[_22067 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_22067 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[ceil32(sub_be75288d[arg1].field_1) + 416] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(sub_be75288d[arg1].field_1) + 416
                                s = 0
                                while ceil32(sub_be75288d[arg1].field_1) + sub_be75288d[arg1].field_1793 + 384 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _19580 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_19580] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _22926 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_22926] = arg1
                                        mem[_22926 + 32] = 1000
                                        mem[_22926 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_22926 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _19580 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _27025 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_27025] == Mask(32, 224, mem[_27025])
                                        if Mask(32, 224, mem[_27025]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _28803 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_28803] = arg1
                                        mem[_28803 + 32] = 1000
                                        mem[_28803 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_28803 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
            else:
                if 31 >= sub_be75288d[arg1].field_1:
                    mem[384] = 256 * sub_be75288d[arg1].field_8
                    mem[96] = 352
                    mem[128] = sub_be75288d[arg1].field_256
                    mem[160] = sub_be75288d[arg1].field_512
                    mem[192] = sub_be75288d[arg1].field_768
                    mem[224] = sub_be75288d[arg1].field_1024
                    mem[256] = sub_be75288d[arg1].field_1280
                    mem[288] = sub_be75288d[arg1].field_1536
                    if sub_be75288d[arg1].field_1792:
                        if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        mem[64] = ceil32(sub_be75288d[arg1].field_1) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416
                        mem[ceil32(sub_be75288d[arg1].field_1) + 384] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                        if sub_be75288d[arg1].field_1792:
                            if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                                mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _10235 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_10235] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _11875 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_11875] = arg1
                                        mem[_11875 + 32] = 1000
                                        mem[_11875 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_11875 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _10235 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _19739 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_19739] == Mask(32, 224, mem[_19739])
                                        if Mask(32, 224, mem[_19739]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _22087 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_22087] = arg1
                                        mem[_22087 + 32] = 1000
                                        mem[_22087 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_22087 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[ceil32(sub_be75288d[arg1].field_1) + 416] = 256 * sub_be75288d[arg1].field_1800
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _10236 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_10236] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _11876 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_11876] = arg1
                                            mem[_11876 + 32] = 1000
                                            mem[_11876 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_11876 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _10236 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _19741 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_19741] == Mask(32, 224, mem[_19741])
                                            if Mask(32, 224, mem[_19741]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _22092 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_22092] = arg1
                                            mem[_22092 + 32] = 1000
                                            mem[_22092 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_22092 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(sub_be75288d[arg1].field_1) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(sub_be75288d[arg1].field_1) + 416
                                    s = 0
                                    while ceil32(sub_be75288d[arg1].field_1) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _19593 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_19593] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _22935 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_22935] = arg1
                                            mem[_22935 + 32] = 1000
                                            mem[_22935 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_22935 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _19593 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _27043 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_27043] == Mask(32, 224, mem[_27043])
                                            if Mask(32, 224, mem[_27043]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _28843 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_28843] = arg1
                                            mem[_28843 + 32] = 1000
                                            mem[_28843 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_28843 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                        else:
                            if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                                revert with 0, 34
                            if not sub_be75288d[arg1].field_1793:
                                mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _10237 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_10237] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _11877 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_11877] = arg1
                                        mem[_11877 + 32] = 1000
                                        mem[_11877 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_11877 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _10237 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _19743 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_19743] == Mask(32, 224, mem[_19743])
                                        if Mask(32, 224, mem[_19743]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _22096 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_22096] = arg1
                                        mem[_22096 + 32] = 1000
                                        mem[_22096 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_22096 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= sub_be75288d[arg1].field_1793:
                                    mem[ceil32(sub_be75288d[arg1].field_1) + 416] = 256 * sub_be75288d[arg1].field_1800
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _10238 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_10238] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _11878 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_11878] = arg1
                                            mem[_11878 + 32] = 1000
                                            mem[_11878 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_11878 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _10238 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _19745 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_19745] == Mask(32, 224, mem[_19745])
                                            if Mask(32, 224, mem[_19745]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _22101 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_22101] = arg1
                                            mem[_22101 + 32] = 1000
                                            mem[_22101 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_22101 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(sub_be75288d[arg1].field_1) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(sub_be75288d[arg1].field_1) + 416
                                    s = 0
                                    while ceil32(sub_be75288d[arg1].field_1) + sub_be75288d[arg1].field_1793 + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _19598 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_19598] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _22936 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_22936] = arg1
                                            mem[_22936 + 32] = 1000
                                            mem[_22936 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_22936 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _19598 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _27045 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_27045] == Mask(32, 224, mem[_27045])
                                            if Mask(32, 224, mem[_27045]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _28847 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_28847] = arg1
                                            mem[_28847 + 32] = 1000
                                            mem[_28847 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_28847 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                    else:
                        if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                            revert with 0, 34
                        mem[64] = ceil32(sub_be75288d[arg1].field_1) + ceil32(sub_be75288d[arg1].field_1793) + 416
                        mem[ceil32(sub_be75288d[arg1].field_1) + 384] = sub_be75288d[arg1].field_1793
                        if sub_be75288d[arg1].field_1792:
                            if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                                mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _10239 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_10239] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _11879 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_11879] = arg1
                                        mem[_11879 + 32] = 1000
                                        mem[_11879 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_11879 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _10239 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _19747 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_19747] == Mask(32, 224, mem[_19747])
                                        if Mask(32, 224, mem[_19747]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _22105 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_22105] = arg1
                                        mem[_22105 + 32] = 1000
                                        mem[_22105 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_22105 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[ceil32(sub_be75288d[arg1].field_1) + 416] = 256 * sub_be75288d[arg1].field_1800
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _10240 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_10240] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _11880 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_11880] = arg1
                                            mem[_11880 + 32] = 1000
                                            mem[_11880 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_11880 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _10240 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _19749 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_19749] == Mask(32, 224, mem[_19749])
                                            if Mask(32, 224, mem[_19749]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _22110 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_22110] = arg1
                                            mem[_22110 + 32] = 1000
                                            mem[_22110 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_22110 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(sub_be75288d[arg1].field_1) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(sub_be75288d[arg1].field_1) + 416
                                    s = 0
                                    while ceil32(sub_be75288d[arg1].field_1) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _19603 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_19603] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _22937 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_22937] = arg1
                                            mem[_22937 + 32] = 1000
                                            mem[_22937 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_22937 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _19603 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _27047 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_27047] == Mask(32, 224, mem[_27047])
                                            if Mask(32, 224, mem[_27047]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _28851 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_28851] = arg1
                                            mem[_28851 + 32] = 1000
                                            mem[_28851 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_28851 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                        else:
                            if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                                revert with 0, 34
                            if not sub_be75288d[arg1].field_1793:
                                mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _10241 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_10241] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _11881 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_11881] = arg1
                                        mem[_11881 + 32] = 1000
                                        mem[_11881 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_11881 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _10241 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _19751 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_19751] == Mask(32, 224, mem[_19751])
                                        if Mask(32, 224, mem[_19751]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _22114 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_22114] = arg1
                                        mem[_22114 + 32] = 1000
                                        mem[_22114 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_22114 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= sub_be75288d[arg1].field_1793:
                                    mem[ceil32(sub_be75288d[arg1].field_1) + 416] = 256 * sub_be75288d[arg1].field_1800
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _10242 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_10242] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _11882 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_11882] = arg1
                                            mem[_11882 + 32] = 1000
                                            mem[_11882 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_11882 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _10242 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _19753 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_19753] == Mask(32, 224, mem[_19753])
                                            if Mask(32, 224, mem[_19753]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _22119 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_22119] = arg1
                                            mem[_22119 + 32] = 1000
                                            mem[_22119 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_22119 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(sub_be75288d[arg1].field_1) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(sub_be75288d[arg1].field_1) + 416
                                    s = 0
                                    while ceil32(sub_be75288d[arg1].field_1) + sub_be75288d[arg1].field_1793 + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _19608 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_19608] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _22938 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_22938] = arg1
                                            mem[_22938 + 32] = 1000
                                            mem[_22938 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_22938 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _19608 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _27049 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_27049] == Mask(32, 224, mem[_27049])
                                            if Mask(32, 224, mem[_27049]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _28855 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_28855] = arg1
                                            mem[_28855 + 32] = 1000
                                            mem[_28855 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_28855 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                else:
                    mem[384] = sub_be75288d[arg1].field_0
                    idx = 384
                    s = 0
                    while sub_be75288d[arg1].field_1 + 352 > idx:
                        mem[idx + 32] = sub_be75288d[arg1][s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    mem[96] = 352
                    mem[128] = sub_be75288d[arg1].field_256
                    mem[160] = sub_be75288d[arg1].field_512
                    mem[192] = sub_be75288d[arg1].field_768
                    mem[224] = sub_be75288d[arg1].field_1024
                    mem[256] = sub_be75288d[arg1].field_1280
                    mem[288] = sub_be75288d[arg1].field_1536
                    if sub_be75288d[arg1].field_1792:
                        if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        mem[64] = ceil32(sub_be75288d[arg1].field_1) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416
                        mem[ceil32(sub_be75288d[arg1].field_1) + 384] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                        if sub_be75288d[arg1].field_1792:
                            if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                                mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _19583 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_19583] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _22927 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_22927] = arg1
                                        mem[_22927 + 32] = 1000
                                        mem[_22927 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_22927 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _19583 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _27027 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_27027] == Mask(32, 224, mem[_27027])
                                        if Mask(32, 224, mem[_27027]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _28807 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_28807] = arg1
                                        mem[_28807 + 32] = 1000
                                        mem[_28807 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_28807 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[ceil32(sub_be75288d[arg1].field_1) + 416] = 256 * sub_be75288d[arg1].field_1800
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _19584 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_19584] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _22928 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_22928] = arg1
                                            mem[_22928 + 32] = 1000
                                            mem[_22928 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_22928 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _19584 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _27029 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_27029] == Mask(32, 224, mem[_27029])
                                            if Mask(32, 224, mem[_27029]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _28812 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_28812] = arg1
                                            mem[_28812 + 32] = 1000
                                            mem[_28812 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_28812 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(sub_be75288d[arg1].field_1) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(sub_be75288d[arg1].field_1) + 416
                                    s = 0
                                    while ceil32(sub_be75288d[arg1].field_1) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _26897 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_26897] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _29527 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_29527] = arg1
                                            mem[_29527 + 32] = 1000
                                            mem[_29527 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_29527 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _26897 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _30339 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_30339] == Mask(32, 224, mem[_30339])
                                            if Mask(32, 224, mem[_30339]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _30747 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_30747] = arg1
                                            mem[_30747 + 32] = 1000
                                            mem[_30747 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_30747 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                        else:
                            if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                                revert with 0, 34
                            if not sub_be75288d[arg1].field_1793:
                                mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _19585 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_19585] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _22929 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_22929] = arg1
                                        mem[_22929 + 32] = 1000
                                        mem[_22929 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_22929 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _19585 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _27031 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_27031] == Mask(32, 224, mem[_27031])
                                        if Mask(32, 224, mem[_27031]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _28816 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_28816] = arg1
                                        mem[_28816 + 32] = 1000
                                        mem[_28816 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_28816 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= sub_be75288d[arg1].field_1793:
                                    mem[ceil32(sub_be75288d[arg1].field_1) + 416] = 256 * sub_be75288d[arg1].field_1800
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _19586 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_19586] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _22930 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_22930] = arg1
                                            mem[_22930 + 32] = 1000
                                            mem[_22930 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_22930 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _19586 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _27033 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_27033] == Mask(32, 224, mem[_27033])
                                            if Mask(32, 224, mem[_27033]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _28821 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_28821] = arg1
                                            mem[_28821 + 32] = 1000
                                            mem[_28821 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_28821 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(sub_be75288d[arg1].field_1) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(sub_be75288d[arg1].field_1) + 416
                                    s = 0
                                    while ceil32(sub_be75288d[arg1].field_1) + sub_be75288d[arg1].field_1793 + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _26902 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_26902] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _29528 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_29528] = arg1
                                            mem[_29528 + 32] = 1000
                                            mem[_29528 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_29528 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _26902 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _30341 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_30341] == Mask(32, 224, mem[_30341])
                                            if Mask(32, 224, mem[_30341]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _30751 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_30751] = arg1
                                            mem[_30751 + 32] = 1000
                                            mem[_30751 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_30751 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                    else:
                        if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                            revert with 0, 34
                        mem[64] = ceil32(sub_be75288d[arg1].field_1) + ceil32(sub_be75288d[arg1].field_1793) + 416
                        mem[ceil32(sub_be75288d[arg1].field_1) + 384] = sub_be75288d[arg1].field_1793
                        if sub_be75288d[arg1].field_1792:
                            if sub_be75288d[arg1].field_1792 == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                                mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _19587 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_19587] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _22931 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_22931] = arg1
                                        mem[_22931 + 32] = 1000
                                        mem[_22931 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_22931 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _19587 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _27035 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_27035] == Mask(32, 224, mem[_27035])
                                        if Mask(32, 224, mem[_27035]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _28825 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_28825] = arg1
                                        mem[_28825 + 32] = 1000
                                        mem[_28825 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_28825 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[ceil32(sub_be75288d[arg1].field_1) + 416] = 256 * sub_be75288d[arg1].field_1800
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _19588 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_19588] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _22932 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_22932] = arg1
                                            mem[_22932 + 32] = 1000
                                            mem[_22932 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_22932 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _19588 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _27037 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_27037] == Mask(32, 224, mem[_27037])
                                            if Mask(32, 224, mem[_27037]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _28830 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_28830] = arg1
                                            mem[_28830 + 32] = 1000
                                            mem[_28830 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_28830 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(sub_be75288d[arg1].field_1) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(sub_be75288d[arg1].field_1) + 416
                                    s = 0
                                    while ceil32(sub_be75288d[arg1].field_1) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _26907 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_26907] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _29529 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_29529] = arg1
                                            mem[_29529 + 32] = 1000
                                            mem[_29529 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_29529 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _26907 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _30343 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_30343] == Mask(32, 224, mem[_30343])
                                            if Mask(32, 224, mem[_30343]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _30755 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_30755] = arg1
                                            mem[_30755 + 32] = 1000
                                            mem[_30755 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_30755 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                        else:
                            if sub_be75288d[arg1].field_1792 == sub_be75288d[arg1].field_1793 < 32:
                                revert with 0, 34
                            if not sub_be75288d[arg1].field_1793:
                                mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _19589 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_19589] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    if not ext_code.size(address(arg3)):
                                        _22933 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_22933] = arg1
                                        mem[_22933 + 32] = 1000
                                        mem[_22933 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_22933 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _19589 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _27039 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_27039] == Mask(32, 224, mem[_27039])
                                        if Mask(32, 224, mem[_27039]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _28834 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_28834] = arg1
                                        mem[_28834 + 32] = 1000
                                        mem[_28834 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_28834 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= sub_be75288d[arg1].field_1793:
                                    mem[ceil32(sub_be75288d[arg1].field_1) + 416] = 256 * sub_be75288d[arg1].field_1800
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _19590 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_19590] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _22934 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_22934] = arg1
                                            mem[_22934 + 32] = 1000
                                            mem[_22934 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_22934 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _19590 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _27041 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_27041] == Mask(32, 224, mem[_27041])
                                            if Mask(32, 224, mem[_27041]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _28839 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_28839] = arg1
                                            mem[_28839 + 32] = 1000
                                            mem[_28839 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_28839 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(sub_be75288d[arg1].field_1) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(sub_be75288d[arg1].field_1) + 416
                                    s = 0
                                    while ceil32(sub_be75288d[arg1].field_1) + sub_be75288d[arg1].field_1793 + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _26912 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_26912] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        if not ext_code.size(address(arg3)):
                                            _29530 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_29530] = arg1
                                            mem[_29530 + 32] = 1000
                                            mem[_29530 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_29530 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _26912 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _30345 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_30345] == Mask(32, 224, mem[_30345])
                                            if Mask(32, 224, mem[_30345]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _30759 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_30759] = arg1
                                            mem[_30759 + 32] = 1000
                                            mem[_30759 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_30759 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
}



}

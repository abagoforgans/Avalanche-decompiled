contract main {




// =====================  Runtime code  =====================


#
#  - sub_1f64e887(?)
#
const decimals = 18


mapping of uint256 balanceOf;
mapping of struct allowance;
uint256 totalSupply;
array of struct stor3;
array of struct stor4;
address owner;
array of address sub_20eea8b5;
address uniswapV2RouterAddress;
address uniswapV2PairAddress;
address futurUsePoolAddress;
address distributionPoolAddress;
address marketingWalletAddress;
uint256 rewardsFee;
uint256 liquidityPoolFee;
uint256 totalFees;
uint256 sub_6cdc78b3;
uint256 initialSupply;
array of uint256 sub_075dc237;
uint256 stor22;
uint8 stor23;
uint8 stor23; offset 8
uint256 stor23; offset 8
uint256 swapTokensAmount;
mapping of uint8 stor25;
mapping of uint8 stor26;
mapping of uint256 stor27;

function sub_075dc237(?) {
    require calldata.size - 4 >= 32
    require arg1 < 3
    return sub_075dc237[arg1]
}

function totalFees() {
    return totalFees
}

function uniswapV2Router() {
    return uniswapV2RouterAddress
}

function totalSupply() {
    return totalSupply
}

function _isBlacklisted(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    return bool(stor25[arg1])
}

function sub_20eea8b5(?) {
    require calldata.size - 4 >= 32
    require arg1 < 3
    return sub_20eea8b5[arg1]
}

function rewardsFee() {
    return rewardsFee
}

function initialSupply() {
    return initialSupply
}

function uniswapV2Pair() {
    return uniswapV2PairAddress
}

function liquidityPoolFee() {
    return liquidityPoolFee
}

function swapTokensAmount() {
    return swapTokensAmount
}

function sub_6cdc78b3(?) {
    return sub_6cdc78b3
}

function balanceOf(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    return balanceOf[address(arg1)]
}

function marketingWallet() {
    return marketingWalletAddress
}

function owner() {
    return owner
}

function futurUsePool() {
    return futurUsePoolAddress
}

function automatedMarketMakerPairs(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    return bool(stor26[arg1])
}

function distributionPool() {
    return distributionPoolAddress
}

function allowance(address arg1, address arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require arg2 == arg2
    return allowance[address(arg1)][address(arg2)].field_0
}

function renounceOwnership() {
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    emit OwnershipTransferred(owner, 0);
    owner = 0
}

function updateRwSwapFee(uint256 arg1) {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    stor22 = arg1
}

function updateSwapTokensAmount(uint256 arg1) {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    swapTokensAmount = arg1
}

function updateFuturWall(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    futurUsePoolAddress = arg1
}

function updateRewardsWall(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    distributionPoolAddress = arg1
}

function updateMarketingWallet(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    marketingWalletAddress = arg1
}

function sub_cc9850a4(?) {
    require calldata.size - 4 >= 64
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if arg1 >= 3:
        revert with 0, 'Invalid rune id'
    sub_075dc237[arg1] = arg2
}

function changeSwapLiquify(bool arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    Mask(248, 0, stor23.field_8) = Mask(248, 0, arg1)
}

function sub_2275c385(?) {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if arg1 <= sub_6cdc78b3:
        revert with 0, 'Invalid max node number'
    sub_6cdc78b3 = arg1
}

function sub_a8682e1c(?) {
    require calldata.size - 4 >= 64
    require arg1 == address(arg1)
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if arg2 >= 3:
        revert with 0, 50
    sub_20eea8b5[arg2] = address(arg1)
}

function blacklistMalicious(address arg1, bool arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require arg2 == arg2
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    stor25[address(arg1)] = uint8(arg2)
}

function updateLiquiditFee(uint256 arg1) {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    liquidityPoolFee = arg1
    if rewardsFee > !arg1:
        revert with 0, 17
    if rewardsFee + arg1 < rewardsFee:
        revert with 0, 'SafeMath: addition overflow'
    totalFees = rewardsFee + arg1
}

function updateRewardsFee(uint256 arg1) {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    rewardsFee = arg1
    if arg1 > !liquidityPoolFee:
        revert with 0, 17
    if arg1 + liquidityPoolFee < arg1:
        revert with 0, 'SafeMath: addition overflow'
    totalFees = arg1 + liquidityPoolFee
}

function transferOwnership(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Ownable: new owner is the zero address'
    emit OwnershipTransferred(owner, arg1);
    owner = arg1
}

function sub_a87ec2f7(?) {
    require calldata.size - 4 >= 32
    if arg1 >= 3:
        revert with 0, 50
    require ext_code.size(sub_20eea8b5[arg1])
    staticcall sub_20eea8b5[arg1].0xcc0915d with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    return ext_call.return_data[0]
}

function sub_7977061e(?) {
    require calldata.size - 4 >= 32
    if arg1 >= 3:
        revert with 0, 50
    require ext_code.size(sub_20eea8b5[arg1])
    staticcall sub_20eea8b5[arg1].0xde72f0ba with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    return ext_call.return_data[0]
}

function sub_d8eb77f7(?) {
    require calldata.size - 4 >= 32
    if arg1 >= 3:
        revert with 0, 50
    require ext_code.size(sub_20eea8b5[arg1])
    staticcall sub_20eea8b5[arg1].rewardPerSec() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    return ext_call.return_data[0]
}

function getNodePrice(uint256 arg1) {
    require calldata.size - 4 >= 32
    if arg1 >= 3:
        revert with 0, 50
    require ext_code.size(sub_20eea8b5[arg1])
    staticcall sub_20eea8b5[arg1].nodePrice() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    return ext_call.return_data[0]
}

function sub_15494a58(?) {
    require calldata.size - 4 >= 64
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if arg2 >= 3:
        revert with 0, 50
    require ext_code.size(sub_20eea8b5[arg2])
    call sub_20eea8b5[arg2].0xe65ce64 with:
         gas gas_remaining wei
        args arg1
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
}

function sub_c239eec5(?) {
    require calldata.size - 4 >= 64
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if arg2 >= 3:
        revert with 0, 50
    require ext_code.size(sub_20eea8b5[arg2])
    call sub_20eea8b5[arg2].0x81958c5c with:
         gas gas_remaining wei
        args arg1
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
}

function sub_e6e9b2b9(?) {
    require calldata.size - 4 >= 64
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if arg2 >= 3:
        revert with 0, 50
    require ext_code.size(sub_20eea8b5[arg2])
    call sub_20eea8b5[arg2].0x6da3c5c4 with:
         gas gas_remaining wei
        args arg1
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
}

function sub_43369165(?) {
    require calldata.size - 4 >= 64
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if arg2 >= 3:
        revert with 0, 50
    require ext_code.size(sub_20eea8b5[arg2])
    call sub_20eea8b5[arg2]._changeNodePrice(uint256 arg1) with:
         gas gas_remaining wei
        args arg1
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
}

function sub_340afa77(?) {
    require calldata.size - 4 >= 64
    require arg1 == address(arg1)
    if arg2 >= 3:
        revert with 0, 50
    require ext_code.size(sub_20eea8b5[arg2])
    staticcall sub_20eea8b5[arg2].0xf55e6f79 with:
            gas gas_remaining wei
           args address(arg1)
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    return ext_call.return_data[0]
}

function sub_9ceb5c48(?) {
    require calldata.size - 4 >= 64
    require arg1 == address(arg1)
    if arg2 >= 3:
        revert with 0, 50
    require ext_code.size(sub_20eea8b5[arg2])
    staticcall sub_20eea8b5[arg2].0x80e9be34 with:
            gas gas_remaining wei
           args address(arg1), 1
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    return ext_call.return_data[0]
}

function sub_34b05227(?) {
    require calldata.size - 4 >= 64
    require arg1 == address(arg1)
    if arg2 >= 3:
        revert with 0, 50
    require ext_code.size(sub_20eea8b5[arg2])
    staticcall sub_20eea8b5[arg2]._getNodeNumberOf(address arg1) with:
            gas gas_remaining wei
           args address(arg1)
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    return ext_call.return_data[0]
}

function boostReward(uint256 arg1) {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if arg1 <= eth.balance(this.address):
        call owner with:
           value arg1 wei
             gas 2300 * is_zero(value) wei
    else:
        call owner with:
           value eth.balance(this.address) wei
             gas 2300 * is_zero(value) wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
}

function approve(address arg1, uint256 arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    if not msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: approve from the zero address'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: approve to the zero address'
    allowance[address(msg.sender)][address(arg1)].field_0 = arg2
    emit Approval(arg2, msg.sender, arg1);
    return 1
}

function mint(uint256 arg1) {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if arg1 <= 0:
        revert with 0, 'Invalid amount'
    if not owner:
        revert with 0, 'ERC20: mint to the zero address'
    if totalSupply > !arg1:
        revert with 0, 17
    if totalSupply + arg1 < totalSupply:
        revert with 0, 'SafeMath: addition overflow'
    totalSupply += arg1
    if balanceOf[stor5] > !arg1:
        revert with 0, 17
    if balanceOf[stor5] + arg1 < balanceOf[stor5]:
        revert with 0, 'SafeMath: addition overflow'
    balanceOf[stor5] += arg1
    emit Transfer(arg1, 0, owner);
}

function setAutomatedMarketMakerPair(address arg1, bool arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require arg2 == arg2
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if uniswapV2PairAddress == arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    'TKN: The PancakeSwap pair cannot be removed from automatedMarketMakerPairs'
    if arg2 == bool(stor26[address(arg1)]):
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    'TKN: Automated market maker pair is already set to that value'
    stor26[address(arg1)] = uint8(arg2)
    emit SetAutomatedMarketMakerPair(arg1, arg2);
}

function decreaseAllowance(address arg1, uint256 arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    if arg2 > allowance[msg.sender][address(arg1)].field_0:
        revert with 0, 32, 37, 0x6545524332303a2064656372656173656420616c6c6f77616e63652062656c6f77207a6572, mem[165 len 27] >> 40, 0
    if allowance[msg.sender][address(arg1)].field_0 < arg2:
        revert with 0, 17
    if not msg.sender:
        revert with 0, 'ERC20: approve from the zero address'
    if not arg1:
        revert with 0, 'ERC20: approve to the zero address'
    allowance[address(msg.sender)][address(arg1)].field_0 = allowance[msg.sender][address(arg1)].field_0 - arg2
    emit Approval((allowance[msg.sender][address(arg1)].field_0 - arg2), msg.sender, arg1);
    return 1
}

function getTotalCreatedNodes() payable {
    mem[64] = 96
    require not msg.value
    idx = 0
    s = 0
    while idx < 3:
        require ext_code.size(sub_20eea8b5[idx])
        staticcall sub_20eea8b5[idx].totalNodesCreated() with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _11 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        if s > !mem[_11]:
            revert with 0, 17
        if s + mem[_11] < s:
            revert with 0, 'SafeMath: addition overflow'
        if idx == -1:
            revert with 0, 17
        idx = idx + 1
        s = s + mem[_11]
        continue 
    return (0x6f32f1ef8b18a2bc3cea59789c79d441 * s)
}

function increaseAllowance(address arg1, uint256 arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    if allowance[msg.sender][address(arg1)].field_0 > !arg2:
        revert with 0, 17
    if allowance[msg.sender][address(arg1)].field_0 + arg2 < allowance[msg.sender][address(arg1)].field_0:
        revert with 0, 'SafeMath: addition overflow'
    if not msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: approve from the zero address'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: approve to the zero address'
    allowance[address(msg.sender)][address(arg1)].field_0 = allowance[msg.sender][address(arg1)].field_0 + arg2
    emit Approval((allowance[msg.sender][address(arg1)].field_0 + arg2), msg.sender, arg1);
    return 1
}

function getRewardAmount(uint256 arg1) {
    require calldata.size - 4 >= 32
    if not msg.sender:
        revert with 0, 'SENDER CAN'T BE ZERO'
    if arg1 >= 3:
        revert with 0, 50
    require ext_code.size(sub_20eea8b5[arg1])
    staticcall sub_20eea8b5[arg1]._isNodeOwner(address arg1) with:
            gas gas_remaining wei
           args msg.sender
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if not ext_call.return_data[0]:
        revert with 0, 'NO NODE OWNER'
    if arg1 >= 3:
        revert with 0, 50
    require ext_code.size(sub_20eea8b5[arg1])
    staticcall sub_20eea8b5[arg1].0x80e9be34 with:
            gas gas_remaining wei
           args msg.sender, 1
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    return ext_call.return_data[0]
}

function transfer(address arg1, uint256 arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    if not msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: transfer from the zero address'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: transfer to the zero address'
    if stor25[address(msg.sender)]:
        revert with 0, 'Blacklisted address'
    if stor25[address(arg1)]:
        revert with 0, 'Blacklisted address'
    if not msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: transfer from the zero address'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: transfer to the zero address'
    if arg2 > balanceOf[address(msg.sender)]:
        revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[166 len 26] >> 48, 0
    if balanceOf[address(msg.sender)] < arg2:
        revert with 0, 17
    balanceOf[address(msg.sender)] -= arg2
    if balanceOf[arg1] > !arg2:
        revert with 0, 17
    if balanceOf[arg1] + arg2 < balanceOf[arg1]:
        revert with 0, 'SafeMath: addition overflow'
    balanceOf[address(arg1)] = balanceOf[arg1] + arg2
    emit Transfer(arg2, msg.sender, arg1);
    return 1
}

function updateUniswapV2Router(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if uniswapV2RouterAddress == arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'TKN: The router already has that address'
    emit UpdateUniswapV2Router(arg1, uniswapV2RouterAddress);
    uniswapV2RouterAddress = arg1
    require ext_code.size(arg1)
    staticcall arg1.factory() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    require ext_code.size(uniswapV2RouterAddress)
    staticcall uniswapV2RouterAddress.WAVAX() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    require ext_code.size(address(ext_call.return_data[0]))
    call address(ext_call.return_data[0]).createPair(address arg1, address arg2) with:
         gas gas_remaining wei
        args address(this.address), address(ext_call.return_data[0])
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    uniswapV2PairAddress = ext_call.return_data[12 len 20]
}

function transferFrom(address arg1, address arg2, uint256 arg3) {
    require calldata.size - 4 >= 96
    require arg1 == arg1
    require arg2 == arg2
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: transfer from the zero address'
    if not arg2:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: transfer to the zero address'
    if stor25[address(arg1)]:
        revert with 0, 'Blacklisted address'
    if stor25[address(arg2)]:
        revert with 0, 'Blacklisted address'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: transfer from the zero address'
    if not arg2:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: transfer to the zero address'
    if arg3 > balanceOf[address(arg1)]:
        revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[166 len 26] >> 48, 0
    if balanceOf[address(arg1)] < arg3:
        revert with 0, 17
    balanceOf[address(arg1)] -= arg3
    if balanceOf[arg2] > !arg3:
        revert with 0, 17
    if balanceOf[arg2] + arg3 < balanceOf[arg2]:
        revert with 0, 'SafeMath: addition overflow'
    balanceOf[address(arg2)] = balanceOf[arg2] + arg3
    emit Transfer(arg3, arg1, arg2);
    if arg3 > allowance[address(arg1)][msg.sender].field_0:
        revert with 0, 32, 40, 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[264 len 24] >> 64, 0
    if allowance[address(arg1)][msg.sender].field_0 < arg3:
        revert with 0, 17
    if not arg1:
        revert with 0, 'ERC20: approve from the zero address'
    if not msg.sender:
        revert with 0, 'ERC20: approve to the zero address'
    allowance[address(arg1)][address(msg.sender)].field_0 = allowance[address(arg1)][msg.sender].field_0 - arg3
    emit Approval((allowance[address(arg1)][msg.sender].field_0 - arg3), arg1, msg.sender);
    return 1
}

function name() {
    if bool(stor3.length):
        if bool(stor3.length) == uint255(stor3.length) * 0.5 < 32:
            revert with 0, 34
        if bool(stor3.length):
            if bool(stor3.length) == uint255(stor3.length) * 0.5 < 32:
                revert with 0, 34
            if Mask(256, -1, stor3.length):
                if 31 < uint255(stor3.length) * 0.5:
                    mem[128] = uint256(stor3.field_0)
                    idx = 128
                    s = 0
                    while (uint255(stor3.length) * 0.5) + 96 > idx:
                        mem[idx + 32] = stor3[s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    return Array(len=2 * Mask(256, -1, stor3.length), data=mem[128 len ceil32(uint255(stor3.length) * 0.5)])
                mem[128] = 256 * stor3.length.field_8
        else:
            if bool(stor3.length) == stor3.length.field_1 < 32:
                revert with 0, 34
            if stor3.length.field_1:
                if 31 < stor3.length.field_1:
                    mem[128] = uint256(stor3.field_0)
                    idx = 128
                    s = 0
                    while stor3.length.field_1 + 96 > idx:
                        mem[idx + 32] = stor3[s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    return Array(len=2 * Mask(256, -1, stor3.length), data=mem[128 len ceil32(uint255(stor3.length) * 0.5)])
                mem[128] = 256 * stor3.length.field_8
        mem[ceil32(uint255(stor3.length) * 0.5) + 192 len ceil32(uint255(stor3.length) * 0.5)] = mem[128 len ceil32(uint255(stor3.length) * 0.5)]
        if ceil32(uint255(stor3.length) * 0.5) > uint255(stor3.length) * 0.5:
            mem[ceil32(uint255(stor3.length) * 0.5) + (uint255(stor3.length) * 0.5) + 192] = 0
        return Array(len=2 * Mask(256, -1, stor3.length), data=mem[128 len ceil32(uint255(stor3.length) * 0.5)], mem[(2 * ceil32(uint255(stor3.length) * 0.5)) + 192 len 2 * ceil32(uint255(stor3.length) * 0.5)]), 
    if bool(stor3.length) == stor3.length.field_1 < 32:
        revert with 0, 34
    if bool(stor3.length):
        if bool(stor3.length) == uint255(stor3.length) * 0.5 < 32:
            revert with 0, 34
        if Mask(256, -1, stor3.length):
            if 31 < uint255(stor3.length) * 0.5:
                mem[128] = uint256(stor3.field_0)
                idx = 128
                s = 0
                while (uint255(stor3.length) * 0.5) + 96 > idx:
                    mem[idx + 32] = stor3[s].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
                return Array(len=stor3.length % 128, data=mem[128 len ceil32(stor3.length.field_1)])
            mem[128] = 256 * stor3.length.field_8
    else:
        if bool(stor3.length) == stor3.length.field_1 < 32:
            revert with 0, 34
        if stor3.length.field_1:
            if 31 < stor3.length.field_1:
                mem[128] = uint256(stor3.field_0)
                idx = 128
                s = 0
                while stor3.length.field_1 + 96 > idx:
                    mem[idx + 32] = stor3[s].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
                return Array(len=stor3.length % 128, data=mem[128 len ceil32(stor3.length.field_1)])
            mem[128] = 256 * stor3.length.field_8
    mem[ceil32(stor3.length.field_1) + 192 len ceil32(stor3.length.field_1)] = mem[128 len ceil32(stor3.length.field_1)]
    if ceil32(stor3.length.field_1) > stor3.length.field_1:
        mem[ceil32(stor3.length.field_1) + stor3.length.field_1 + 192] = 0
    return Array(len=stor3.length % 128, data=mem[128 len ceil32(stor3.length.field_1)], mem[(2 * ceil32(stor3.length.field_1)) + 192 len 2 * ceil32(stor3.length.field_1)]), 
}

function symbol() {
    if bool(stor4.length):
        if bool(stor4.length) == uint255(stor4.length) * 0.5 < 32:
            revert with 0, 34
        if bool(stor4.length):
            if bool(stor4.length) == uint255(stor4.length) * 0.5 < 32:
                revert with 0, 34
            if Mask(256, -1, stor4.length):
                if 31 < uint255(stor4.length) * 0.5:
                    mem[128] = uint256(stor4.field_0)
                    idx = 128
                    s = 0
                    while (uint255(stor4.length) * 0.5) + 96 > idx:
                        mem[idx + 32] = stor4[s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    return Array(len=2 * Mask(256, -1, stor4.length), data=mem[128 len ceil32(uint255(stor4.length) * 0.5)])
                mem[128] = 256 * stor4.length.field_8
        else:
            if bool(stor4.length) == stor4.length.field_1 < 32:
                revert with 0, 34
            if stor4.length.field_1:
                if 31 < stor4.length.field_1:
                    mem[128] = uint256(stor4.field_0)
                    idx = 128
                    s = 0
                    while stor4.length.field_1 + 96 > idx:
                        mem[idx + 32] = stor4[s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    return Array(len=2 * Mask(256, -1, stor4.length), data=mem[128 len ceil32(uint255(stor4.length) * 0.5)])
                mem[128] = 256 * stor4.length.field_8
        mem[ceil32(uint255(stor4.length) * 0.5) + 192 len ceil32(uint255(stor4.length) * 0.5)] = mem[128 len ceil32(uint255(stor4.length) * 0.5)]
        if ceil32(uint255(stor4.length) * 0.5) > uint255(stor4.length) * 0.5:
            mem[ceil32(uint255(stor4.length) * 0.5) + (uint255(stor4.length) * 0.5) + 192] = 0
        return Array(len=2 * Mask(256, -1, stor4.length), data=mem[128 len ceil32(uint255(stor4.length) * 0.5)], mem[(2 * ceil32(uint255(stor4.length) * 0.5)) + 192 len 2 * ceil32(uint255(stor4.length) * 0.5)]), 
    if bool(stor4.length) == stor4.length.field_1 < 32:
        revert with 0, 34
    if bool(stor4.length):
        if bool(stor4.length) == uint255(stor4.length) * 0.5 < 32:
            revert with 0, 34
        if Mask(256, -1, stor4.length):
            if 31 < uint255(stor4.length) * 0.5:
                mem[128] = uint256(stor4.field_0)
                idx = 128
                s = 0
                while (uint255(stor4.length) * 0.5) + 96 > idx:
                    mem[idx + 32] = stor4[s].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
                return Array(len=stor4.length % 128, data=mem[128 len ceil32(stor4.length.field_1)])
            mem[128] = 256 * stor4.length.field_8
    else:
        if bool(stor4.length) == stor4.length.field_1 < 32:
            revert with 0, 34
        if stor4.length.field_1:
            if 31 < stor4.length.field_1:
                mem[128] = uint256(stor4.field_0)
                idx = 128
                s = 0
                while stor4.length.field_1 + 96 > idx:
                    mem[idx + 32] = stor4[s].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
                return Array(len=stor4.length % 128, data=mem[128 len ceil32(stor4.length.field_1)])
            mem[128] = 256 * stor4.length.field_8
    mem[ceil32(stor4.length.field_1) + 192 len ceil32(stor4.length.field_1)] = mem[128 len ceil32(stor4.length.field_1)]
    if ceil32(stor4.length.field_1) > stor4.length.field_1:
        mem[ceil32(stor4.length.field_1) + stor4.length.field_1 + 192] = 0
    return Array(len=stor4.length % 128, data=mem[128 len ceil32(stor4.length.field_1)], mem[(2 * ceil32(stor4.length.field_1)) + 192 len 2 * ceil32(stor4.length.field_1)]), 
}

function cashoutAll() payable {
    mem[64] = 96
    require not msg.value
    mem[0] = msg.sender
    mem[32] = 25
    if stor25[msg.sender]:
        revert with 0, 'Cashout: Blacklisted address'
    if not msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'MANIA CSHT:  creation from the zero address'
    if futurUsePoolAddress == msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    'MANIA CSHT: futur, marketing and rewardsPool cannot cashout rewards'
    if distributionPoolAddress == msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    'MANIA CSHT: futur, marketing and rewardsPool cannot cashout rewards'
    if marketingWalletAddress == msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    'MANIA CSHT: futur, marketing and rewardsPool cannot cashout rewards'
    idx = 0
    while idx < 3:
        mem[mem[64] + 4] = msg.sender
        require ext_code.size(sub_20eea8b5[idx])
        staticcall sub_20eea8b5[idx]._getNodeNumberOf(address arg1) with:
                gas gas_remaining wei
               args msg.sender
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _37 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        if mem[_37]:
            if idx >= 3:
                revert with 0, 50
            mem[mem[64] + 4] = msg.sender
            mem[mem[64] + 36] = 1
            require ext_code.size(sub_20eea8b5[idx])
            staticcall sub_20eea8b5[idx].0x80e9be34 with:
                    gas gas_remaining wei
                   args msg.sender, 1
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _43 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _44 = mem[_43]
            if 0 > !mem[_43]:
                revert with 0, 17
            if mem[_43] < 0:
                revert with 0, 'SafeMath: addition overflow'
            if idx >= 3:
                revert with 0, 50
            mem[mem[64] + 4] = msg.sender
            mem[mem[64] + 36] = 0
            require ext_code.size(sub_20eea8b5[idx])
            staticcall sub_20eea8b5[idx].0x80e9be34 with:
                    gas gas_remaining wei
                   args msg.sender, 0
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _49 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            if 0 > !mem[_49]:
                revert with 0, 17
            if mem[_49] < 0:
                revert with 0, 'SafeMath: addition overflow'
            if idx >= 3:
                revert with 0, 50
            if not _44:
                _53 = mem[64]
                mem[64] = mem[64] + 64
                mem[_53] = 26
                mem[_53 + 32] = 'SafeMath: division by zero'
            else:
                if _44 and sub_075dc237[idx] > -1 / _44:
                    revert with 0, 17
                if not _44:
                    revert with 0, 18
                if _44 * sub_075dc237[idx] / _44 != sub_075dc237[idx]:
                    revert with 0, 'SafeMath: multiplication overflow'
                _56 = mem[64]
                mem[64] = mem[64] + 64
                mem[_56] = 26
                mem[_56 + 32] = 'SafeMath: division by zero'
                if 0 > !(_44 * sub_075dc237[idx] / 100):
                    revert with 0, 17
                if _44 * sub_075dc237[idx] / 100 < 0:
                    revert with 0, 'SafeMath: addition overflow'
        if idx == -1:
            revert with 0, 17
        idx = idx + 1
        continue 
    revert with 0, 'AgamottoToken: You don't have enough reward to cash out'
}

function sub_ef690f34(?) {
    require calldata.size - 4 >= 64
    if not msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'AgamottoToken:  creation from the zero address'
    if stor25[address(msg.sender)]:
        revert with 0, 'Cashout: Blacklisted address'
    if futurUsePoolAddress == msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    'CSHT: futur, marketing and rewardsPool cannot cashout rewards'
    if distributionPoolAddress == msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    'CSHT: futur, marketing and rewardsPool cannot cashout rewards'
    if marketingWalletAddress == msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    'CSHT: futur, marketing and rewardsPool cannot cashout rewards'
    if arg1 >= 3:
        revert with 0, 50
    require ext_code.size(sub_20eea8b5[arg1])
    staticcall sub_20eea8b5[arg1]._getNodeNumberOf(address arg1) with:
            gas gas_remaining wei
           args msg.sender
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if ext_call.return_data[0]:
        if arg1 >= 3:
            revert with 0, 50
        mem[ceil32(return_data.size) + 100] = msg.sender
        mem[ceil32(return_data.size) + 132] = arg2
        mem[ceil32(return_data.size) + 164] = 1
        require ext_code.size(sub_20eea8b5[arg1])
        staticcall sub_20eea8b5[arg1].0x288d8855 with:
                gas gas_remaining wei
               args msg.sender, arg2, 1
        mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if arg1 >= 3:
            revert with 0, 50
        mem[(2 * ceil32(return_data.size)) + 100] = msg.sender
        mem[(2 * ceil32(return_data.size)) + 132] = arg2
        mem[(2 * ceil32(return_data.size)) + 164] = 0
        require ext_code.size(sub_20eea8b5[arg1])
        staticcall sub_20eea8b5[arg1].0x288d8855 with:
                gas gas_remaining wei
               args msg.sender, arg2, 0
        mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if ext_call.return_data[0] > ext_call.return_data[0]:
            revert with 0, 'SafeMath: subtraction overflow', 0
        if ext_call.return_data[0] < ext_call.return_data[0]:
            revert with 0, 17
        if ext_call.return_data[0] <= 0:
            revert with 0, 'CSHT: You don't have enough reward to cash out'
        if not uint8(stor23.field_8):
            if not distributionPoolAddress:
                revert with 0, 'ERC20: transfer from the zero address'
            if not msg.sender:
                revert with 0, 'ERC20: transfer to the zero address'
            if ext_call.return_data[0] > balanceOf[stor12]:
                revert with 0, 
                            32,
                            38,
                            0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[(4 * ceil32(return_data.size)) + 230 len 26] >> 48,
                            0
            if balanceOf[stor12] < ext_call.return_data[0]:
                revert with 0, 17
            balanceOf[stor12] -= ext_call.return_data[0]
            if balanceOf[msg.sender] > !ext_call.return_data[0]:
                revert with 0, 17
            if balanceOf[msg.sender] + ext_call.return_data[0] < balanceOf[msg.sender]:
                revert with 0, 'SafeMath: addition overflow'
            balanceOf[address(msg.sender)] = balanceOf[msg.sender] + ext_call.return_data[0]
            emit Transfer(ext_call.return_data[0], distributionPoolAddress, msg.sender);
        else:
            if arg1 >= 3:
                revert with 0, 50
            if sub_075dc237[arg1] <= 0:
                if 0 > ext_call.return_data[0]:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if ext_call.return_data[0] < 0:
                    revert with 0, 17
                if not distributionPoolAddress:
                    revert with 0, 'ERC20: transfer from the zero address'
                if not msg.sender:
                    revert with 0, 'ERC20: transfer to the zero address'
                if ext_call.return_data[0] > balanceOf[stor12]:
                    revert with 0, 
                                32,
                                38,
                                0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[(4 * ceil32(return_data.size)) + 294 len 26] >> 48,
                                0
                if balanceOf[stor12] < ext_call.return_data[0]:
                    revert with 0, 17
                balanceOf[stor12] -= ext_call.return_data[0]
                if balanceOf[msg.sender] > !ext_call.return_data[0]:
                    revert with 0, 17
                if balanceOf[msg.sender] + ext_call.return_data[0] < balanceOf[msg.sender]:
                    revert with 0, 'SafeMath: addition overflow'
                balanceOf[address(msg.sender)] = balanceOf[msg.sender] + ext_call.return_data[0]
                emit Transfer(ext_call.return_data[0], distributionPoolAddress, msg.sender);
            else:
                if arg1 >= 3:
                    revert with 0, 50
                if not ext_call.return_data[0]:
                    if not distributionPoolAddress:
                        revert with 0, 'ERC20: transfer from the zero address'
                    if not this.address:
                        revert with 0, 'ERC20: transfer to the zero address'
                    if 0 > balanceOf[stor12]:
                        revert with 0, 
                                    32,
                                    38,
                                    0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[(4 * ceil32(return_data.size)) + 294 len 26] >> 48,
                                    0
                    if balanceOf[stor12] < 0:
                        revert with 0, 17
                    if balanceOf[this.address] > !0:
                        revert with 0, 17
                    if balanceOf[this.address] < balanceOf[this.address]:
                        revert with 0, 'SafeMath: addition overflow'
                    balanceOf[address(this.address)] = balanceOf[this.address]
                    emit Transfer(0, distributionPoolAddress, this.address);
                    mem[(4 * ceil32(return_data.size)) + 352] = this.address
                    require ext_code.size(uniswapV2RouterAddress)
                    staticcall uniswapV2RouterAddress.WAVAX() with:
                            gas gas_remaining wei
                    mem[(4 * ceil32(return_data.size)) + 416] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                    mem[(4 * ceil32(return_data.size)) + 384] = ext_call.return_data[12 len 20]
                    if not this.address:
                        revert with 0, 'ERC20: approve from the zero address', mem[(6 * ceil32(return_data.size)) + 548 len 9 * ceil32(return_data.size)]
                    if not uniswapV2RouterAddress:
                        revert with 0, 'ERC20: approve to the zero address', mem[(6 * ceil32(return_data.size)) + 548 len 9 * ceil32(return_data.size)]
                    allowance[address(this.address)][stor9].field_0 = 0
                    emit Approval(address arg1, address arg2, uint256 arg3):
                                  0,
                                  mem[(6 * ceil32(return_data.size)) + 448 len 9 * ceil32(return_data.size)],
                                  this.address,
                                  uniswapV2RouterAddress,
                    mem[(6 * ceil32(return_data.size)) + 416] = 0x762b156200000000000000000000000000000000000000000000000000000000
                    mem[(6 * ceil32(return_data.size)) + 420] = 0
                    idx = 0
                    s = (6 * ceil32(return_data.size)) + 612
                    t = (4 * ceil32(return_data.size)) + 352
                    while idx < 2:
                        mem[s] = mem[t + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    require ext_code.size(uniswapV2RouterAddress)
                    call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                         gas gas_remaining wei
                        args 0, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 612 len 64]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if eth.balance(this.address) > eth.balance(this.address):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if eth.balance(this.address) < eth.balance(this.address):
                        revert with 0, 17
                    call futurUsePoolAddress with:
                         gas 2300 wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if 0 > ext_call.return_data[0]:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if ext_call.return_data[0] < 0:
                        revert with 0, 17
                    if not distributionPoolAddress:
                        revert with 0, 'ERC20: transfer from the zero address'
                    if not msg.sender:
                        revert with 0, 'ERC20: transfer to the zero address'
                    if ext_call.return_data[0] > balanceOf[stor12]:
                        revert with 0, 
                                    32,
                                    38,
                                    0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[(6 * ceil32(return_data.size)) + 614 len 26] >> 48,
                                    0
                    if balanceOf[stor12] < ext_call.return_data[0]:
                        revert with 0, 17
                    balanceOf[stor12] -= ext_call.return_data[0]
                    if balanceOf[msg.sender] > !ext_call.return_data[0]:
                        revert with 0, 17
                    if balanceOf[msg.sender] + ext_call.return_data[0] < balanceOf[msg.sender]:
                        revert with 0, 'SafeMath: addition overflow'
                    balanceOf[address(msg.sender)] = balanceOf[msg.sender] + ext_call.return_data[0]
                    emit Transfer(ext_call.return_data[0], distributionPoolAddress, msg.sender);
                else:
                    if ext_call.return_data[0] and sub_075dc237[arg1] > -1 / ext_call.return_data[0]:
                        revert with 0, 17
                    if not ext_call.return_data[0]:
                        revert with 0, 18
                    if ext_call.return_data[0] * sub_075dc237[arg1] / ext_call.return_data[0] != sub_075dc237[arg1]:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if ext_call.return_data[0] * sub_075dc237[arg1] / 100 > !0:
                        revert with 0, 17
                    if ext_call.return_data[0] * sub_075dc237[arg1] / 100 < ext_call.return_data[0] * sub_075dc237[arg1] / 100:
                        revert with 0, 'SafeMath: addition overflow'
                    if not distributionPoolAddress:
                        revert with 0, 'ERC20: transfer from the zero address'
                    if not this.address:
                        revert with 0, 'ERC20: transfer to the zero address'
                    if ext_call.return_data[0] * sub_075dc237[arg1] / 100 > balanceOf[stor12]:
                        revert with 0, 
                                    32,
                                    38,
                                    0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[(4 * ceil32(return_data.size)) + 294 len 26] >> 48,
                                    0
                    if balanceOf[stor12] < ext_call.return_data[0] * sub_075dc237[arg1] / 100:
                        revert with 0, 17
                    balanceOf[stor12] -= ext_call.return_data[0] * sub_075dc237[arg1] / 100
                    if balanceOf[this.address] > !(ext_call.return_data[0] * sub_075dc237[arg1] / 100):
                        revert with 0, 17
                    if balanceOf[this.address] + (ext_call.return_data[0] * sub_075dc237[arg1] / 100) < balanceOf[this.address]:
                        revert with 0, 'SafeMath: addition overflow'
                    balanceOf[address(this.address)] = balanceOf[this.address] + (ext_call.return_data[0] * sub_075dc237[arg1] / 100)
                    emit Transfer((ext_call.return_data[0] * sub_075dc237[arg1] / 100), distributionPoolAddress, this.address);
                    if ext_call.return_data[0] * sub_075dc237[arg1] / 100 > !0:
                        revert with 0, 17
                    if ext_call.return_data[0] * sub_075dc237[arg1] / 100 < ext_call.return_data[0] * sub_075dc237[arg1] / 100:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[(4 * ceil32(return_data.size)) + 352] = this.address
                    require ext_code.size(uniswapV2RouterAddress)
                    staticcall uniswapV2RouterAddress.WAVAX() with:
                            gas gas_remaining wei
                    mem[(4 * ceil32(return_data.size)) + 416] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                    mem[(4 * ceil32(return_data.size)) + 384] = ext_call.return_data[12 len 20]
                    if not this.address:
                        revert with 0, 'ERC20: approve from the zero address', mem[(6 * ceil32(return_data.size)) + 548 len 9 * ceil32(return_data.size)]
                    if not uniswapV2RouterAddress:
                        revert with 0, 'ERC20: approve to the zero address', mem[(6 * ceil32(return_data.size)) + 548 len 9 * ceil32(return_data.size)]
                    allowance[address(this.address)][stor9].field_0 = ext_call.return_data[0] * sub_075dc237[arg1] / 100
                    emit Approval(address arg1, address arg2, uint256 arg3):
                                  ext_call.return_data[0] * sub_075dc237[arg1] / 100,
                                  mem[(6 * ceil32(return_data.size)) + 448 len 9 * ceil32(return_data.size)],
                                  this.address,
                                  uniswapV2RouterAddress,
                    mem[(6 * ceil32(return_data.size)) + 416] = 0x762b156200000000000000000000000000000000000000000000000000000000
                    mem[(6 * ceil32(return_data.size)) + 420] = ext_call.return_data[0] * sub_075dc237[arg1] / 100
                    idx = 0
                    s = (6 * ceil32(return_data.size)) + 612
                    t = (4 * ceil32(return_data.size)) + 352
                    while idx < 2:
                        mem[s] = mem[t + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    require ext_code.size(uniswapV2RouterAddress)
                    call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                         gas gas_remaining wei
                        args ext_call.return_data[0] * sub_075dc237[arg1] / 100, 0, 160, address(this.address), block.timestamp, 2, mem[(6 * ceil32(return_data.size)) + 612 len 64]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if eth.balance(this.address) > eth.balance(this.address):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if eth.balance(this.address) < eth.balance(this.address):
                        revert with 0, 17
                    call futurUsePoolAddress with:
                         gas 2300 wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if ext_call.return_data[0] * sub_075dc237[arg1] / 100 > ext_call.return_data[0]:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if ext_call.return_data[0] < ext_call.return_data[0] * sub_075dc237[arg1] / 100:
                        revert with 0, 17
                    if not distributionPoolAddress:
                        revert with 0, 'ERC20: transfer from the zero address'
                    if not msg.sender:
                        revert with 0, 'ERC20: transfer to the zero address'
                    if ext_call.return_data[0] - (ext_call.return_data[0] * sub_075dc237[arg1] / 100) > balanceOf[stor12]:
                        revert with 0, 
                                    32,
                                    38,
                                    0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[(6 * ceil32(return_data.size)) + 614 len 26] >> 48,
                                    0
                    if balanceOf[stor12] < ext_call.return_data[0] - (ext_call.return_data[0] * sub_075dc237[arg1] / 100):
                        revert with 0, 17
                    balanceOf[stor12] = balanceOf[stor12] - ext_call.return_data[0] + (ext_call.return_data[0] * sub_075dc237[arg1] / 100)
                    if balanceOf[msg.sender] > !(ext_call.return_data[0] - (ext_call.return_data[0] * sub_075dc237[arg1] / 100)):
                        revert with 0, 17
                    if balanceOf[msg.sender] + ext_call.return_data[0] - (ext_call.return_data[0] * sub_075dc237[arg1] / 100) < balanceOf[msg.sender]:
                        revert with 0, 'SafeMath: addition overflow'
                    balanceOf[address(msg.sender)] = balanceOf[msg.sender] + ext_call.return_data[0] - (ext_call.return_data[0] * sub_075dc237[arg1] / 100)
                    emit Transfer((ext_call.return_data[0] - (ext_call.return_data[0] * sub_075dc237[arg1] / 100)), distributionPoolAddress, msg.sender);
        if arg1 >= 3:
            revert with 0, 50
        require ext_code.size(sub_20eea8b5[arg1])
        call sub_20eea8b5[arg1]._cashoutNodeReward(address arg1, uint256 arg2) with:
             gas gas_remaining wei
            args msg.sender, arg2
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
}

function createNodeWithTokens(string arg1, uint256 arg2) {
    require calldata.size - 4 >= 64
    require arg1 <= test266151307()
    require arg1 + 35 < calldata.size
    if arg1.length > test266151307():
        revert with 0, 65
    if ceil32(ceil32(arg1.length)) + 97 < 96 or ceil32(ceil32(arg1.length)) + 97 > test266151307():
        revert with 0, 65
    mem[96] = arg1.length
    require arg1 + arg1.length + 36 <= calldata.size
    mem[128 len arg1.length] = arg1[all]
    mem[arg1.length + 128] = 0
    if arg1.length <= 3:
        revert with 0, 'NODE CREATION: NAME SIZE INVALID'
    if arg1.length >= 32:
        revert with 0, 'NODE CREATION: NAME SIZE INVALID'
    if sub_6cdc78b3 <= stor27[msg.sender]:
        revert with 0, 'cannot create node more than 100'
    if not msg.sender:
        revert with 0, 'NODE CREATION:  creation from the zero address'
    if stor25[address(msg.sender)]:
        revert with 0, 'NODE CREATION: Blacklisted address'
    if futurUsePoolAddress == msg.sender:
        revert with 0, 'NODE CREATION: futur and rewardsPool cannot create node'
    if distributionPoolAddress == msg.sender:
        revert with 0, 'NODE CREATION: futur and rewardsPool cannot create node'
    if arg2 >= 3:
        revert with 0, 50
    require ext_code.size(sub_20eea8b5[arg2])
    staticcall sub_20eea8b5[arg2].nodePrice() with:
            gas gas_remaining wei
    mem[ceil32(ceil32(arg1.length)) + 97] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if balanceOf[address(msg.sender)] < ext_call.return_data[0]:
        revert with 0, 'NODE CREATION: Balance too low for creation.'
    if balanceOf[this.address] < swapTokensAmount:
        if not msg.sender:
            revert with 0, 'ERC20: transfer from the zero address'
        if not this.address:
            revert with 0, 'ERC20: transfer to the zero address'
        if ext_call.return_data[0] > balanceOf[address(msg.sender)]:
            revert with 0, 
                        32,
                        38,
                        0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(ceil32(arg1.length)) + ceil32(return_data.size) + 167 len 26] >> 48,
                        0
        if balanceOf[address(msg.sender)] < ext_call.return_data[0]:
            revert with 0, 17
        balanceOf[address(msg.sender)] -= ext_call.return_data[0]
        if balanceOf[this.address] > !ext_call.return_data[0]:
            revert with 0, 17
        if balanceOf[this.address] + ext_call.return_data[0] < balanceOf[this.address]:
            revert with 0, 'SafeMath: addition overflow'
        balanceOf[address(this.address)] = balanceOf[this.address] + ext_call.return_data[0]
        emit Transfer(ext_call.return_data[0], msg.sender, this.address);
        if arg2 >= 3:
            revert with 0, 50
        require ext_code.size(sub_20eea8b5[arg2])
        call sub_20eea8b5[arg2].createNode(address arg1, string arg2) with:
             gas gas_remaining wei
            args msg.sender, Array(len=arg1.length, data=arg1[all])
    else:
        if not uint8(stor23.field_8):
            if not msg.sender:
                revert with 0, 'ERC20: transfer from the zero address'
            if not this.address:
                revert with 0, 'ERC20: transfer to the zero address'
            if ext_call.return_data[0] > balanceOf[address(msg.sender)]:
                revert with 0, 
                            32,
                            38,
                            0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(ceil32(arg1.length)) + ceil32(return_data.size) + 167 len 26] >> 48,
                            0
            if balanceOf[address(msg.sender)] < ext_call.return_data[0]:
                revert with 0, 17
            balanceOf[address(msg.sender)] -= ext_call.return_data[0]
            if balanceOf[this.address] > !ext_call.return_data[0]:
                revert with 0, 17
            if balanceOf[this.address] + ext_call.return_data[0] < balanceOf[this.address]:
                revert with 0, 'SafeMath: addition overflow'
            balanceOf[address(this.address)] = balanceOf[this.address] + ext_call.return_data[0]
            emit Transfer(ext_call.return_data[0], msg.sender, this.address);
            if arg2 >= 3:
                revert with 0, 50
            require ext_code.size(sub_20eea8b5[arg2])
            call sub_20eea8b5[arg2].createNode(address arg1, string arg2) with:
                 gas gas_remaining wei
                args msg.sender, Array(len=arg1.length, data=arg1[all])
        else:
            if uint8(stor23.field_0):
                if not msg.sender:
                    revert with 0, 'ERC20: transfer from the zero address'
                if not this.address:
                    revert with 0, 'ERC20: transfer to the zero address'
                if ext_call.return_data[0] > balanceOf[address(msg.sender)]:
                    revert with 0, 
                                32,
                                38,
                                0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(ceil32(arg1.length)) + ceil32(return_data.size) + 167 len 26] >> 48,
                                0
                if balanceOf[address(msg.sender)] < ext_call.return_data[0]:
                    revert with 0, 17
                balanceOf[address(msg.sender)] -= ext_call.return_data[0]
                if balanceOf[this.address] > !ext_call.return_data[0]:
                    revert with 0, 17
                if balanceOf[this.address] + ext_call.return_data[0] < balanceOf[this.address]:
                    revert with 0, 'SafeMath: addition overflow'
                balanceOf[address(this.address)] = balanceOf[this.address] + ext_call.return_data[0]
                emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                if arg2 >= 3:
                    revert with 0, 50
                require ext_code.size(sub_20eea8b5[arg2])
                call sub_20eea8b5[arg2].createNode(address arg1, string arg2) with:
                     gas gas_remaining wei
                    args msg.sender, Array(len=arg1.length, data=arg1[all])
            else:
                if owner == msg.sender:
                    if not msg.sender:
                        revert with 0, 'ERC20: transfer from the zero address'
                    if not this.address:
                        revert with 0, 'ERC20: transfer to the zero address'
                    if ext_call.return_data[0] > balanceOf[address(msg.sender)]:
                        revert with 0, 
                                    32,
                                    38,
                                    0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(ceil32(arg1.length)) + ceil32(return_data.size) + 167 len 26] >> 48,
                                    0
                    if balanceOf[address(msg.sender)] < ext_call.return_data[0]:
                        revert with 0, 17
                    balanceOf[address(msg.sender)] -= ext_call.return_data[0]
                    if balanceOf[this.address] > !ext_call.return_data[0]:
                        revert with 0, 17
                    if balanceOf[this.address] + ext_call.return_data[0] < balanceOf[this.address]:
                        revert with 0, 'SafeMath: addition overflow'
                    balanceOf[address(this.address)] = balanceOf[this.address] + ext_call.return_data[0]
                    emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                    if arg2 >= 3:
                        revert with 0, 50
                    require ext_code.size(sub_20eea8b5[arg2])
                    call sub_20eea8b5[arg2].createNode(address arg1, string arg2) with:
                         gas gas_remaining wei
                        args msg.sender, Array(len=arg1.length, data=arg1[all])
                else:
                    if stor26[address(msg.sender)]:
                        if not msg.sender:
                            revert with 0, 'ERC20: transfer from the zero address'
                        if not this.address:
                            revert with 0, 'ERC20: transfer to the zero address'
                        if ext_call.return_data[0] > balanceOf[address(msg.sender)]:
                            revert with 0, 
                                        32,
                                        38,
                                        0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(ceil32(arg1.length)) + ceil32(return_data.size) + 167 len 26] >> 48,
                                        0
                        if balanceOf[address(msg.sender)] < ext_call.return_data[0]:
                            revert with 0, 17
                        balanceOf[address(msg.sender)] -= ext_call.return_data[0]
                        if balanceOf[this.address] > !ext_call.return_data[0]:
                            revert with 0, 17
                        if balanceOf[this.address] + ext_call.return_data[0] < balanceOf[this.address]:
                            revert with 0, 'SafeMath: addition overflow'
                        balanceOf[address(this.address)] = balanceOf[this.address] + ext_call.return_data[0]
                        emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                        if arg2 >= 3:
                            revert with 0, 50
                        require ext_code.size(sub_20eea8b5[arg2])
                        call sub_20eea8b5[arg2].createNode(address arg1, string arg2) with:
                             gas gas_remaining wei
                            args msg.sender, Array(len=arg1.length, data=arg1[all])
                    else:
                        uint8(stor23.field_0) = 1
                        if not balanceOf[this.address]:
                            mem[ceil32(ceil32(arg1.length)) + ceil32(return_data.size) + 97] = 26
                            mem[ceil32(ceil32(arg1.length)) + ceil32(return_data.size) + 129] = 'SafeMath: division by zero'
                            mem[ceil32(ceil32(arg1.length)) + ceil32(return_data.size) + 161] = 26
                            mem[ceil32(ceil32(arg1.length)) + ceil32(return_data.size) + 193] = 'SafeMath: division by zero'
                            mem[ceil32(ceil32(arg1.length)) + ceil32(return_data.size) + 225] = 2
                            mem[ceil32(ceil32(arg1.length)) + ceil32(return_data.size) + 257] = this.address
                            require ext_code.size(uniswapV2RouterAddress)
                            staticcall uniswapV2RouterAddress.WAVAX() with:
                                    gas gas_remaining wei
                            mem[ceil32(ceil32(arg1.length)) + ceil32(return_data.size) + 321] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 321
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                            mem[ceil32(ceil32(arg1.length)) + ceil32(return_data.size) + 289] = ext_call.return_data[12 len 20]
                            if not this.address:
                                mem[ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 321] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 325] = 32
                                mem[ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 357] = 36
                                mem[ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 389] = 'ERC20: approve from the zero add'
                                mem[ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 421] = 0x7265737300000000000000000000000000000000000000000000000000000000
                                revert with memory
                                  from ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 321
                                   len ceil32(return_data.size) + 132
                            if not uniswapV2RouterAddress:
                                mem[ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 321] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 325] = 32
                                mem[ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 357] = 34
                                mem[ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 389] = 'ERC20: approve to the zero addre'
                                mem[ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 421] = 0x7373000000000000000000000000000000000000000000000000000000000000
                                revert with memory
                                  from ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 321
                                   len ceil32(return_data.size) + 132
                            mem[0] = uniswapV2RouterAddress
                            mem[32] = sha3(address(this.address), 1)
                            allowance[address(this.address)][stor9].field_0 = 0
                            mem[ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 321] = 0
                            emit Approval(mem[ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 321 len ceil32(return_data.size) + 32], this.address, uniswapV2RouterAddress);
                            mem[ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 321] = 0x762b156200000000000000000000000000000000000000000000000000000000
                            mem[ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 325] = 0
                            mem[ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 357] = 0
                            mem[ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 389] = 160
                            mem[ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 485] = 2
                            idx = 0
                            s = ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 517
                            t = ceil32(ceil32(arg1.length)) + ceil32(return_data.size) + 257
                            while idx < mem[ceil32(ceil32(arg1.length)) + ceil32(return_data.size) + 225]:
                                mem[s] = mem[t + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 421] = this.address
                            mem[ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 453] = block.timestamp
                            require ext_code.size(uniswapV2RouterAddress)
                            call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + -mem[64] + 577]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _642 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_642] = 30
                            mem[_642 + 32] = 'SafeMath: subtraction overflow'
                            if eth.balance(this.address) > eth.balance(this.address):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if eth.balance(this.address) < eth.balance(this.address):
                                revert with 0, 17
                            call distributionPoolAddress with:
                                 gas 2300 wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _697 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_697] = 30
                            mem[_697 + 32] = 'SafeMath: subtraction overflow'
                            if not this.address:
                                revert with 0, 'ERC20: transfer from the zero address'
                            if not distributionPoolAddress:
                                revert with 0, 'ERC20: transfer to the zero address'
                            _718 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_718] = 38
                            mem[_718 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                            if 0 > balanceOf[address(this.address)]:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 38
                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_718 + 70 len 26]
                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                            if balanceOf[address(this.address)] < 0:
                                revert with 0, 17
                            if balanceOf[stor12] > -1:
                                revert with 0, 17
                            if balanceOf[stor12] < balanceOf[stor12]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = distributionPoolAddress
                            mem[32] = 0
                            balanceOf[stor12] = balanceOf[stor12]
                            emit Transfer(0, this.address, distributionPoolAddress);
                            if balanceOf[this.address]:
                                if balanceOf[this.address] and liquidityPoolFee > -1 / balanceOf[this.address]:
                                    revert with 0, 17
                                if not balanceOf[this.address]:
                                    revert with 0, 18
                                if balanceOf[this.address] * liquidityPoolFee / balanceOf[this.address] != liquidityPoolFee:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _774 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_774] = 26
                                mem[_774 + 32] = 'SafeMath: division by zero'
                                _780 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_780] = 26
                                mem[_780 + 32] = 'SafeMath: division by zero'
                                _786 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_786] = 30
                                mem[_786 + 32] = 'SafeMath: subtraction overflow'
                                if balanceOf[this.address] * liquidityPoolFee / 100 / 2 > balanceOf[this.address] * liquidityPoolFee / 100:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if balanceOf[this.address] * liquidityPoolFee / 100 < balanceOf[this.address] * liquidityPoolFee / 100 / 2:
                                    revert with 0, 17
                                _818 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                mem[_818 + 32 len 64] = call.data[calldata.size len 64]
                                if 0 >= mem[_818]:
                                    revert with 0, 50
                                mem[_818 + 32] = this.address
                                require ext_code.size(uniswapV2RouterAddress)
                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                        gas gas_remaining wei
                                mem[_818 + 96] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = _818 + ceil32(return_data.size) + 96
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                if 1 >= mem[_818]:
                                    revert with 0, 50
                                mem[_818 + 64] = ext_call.return_data[12 len 20]
                                if not this.address:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not uniswapV2RouterAddress:
                                    revert with 0, 'ERC20: approve to the zero address'
                                mem[0] = uniswapV2RouterAddress
                                mem[32] = sha3(address(this.address), 1)
                                allowance[address(this.address)][stor9].field_0 = balanceOf[this.address] * liquidityPoolFee / 100 / 2
                                allowance[address(this.address)][stor9].field_255 = 0
                                emit Approval((balanceOf[this.address] * liquidityPoolFee / 100 / 2), this.address, uniswapV2RouterAddress);
                                mem[_818 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                mem[_818 + ceil32(return_data.size) + 100] = balanceOf[this.address] * liquidityPoolFee / 100 / 2
                                mem[_818 + ceil32(return_data.size) + 132] = 0
                                mem[_818 + ceil32(return_data.size) + 164] = 160
                                mem[_818 + ceil32(return_data.size) + 260] = mem[_818]
                                idx = 0
                                s = _818 + ceil32(return_data.size) + 292
                                t = _818 + 32
                                while idx < mem[_818]:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(uniswapV2RouterAddress)
                                call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                     gas gas_remaining wei
                                    args Mask(255, 1, balanceOf[this.address] * liquidityPoolFee / 100), 0, 160, address(this.address), block.timestamp, mem[_818 + ceil32(return_data.size) + 260 len (32 * mem[_818]) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[_818 + ceil32(return_data.size) + 96] = 30
                                mem[_818 + ceil32(return_data.size) + 128] = 'SafeMath: subtraction overflow'
                                if eth.balance(this.address) > eth.balance(this.address):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if eth.balance(this.address) < eth.balance(this.address):
                                    revert with 0, 17
                                if not this.address:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not uniswapV2RouterAddress:
                                    revert with 0, 'ERC20: approve to the zero address'
                                allowance[address(this.address)][stor9].field_0 = (balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2)
                                emit Approval(((balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2)), this.address, uniswapV2RouterAddress);
                                mem[_818 + ceil32(return_data.size) + 228] = 0
                                mem[_818 + ceil32(return_data.size) + 260] = 0
                                mem[_818 + ceil32(return_data.size) + 292] = 0
                                mem[_818 + ceil32(return_data.size) + 324] = block.timestamp
                                require ext_code.size(uniswapV2RouterAddress)
                                call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                     gas gas_remaining wei
                                    args this.address, (balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2), 0, 0, 0, block.timestamp
                                mem[_818 + ceil32(return_data.size) + 160 len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 96
                                emit SwapAndLiquify(Mask(255, 1, balanceOf[this.address] * liquidityPoolFee / 100), 0, (balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2));
                                mem[_818 + (2 * ceil32(return_data.size)) + 160] = 2
                                mem[_818 + (2 * ceil32(return_data.size)) + 192] = this.address
                                require ext_code.size(uniswapV2RouterAddress)
                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                        gas gas_remaining wei
                                mem[_818 + (2 * ceil32(return_data.size)) + 256] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = _818 + (4 * ceil32(return_data.size)) + 256
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                mem[_818 + (2 * ceil32(return_data.size)) + 224] = ext_call.return_data[12 len 20]
                                if not this.address:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not uniswapV2RouterAddress:
                                    revert with 0, 'ERC20: approve to the zero address'
                                mem[0] = uniswapV2RouterAddress
                                mem[32] = sha3(address(this.address), 1)
                                allowance[address(this.address)][stor9].field_0 = balanceOf[this.address]
                                emit Approval(balanceOf[this.address], this.address, uniswapV2RouterAddress);
                                mem[_818 + (4 * ceil32(return_data.size)) + 256] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                mem[_818 + (4 * ceil32(return_data.size)) + 260] = balanceOf[this.address]
                                mem[_818 + (4 * ceil32(return_data.size)) + 292] = 0
                                mem[_818 + (4 * ceil32(return_data.size)) + 324] = 160
                                mem[_818 + (4 * ceil32(return_data.size)) + 420] = 2
                                idx = 0
                                s = _818 + (4 * ceil32(return_data.size)) + 452
                                t = _818 + (2 * ceil32(return_data.size)) + 192
                                while idx < mem[_818 + (2 * ceil32(return_data.size)) + 160]:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[_818 + (4 * ceil32(return_data.size)) + 356] = this.address
                                mem[_818 + (4 * ceil32(return_data.size)) + 388] = block.timestamp
                                require ext_code.size(uniswapV2RouterAddress)
                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len _818 + (4 * ceil32(return_data.size)) + (32 * mem[_818 + (2 * ceil32(return_data.size)) + 160]) + -mem[64] + 448]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _1955 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1955] = 30
                                mem[_1955 + 32] = 'SafeMath: subtraction overflow'
                                if eth.balance(this.address) > eth.balance(this.address):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if eth.balance(this.address) < eth.balance(this.address):
                                    revert with 0, 17
                                call marketingWalletAddress with:
                                     gas 2300 wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                uint8(stor23.field_0) = 0
                                if not msg.sender:
                                    revert with 0, 'ERC20: transfer from the zero address'
                                if not this.address:
                                    revert with 0, 'ERC20: transfer to the zero address'
                                _2011 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_2011] = 38
                                mem[_2011 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                if ext_call.return_data[0] > balanceOf[address(msg.sender)]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 38
                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_2011 + 70 len 26]
                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                            else:
                                _765 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_765] = 26
                                mem[_765 + 32] = 'SafeMath: division by zero'
                                _777 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_777] = 26
                                mem[_777 + 32] = 'SafeMath: division by zero'
                                _783 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_783] = 30
                                mem[_783 + 32] = 'SafeMath: subtraction overflow'
                                _794 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                mem[_794 + 32 len 64] = call.data[calldata.size len 64]
                                if 0 >= mem[_794]:
                                    revert with 0, 50
                                mem[_794 + 32] = this.address
                                require ext_code.size(uniswapV2RouterAddress)
                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                        gas gas_remaining wei
                                mem[_794 + 96] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = _794 + ceil32(return_data.size) + 96
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                if 1 >= mem[_794]:
                                    revert with 0, 50
                                mem[_794 + 64] = ext_call.return_data[12 len 20]
                                if not this.address:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not uniswapV2RouterAddress:
                                    revert with 0, 'ERC20: approve to the zero address'
                                mem[0] = uniswapV2RouterAddress
                                mem[32] = sha3(address(this.address), 1)
                                allowance[address(this.address)][stor9].field_0 = 0
                                emit Approval(0, this.address, uniswapV2RouterAddress);
                                mem[_794 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                mem[_794 + ceil32(return_data.size) + 100] = 0
                                mem[_794 + ceil32(return_data.size) + 132] = 0
                                mem[_794 + ceil32(return_data.size) + 164] = 160
                                mem[_794 + ceil32(return_data.size) + 260] = mem[_794]
                                idx = 0
                                s = _794 + ceil32(return_data.size) + 292
                                t = _794 + 32
                                while idx < mem[_794]:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[_794 + ceil32(return_data.size) + 196] = this.address
                                mem[_794 + ceil32(return_data.size) + 228] = block.timestamp
                                require ext_code.size(uniswapV2RouterAddress)
                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len _794 + ceil32(return_data.size) + (32 * mem[_794]) + -mem[64] + 288]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _1446 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1446] = 30
                                mem[_1446 + 32] = 'SafeMath: subtraction overflow'
                                if eth.balance(this.address) > eth.balance(this.address):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if eth.balance(this.address) < eth.balance(this.address):
                                    revert with 0, 17
                                if not this.address:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not uniswapV2RouterAddress:
                                    revert with 0, 'ERC20: approve to the zero address'
                                mem[0] = uniswapV2RouterAddress
                                mem[32] = sha3(address(this.address), 1)
                                allowance[address(this.address)][stor9].field_0 = 0
                                emit Approval(0, this.address, uniswapV2RouterAddress);
                                mem[mem[64] + 68] = 0
                                mem[mem[64] + 100] = 0
                                mem[mem[64] + 132] = 0
                                mem[mem[64] + 164] = block.timestamp
                                require ext_code.size(uniswapV2RouterAddress)
                                call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                     gas gas_remaining wei
                                    args this.address, 0, 0, 0, 0, block.timestamp
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                mem[mem[64] + 32] = 0
                                mem[mem[64] + 64] = 0
                                emit SwapAndLiquify(uint256 arg1, uint256 arg2, uint256 arg3):
                                                    0,
                                mem[0] = this.address
                                mem[32] = 0
                                _1589 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                mem[_1589 + 32 len 64] = call.data[calldata.size len 64]
                                if 0 >= mem[_1589]:
                                    revert with 0, 50
                                mem[_1589 + 32] = this.address
                                require ext_code.size(uniswapV2RouterAddress)
                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                        gas gas_remaining wei
                                mem[_1589 + 96] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = _1589 + ceil32(return_data.size) + 96
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                if 1 >= mem[_1589]:
                                    revert with 0, 50
                                mem[_1589 + 64] = ext_call.return_data[12 len 20]
                                if not this.address:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not uniswapV2RouterAddress:
                                    revert with 0, 'ERC20: approve to the zero address'
                                mem[0] = uniswapV2RouterAddress
                                mem[32] = sha3(address(this.address), 1)
                                allowance[address(this.address)][stor9].field_0 = balanceOf[this.address]
                                emit Approval(balanceOf[this.address], this.address, uniswapV2RouterAddress);
                                mem[_1589 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                mem[_1589 + ceil32(return_data.size) + 100] = balanceOf[this.address]
                                mem[_1589 + ceil32(return_data.size) + 132] = 0
                                mem[_1589 + ceil32(return_data.size) + 164] = 160
                                mem[_1589 + ceil32(return_data.size) + 260] = mem[_1589]
                                idx = 0
                                s = _1589 + ceil32(return_data.size) + 292
                                t = _1589 + 32
                                while idx < mem[_1589]:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[_1589 + ceil32(return_data.size) + 196] = this.address
                                mem[_1589 + ceil32(return_data.size) + 228] = block.timestamp
                                require ext_code.size(uniswapV2RouterAddress)
                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len _1589 + ceil32(return_data.size) + (32 * mem[_1589]) + -mem[64] + 288]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _1956 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1956] = 30
                                mem[_1956 + 32] = 'SafeMath: subtraction overflow'
                                if eth.balance(this.address) > eth.balance(this.address):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if eth.balance(this.address) < eth.balance(this.address):
                                    revert with 0, 17
                                call marketingWalletAddress with:
                                     gas 2300 wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                uint8(stor23.field_0) = 0
                                if not msg.sender:
                                    revert with 0, 'ERC20: transfer from the zero address'
                                if not this.address:
                                    revert with 0, 'ERC20: transfer to the zero address'
                                _2014 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_2014] = 38
                                mem[_2014 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                if ext_call.return_data[0] > balanceOf[address(msg.sender)]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 38
                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_2014 + 70 len 26]
                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                            ('le', ('ext_call.return_data', 0, 32), ('stor', ('map', ('mask_shl', 160, 0, 0, 'msg.sender'), ('name', 'balanceOf', 0))))
                            if balanceOf[address(msg.sender)] < ext_call.return_data[0]:
                                revert with 0, 17
                            balanceOf[address(msg.sender)] -= ext_call.return_data[0]
                            if balanceOf[this.address] > !ext_call.return_data[0]:
                                revert with 0, 17
                            if balanceOf[this.address] + ext_call.return_data[0] < balanceOf[this.address]:
                                revert with 0, 'SafeMath: addition overflow'
                            balanceOf[address(this.address)] = balanceOf[this.address] + ext_call.return_data[0]
                            emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                            if arg2 >= 3:
                                revert with 0, 50
                            mem[mem[64]] = 0x12b8603f00000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = msg.sender
                            mem[mem[64] + 36] = 64
                            mem[mem[64] + 68] = mem[96]
                            mem[mem[64] + 100 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                            if ceil32(mem[96]) > mem[96]:
                                mem[mem[64] + mem[96] + 100] = 0
                            require ext_code.size(sub_20eea8b5[arg2])
                            call sub_20eea8b5[arg2].createNode(address arg1, string arg2) with:
                                 gas gas_remaining wei
                                args msg.sender, Array(len=mem[96], data=mem[mem[64] + 100 len ceil32(mem[96])])
                        else:
                            if balanceOf[this.address] and rewardsFee > -1 / balanceOf[this.address]:
                                revert with 0, 17
                            if not balanceOf[this.address]:
                                revert with 0, 18
                            if balanceOf[this.address] * rewardsFee / balanceOf[this.address] != rewardsFee:
                                revert with 0, 'SafeMath: multiplication overflow'
                            mem[ceil32(ceil32(arg1.length)) + ceil32(return_data.size) + 97] = 26
                            mem[ceil32(ceil32(arg1.length)) + ceil32(return_data.size) + 129] = 'SafeMath: division by zero'
                            if balanceOf[this.address] * rewardsFee / 100:
                                if balanceOf[this.address] * rewardsFee / 100 and stor22 > -1 / balanceOf[this.address] * rewardsFee / 100:
                                    revert with 0, 17
                                if not balanceOf[this.address] * rewardsFee / 100:
                                    revert with 0, 18
                                if balanceOf[this.address] * rewardsFee / 100 * stor22 / balanceOf[this.address] * rewardsFee / 100 != stor22:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[ceil32(ceil32(arg1.length)) + ceil32(return_data.size) + 161] = 26
                                mem[ceil32(ceil32(arg1.length)) + ceil32(return_data.size) + 193] = 'SafeMath: division by zero'
                                mem[ceil32(ceil32(arg1.length)) + ceil32(return_data.size) + 225] = 2
                                mem[ceil32(ceil32(arg1.length)) + ceil32(return_data.size) + 257] = this.address
                                require ext_code.size(uniswapV2RouterAddress)
                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                        gas gas_remaining wei
                                mem[ceil32(ceil32(arg1.length)) + ceil32(return_data.size) + 321] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 321
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                mem[ceil32(ceil32(arg1.length)) + ceil32(return_data.size) + 289] = ext_call.return_data[12 len 20]
                                if not this.address:
                                    mem[ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 321] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 325] = 32
                                    mem[ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 357] = 36
                                    mem[ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 389] = 'ERC20: approve from the zero add'
                                    mem[ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 421] = 0x7265737300000000000000000000000000000000000000000000000000000000
                                    revert with memory
                                      from ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 321
                                       len ceil32(return_data.size) + 132
                                if not uniswapV2RouterAddress:
                                    mem[ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 321] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 325] = 32
                                    mem[ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 357] = 34
                                    mem[ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 389] = 'ERC20: approve to the zero addre'
                                    mem[ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 421] = 0x7373000000000000000000000000000000000000000000000000000000000000
                                    revert with memory
                                      from ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 321
                                       len ceil32(return_data.size) + 132
                                mem[0] = uniswapV2RouterAddress
                                mem[32] = sha3(address(this.address), 1)
                                allowance[address(this.address)][stor9].field_0 = balanceOf[this.address] * rewardsFee / 100 * stor22 / 100
                                mem[ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 321] = balanceOf[this.address] * rewardsFee / 100 * stor22 / 100
                                emit Approval(mem[ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 321 len ceil32(return_data.size) + 32], this.address, uniswapV2RouterAddress);
                                mem[ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 321] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                mem[ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 325] = balanceOf[this.address] * rewardsFee / 100 * stor22 / 100
                                mem[ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 357] = 0
                                mem[ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 389] = 160
                                mem[ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 485] = 2
                                idx = 0
                                s = ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 517
                                t = ceil32(ceil32(arg1.length)) + ceil32(return_data.size) + 257
                                while idx < mem[ceil32(ceil32(arg1.length)) + ceil32(return_data.size) + 225]:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 421] = this.address
                                mem[ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 453] = block.timestamp
                                require ext_code.size(uniswapV2RouterAddress)
                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + -mem[64] + 577]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _640 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_640] = 30
                                mem[_640 + 32] = 'SafeMath: subtraction overflow'
                                if eth.balance(this.address) > eth.balance(this.address):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if eth.balance(this.address) < eth.balance(this.address):
                                    revert with 0, 17
                                call distributionPoolAddress with:
                                     gas 2300 wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _693 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_693] = 30
                                mem[_693 + 32] = 'SafeMath: subtraction overflow'
                                if balanceOf[this.address] * rewardsFee / 100 * stor22 / 100 > balanceOf[this.address] * rewardsFee / 100:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if balanceOf[this.address] * rewardsFee / 100 < balanceOf[this.address] * rewardsFee / 100 * stor22 / 100:
                                    revert with 0, 17
                                if not this.address:
                                    revert with 0, 'ERC20: transfer from the zero address'
                                if not distributionPoolAddress:
                                    revert with 0, 'ERC20: transfer to the zero address'
                                _710 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_710] = 38
                                mem[_710 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                if (balanceOf[this.address] * rewardsFee / 100) - (balanceOf[this.address] * rewardsFee / 100 * stor22 / 100) > balanceOf[address(this.address)]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 38
                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_710 + 70 len 26]
                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                if balanceOf[address(this.address)] < (balanceOf[this.address] * rewardsFee / 100) - (balanceOf[this.address] * rewardsFee / 100 * stor22 / 100):
                                    revert with 0, 17
                                balanceOf[address(this.address)] = balanceOf[address(this.address)] - (balanceOf[this.address] * rewardsFee / 100) + (balanceOf[this.address] * rewardsFee / 100 * stor22 / 100)
                                if balanceOf[stor12] > !((balanceOf[this.address] * rewardsFee / 100) - (balanceOf[this.address] * rewardsFee / 100 * stor22 / 100)):
                                    revert with 0, 17
                                if balanceOf[stor12] + (balanceOf[this.address] * rewardsFee / 100) - (balanceOf[this.address] * rewardsFee / 100 * stor22 / 100) < balanceOf[stor12]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = distributionPoolAddress
                                mem[32] = 0
                                balanceOf[stor12] = balanceOf[stor12] + (balanceOf[this.address] * rewardsFee / 100) - (balanceOf[this.address] * rewardsFee / 100 * stor22 / 100)
                                emit Transfer(((balanceOf[this.address] * rewardsFee / 100) - (balanceOf[this.address] * rewardsFee / 100 * stor22 / 100)), this.address, distributionPoolAddress);
                                if not balanceOf[this.address]:
                                    _763 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_763] = 26
                                    mem[_763 + 32] = 'SafeMath: division by zero'
                                    _775 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_775] = 26
                                    mem[_775 + 32] = 'SafeMath: division by zero'
                                    _781 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_781] = 30
                                    mem[_781 + 32] = 'SafeMath: subtraction overflow'
                                    _788 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    mem[_788 + 32 len 64] = call.data[calldata.size len 64]
                                    if 0 >= mem[_788]:
                                        revert with 0, 50
                                    mem[_788 + 32] = this.address
                                    require ext_code.size(uniswapV2RouterAddress)
                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                            gas gas_remaining wei
                                    mem[_788 + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = _788 + ceil32(return_data.size) + 96
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    if 1 >= mem[_788]:
                                        revert with 0, 50
                                    mem[_788 + 64] = ext_call.return_data[12 len 20]
                                    if not this.address:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not uniswapV2RouterAddress:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    mem[0] = uniswapV2RouterAddress
                                    mem[32] = sha3(address(this.address), 1)
                                    allowance[address(this.address)][stor9].field_0 = 0
                                    emit Approval(0, this.address, uniswapV2RouterAddress);
                                    mem[_788 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                    mem[_788 + ceil32(return_data.size) + 100] = 0
                                    mem[_788 + ceil32(return_data.size) + 132] = 0
                                    mem[_788 + ceil32(return_data.size) + 164] = 160
                                    mem[_788 + ceil32(return_data.size) + 260] = mem[_788]
                                    idx = 0
                                    s = _788 + ceil32(return_data.size) + 292
                                    t = _788 + 32
                                    while idx < mem[_788]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(uniswapV2RouterAddress)
                                    call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args 0, 0, 160, address(this.address), block.timestamp, mem[_788 + ceil32(return_data.size) + 260 len (32 * mem[_788]) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_788 + ceil32(return_data.size) + 96] = 30
                                    mem[_788 + ceil32(return_data.size) + 128] = 'SafeMath: subtraction overflow'
                                    if eth.balance(this.address) > eth.balance(this.address):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if eth.balance(this.address) < eth.balance(this.address):
                                        revert with 0, 17
                                    if not this.address:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not uniswapV2RouterAddress:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    allowance[address(this.address)][stor9].field_0 = 0
                                    emit Approval(0, this.address, uniswapV2RouterAddress);
                                    mem[_788 + ceil32(return_data.size) + 228] = 0
                                    mem[_788 + ceil32(return_data.size) + 260] = 0
                                    mem[_788 + ceil32(return_data.size) + 292] = 0
                                    mem[_788 + ceil32(return_data.size) + 324] = block.timestamp
                                    require ext_code.size(uniswapV2RouterAddress)
                                    call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                         gas gas_remaining wei
                                        args this.address, 0, 0, 0, 0, block.timestamp
                                    mem[_788 + ceil32(return_data.size) + 160 len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 96
                                    emit SwapAndLiquify(uint256 arg1, uint256 arg2, uint256 arg3):
                                                        0,
                                    mem[_788 + (2 * ceil32(return_data.size)) + 160] = 2
                                    mem[_788 + (2 * ceil32(return_data.size)) + 192] = this.address
                                    require ext_code.size(uniswapV2RouterAddress)
                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                            gas gas_remaining wei
                                    mem[_788 + (2 * ceil32(return_data.size)) + 256] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = _788 + (4 * ceil32(return_data.size)) + 256
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    mem[_788 + (2 * ceil32(return_data.size)) + 224] = ext_call.return_data[12 len 20]
                                    if not this.address:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not uniswapV2RouterAddress:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    mem[0] = uniswapV2RouterAddress
                                    mem[32] = sha3(address(this.address), 1)
                                    allowance[address(this.address)][stor9].field_0 = balanceOf[this.address]
                                    emit Approval(balanceOf[this.address], this.address, uniswapV2RouterAddress);
                                    mem[_788 + (4 * ceil32(return_data.size)) + 256] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                    mem[_788 + (4 * ceil32(return_data.size)) + 260] = balanceOf[this.address]
                                    mem[_788 + (4 * ceil32(return_data.size)) + 292] = 0
                                    mem[_788 + (4 * ceil32(return_data.size)) + 324] = 160
                                    mem[_788 + (4 * ceil32(return_data.size)) + 420] = 2
                                    idx = 0
                                    s = _788 + (4 * ceil32(return_data.size)) + 452
                                    t = _788 + (2 * ceil32(return_data.size)) + 192
                                    while idx < mem[_788 + (2 * ceil32(return_data.size)) + 160]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_788 + (4 * ceil32(return_data.size)) + 356] = this.address
                                    mem[_788 + (4 * ceil32(return_data.size)) + 388] = block.timestamp
                                    require ext_code.size(uniswapV2RouterAddress)
                                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _788 + (4 * ceil32(return_data.size)) + (32 * mem[_788 + (2 * ceil32(return_data.size)) + 160]) + -mem[64] + 448]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _1952 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_1952] = 30
                                    mem[_1952 + 32] = 'SafeMath: subtraction overflow'
                                    if eth.balance(this.address) > eth.balance(this.address):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if eth.balance(this.address) < eth.balance(this.address):
                                        revert with 0, 17
                                    call marketingWalletAddress with:
                                         gas 2300 wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    uint8(stor23.field_0) = 0
                                    if not msg.sender:
                                        revert with 0, 'ERC20: transfer from the zero address'
                                    if not this.address:
                                        revert with 0, 'ERC20: transfer to the zero address'
                                    _2002 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_2002] = 38
                                    mem[_2002 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                    if ext_call.return_data[0] > balanceOf[address(msg.sender)]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 38
                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_2002 + 70 len 26]
                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                    if balanceOf[address(msg.sender)] < ext_call.return_data[0]:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)] -= ext_call.return_data[0]
                                    if balanceOf[this.address] > !ext_call.return_data[0]:
                                        revert with 0, 17
                                    if balanceOf[this.address] + ext_call.return_data[0] < balanceOf[this.address]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(this.address)] = balanceOf[this.address] + ext_call.return_data[0]
                                    emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                    if arg2 >= 3:
                                        revert with 0, 50
                                    mem[mem[64]] = 0x12b8603f00000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = 64
                                    mem[mem[64] + 68] = mem[96]
                                    mem[mem[64] + 100 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                                    if ceil32(mem[96]) > mem[96]:
                                        mem[mem[64] + mem[96] + 100] = 0
                                    require ext_code.size(sub_20eea8b5[arg2])
                                    call sub_20eea8b5[arg2].createNode(address arg1, string arg2) with:
                                         gas gas_remaining wei
                                        args msg.sender, Array(len=mem[96], data=mem[mem[64] + 100 len ceil32(mem[96])])
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if stor27[address(msg.sender)] > -2:
                                        revert with 0, 17
                                    if stor27[address(msg.sender)] + 1 < stor27[address(msg.sender)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor27[address(msg.sender)]++
                                if balanceOf[this.address] and liquidityPoolFee > -1 / balanceOf[this.address]:
                                    revert with 0, 17
                                if not balanceOf[this.address]:
                                    revert with 0, 18
                                if balanceOf[this.address] * liquidityPoolFee / balanceOf[this.address] != liquidityPoolFee:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _772 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_772] = 26
                                mem[_772 + 32] = 'SafeMath: division by zero'
                                _778 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_778] = 26
                                mem[_778 + 32] = 'SafeMath: division by zero'
                                _784 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_784] = 30
                                mem[_784 + 32] = 'SafeMath: subtraction overflow'
                                if balanceOf[this.address] * liquidityPoolFee / 100 / 2 > balanceOf[this.address] * liquidityPoolFee / 100:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if balanceOf[this.address] * liquidityPoolFee / 100 < balanceOf[this.address] * liquidityPoolFee / 100 / 2:
                                    revert with 0, 17
                                _814 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                mem[_814 + 32 len 64] = call.data[calldata.size len 64]
                                if 0 >= mem[_814]:
                                    revert with 0, 50
                                mem[_814 + 32] = this.address
                                require ext_code.size(uniswapV2RouterAddress)
                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                        gas gas_remaining wei
                                mem[_814 + 96] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = _814 + ceil32(return_data.size) + 96
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                if 1 >= mem[_814]:
                                    revert with 0, 50
                                mem[_814 + 64] = ext_call.return_data[12 len 20]
                                if not this.address:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not uniswapV2RouterAddress:
                                    revert with 0, 'ERC20: approve to the zero address'
                                mem[0] = uniswapV2RouterAddress
                                mem[32] = sha3(address(this.address), 1)
                                allowance[address(this.address)][stor9].field_0 = balanceOf[this.address] * liquidityPoolFee / 100 / 2
                                allowance[address(this.address)][stor9].field_255 = 0
                                emit Approval((balanceOf[this.address] * liquidityPoolFee / 100 / 2), this.address, uniswapV2RouterAddress);
                                mem[_814 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                mem[_814 + ceil32(return_data.size) + 100] = balanceOf[this.address] * liquidityPoolFee / 100 / 2
                                mem[_814 + ceil32(return_data.size) + 132] = 0
                                mem[_814 + ceil32(return_data.size) + 164] = 160
                                mem[_814 + ceil32(return_data.size) + 260] = mem[_814]
                                idx = 0
                                s = _814 + ceil32(return_data.size) + 292
                                t = _814 + 32
                                while idx < mem[_814]:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(uniswapV2RouterAddress)
                                call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                     gas gas_remaining wei
                                    args Mask(255, 1, balanceOf[this.address] * liquidityPoolFee / 100), 0, 160, address(this.address), block.timestamp, mem[_814 + ceil32(return_data.size) + 260 len (32 * mem[_814]) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[_814 + ceil32(return_data.size) + 96] = 30
                                mem[_814 + ceil32(return_data.size) + 128] = 'SafeMath: subtraction overflow'
                                if eth.balance(this.address) > eth.balance(this.address):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if eth.balance(this.address) < eth.balance(this.address):
                                    revert with 0, 17
                                if not this.address:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not uniswapV2RouterAddress:
                                    revert with 0, 'ERC20: approve to the zero address'
                                allowance[address(this.address)][stor9].field_0 = (balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2)
                                emit Approval(((balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2)), this.address, uniswapV2RouterAddress);
                                mem[_814 + ceil32(return_data.size) + 228] = 0
                                mem[_814 + ceil32(return_data.size) + 260] = 0
                                mem[_814 + ceil32(return_data.size) + 292] = 0
                                mem[_814 + ceil32(return_data.size) + 324] = block.timestamp
                                require ext_code.size(uniswapV2RouterAddress)
                                call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                     gas gas_remaining wei
                                    args this.address, (balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2), 0, 0, 0, block.timestamp
                                mem[_814 + ceil32(return_data.size) + 160 len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 96
                                emit SwapAndLiquify(Mask(255, 1, balanceOf[this.address] * liquidityPoolFee / 100), 0, (balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2));
                                mem[_814 + (2 * ceil32(return_data.size)) + 160] = 2
                                mem[_814 + (2 * ceil32(return_data.size)) + 192] = this.address
                                require ext_code.size(uniswapV2RouterAddress)
                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                        gas gas_remaining wei
                                mem[_814 + (2 * ceil32(return_data.size)) + 256] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                mem[_814 + (2 * ceil32(return_data.size)) + 224] = ext_call.return_data[12 len 20]
                                if not this.address:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not uniswapV2RouterAddress:
                                    revert with 0, 'ERC20: approve to the zero address'
                                allowance[address(this.address)][stor9].field_0 = balanceOf[this.address]
                                emit Approval(balanceOf[this.address], this.address, uniswapV2RouterAddress);
                                mem[_814 + (4 * ceil32(return_data.size)) + 256] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                mem[_814 + (4 * ceil32(return_data.size)) + 260] = balanceOf[this.address]
                                mem[_814 + (4 * ceil32(return_data.size)) + 292] = 0
                                mem[_814 + (4 * ceil32(return_data.size)) + 324] = 160
                                mem[_814 + (4 * ceil32(return_data.size)) + 420] = 2
                                idx = 0
                                s = _814 + (4 * ceil32(return_data.size)) + 452
                                t = _814 + (2 * ceil32(return_data.size)) + 192
                                while idx < mem[_814 + (2 * ceil32(return_data.size)) + 160]:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[_814 + (4 * ceil32(return_data.size)) + 356] = this.address
                                mem[_814 + (4 * ceil32(return_data.size)) + 388] = block.timestamp
                                require ext_code.size(uniswapV2RouterAddress)
                                call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                     gas gas_remaining wei
                                    args balanceOf[this.address], 0, 160, address(this.address), block.timestamp, mem[_814 + (4 * ceil32(return_data.size)) + 420 len (32 * mem[_814 + (2 * ceil32(return_data.size)) + 160]) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[_814 + (4 * ceil32(return_data.size)) + 256] = 30
                                mem[_814 + (4 * ceil32(return_data.size)) + 288] = 'SafeMath: subtraction overflow'
                                if eth.balance(this.address) > eth.balance(this.address):
                                    mem[_814 + (4 * ceil32(return_data.size)) + 320] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[_814 + (4 * ceil32(return_data.size)) + 324] = 32
                                    mem[_814 + (4 * ceil32(return_data.size)) + 356] = 30
                                    mem[_814 + (4 * ceil32(return_data.size)) + 388] = 'SafeMath: subtraction overflow'
                                    mem[_814 + (4 * ceil32(return_data.size)) + 418] = 0
                                    revert with memory
                                      from _814 + (4 * ceil32(return_data.size)) + 320
                                       len (5 * ceil32(return_data.size)) + 100
                                if eth.balance(this.address) < eth.balance(this.address):
                                    revert with 0, 17
                                call marketingWalletAddress with:
                                     gas 2300 wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                uint8(stor23.field_0) = 0
                                if not msg.sender:
                                    mem[_814 + (4 * ceil32(return_data.size)) + 320] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[_814 + (4 * ceil32(return_data.size)) + 324] = 32
                                    mem[_814 + (4 * ceil32(return_data.size)) + 356] = 37
                                    mem[_814 + (4 * ceil32(return_data.size)) + 388] = 'ERC20: transfer from the zero ad'
                                    mem[_814 + (4 * ceil32(return_data.size)) + 420] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                    revert with memory
                                      from _814 + (4 * ceil32(return_data.size)) + 320
                                       len (5 * ceil32(return_data.size)) + 132
                                if not this.address:
                                    mem[_814 + (4 * ceil32(return_data.size)) + 320] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[_814 + (4 * ceil32(return_data.size)) + 324] = 32
                                    mem[_814 + (4 * ceil32(return_data.size)) + 356] = 35
                                    mem[_814 + (4 * ceil32(return_data.size)) + 388] = 'ERC20: transfer to the zero addr'
                                    mem[_814 + (4 * ceil32(return_data.size)) + 420] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                    revert with memory
                                      from _814 + (4 * ceil32(return_data.size)) + 320
                                       len (5 * ceil32(return_data.size)) + 132
                                mem[_814 + (4 * ceil32(return_data.size)) + 320] = 38
                                mem[_814 + (4 * ceil32(return_data.size)) + 352 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                if ext_call.return_data[0] > balanceOf[address(msg.sender)]:
                                    mem[_814 + (4 * ceil32(return_data.size)) + 416] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[_814 + (4 * ceil32(return_data.size)) + 420] = 32
                                    mem[_814 + (4 * ceil32(return_data.size)) + 452] = 38
                                    mem[_814 + (4 * ceil32(return_data.size)) + 484 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, Mask(208, 32, block.timestamp) >> 32
                                    mem[_814 + (4 * ceil32(return_data.size)) + 522] = 0
                                    revert with memory
                                      from _814 + (4 * ceil32(return_data.size)) + 416
                                       len (5 * ceil32(return_data.size)) + 132
                                if balanceOf[address(msg.sender)] < ext_call.return_data[0]:
                                    revert with 0, 17
                                balanceOf[address(msg.sender)] -= ext_call.return_data[0]
                                if balanceOf[this.address] > !ext_call.return_data[0]:
                                    revert with 0, 17
                                if balanceOf[this.address] + ext_call.return_data[0] >= balanceOf[this.address]:
                                    balanceOf[address(this.address)] = balanceOf[this.address] + ext_call.return_data[0]
                                    emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                    if arg2 >= 3:
                                        revert with 0, 50
                                    mem[_814 + (4 * ceil32(return_data.size)) + 416] = 0x12b8603f00000000000000000000000000000000000000000000000000000000
                                    mem[_814 + (4 * ceil32(return_data.size)) + 420] = msg.sender
                                    mem[_814 + (4 * ceil32(return_data.size)) + 452] = 64
                                    mem[_814 + (4 * ceil32(return_data.size)) + 484] = mem[96]
                                    mem[_814 + (4 * ceil32(return_data.size)) + 516 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                                    if ceil32(mem[96]) > mem[96]:
                                        mem[_814 + (4 * ceil32(return_data.size)) + mem[96] + 516] = 0
                                    require ext_code.size(sub_20eea8b5[arg2])
                                    call sub_20eea8b5[arg2].createNode(address arg1, string arg2) with:
                                         gas gas_remaining wei
                                        args mem[_814 + (4 * ceil32(return_data.size)) + 420 len ceil32(mem[96]) + (5 * ceil32(return_data.size)) + 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if stor27[address(msg.sender)] > -2:
                                        revert with 0, 17
                                    if stor27[address(msg.sender)] + 1 >= stor27[address(msg.sender)]:
                                        stor27[address(msg.sender)]++
                                mem[_814 + (4 * ceil32(return_data.size)) + 416] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[_814 + (4 * ceil32(return_data.size)) + 420] = 32
                                mem[_814 + (4 * ceil32(return_data.size)) + 452] = 27
                                mem[_814 + (4 * ceil32(return_data.size)) + 484] = 'SafeMath: addition overflow'
                                revert with memory
                                  from _814 + (4 * ceil32(return_data.size)) + 416
                                   len (5 * ceil32(return_data.size)) + 100
                            mem[ceil32(ceil32(arg1.length)) + ceil32(return_data.size) + 161] = 26
                            mem[ceil32(ceil32(arg1.length)) + ceil32(return_data.size) + 193] = 'SafeMath: division by zero'
                            mem[ceil32(ceil32(arg1.length)) + ceil32(return_data.size) + 225] = 2
                            mem[ceil32(ceil32(arg1.length)) + ceil32(return_data.size) + 257] = this.address
                            require ext_code.size(uniswapV2RouterAddress)
                            staticcall uniswapV2RouterAddress.WAVAX() with:
                                    gas gas_remaining wei
                            mem[ceil32(ceil32(arg1.length)) + ceil32(return_data.size) + 321] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 321
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                            mem[ceil32(ceil32(arg1.length)) + ceil32(return_data.size) + 289] = ext_call.return_data[12 len 20]
                            if not this.address:
                                mem[ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 321] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 325] = 32
                                mem[ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 357] = 36
                                mem[ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 389] = 'ERC20: approve from the zero add'
                                mem[ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 421] = 0x7265737300000000000000000000000000000000000000000000000000000000
                                revert with memory
                                  from ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 321
                                   len ceil32(return_data.size) + 132
                            if not uniswapV2RouterAddress:
                                mem[ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 321] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 325] = 32
                                mem[ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 357] = 34
                                mem[ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 389] = 'ERC20: approve to the zero addre'
                                mem[ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 421] = 0x7373000000000000000000000000000000000000000000000000000000000000
                                revert with memory
                                  from ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 321
                                   len ceil32(return_data.size) + 132
                            mem[0] = uniswapV2RouterAddress
                            mem[32] = sha3(address(this.address), 1)
                            allowance[address(this.address)][stor9].field_0 = 0
                            mem[ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 321] = 0
                            emit Approval(mem[ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 321 len ceil32(return_data.size) + 32], this.address, uniswapV2RouterAddress);
                            mem[ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 321] = 0x762b156200000000000000000000000000000000000000000000000000000000
                            mem[ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 325] = 0
                            mem[ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 357] = 0
                            mem[ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 389] = 160
                            mem[ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 485] = 2
                            idx = 0
                            s = ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 517
                            t = ceil32(ceil32(arg1.length)) + ceil32(return_data.size) + 257
                            while idx < mem[ceil32(ceil32(arg1.length)) + ceil32(return_data.size) + 225]:
                                mem[s] = mem[t + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 421] = this.address
                            mem[ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 453] = block.timestamp
                            require ext_code.size(uniswapV2RouterAddress)
                            call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + -mem[64] + 577]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _641 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_641] = 30
                            mem[_641 + 32] = 'SafeMath: subtraction overflow'
                            if eth.balance(this.address) > eth.balance(this.address):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if eth.balance(this.address) < eth.balance(this.address):
                                revert with 0, 17
                            call distributionPoolAddress with:
                                 gas 2300 wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _695 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_695] = 30
                            mem[_695 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > balanceOf[this.address] * rewardsFee / 100:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if balanceOf[this.address] * rewardsFee / 100 < 0:
                                revert with 0, 17
                            if not this.address:
                                revert with 0, 'ERC20: transfer from the zero address'
                            if not distributionPoolAddress:
                                revert with 0, 'ERC20: transfer to the zero address'
                            _714 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_714] = 38
                            mem[_714 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                            if balanceOf[this.address] * rewardsFee / 100 > balanceOf[address(this.address)]:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 38
                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_714 + 70 len 26]
                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                            if balanceOf[address(this.address)] < balanceOf[this.address] * rewardsFee / 100:
                                revert with 0, 17
                            balanceOf[address(this.address)] -= balanceOf[this.address] * rewardsFee / 100
                            if balanceOf[stor12] > !(balanceOf[this.address] * rewardsFee / 100):
                                revert with 0, 17
                            if balanceOf[stor12] + (balanceOf[this.address] * rewardsFee / 100) < balanceOf[stor12]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = distributionPoolAddress
                            mem[32] = 0
                            balanceOf[stor12] += balanceOf[this.address] * rewardsFee / 100
                            emit Transfer((balanceOf[this.address] * rewardsFee / 100), this.address, distributionPoolAddress);
                            if not balanceOf[this.address]:
                                _764 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_764] = 26
                                mem[_764 + 32] = 'SafeMath: division by zero'
                                _776 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_776] = 26
                                mem[_776 + 32] = 'SafeMath: division by zero'
                                _782 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_782] = 30
                                mem[_782 + 32] = 'SafeMath: subtraction overflow'
                                _791 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                mem[_791 + 32 len 64] = call.data[calldata.size len 64]
                                if 0 >= mem[_791]:
                                    revert with 0, 50
                                mem[_791 + 32] = this.address
                                require ext_code.size(uniswapV2RouterAddress)
                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                        gas gas_remaining wei
                                mem[_791 + 96] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = _791 + ceil32(return_data.size) + 96
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                if 1 >= mem[_791]:
                                    revert with 0, 50
                                mem[_791 + 64] = ext_call.return_data[12 len 20]
                                if not this.address:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not uniswapV2RouterAddress:
                                    revert with 0, 'ERC20: approve to the zero address'
                                mem[0] = uniswapV2RouterAddress
                                mem[32] = sha3(address(this.address), 1)
                                allowance[address(this.address)][stor9].field_0 = 0
                                emit Approval(0, this.address, uniswapV2RouterAddress);
                                mem[_791 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                mem[_791 + ceil32(return_data.size) + 100] = 0
                                mem[_791 + ceil32(return_data.size) + 132] = 0
                                mem[_791 + ceil32(return_data.size) + 164] = 160
                                mem[_791 + ceil32(return_data.size) + 260] = mem[_791]
                                idx = 0
                                s = _791 + ceil32(return_data.size) + 292
                                t = _791 + 32
                                while idx < mem[_791]:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[_791 + ceil32(return_data.size) + 196] = this.address
                                mem[_791 + ceil32(return_data.size) + 228] = block.timestamp
                                require ext_code.size(uniswapV2RouterAddress)
                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len _791 + ceil32(return_data.size) + (32 * mem[_791]) + -mem[64] + 288]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _1444 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1444] = 30
                                mem[_1444 + 32] = 'SafeMath: subtraction overflow'
                                if eth.balance(this.address) > eth.balance(this.address):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if eth.balance(this.address) < eth.balance(this.address):
                                    revert with 0, 17
                                if not this.address:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not uniswapV2RouterAddress:
                                    revert with 0, 'ERC20: approve to the zero address'
                                mem[0] = uniswapV2RouterAddress
                                mem[32] = sha3(address(this.address), 1)
                                allowance[address(this.address)][stor9].field_0 = 0
                                emit Approval(0, this.address, uniswapV2RouterAddress);
                                mem[mem[64] + 68] = 0
                                mem[mem[64] + 100] = 0
                                mem[mem[64] + 132] = 0
                                mem[mem[64] + 164] = block.timestamp
                                require ext_code.size(uniswapV2RouterAddress)
                                call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                     gas gas_remaining wei
                                    args this.address, 0, 0, 0, 0, block.timestamp
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                mem[mem[64] + 32] = 0
                                mem[mem[64] + 64] = 0
                                emit SwapAndLiquify(uint256 arg1, uint256 arg2, uint256 arg3):
                                                    0,
                                mem[0] = this.address
                                mem[32] = 0
                                _1585 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                mem[_1585 + 32 len 64] = call.data[calldata.size len 64]
                                if 0 >= mem[_1585]:
                                    revert with 0, 50
                                mem[_1585 + 32] = this.address
                                require ext_code.size(uniswapV2RouterAddress)
                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                        gas gas_remaining wei
                                mem[_1585 + 96] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = _1585 + ceil32(return_data.size) + 96
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                if 1 >= mem[_1585]:
                                    revert with 0, 50
                                mem[_1585 + 64] = ext_call.return_data[12 len 20]
                                if not this.address:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not uniswapV2RouterAddress:
                                    revert with 0, 'ERC20: approve to the zero address'
                                mem[0] = uniswapV2RouterAddress
                                mem[32] = sha3(address(this.address), 1)
                                allowance[address(this.address)][stor9].field_0 = balanceOf[this.address]
                                emit Approval(balanceOf[this.address], this.address, uniswapV2RouterAddress);
                                mem[_1585 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                mem[_1585 + ceil32(return_data.size) + 100] = balanceOf[this.address]
                                mem[_1585 + ceil32(return_data.size) + 132] = 0
                                mem[_1585 + ceil32(return_data.size) + 164] = 160
                                mem[_1585 + ceil32(return_data.size) + 260] = mem[_1585]
                                idx = 0
                                s = _1585 + ceil32(return_data.size) + 292
                                t = _1585 + 32
                                while idx < mem[_1585]:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[_1585 + ceil32(return_data.size) + 228] = block.timestamp
                                require ext_code.size(uniswapV2RouterAddress)
                                call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                     gas gas_remaining wei
                                    args balanceOf[this.address], 0, 160, address(this.address), block.timestamp, mem[_1585 + ceil32(return_data.size) + 260 len (32 * mem[_1585]) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[_1585 + ceil32(return_data.size) + 96] = 30
                                mem[_1585 + ceil32(return_data.size) + 128] = 'SafeMath: subtraction overflow'
                                if eth.balance(this.address) > eth.balance(this.address):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if eth.balance(this.address) < eth.balance(this.address):
                                    revert with 0, 17
                                call marketingWalletAddress with:
                                     gas 2300 wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                uint8(stor23.field_0) = 0
                                if not msg.sender:
                                    revert with 0, 'ERC20: transfer from the zero address'
                                if not this.address:
                                    revert with 0, 'ERC20: transfer to the zero address'
                                mem[_1585 + ceil32(return_data.size) + 160] = 38
                                mem[_1585 + ceil32(return_data.size) + 192 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                if ext_call.return_data[0] > balanceOf[address(msg.sender)]:
                                    revert with 0, 
                                                32,
                                                38,
                                                0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, Mask(208, 32, block.timestamp) >> 32 >> 48,
                                                0
                                if balanceOf[address(msg.sender)] < ext_call.return_data[0]:
                                    revert with 0, 17
                                balanceOf[address(msg.sender)] -= ext_call.return_data[0]
                                if balanceOf[this.address] > !ext_call.return_data[0]:
                                    revert with 0, 17
                                if balanceOf[this.address] + ext_call.return_data[0] < balanceOf[this.address]:
                                    revert with 0, 'SafeMath: addition overflow'
                                balanceOf[address(this.address)] = balanceOf[this.address] + ext_call.return_data[0]
                                emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                if arg2 >= 3:
                                    revert with 0, 50
                                mem[_1585 + ceil32(return_data.size) + 256] = 0x12b8603f00000000000000000000000000000000000000000000000000000000
                                mem[_1585 + ceil32(return_data.size) + 260] = msg.sender
                                mem[_1585 + ceil32(return_data.size) + 292] = 64
                                mem[_1585 + ceil32(return_data.size) + 324] = mem[96]
                                mem[_1585 + ceil32(return_data.size) + 356 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                                if ceil32(mem[96]) > mem[96]:
                                    mem[_1585 + ceil32(return_data.size) + mem[96] + 356] = 0
                                require ext_code.size(sub_20eea8b5[arg2])
                                call sub_20eea8b5[arg2].createNode(address arg1, string arg2) with:
                                     gas gas_remaining wei
                                    args msg.sender, Array(len=mem[96], data=mem[_1585 + ceil32(return_data.size) + 356 len ceil32(mem[96])])
                            else:
                                if balanceOf[this.address] and liquidityPoolFee > -1 / balanceOf[this.address]:
                                    revert with 0, 17
                                if not balanceOf[this.address]:
                                    revert with 0, 18
                                if balanceOf[this.address] * liquidityPoolFee / balanceOf[this.address] != liquidityPoolFee:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _773 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_773] = 26
                                mem[_773 + 32] = 'SafeMath: division by zero'
                                _779 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_779] = 26
                                mem[_779 + 32] = 'SafeMath: division by zero'
                                _785 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_785] = 30
                                mem[_785 + 32] = 'SafeMath: subtraction overflow'
                                if balanceOf[this.address] * liquidityPoolFee / 100 / 2 > balanceOf[this.address] * liquidityPoolFee / 100:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if balanceOf[this.address] * liquidityPoolFee / 100 < balanceOf[this.address] * liquidityPoolFee / 100 / 2:
                                    revert with 0, 17
                                _816 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                mem[_816 + 32 len 64] = call.data[calldata.size len 64]
                                if 0 >= mem[_816]:
                                    revert with 0, 50
                                mem[_816 + 32] = this.address
                                require ext_code.size(uniswapV2RouterAddress)
                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                        gas gas_remaining wei
                                mem[_816 + 96] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = _816 + ceil32(return_data.size) + 96
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                if 1 >= mem[_816]:
                                    revert with 0, 50
                                mem[_816 + 64] = ext_call.return_data[12 len 20]
                                if not this.address:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not uniswapV2RouterAddress:
                                    revert with 0, 'ERC20: approve to the zero address'
                                mem[0] = uniswapV2RouterAddress
                                mem[32] = sha3(address(this.address), 1)
                                allowance[address(this.address)][stor9].field_0 = balanceOf[this.address] * liquidityPoolFee / 100 / 2
                                allowance[address(this.address)][stor9].field_255 = 0
                                emit Approval((balanceOf[this.address] * liquidityPoolFee / 100 / 2), this.address, uniswapV2RouterAddress);
                                mem[_816 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                mem[_816 + ceil32(return_data.size) + 100] = balanceOf[this.address] * liquidityPoolFee / 100 / 2
                                mem[_816 + ceil32(return_data.size) + 132] = 0
                                mem[_816 + ceil32(return_data.size) + 164] = 160
                                mem[_816 + ceil32(return_data.size) + 260] = mem[_816]
                                idx = 0
                                s = _816 + ceil32(return_data.size) + 292
                                t = _816 + 32
                                while idx < mem[_816]:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[_816 + ceil32(return_data.size) + 196] = this.address
                                mem[_816 + ceil32(return_data.size) + 228] = block.timestamp
                                require ext_code.size(uniswapV2RouterAddress)
                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len _816 + ceil32(return_data.size) + (32 * mem[_816]) + -mem[64] + 288]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _1443 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1443] = 30
                                mem[_1443 + 32] = 'SafeMath: subtraction overflow'
                                if eth.balance(this.address) > eth.balance(this.address):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if eth.balance(this.address) < eth.balance(this.address):
                                    revert with 0, 17
                                if not this.address:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not uniswapV2RouterAddress:
                                    revert with 0, 'ERC20: approve to the zero address'
                                mem[0] = uniswapV2RouterAddress
                                mem[32] = sha3(address(this.address), 1)
                                allowance[address(this.address)][stor9].field_0 = (balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2)
                                emit Approval(((balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2)), this.address, uniswapV2RouterAddress);
                                mem[mem[64] + 68] = 0
                                mem[mem[64] + 100] = 0
                                mem[mem[64] + 132] = 0
                                mem[mem[64] + 164] = block.timestamp
                                require ext_code.size(uniswapV2RouterAddress)
                                call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                     gas gas_remaining wei
                                    args this.address, (balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2), 0, 0, 0, block.timestamp
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                mem[mem[64] + 32] = 0
                                mem[mem[64] + 64] = (balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2)
                                emit SwapAndLiquify(Mask(255, 1, balanceOf[this.address] * liquidityPoolFee / 100), 0, (balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2));
                                mem[0] = this.address
                                mem[32] = 0
                                _1583 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                mem[_1583 + 32 len 64] = call.data[calldata.size len 64]
                                if 0 >= mem[_1583]:
                                    revert with 0, 50
                                mem[_1583 + 32] = this.address
                                require ext_code.size(uniswapV2RouterAddress)
                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                        gas gas_remaining wei
                                mem[_1583 + 96] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = _1583 + ceil32(return_data.size) + 96
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                if 1 >= mem[_1583]:
                                    revert with 0, 50
                                mem[_1583 + 64] = ext_call.return_data[12 len 20]
                                if not this.address:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not uniswapV2RouterAddress:
                                    revert with 0, 'ERC20: approve to the zero address'
                                mem[0] = uniswapV2RouterAddress
                                mem[32] = sha3(address(this.address), 1)
                                allowance[address(this.address)][stor9].field_0 = balanceOf[this.address]
                                emit Approval(balanceOf[this.address], this.address, uniswapV2RouterAddress);
                                mem[_1583 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                mem[_1583 + ceil32(return_data.size) + 100] = balanceOf[this.address]
                                mem[_1583 + ceil32(return_data.size) + 132] = 0
                                mem[_1583 + ceil32(return_data.size) + 164] = 160
                                mem[_1583 + ceil32(return_data.size) + 260] = mem[_1583]
                                idx = 0
                                s = _1583 + ceil32(return_data.size) + 292
                                t = _1583 + 32
                                while idx < mem[_1583]:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[_1583 + ceil32(return_data.size) + 228] = block.timestamp
                                require ext_code.size(uniswapV2RouterAddress)
                                call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                     gas gas_remaining wei
                                    args balanceOf[this.address], 0, 160, address(this.address), block.timestamp, mem[_1583 + ceil32(return_data.size) + 260 len (32 * mem[_1583]) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[_1583 + ceil32(return_data.size) + 96] = 30
                                mem[_1583 + ceil32(return_data.size) + 128] = 'SafeMath: subtraction overflow'
                                if eth.balance(this.address) > eth.balance(this.address):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if eth.balance(this.address) < eth.balance(this.address):
                                    revert with 0, 17
                                call marketingWalletAddress with:
                                     gas 2300 wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                uint8(stor23.field_0) = 0
                                if not msg.sender:
                                    revert with 0, 'ERC20: transfer from the zero address'
                                if not this.address:
                                    revert with 0, 'ERC20: transfer to the zero address'
                                mem[_1583 + ceil32(return_data.size) + 160] = 38
                                mem[_1583 + ceil32(return_data.size) + 192 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                if ext_call.return_data[0] > balanceOf[address(msg.sender)]:
                                    revert with 0, 
                                                32,
                                                38,
                                                0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, Mask(208, 32, block.timestamp) >> 32 >> 48,
                                                0
                                if balanceOf[address(msg.sender)] < ext_call.return_data[0]:
                                    revert with 0, 17
                                balanceOf[address(msg.sender)] -= ext_call.return_data[0]
                                if balanceOf[this.address] > !ext_call.return_data[0]:
                                    revert with 0, 17
                                if balanceOf[this.address] + ext_call.return_data[0] < balanceOf[this.address]:
                                    revert with 0, 'SafeMath: addition overflow'
                                balanceOf[address(this.address)] = balanceOf[this.address] + ext_call.return_data[0]
                                emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                if arg2 >= 3:
                                    revert with 0, 50
                                mem[_1583 + ceil32(return_data.size) + 256] = 0x12b8603f00000000000000000000000000000000000000000000000000000000
                                mem[_1583 + ceil32(return_data.size) + 260] = msg.sender
                                mem[_1583 + ceil32(return_data.size) + 292] = 64
                                mem[_1583 + ceil32(return_data.size) + 324] = mem[96]
                                mem[_1583 + ceil32(return_data.size) + 356 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                                if ceil32(mem[96]) > mem[96]:
                                    mem[_1583 + ceil32(return_data.size) + mem[96] + 356] = 0
                                require ext_code.size(sub_20eea8b5[arg2])
                                call sub_20eea8b5[arg2].createNode(address arg1, string arg2) with:
                                     gas gas_remaining wei
                                    args msg.sender, Array(len=mem[96], data=mem[_1583 + ceil32(return_data.size) + 356 len ceil32(mem[96])])
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    if stor27[address(msg.sender)] > -2:
        revert with 0, 17
    if stor27[address(msg.sender)] + 1 < stor27[address(msg.sender)]:
        revert with 0, 'SafeMath: addition overflow'
    stor27[address(msg.sender)]++
}

function sub_c16aaecf(?) {
    require calldata.size - 4 >= 64
    require arg2 <= test266151307()
    require arg2 + 35 < calldata.size
    if arg2.length > test266151307():
        revert with 0, 65
    if ceil32(ceil32(arg2.length)) + 97 < 96 or ceil32(ceil32(arg2.length)) + 97 > test266151307():
        revert with 0, 65
    mem[64] = ceil32(ceil32(arg2.length)) + 97
    mem[96] = arg2.length
    require arg2 + arg2.length + 36 <= calldata.size
    mem[128 len arg2.length] = arg2[all]
    mem[arg2.length + 128] = 0
    idx = 0
    s = 0
    while idx < 3:
        mem[mem[64] + 4] = msg.sender
        mem[mem[64] + 36] = 0
        require ext_code.size(sub_20eea8b5[idx])
        staticcall sub_20eea8b5[idx].0x80e9be34 with:
                gas gas_remaining wei
               args msg.sender, 0
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _15 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        if s > !mem[_15]:
            revert with 0, 17
        if s + mem[_15] < s:
            revert with 0, 'SafeMath: addition overflow'
        if idx == -1:
            revert with 0, 17
        idx = idx + 1
        s = s + mem[_15]
        continue 
    mem[0] = msg.sender
    mem[32] = 0
    if arg1 >= 3:
        revert with 0, 50
    require ext_code.size(sub_20eea8b5[arg1])
    staticcall sub_20eea8b5[arg1].nodePrice() with:
            gas gas_remaining wei
    mem[mem[64]] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _12 = mem[64]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    _14 = mem[_12]
    if 0x6f32f1ef8b18a2bc3cea59789c79d441 * s > !balanceOf[address(msg.sender)]:
        revert with 0, 17
    if (0x6f32f1ef8b18a2bc3cea59789c79d441 * s) + balanceOf[address(msg.sender)] < 0x6f32f1ef8b18a2bc3cea59789c79d441 * s:
        revert with 0, 'SafeMath: addition overflow'
    if (0x6f32f1ef8b18a2bc3cea59789c79d441 * s) + balanceOf[address(msg.sender)] < mem[_12]:
        revert with 0, 'Insufficient balance'
    if 0x6f32f1ef8b18a2bc3cea59789c79d441 * s >= mem[_12]:
        idx = 0
        while idx < 3:
            mem[mem[64] + 4] = msg.sender
            mem[mem[64] + 36] = 0
            require ext_code.size(sub_20eea8b5[idx])
            staticcall sub_20eea8b5[idx].0x80e9be34 with:
                    gas gas_remaining wei
                   args msg.sender, 0
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _492 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _504 = mem[_492]
            if not _14:
                if not distributionPoolAddress:
                    revert with 0, 'ERC20: transfer from the zero address'
                if not msg.sender:
                    revert with 0, 'ERC20: transfer to the zero address'
                _524 = mem[64]
                mem[64] = mem[64] + 96
                mem[_524] = 38
                mem[_524 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                mem[32] = 0
                if _504 > balanceOf[stor12]:
                    _534 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 38
                    idx = 0
                    while idx < 38:
                        mem[idx + _534 + 68] = mem[_524 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_534 + 106] = 0
                    revert with memory
                      from mem[64]
                       len _534 + -mem[64] + 132
                if balanceOf[stor12] < _504:
                    revert with 0, 17
                balanceOf[stor12] -= _504
                if balanceOf[msg.sender] > !_504:
                    revert with 0, 17
                if balanceOf[msg.sender] + _504 < balanceOf[msg.sender]:
                    revert with 0, 'SafeMath: addition overflow'
                mem[0] = msg.sender
                mem[32] = 0
                balanceOf[address(msg.sender)] = balanceOf[msg.sender] + _504
                emit Transfer(_504, distributionPoolAddress, msg.sender);
                if idx >= 3:
                    revert with 0, 50
                mem[mem[64]] = 0xd74037e500000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = msg.sender
                mem[mem[64] + 36] = 0
                mem[mem[64] + 68] = 0
                require ext_code.size(sub_20eea8b5[idx])
                call sub_20eea8b5[idx].0xd74037e5 with:
                     gas gas_remaining wei
                    args msg.sender, 0, 0
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            if 0 > !mem[_492]:
                revert with 0, 17
            if mem[_492] < 0:
                revert with 0, 'SafeMath: addition overflow'
            if mem[_492] < _14:
                if not distributionPoolAddress:
                    revert with 0, 'ERC20: transfer from the zero address'
                if not msg.sender:
                    revert with 0, 'ERC20: transfer to the zero address'
                _558 = mem[64]
                mem[64] = mem[64] + 96
                mem[_558] = 38
                mem[_558 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                mem[32] = 0
                if _504 > balanceOf[stor12]:
                    _564 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 38
                    idx = 0
                    while idx < 38:
                        mem[idx + _564 + 68] = mem[_558 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_564 + 106] = 0
                    revert with memory
                      from mem[64]
                       len _564 + -mem[64] + 132
                if balanceOf[stor12] < _504:
                    revert with 0, 17
                balanceOf[stor12] -= _504
                if balanceOf[msg.sender] > !_504:
                    revert with 0, 17
                if balanceOf[msg.sender] + _504 < balanceOf[msg.sender]:
                    revert with 0, 'SafeMath: addition overflow'
                mem[0] = msg.sender
                mem[32] = 0
                balanceOf[address(msg.sender)] = balanceOf[msg.sender] + _504
                emit Transfer(_504, distributionPoolAddress, msg.sender);
                if idx >= 3:
                    revert with 0, 50
                mem[mem[64]] = 0xd74037e500000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = msg.sender
                mem[mem[64] + 36] = 0
                mem[mem[64] + 68] = 0
                require ext_code.size(sub_20eea8b5[idx])
                call sub_20eea8b5[idx].0xd74037e5 with:
                     gas gas_remaining wei
                    args msg.sender, 0, 0
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if 0 > !_504:
                    revert with 0, 17
                if _504 < 0:
                    revert with 0, 'SafeMath: addition overflow'
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            _543 = mem[64]
            mem[64] = mem[64] + 64
            mem[_543] = 30
            mem[_543 + 32] = 'SafeMath: subtraction overflow'
            if 0 > _14:
                _557 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _557 + 68] = mem[_543 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_557 + 98] = 0
                revert with memory
                  from mem[64]
                   len _557 + -mem[64] + 100
            if _14 < 0:
                revert with 0, 17
            if not distributionPoolAddress:
                revert with 0, 'ERC20: transfer from the zero address'
            if not msg.sender:
                revert with 0, 'ERC20: transfer to the zero address'
            _609 = mem[64]
            mem[64] = mem[64] + 96
            mem[_609] = 38
            mem[_609 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
            mem[32] = 0
            if _14 > balanceOf[stor12]:
                _645 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 38
                idx = 0
                while idx < 38:
                    mem[idx + _645 + 68] = mem[_609 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_645 + 106] = 0
                revert with memory
                  from mem[64]
                   len _645 + -mem[64] + 132
            if balanceOf[stor12] < _14:
                revert with 0, 17
            balanceOf[stor12] -= _14
            if balanceOf[msg.sender] > !_14:
                revert with 0, 17
            if balanceOf[msg.sender] + _14 < balanceOf[msg.sender]:
                revert with 0, 'SafeMath: addition overflow'
            mem[0] = msg.sender
            mem[32] = 0
            balanceOf[address(msg.sender)] = balanceOf[msg.sender] + _14
            emit Transfer(_14, distributionPoolAddress, msg.sender);
            if idx >= 3:
                revert with 0, 50
            _815 = mem[64]
            mem[64] = mem[64] + 64
            mem[_815] = 30
            mem[_815 + 32] = 'SafeMath: subtraction overflow'
            if 0 > _14:
                _829 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _829 + 68] = mem[_815 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_829 + 98] = 0
                revert with memory
                  from mem[64]
                   len _829 + -mem[64] + 100
            if _14 < 0:
                revert with 0, 17
            mem[mem[64]] = 0xd74037e500000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = msg.sender
            mem[mem[64] + 36] = _14
            mem[mem[64] + 68] = 0
            require ext_code.size(sub_20eea8b5[idx])
            call sub_20eea8b5[idx].0xd74037e5 with:
                 gas gas_remaining wei
                args msg.sender, _14, 0
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if mem[96] <= 3:
                revert with 0, 'NODE CREATION: NAME SIZE INVALID'
            if mem[96] >= 32:
                revert with 0, 'NODE CREATION: NAME SIZE INVALID'
            if sub_6cdc78b3 <= stor27[msg.sender]:
                revert with 0, 'cannot create node more than 100'
            if not msg.sender:
                revert with 0, 'NODE CREATION:  creation from the zero address'
            mem[0] = msg.sender
            mem[32] = 25
            if stor25[address(msg.sender)]:
                revert with 0, 'NODE CREATION: Blacklisted address'
            if futurUsePoolAddress == msg.sender:
                revert with 0, 'NODE CREATION: futur and rewardsPool cannot create node'
            if distributionPoolAddress == msg.sender:
                revert with 0, 'NODE CREATION: futur and rewardsPool cannot create node'
            if arg1 >= 3:
                revert with 0, 50
            require ext_code.size(sub_20eea8b5[arg1])
            staticcall sub_20eea8b5[arg1].nodePrice() with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1033 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _1038 = mem[_1033]
            if balanceOf[address(msg.sender)] < mem[_1033]:
                revert with 0, 'NODE CREATION: Balance too low for creation.'
            mem[0] = this.address
            mem[32] = 0
            if balanceOf[this.address] < swapTokensAmount:
                if not msg.sender:
                    revert with 0, 'ERC20: transfer from the zero address'
                if not this.address:
                    revert with 0, 'ERC20: transfer to the zero address'
                _1101 = mem[64]
                mem[64] = mem[64] + 96
                mem[_1101] = 38
                mem[_1101 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                mem[32] = 0
                if _1038 > balanceOf[address(msg.sender)]:
                    _1118 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 38
                    idx = 0
                    while idx < 38:
                        mem[idx + _1118 + 68] = mem[_1101 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1118 + 106] = 0
                    revert with memory
                      from mem[64]
                       len _1118 + -mem[64] + 132
                if balanceOf[address(msg.sender)] < _1038:
                    revert with 0, 17
                balanceOf[address(msg.sender)] -= _1038
                if balanceOf[this.address] > !_1038:
                    revert with 0, 17
                if balanceOf[this.address] + _1038 < balanceOf[this.address]:
                    revert with 0, 'SafeMath: addition overflow'
                balanceOf[address(this.address)] = balanceOf[this.address] + _1038
                emit Transfer(_1038, msg.sender, this.address);
                if arg1 >= 3:
                    revert with 0, 50
                mem[mem[64]] = 0x12b8603f00000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = msg.sender
                mem[mem[64] + 36] = 64
                mem[mem[64] + 68] = mem[96]
                idx = 0
                while idx < mem[96]:
                    mem[idx + mem[64] + 100] = mem[idx + 128]
                    idx = idx + 32
                    continue 
                if ceil32(mem[96]) > mem[96]:
                    mem[mem[64] + mem[96] + 100] = 0
                require ext_code.size(sub_20eea8b5[arg1])
                call sub_20eea8b5[arg1].createNode(address arg1, string arg2) with:
                     gas gas_remaining wei
                    args msg.sender, Array(len=mem[96], data=mem[mem[64] + 100 len ceil32(mem[96])])
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if stor27[address(msg.sender)] > -2:
                    revert with 0, 17
                if stor27[address(msg.sender)] + 1 < stor27[address(msg.sender)]:
                    revert with 0, 'SafeMath: addition overflow'
            else:
                if not uint8(stor23.field_8):
                    if not msg.sender:
                        revert with 0, 'ERC20: transfer from the zero address'
                    if not this.address:
                        revert with 0, 'ERC20: transfer to the zero address'
                    _1110 = mem[64]
                    mem[64] = mem[64] + 96
                    mem[_1110] = 38
                    mem[_1110 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                    mem[32] = 0
                    if _1038 > balanceOf[address(msg.sender)]:
                        _1129 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 38
                        idx = 0
                        while idx < 38:
                            mem[idx + _1129 + 68] = mem[_1110 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1129 + 106] = 0
                        revert with memory
                          from mem[64]
                           len _1129 + -mem[64] + 132
                    if balanceOf[address(msg.sender)] < _1038:
                        revert with 0, 17
                    balanceOf[address(msg.sender)] -= _1038
                    if balanceOf[this.address] > !_1038:
                        revert with 0, 17
                    if balanceOf[this.address] + _1038 < balanceOf[this.address]:
                        revert with 0, 'SafeMath: addition overflow'
                    balanceOf[address(this.address)] = balanceOf[this.address] + _1038
                    emit Transfer(_1038, msg.sender, this.address);
                    if arg1 >= 3:
                        revert with 0, 50
                    mem[mem[64]] = 0x12b8603f00000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = msg.sender
                    mem[mem[64] + 36] = 64
                    mem[mem[64] + 68] = mem[96]
                    idx = 0
                    while idx < mem[96]:
                        mem[idx + mem[64] + 100] = mem[idx + 128]
                        idx = idx + 32
                        continue 
                    if ceil32(mem[96]) > mem[96]:
                        mem[mem[64] + mem[96] + 100] = 0
                    require ext_code.size(sub_20eea8b5[arg1])
                    call sub_20eea8b5[arg1].createNode(address arg1, string arg2) with:
                         gas gas_remaining wei
                        args msg.sender, Array(len=mem[96], data=mem[mem[64] + 100 len ceil32(mem[96])])
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if stor27[address(msg.sender)] > -2:
                        revert with 0, 17
                    if stor27[address(msg.sender)] + 1 < stor27[address(msg.sender)]:
                        revert with 0, 'SafeMath: addition overflow'
                else:
                    if uint8(stor23.field_0):
                        if not msg.sender:
                            revert with 0, 'ERC20: transfer from the zero address'
                        if not this.address:
                            revert with 0, 'ERC20: transfer to the zero address'
                        _1121 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_1121] = 38
                        mem[_1121 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                        mem[32] = 0
                        if _1038 > balanceOf[address(msg.sender)]:
                            _1139 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 38
                            idx = 0
                            while idx < 38:
                                mem[idx + _1139 + 68] = mem[_1121 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_1139 + 106] = 0
                            revert with memory
                              from mem[64]
                               len _1139 + -mem[64] + 132
                        if balanceOf[address(msg.sender)] < _1038:
                            revert with 0, 17
                        balanceOf[address(msg.sender)] -= _1038
                        if balanceOf[this.address] > !_1038:
                            revert with 0, 17
                        if balanceOf[this.address] + _1038 < balanceOf[this.address]:
                            revert with 0, 'SafeMath: addition overflow'
                        balanceOf[address(this.address)] = balanceOf[this.address] + _1038
                        emit Transfer(_1038, msg.sender, this.address);
                        if arg1 >= 3:
                            revert with 0, 50
                        mem[mem[64]] = 0x12b8603f00000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = msg.sender
                        mem[mem[64] + 36] = 64
                        mem[mem[64] + 68] = mem[96]
                        idx = 0
                        while idx < mem[96]:
                            mem[idx + mem[64] + 100] = mem[idx + 128]
                            idx = idx + 32
                            continue 
                        if ceil32(mem[96]) > mem[96]:
                            mem[mem[64] + mem[96] + 100] = 0
                        require ext_code.size(sub_20eea8b5[arg1])
                        call sub_20eea8b5[arg1].createNode(address arg1, string arg2) with:
                             gas gas_remaining wei
                            args msg.sender, Array(len=mem[96], data=mem[mem[64] + 100 len ceil32(mem[96])])
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if stor27[address(msg.sender)] > -2:
                            revert with 0, 17
                        if stor27[address(msg.sender)] + 1 < stor27[address(msg.sender)]:
                            revert with 0, 'SafeMath: addition overflow'
                    else:
                        if owner == msg.sender:
                            if not msg.sender:
                                revert with 0, 'ERC20: transfer from the zero address'
                            if not this.address:
                                revert with 0, 'ERC20: transfer to the zero address'
                            _1132 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_1132] = 38
                            mem[_1132 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                            mem[32] = 0
                            if _1038 > balanceOf[address(msg.sender)]:
                                _1152 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 38
                                idx = 0
                                while idx < 38:
                                    mem[idx + _1152 + 68] = mem[_1132 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_1152 + 106] = 0
                                revert with memory
                                  from mem[64]
                                   len _1152 + -mem[64] + 132
                            if balanceOf[address(msg.sender)] < _1038:
                                revert with 0, 17
                            balanceOf[address(msg.sender)] -= _1038
                            if balanceOf[this.address] > !_1038:
                                revert with 0, 17
                            if balanceOf[this.address] + _1038 < balanceOf[this.address]:
                                revert with 0, 'SafeMath: addition overflow'
                            balanceOf[address(this.address)] = balanceOf[this.address] + _1038
                            emit Transfer(_1038, msg.sender, this.address);
                            if arg1 >= 3:
                                revert with 0, 50
                            mem[mem[64]] = 0x12b8603f00000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = msg.sender
                            mem[mem[64] + 36] = 64
                            mem[mem[64] + 68] = mem[96]
                            idx = 0
                            while idx < mem[96]:
                                mem[idx + mem[64] + 100] = mem[idx + 128]
                                idx = idx + 32
                                continue 
                            if ceil32(mem[96]) > mem[96]:
                                mem[mem[64] + mem[96] + 100] = 0
                            require ext_code.size(sub_20eea8b5[arg1])
                            call sub_20eea8b5[arg1].createNode(address arg1, string arg2) with:
                                 gas gas_remaining wei
                                args msg.sender, Array(len=mem[96], data=mem[mem[64] + 100 len ceil32(mem[96])])
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if stor27[address(msg.sender)] > -2:
                                revert with 0, 17
                            if stor27[address(msg.sender)] + 1 < stor27[address(msg.sender)]:
                                revert with 0, 'SafeMath: addition overflow'
                        else:
                            mem[0] = msg.sender
                            mem[32] = 26
                            if stor26[address(msg.sender)]:
                                if not msg.sender:
                                    revert with 0, 'ERC20: transfer from the zero address'
                                if not this.address:
                                    revert with 0, 'ERC20: transfer to the zero address'
                                _1142 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_1142] = 38
                                mem[_1142 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                mem[32] = 0
                                if _1038 > balanceOf[address(msg.sender)]:
                                    _1159 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 38
                                    idx = 0
                                    while idx < 38:
                                        mem[idx + _1159 + 68] = mem[_1142 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_1159 + 106] = 0
                                    revert with memory
                                      from mem[64]
                                       len _1159 + -mem[64] + 132
                                if balanceOf[address(msg.sender)] < _1038:
                                    revert with 0, 17
                                balanceOf[address(msg.sender)] -= _1038
                                if balanceOf[this.address] > !_1038:
                                    revert with 0, 17
                                if balanceOf[this.address] + _1038 < balanceOf[this.address]:
                                    revert with 0, 'SafeMath: addition overflow'
                                balanceOf[address(this.address)] = balanceOf[this.address] + _1038
                                emit Transfer(_1038, msg.sender, this.address);
                                if arg1 >= 3:
                                    revert with 0, 50
                                _1273 = mem[64]
                                mem[mem[64]] = 0x12b8603f00000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = msg.sender
                                mem[mem[64] + 36] = 64
                                _1297 = mem[96]
                                mem[mem[64] + 68] = mem[96]
                                idx = 0
                                while idx < _1297:
                                    mem[idx + mem[64] + 100] = mem[idx + 128]
                                    idx = idx + 32
                                    continue 
                                if ceil32(_1297) > _1297:
                                    mem[_1273 + _1297 + 100] = 0
                                require ext_code.size(sub_20eea8b5[arg1])
                                call sub_20eea8b5[arg1].mem[mem[64] len 4] with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len ceil32(_1297) + _1273 + -mem[64] + 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if stor27[address(msg.sender)] > -2:
                                    revert with 0, 17
                                if stor27[address(msg.sender)] + 1 < stor27[address(msg.sender)]:
                                    revert with 0, 'SafeMath: addition overflow'
                            else:
                                uint8(stor23.field_0) = 1
                                if not balanceOf[this.address]:
                                    _1161 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_1161] = 26
                                    mem[_1161 + 32] = 'SafeMath: division by zero'
                                    _1266 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_1266] = 26
                                    mem[_1266 + 32] = 'SafeMath: division by zero'
                                    _1358 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    mem[_1358 + 32 len 64] = call.data[calldata.size len 64]
                                    if 0 >= mem[_1358]:
                                        revert with 0, 50
                                    mem[_1358 + 32] = this.address
                                    require ext_code.size(uniswapV2RouterAddress)
                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                            gas gas_remaining wei
                                    mem[_1358 + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = _1358 + ceil32(return_data.size) + 96
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    if 1 >= mem[_1358]:
                                        revert with 0, 50
                                    mem[_1358 + 64] = ext_call.return_data[12 len 20]
                                    if not this.address:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not uniswapV2RouterAddress:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    mem[0] = uniswapV2RouterAddress
                                    mem[32] = sha3(address(this.address), 1)
                                    allowance[address(this.address)][stor9].field_0 = 0
                                    emit Approval(0, this.address, uniswapV2RouterAddress);
                                    mem[_1358 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                    mem[_1358 + ceil32(return_data.size) + 100] = 0
                                    mem[_1358 + ceil32(return_data.size) + 132] = 0
                                    mem[_1358 + ceil32(return_data.size) + 164] = 160
                                    mem[_1358 + ceil32(return_data.size) + 260] = mem[_1358]
                                    idx = 0
                                    s = _1358 + ceil32(return_data.size) + 292
                                    t = _1358 + 32
                                    while idx < mem[_1358]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_1358 + ceil32(return_data.size) + 196] = this.address
                                    mem[_1358 + ceil32(return_data.size) + 228] = block.timestamp
                                    require ext_code.size(uniswapV2RouterAddress)
                                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _1358 + ceil32(return_data.size) + (32 * mem[_1358]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _2402 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_2402] = 30
                                    mem[_2402 + 32] = 'SafeMath: subtraction overflow'
                                    if eth.balance(this.address) > eth.balance(this.address):
                                        _2426 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _2426 + 68] = mem[_2402 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_2426 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _2426 + -mem[64] + 100
                                    if eth.balance(this.address) < eth.balance(this.address):
                                        revert with 0, 17
                                    call distributionPoolAddress with:
                                         gas 2300 wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _2569 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_2569] = 30
                                    mem[_2569 + 32] = 'SafeMath: subtraction overflow'
                                    if not this.address:
                                        revert with 0, 'ERC20: transfer from the zero address'
                                    if not distributionPoolAddress:
                                        revert with 0, 'ERC20: transfer to the zero address'
                                    _2634 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_2634] = 38
                                    mem[_2634 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                    mem[32] = 0
                                    if 0 > balanceOf[address(this.address)]:
                                        _2662 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 38
                                        idx = 0
                                        while idx < 38:
                                            mem[idx + _2662 + 68] = mem[_2634 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_2662 + 106] = 0
                                        revert with memory
                                          from mem[64]
                                           len _2662 + -mem[64] + 132
                                    if balanceOf[address(this.address)] < 0:
                                        revert with 0, 17
                                    if balanceOf[stor12] > -1:
                                        revert with 0, 17
                                    if balanceOf[stor12] < balanceOf[stor12]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = distributionPoolAddress
                                    mem[32] = 0
                                    balanceOf[stor12] = balanceOf[stor12]
                                    emit Transfer(0, this.address, distributionPoolAddress);
                                    if not balanceOf[this.address]:
                                        _2771 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2771] = 26
                                        mem[_2771 + 32] = 'SafeMath: division by zero'
                                        _2807 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2807] = 26
                                        mem[_2807 + 32] = 'SafeMath: division by zero'
                                        _2825 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2825] = 30
                                        mem[_2825 + 32] = 'SafeMath: subtraction overflow'
                                        _2860 = mem[64]
                                        mem[mem[64]] = 2
                                        mem[64] = mem[64] + 96
                                        mem[_2860 + 32 len 64] = call.data[calldata.size len 64]
                                        if 0 >= mem[_2860]:
                                            revert with 0, 50
                                        mem[_2860 + 32] = this.address
                                        require ext_code.size(uniswapV2RouterAddress)
                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                gas gas_remaining wei
                                        mem[_2860 + 96] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[64] = _2860 + ceil32(return_data.size) + 96
                                        require return_data.size >= 32
                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                        if 1 >= mem[_2860]:
                                            revert with 0, 50
                                        mem[_2860 + 64] = ext_call.return_data[12 len 20]
                                        if not this.address:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not uniswapV2RouterAddress:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        mem[0] = uniswapV2RouterAddress
                                        mem[32] = sha3(address(this.address), 1)
                                        allowance[address(this.address)][stor9].field_0 = 0
                                        emit Approval(0, this.address, uniswapV2RouterAddress);
                                        mem[_2860 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                        mem[_2860 + ceil32(return_data.size) + 100] = 0
                                        mem[_2860 + ceil32(return_data.size) + 132] = 0
                                        mem[_2860 + ceil32(return_data.size) + 164] = 160
                                        mem[_2860 + ceil32(return_data.size) + 260] = mem[_2860]
                                        idx = 0
                                        s = _2860 + ceil32(return_data.size) + 292
                                        t = _2860 + 32
                                        while idx < mem[_2860]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_2860 + ceil32(return_data.size) + 228] = block.timestamp
                                        require ext_code.size(uniswapV2RouterAddress)
                                        call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args 0, 0, 160, address(this.address), block.timestamp, mem[_2860 + ceil32(return_data.size) + 260 len (32 * mem[_2860]) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[_2860 + ceil32(return_data.size) + 96] = 30
                                        mem[_2860 + ceil32(return_data.size) + 128] = 'SafeMath: subtraction overflow'
                                        if eth.balance(this.address) > eth.balance(this.address):
                                            mem[_2860 + ceil32(return_data.size) + 160] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_2860 + ceil32(return_data.size) + 164] = 32
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _2860 + ceil32(return_data.size) + 228] = mem[_2860 + ceil32(return_data.size) + idx + 128]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 32, 30, mem[_2860 + ceil32(return_data.size) + 228 len 30], 0
                                        if eth.balance(this.address) < eth.balance(this.address):
                                            revert with 0, 17
                                        if not this.address:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not uniswapV2RouterAddress:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(this.address)][stor9].field_0 = 0
                                        emit Approval(0, this.address, uniswapV2RouterAddress);
                                        mem[_2860 + ceil32(return_data.size) + 228] = 0
                                        mem[_2860 + ceil32(return_data.size) + 260] = 0
                                        mem[_2860 + ceil32(return_data.size) + 292] = 0
                                        mem[_2860 + ceil32(return_data.size) + 324] = block.timestamp
                                        require ext_code.size(uniswapV2RouterAddress)
                                        call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                             gas gas_remaining wei
                                            args this.address, 0, 0, 0, 0, block.timestamp
                                        mem[_2860 + ceil32(return_data.size) + 160 len 96] = ext_call.return_data[0 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 96
                                        emit SwapAndLiquify(uint256 arg1, uint256 arg2, uint256 arg3):
                                                            0,
                                        mem[_2860 + (2 * ceil32(return_data.size)) + 160] = 2
                                        mem[_2860 + (2 * ceil32(return_data.size)) + 192] = this.address
                                        require ext_code.size(uniswapV2RouterAddress)
                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                gas gas_remaining wei
                                        mem[_2860 + (2 * ceil32(return_data.size)) + 256] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                        mem[_2860 + (2 * ceil32(return_data.size)) + 224] = ext_call.return_data[12 len 20]
                                        if not this.address:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not uniswapV2RouterAddress:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(this.address)][stor9].field_0 = balanceOf[this.address]
                                        emit Approval(balanceOf[this.address], this.address, uniswapV2RouterAddress);
                                        mem[_2860 + (4 * ceil32(return_data.size)) + 256] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                        mem[_2860 + (4 * ceil32(return_data.size)) + 260] = balanceOf[this.address]
                                        mem[_2860 + (4 * ceil32(return_data.size)) + 292] = 0
                                        mem[_2860 + (4 * ceil32(return_data.size)) + 324] = 160
                                        mem[_2860 + (4 * ceil32(return_data.size)) + 420] = 2
                                        idx = 0
                                        s = _2860 + (4 * ceil32(return_data.size)) + 452
                                        t = _2860 + (2 * ceil32(return_data.size)) + 192
                                        while idx < mem[_2860 + (2 * ceil32(return_data.size)) + 160]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_2860 + (4 * ceil32(return_data.size)) + 356] = this.address
                                        mem[_2860 + (4 * ceil32(return_data.size)) + 388] = block.timestamp
                                        require ext_code.size(uniswapV2RouterAddress)
                                        call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args balanceOf[this.address], 0, 160, address(this.address), block.timestamp, mem[_2860 + (4 * ceil32(return_data.size)) + 420 len (32 * mem[_2860 + (2 * ceil32(return_data.size)) + 160]) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[_2860 + (4 * ceil32(return_data.size)) + 256] = 30
                                        mem[_2860 + (4 * ceil32(return_data.size)) + 288] = 'SafeMath: subtraction overflow'
                                        if eth.balance(this.address) > eth.balance(this.address):
                                            mem[_2860 + (4 * ceil32(return_data.size)) + 320] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_2860 + (4 * ceil32(return_data.size)) + 324] = 32
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _2860 + (4 * ceil32(return_data.size)) + 388] = mem[_2860 + (4 * ceil32(return_data.size)) + idx + 288]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 32, 30, mem[_2860 + (4 * ceil32(return_data.size)) + 388 len 30], 0
                                        if eth.balance(this.address) < eth.balance(this.address):
                                            revert with 0, 17
                                        call marketingWalletAddress with:
                                             gas 2300 wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        uint8(stor23.field_0) = 0
                                        if not msg.sender:
                                            mem[_2860 + (4 * ceil32(return_data.size)) + 320] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_2860 + (4 * ceil32(return_data.size)) + 324] = 32
                                            mem[_2860 + (4 * ceil32(return_data.size)) + 356] = 37
                                            mem[_2860 + (4 * ceil32(return_data.size)) + 388] = 'ERC20: transfer from the zero ad'
                                            mem[_2860 + (4 * ceil32(return_data.size)) + 420] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                            revert with memory
                                              from _2860 + (4 * ceil32(return_data.size)) + 320
                                               len (5 * ceil32(return_data.size)) + 132
                                        if not this.address:
                                            mem[_2860 + (4 * ceil32(return_data.size)) + 320] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_2860 + (4 * ceil32(return_data.size)) + 324] = 32
                                            mem[_2860 + (4 * ceil32(return_data.size)) + 356] = 35
                                            mem[_2860 + (4 * ceil32(return_data.size)) + 388] = 'ERC20: transfer to the zero addr'
                                            mem[_2860 + (4 * ceil32(return_data.size)) + 420] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                            revert with memory
                                              from _2860 + (4 * ceil32(return_data.size)) + 320
                                               len (5 * ceil32(return_data.size)) + 132
                                        mem[_2860 + (4 * ceil32(return_data.size)) + 320] = 38
                                        mem[_2860 + (4 * ceil32(return_data.size)) + 352 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                        if _1038 > balanceOf[address(msg.sender)]:
                                            mem[_2860 + (4 * ceil32(return_data.size)) + 416] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_2860 + (4 * ceil32(return_data.size)) + 420] = 32
                                            idx = 0
                                            while idx < 38:
                                                mem[idx + _2860 + (4 * ceil32(return_data.size)) + 484] = mem[_2860 + (4 * ceil32(return_data.size)) + idx + 352]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 32, 38, mem[_2860 + (4 * ceil32(return_data.size)) + 484 len 38], 0
                                        if balanceOf[address(msg.sender)] < _1038:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] -= _1038
                                        if balanceOf[this.address] > !_1038:
                                            revert with 0, 17
                                        if balanceOf[this.address] + _1038 >= balanceOf[this.address]:
                                            balanceOf[address(this.address)] = balanceOf[this.address] + _1038
                                            emit Transfer(_1038, msg.sender, this.address);
                                            if arg1 >= 3:
                                                revert with 0, 50
                                            mem[_2860 + (4 * ceil32(return_data.size)) + 416] = 0x12b8603f00000000000000000000000000000000000000000000000000000000
                                            mem[_2860 + (4 * ceil32(return_data.size)) + 420] = msg.sender
                                            mem[_2860 + (4 * ceil32(return_data.size)) + 452] = 64
                                            mem[_2860 + (4 * ceil32(return_data.size)) + 484] = mem[96]
                                            idx = 0
                                            while idx < mem[96]:
                                                mem[idx + _2860 + (4 * ceil32(return_data.size)) + 516] = mem[idx + 128]
                                                idx = idx + 32
                                                continue 
                                            if ceil32(mem[96]) > mem[96]:
                                                mem[_2860 + (4 * ceil32(return_data.size)) + mem[96] + 516] = 0
                                            require ext_code.size(sub_20eea8b5[arg1])
                                            call sub_20eea8b5[arg1].createNode(address arg1, string arg2) with:
                                                 gas gas_remaining wei
                                                args mem[_2860 + (4 * ceil32(return_data.size)) + 420 len ceil32(mem[96]) + (5 * ceil32(return_data.size)) + 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if stor27[address(msg.sender)] > -2:
                                                revert with 0, 17
                                            if stor27[address(msg.sender)] + 1 >= stor27[address(msg.sender)]:
                                                stor27[address(msg.sender)]++
                                        mem[_2860 + (4 * ceil32(return_data.size)) + 416] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[_2860 + (4 * ceil32(return_data.size)) + 420] = 32
                                        mem[_2860 + (4 * ceil32(return_data.size)) + 452] = 27
                                        mem[_2860 + (4 * ceil32(return_data.size)) + 484] = 'SafeMath: addition overflow'
                                        revert with memory
                                          from _2860 + (4 * ceil32(return_data.size)) + 416
                                           len (5 * ceil32(return_data.size)) + 100
                                    if balanceOf[this.address] and liquidityPoolFee > -1 / balanceOf[this.address]:
                                        revert with 0, 17
                                    if not balanceOf[this.address]:
                                        revert with 0, 18
                                    if balanceOf[this.address] * liquidityPoolFee / balanceOf[this.address] != liquidityPoolFee:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _2798 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_2798] = 26
                                    mem[_2798 + 32] = 'SafeMath: division by zero'
                                    _2816 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_2816] = 26
                                    mem[_2816 + 32] = 'SafeMath: division by zero'
                                    _2834 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_2834] = 30
                                    mem[_2834 + 32] = 'SafeMath: subtraction overflow'
                                    if balanceOf[this.address] * liquidityPoolFee / 100 / 2 > balanceOf[this.address] * liquidityPoolFee / 100:
                                        _2859 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _2859 + 68] = mem[_2834 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_2859 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _2859 + -mem[64] + 100
                                    if balanceOf[this.address] * liquidityPoolFee / 100 < balanceOf[this.address] * liquidityPoolFee / 100 / 2:
                                        revert with 0, 17
                                    _2932 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    mem[_2932 + 32 len 64] = call.data[calldata.size len 64]
                                    if 0 >= mem[_2932]:
                                        revert with 0, 50
                                    mem[_2932 + 32] = this.address
                                    require ext_code.size(uniswapV2RouterAddress)
                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                            gas gas_remaining wei
                                    mem[_2932 + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = _2932 + ceil32(return_data.size) + 96
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    if 1 >= mem[_2932]:
                                        revert with 0, 50
                                    mem[_2932 + 64] = ext_call.return_data[12 len 20]
                                    if not this.address:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not uniswapV2RouterAddress:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    mem[0] = uniswapV2RouterAddress
                                    mem[32] = sha3(address(this.address), 1)
                                    allowance[address(this.address)][stor9].field_0 = balanceOf[this.address] * liquidityPoolFee / 100 / 2
                                    allowance[address(this.address)][stor9].field_255 = 0
                                    emit Approval((balanceOf[this.address] * liquidityPoolFee / 100 / 2), this.address, uniswapV2RouterAddress);
                                    mem[_2932 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                    mem[_2932 + ceil32(return_data.size) + 100] = balanceOf[this.address] * liquidityPoolFee / 100 / 2
                                    mem[_2932 + ceil32(return_data.size) + 132] = 0
                                    mem[_2932 + ceil32(return_data.size) + 164] = 160
                                    mem[_2932 + ceil32(return_data.size) + 260] = mem[_2932]
                                    idx = 0
                                    s = _2932 + ceil32(return_data.size) + 292
                                    t = _2932 + 32
                                    while idx < mem[_2932]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_2932 + ceil32(return_data.size) + 228] = block.timestamp
                                    require ext_code.size(uniswapV2RouterAddress)
                                    call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args Mask(255, 1, balanceOf[this.address] * liquidityPoolFee / 100), 0, 160, address(this.address), block.timestamp, mem[_2932 + ceil32(return_data.size) + 260 len (32 * mem[_2932]) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_2932 + ceil32(return_data.size) + 96] = 30
                                    mem[_2932 + ceil32(return_data.size) + 128] = 'SafeMath: subtraction overflow'
                                    if eth.balance(this.address) > eth.balance(this.address):
                                        mem[_2932 + ceil32(return_data.size) + 160] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[_2932 + ceil32(return_data.size) + 164] = 32
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _2932 + ceil32(return_data.size) + 228] = mem[_2932 + ceil32(return_data.size) + idx + 128]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 32, 30, mem[_2932 + ceil32(return_data.size) + 228 len 30], 0
                                    if eth.balance(this.address) < eth.balance(this.address):
                                        revert with 0, 17
                                    if not this.address:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not uniswapV2RouterAddress:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    allowance[address(this.address)][stor9].field_0 = (balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2)
                                    emit Approval(((balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2)), this.address, uniswapV2RouterAddress);
                                    mem[_2932 + ceil32(return_data.size) + 228] = 0
                                    mem[_2932 + ceil32(return_data.size) + 260] = 0
                                    mem[_2932 + ceil32(return_data.size) + 292] = 0
                                    mem[_2932 + ceil32(return_data.size) + 324] = block.timestamp
                                    require ext_code.size(uniswapV2RouterAddress)
                                    call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                         gas gas_remaining wei
                                        args this.address, (balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2), 0, 0, 0, block.timestamp
                                    mem[_2932 + ceil32(return_data.size) + 160 len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 96
                                    emit SwapAndLiquify(Mask(255, 1, balanceOf[this.address] * liquidityPoolFee / 100), 0, (balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2));
                                    mem[_2932 + (2 * ceil32(return_data.size)) + 160] = 2
                                    mem[_2932 + (2 * ceil32(return_data.size)) + 192] = this.address
                                    require ext_code.size(uniswapV2RouterAddress)
                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                            gas gas_remaining wei
                                    mem[_2932 + (2 * ceil32(return_data.size)) + 256] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = _2932 + (4 * ceil32(return_data.size)) + 256
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    mem[_2932 + (2 * ceil32(return_data.size)) + 224] = ext_call.return_data[12 len 20]
                                    if not this.address:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not uniswapV2RouterAddress:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    mem[0] = uniswapV2RouterAddress
                                    mem[32] = sha3(address(this.address), 1)
                                    allowance[address(this.address)][stor9].field_0 = balanceOf[this.address]
                                    emit Approval(balanceOf[this.address], this.address, uniswapV2RouterAddress);
                                    mem[_2932 + (4 * ceil32(return_data.size)) + 256] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                    mem[_2932 + (4 * ceil32(return_data.size)) + 260] = balanceOf[this.address]
                                    mem[_2932 + (4 * ceil32(return_data.size)) + 292] = 0
                                    mem[_2932 + (4 * ceil32(return_data.size)) + 324] = 160
                                    mem[_2932 + (4 * ceil32(return_data.size)) + 420] = 2
                                    idx = 0
                                    s = _2932 + (4 * ceil32(return_data.size)) + 452
                                    t = _2932 + (2 * ceil32(return_data.size)) + 192
                                    while idx < mem[_2932 + (2 * ceil32(return_data.size)) + 160]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_2932 + (4 * ceil32(return_data.size)) + 356] = this.address
                                    mem[_2932 + (4 * ceil32(return_data.size)) + 388] = block.timestamp
                                    require ext_code.size(uniswapV2RouterAddress)
                                    call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args balanceOf[this.address], 0, 160, address(this.address), block.timestamp, mem[_2932 + (4 * ceil32(return_data.size)) + 420 len (32 * mem[_2932 + (2 * ceil32(return_data.size)) + 160]) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_2932 + (4 * ceil32(return_data.size)) + 256] = 30
                                    mem[_2932 + (4 * ceil32(return_data.size)) + 288] = 'SafeMath: subtraction overflow'
                                    if eth.balance(this.address) > eth.balance(this.address):
                                        mem[_2932 + (4 * ceil32(return_data.size)) + 320] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[_2932 + (4 * ceil32(return_data.size)) + 324] = 32
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _2932 + (4 * ceil32(return_data.size)) + 388] = mem[_2932 + (4 * ceil32(return_data.size)) + idx + 288]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 32, 30, mem[_2932 + (4 * ceil32(return_data.size)) + 388 len 30], 0
                                    if eth.balance(this.address) < eth.balance(this.address):
                                        revert with 0, 17
                                    call marketingWalletAddress with:
                                         gas 2300 wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    uint8(stor23.field_0) = 0
                                    if not msg.sender:
                                        mem[_2932 + (4 * ceil32(return_data.size)) + 320] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[_2932 + (4 * ceil32(return_data.size)) + 324] = 32
                                        mem[_2932 + (4 * ceil32(return_data.size)) + 356] = 37
                                        mem[_2932 + (4 * ceil32(return_data.size)) + 388] = 'ERC20: transfer from the zero ad'
                                        mem[_2932 + (4 * ceil32(return_data.size)) + 420] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                        revert with memory
                                          from _2932 + (4 * ceil32(return_data.size)) + 320
                                           len (5 * ceil32(return_data.size)) + 132
                                    if not this.address:
                                        mem[_2932 + (4 * ceil32(return_data.size)) + 320] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[_2932 + (4 * ceil32(return_data.size)) + 324] = 32
                                        mem[_2932 + (4 * ceil32(return_data.size)) + 356] = 35
                                        mem[_2932 + (4 * ceil32(return_data.size)) + 388] = 'ERC20: transfer to the zero addr'
                                        mem[_2932 + (4 * ceil32(return_data.size)) + 420] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                        revert with memory
                                          from _2932 + (4 * ceil32(return_data.size)) + 320
                                           len (5 * ceil32(return_data.size)) + 132
                                    mem[_2932 + (4 * ceil32(return_data.size)) + 320] = 38
                                    mem[_2932 + (4 * ceil32(return_data.size)) + 352 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                    if _1038 > balanceOf[address(msg.sender)]:
                                        mem[_2932 + (4 * ceil32(return_data.size)) + 416] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[_2932 + (4 * ceil32(return_data.size)) + 420] = 32
                                        idx = 0
                                        while idx < 38:
                                            mem[idx + _2932 + (4 * ceil32(return_data.size)) + 484] = mem[_2932 + (4 * ceil32(return_data.size)) + idx + 352]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 32, 38, mem[_2932 + (4 * ceil32(return_data.size)) + 484 len 38], 0
                                    if balanceOf[address(msg.sender)] < _1038:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)] -= _1038
                                    if balanceOf[this.address] > !_1038:
                                        revert with 0, 17
                                    if balanceOf[this.address] + _1038 >= balanceOf[this.address]:
                                        balanceOf[address(this.address)] = balanceOf[this.address] + _1038
                                        emit Transfer(_1038, msg.sender, this.address);
                                        if arg1 >= 3:
                                            revert with 0, 50
                                        mem[_2932 + (4 * ceil32(return_data.size)) + 416] = 0x12b8603f00000000000000000000000000000000000000000000000000000000
                                        mem[_2932 + (4 * ceil32(return_data.size)) + 420] = msg.sender
                                        mem[_2932 + (4 * ceil32(return_data.size)) + 452] = 64
                                        mem[_2932 + (4 * ceil32(return_data.size)) + 484] = mem[96]
                                        idx = 0
                                        while idx < mem[96]:
                                            mem[idx + _2932 + (4 * ceil32(return_data.size)) + 516] = mem[idx + 128]
                                            idx = idx + 32
                                            continue 
                                        if ceil32(mem[96]) > mem[96]:
                                            mem[_2932 + (4 * ceil32(return_data.size)) + mem[96] + 516] = 0
                                        require ext_code.size(sub_20eea8b5[arg1])
                                        call sub_20eea8b5[arg1].createNode(address arg1, string arg2) with:
                                             gas gas_remaining wei
                                            args mem[_2932 + (4 * ceil32(return_data.size)) + 420 len ceil32(mem[96]) + (5 * ceil32(return_data.size)) + 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if stor27[address(msg.sender)] > -2:
                                            revert with 0, 17
                                        if stor27[address(msg.sender)] + 1 >= stor27[address(msg.sender)]:
                                            stor27[address(msg.sender)]++
                                    mem[_2932 + (4 * ceil32(return_data.size)) + 416] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[_2932 + (4 * ceil32(return_data.size)) + 420] = 32
                                    mem[_2932 + (4 * ceil32(return_data.size)) + 452] = 27
                                    mem[_2932 + (4 * ceil32(return_data.size)) + 484] = 'SafeMath: addition overflow'
                                    revert with memory
                                      from _2932 + (4 * ceil32(return_data.size)) + 416
                                       len (5 * ceil32(return_data.size)) + 100
                                if balanceOf[this.address] and rewardsFee > -1 / balanceOf[this.address]:
                                    revert with 0, 17
                                if not balanceOf[this.address]:
                                    revert with 0, 18
                                if balanceOf[this.address] * rewardsFee / balanceOf[this.address] != rewardsFee:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _1206 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1206] = 26
                                mem[_1206 + 32] = 'SafeMath: division by zero'
                                if not balanceOf[this.address] * rewardsFee / 100:
                                    _1316 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_1316] = 26
                                    mem[_1316 + 32] = 'SafeMath: division by zero'
                                    _1421 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    mem[_1421 + 32 len 64] = call.data[calldata.size len 64]
                                    if 0 >= mem[_1421]:
                                        revert with 0, 50
                                    mem[_1421 + 32] = this.address
                                    require ext_code.size(uniswapV2RouterAddress)
                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                            gas gas_remaining wei
                                    mem[_1421 + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = _1421 + ceil32(return_data.size) + 96
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    if 1 >= mem[_1421]:
                                        revert with 0, 50
                                    mem[_1421 + 64] = ext_call.return_data[12 len 20]
                                    if not this.address:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not uniswapV2RouterAddress:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    mem[0] = uniswapV2RouterAddress
                                    mem[32] = sha3(address(this.address), 1)
                                    allowance[address(this.address)][stor9].field_0 = 0
                                    emit Approval(0, this.address, uniswapV2RouterAddress);
                                    mem[_1421 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                    mem[_1421 + ceil32(return_data.size) + 100] = 0
                                    mem[_1421 + ceil32(return_data.size) + 132] = 0
                                    mem[_1421 + ceil32(return_data.size) + 164] = 160
                                    mem[_1421 + ceil32(return_data.size) + 260] = mem[_1421]
                                    idx = 0
                                    s = _1421 + ceil32(return_data.size) + 292
                                    t = _1421 + 32
                                    while idx < mem[_1421]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_1421 + ceil32(return_data.size) + 228] = block.timestamp
                                    require ext_code.size(uniswapV2RouterAddress)
                                    call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args 0, 0, 160, address(this.address), block.timestamp, mem[_1421 + ceil32(return_data.size) + 260 len (32 * mem[_1421]) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_1421 + ceil32(return_data.size) + 96] = 30
                                    mem[_1421 + ceil32(return_data.size) + 128] = 'SafeMath: subtraction overflow'
                                    if eth.balance(this.address) > eth.balance(this.address):
                                        mem[_1421 + ceil32(return_data.size) + 160] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[_1421 + ceil32(return_data.size) + 164] = 32
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _1421 + ceil32(return_data.size) + 228] = mem[_1421 + ceil32(return_data.size) + idx + 128]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 32, 30, mem[_1421 + ceil32(return_data.size) + 228 len 30], 0
                                    if eth.balance(this.address) < eth.balance(this.address):
                                        revert with 0, 17
                                    call distributionPoolAddress with:
                                         gas 2300 wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_1421 + ceil32(return_data.size) + 160] = 30
                                    mem[_1421 + ceil32(return_data.size) + 192] = 'SafeMath: subtraction overflow'
                                    if 0 > balanceOf[this.address] * rewardsFee / 100:
                                        mem[_1421 + ceil32(return_data.size) + 224] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[_1421 + ceil32(return_data.size) + 228] = 32
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _1421 + ceil32(return_data.size) + 292] = mem[_1421 + ceil32(return_data.size) + idx + 192]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 32, 30, mem[_1421 + ceil32(return_data.size) + 292 len 30], 0
                                    if balanceOf[this.address] * rewardsFee / 100 < 0:
                                        revert with 0, 17
                                    if not this.address:
                                        revert with 0, 'ERC20: transfer from the zero address'
                                    if not distributionPoolAddress:
                                        revert with 0, 'ERC20: transfer to the zero address'
                                    mem[_1421 + ceil32(return_data.size) + 224] = 38
                                    mem[_1421 + ceil32(return_data.size) + 256 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                    if balanceOf[this.address] * rewardsFee / 100 > balanceOf[address(this.address)]:
                                        mem[_1421 + ceil32(return_data.size) + 320] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[_1421 + ceil32(return_data.size) + 324] = 32
                                        idx = 0
                                        while idx < 38:
                                            mem[idx + _1421 + ceil32(return_data.size) + 388] = mem[_1421 + ceil32(return_data.size) + idx + 256]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 32, 38, mem[_1421 + ceil32(return_data.size) + 388 len 38], 0
                                    if balanceOf[address(this.address)] < balanceOf[this.address] * rewardsFee / 100:
                                        revert with 0, 17
                                    balanceOf[address(this.address)] -= balanceOf[this.address] * rewardsFee / 100
                                    if balanceOf[stor12] > !(balanceOf[this.address] * rewardsFee / 100):
                                        revert with 0, 17
                                    if balanceOf[stor12] + (balanceOf[this.address] * rewardsFee / 100) < balanceOf[stor12]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[stor12] += balanceOf[this.address] * rewardsFee / 100
                                    emit Transfer((balanceOf[this.address] * rewardsFee / 100), this.address, distributionPoolAddress);
                                    if not balanceOf[this.address]:
                                        mem[_1421 + ceil32(return_data.size) + 320] = 26
                                        mem[_1421 + ceil32(return_data.size) + 352] = 'SafeMath: division by zero'
                                        mem[_1421 + ceil32(return_data.size) + 384] = 26
                                        mem[_1421 + ceil32(return_data.size) + 416] = 'SafeMath: division by zero'
                                        mem[_1421 + ceil32(return_data.size) + 448] = 30
                                        mem[_1421 + ceil32(return_data.size) + 480] = 'SafeMath: subtraction overflow'
                                        mem[_1421 + ceil32(return_data.size) + 512] = 2
                                        mem[_1421 + ceil32(return_data.size) + 544] = this.address
                                        require ext_code.size(uniswapV2RouterAddress)
                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                gas gas_remaining wei
                                        mem[_1421 + ceil32(return_data.size) + 608] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[64] = _1421 + (2 * ceil32(return_data.size)) + 608
                                        require return_data.size >= 32
                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                        mem[_1421 + ceil32(return_data.size) + 576] = ext_call.return_data[12 len 20]
                                        if not this.address:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not uniswapV2RouterAddress:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        mem[0] = uniswapV2RouterAddress
                                        mem[32] = sha3(address(this.address), 1)
                                        allowance[address(this.address)][stor9].field_0 = 0
                                        emit Approval(0, this.address, uniswapV2RouterAddress);
                                        mem[_1421 + (2 * ceil32(return_data.size)) + 608] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                        mem[_1421 + (2 * ceil32(return_data.size)) + 612] = 0
                                        mem[_1421 + (2 * ceil32(return_data.size)) + 644] = 0
                                        mem[_1421 + (2 * ceil32(return_data.size)) + 676] = 160
                                        mem[_1421 + (2 * ceil32(return_data.size)) + 772] = 2
                                        idx = 0
                                        s = _1421 + (2 * ceil32(return_data.size)) + 804
                                        t = _1421 + ceil32(return_data.size) + 544
                                        while idx < mem[_1421 + ceil32(return_data.size) + 512]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_1421 + (2 * ceil32(return_data.size)) + 708] = this.address
                                        mem[_1421 + (2 * ceil32(return_data.size)) + 740] = block.timestamp
                                        require ext_code.size(uniswapV2RouterAddress)
                                        call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args 0, 0, 160, address(this.address), block.timestamp, mem[_1421 + (2 * ceil32(return_data.size)) + 772 len (32 * mem[_1421 + ceil32(return_data.size) + 512]) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[_1421 + (2 * ceil32(return_data.size)) + 608] = 30
                                        mem[_1421 + (2 * ceil32(return_data.size)) + 640] = 'SafeMath: subtraction overflow'
                                        if eth.balance(this.address) > eth.balance(this.address):
                                            mem[_1421 + (2 * ceil32(return_data.size)) + 672] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_1421 + (2 * ceil32(return_data.size)) + 676] = 32
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _1421 + (2 * ceil32(return_data.size)) + 740] = mem[_1421 + (2 * ceil32(return_data.size)) + idx + 640]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 32, 30, mem[_1421 + (2 * ceil32(return_data.size)) + 740 len 30], 0
                                        if eth.balance(this.address) < eth.balance(this.address):
                                            revert with 0, 17
                                        if not this.address:
                                            mem[_1421 + (2 * ceil32(return_data.size)) + 672] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_1421 + (2 * ceil32(return_data.size)) + 676] = 32
                                            mem[_1421 + (2 * ceil32(return_data.size)) + 708] = 36
                                            mem[_1421 + (2 * ceil32(return_data.size)) + 740] = 'ERC20: approve from the zero add'
                                            mem[_1421 + (2 * ceil32(return_data.size)) + 772] = 0x7265737300000000000000000000000000000000000000000000000000000000
                                            revert with memory
                                              from _1421 + (2 * ceil32(return_data.size)) + 672
                                               len ceil32(return_data.size) + 132
                                        if not uniswapV2RouterAddress:
                                            mem[_1421 + (2 * ceil32(return_data.size)) + 672] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_1421 + (2 * ceil32(return_data.size)) + 676] = 32
                                            mem[_1421 + (2 * ceil32(return_data.size)) + 708] = 34
                                            mem[_1421 + (2 * ceil32(return_data.size)) + 740] = 'ERC20: approve to the zero addre'
                                            mem[_1421 + (2 * ceil32(return_data.size)) + 772] = 0x7373000000000000000000000000000000000000000000000000000000000000
                                            revert with memory
                                              from _1421 + (2 * ceil32(return_data.size)) + 672
                                               len ceil32(return_data.size) + 132
                                        allowance[address(this.address)][stor9].field_0 = 0
                                        emit Approval(0, this.address, uniswapV2RouterAddress);
                                        mem[_1421 + (2 * ceil32(return_data.size)) + 676] = this.address
                                        mem[_1421 + (2 * ceil32(return_data.size)) + 708] = 0
                                        mem[_1421 + (2 * ceil32(return_data.size)) + 740] = 0
                                        mem[_1421 + (2 * ceil32(return_data.size)) + 772] = 0
                                        mem[_1421 + (2 * ceil32(return_data.size)) + 804] = 0
                                        mem[_1421 + (2 * ceil32(return_data.size)) + 836] = block.timestamp
                                        require ext_code.size(uniswapV2RouterAddress)
                                        call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                             gas gas_remaining wei
                                            args mem[_1421 + (2 * ceil32(return_data.size)) + 676 len ceil32(return_data.size) + 192]
                                        mem[_1421 + (2 * ceil32(return_data.size)) + 672 len 96] = ext_call.return_data[0 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 96
                                        mem[_1421 + (4 * ceil32(return_data.size)) + 672] = 0
                                        mem[_1421 + (4 * ceil32(return_data.size)) + 704] = 0
                                        mem[_1421 + (4 * ceil32(return_data.size)) + 736] = 0
                                        emit SwapAndLiquify(uint256 arg1, uint256 arg2, uint256 arg3):
                                                            mem[_1421 + (4 * ceil32(return_data.size)) + 672 len (5 * ceil32(return_data.size)) + 96],
                                        mem[_1421 + (4 * ceil32(return_data.size)) + 672] = 2
                                        mem[_1421 + (4 * ceil32(return_data.size)) + 704] = this.address
                                        require ext_code.size(uniswapV2RouterAddress)
                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                gas gas_remaining wei
                                        mem[_1421 + (4 * ceil32(return_data.size)) + 768] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[64] = _1421 + (6 * ceil32(return_data.size)) + 768
                                        require return_data.size >= 32
                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                        mem[_1421 + (4 * ceil32(return_data.size)) + 736] = ext_call.return_data[12 len 20]
                                        if not this.address:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not uniswapV2RouterAddress:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        mem[0] = uniswapV2RouterAddress
                                        mem[32] = sha3(address(this.address), 1)
                                        allowance[address(this.address)][stor9].field_0 = balanceOf[this.address]
                                        emit Approval(balanceOf[this.address], this.address, uniswapV2RouterAddress);
                                        mem[_1421 + (6 * ceil32(return_data.size)) + 768] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                        mem[_1421 + (6 * ceil32(return_data.size)) + 772] = balanceOf[this.address]
                                        mem[_1421 + (6 * ceil32(return_data.size)) + 804] = 0
                                        mem[_1421 + (6 * ceil32(return_data.size)) + 836] = 160
                                        mem[_1421 + (6 * ceil32(return_data.size)) + 932] = 2
                                        idx = 0
                                        s = _1421 + (6 * ceil32(return_data.size)) + 964
                                        t = _1421 + (4 * ceil32(return_data.size)) + 704
                                        while idx < mem[_1421 + (4 * ceil32(return_data.size)) + 672]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_1421 + (6 * ceil32(return_data.size)) + 900] = block.timestamp
                                        require ext_code.size(uniswapV2RouterAddress)
                                        call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args balanceOf[this.address], 0, 160, address(this.address), block.timestamp, mem[_1421 + (6 * ceil32(return_data.size)) + 932 len (32 * mem[_1421 + (4 * ceil32(return_data.size)) + 672]) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[_1421 + (6 * ceil32(return_data.size)) + 768] = 30
                                        mem[_1421 + (6 * ceil32(return_data.size)) + 800] = 'SafeMath: subtraction overflow'
                                        if eth.balance(this.address) > eth.balance(this.address):
                                            mem[_1421 + (6 * ceil32(return_data.size)) + 832] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_1421 + (6 * ceil32(return_data.size)) + 836] = 32
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _1421 + (6 * ceil32(return_data.size)) + 900] = mem[_1421 + (6 * ceil32(return_data.size)) + idx + 800]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 32, 30, mem[_1421 + (6 * ceil32(return_data.size)) + 900 len 30], 0
                                        if eth.balance(this.address) < eth.balance(this.address):
                                            revert with 0, 17
                                        call marketingWalletAddress with:
                                             gas 2300 wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        uint8(stor23.field_0) = 0
                                        if not msg.sender:
                                            revert with 0, 
                                                        'ERC20: transfer from the zero address',
                                                        mem[_1421 + (6 * ceil32(return_data.size)) + 964 len 9 * ceil32(return_data.size)]
                                        if not this.address:
                                            revert with 0, 
                                                        'ERC20: transfer to the zero address',
                                                        mem[_1421 + (6 * ceil32(return_data.size)) + 964 len 9 * ceil32(return_data.size)]
                                        mem[_1421 + (6 * ceil32(return_data.size)) + 832] = 38
                                        mem[_1421 + (6 * ceil32(return_data.size)) + 864 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                        if _1038 > balanceOf[address(msg.sender)]:
                                            mem[_1421 + (6 * ceil32(return_data.size)) + 928] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_1421 + (6 * ceil32(return_data.size)) + 932] = 32
                                            idx = 0
                                            while idx < 38:
                                                mem[idx + _1421 + (6 * ceil32(return_data.size)) + 996] = mem[_1421 + (6 * ceil32(return_data.size)) + idx + 864]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 32, 38, mem[_1421 + (6 * ceil32(return_data.size)) + 996 len 38], 0
                                        if balanceOf[address(msg.sender)] < _1038:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] -= _1038
                                        if balanceOf[this.address] > !_1038:
                                            revert with 0, 17
                                        if balanceOf[this.address] + _1038 < balanceOf[this.address]:
                                            revert with 0, 'SafeMath: addition overflow', mem[_1421 + (6 * ceil32(return_data.size)) + 1028 len 9 * ceil32(return_data.size)]
                                        balanceOf[address(this.address)] = balanceOf[this.address] + _1038
                                        emit Transfer(_1038, msg.sender, this.address);
                                        if arg1 >= 3:
                                            revert with 0, 50
                                        mem[_1421 + (6 * ceil32(return_data.size)) + 928] = 0x12b8603f00000000000000000000000000000000000000000000000000000000
                                        mem[_1421 + (6 * ceil32(return_data.size)) + 932] = msg.sender
                                        mem[_1421 + (6 * ceil32(return_data.size)) + 964] = 64
                                        mem[_1421 + (6 * ceil32(return_data.size)) + 996] = mem[96]
                                        idx = 0
                                        while idx < mem[96]:
                                            mem[idx + _1421 + (6 * ceil32(return_data.size)) + 1028] = mem[idx + 128]
                                            idx = idx + 32
                                            continue 
                                        if ceil32(mem[96]) > mem[96]:
                                            mem[_1421 + (6 * ceil32(return_data.size)) + mem[96] + 1028] = 0
                                        require ext_code.size(sub_20eea8b5[arg1])
                                        call sub_20eea8b5[arg1].createNode(address arg1, string arg2) with:
                                             gas gas_remaining wei
                                            args msg.sender, Array(len=mem[96], data=mem[_1421 + (6 * ceil32(return_data.size)) + 1028 len (9 * ceil32(return_data.size)) + ceil32(mem[96])])
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if stor27[address(msg.sender)] > -2:
                                            revert with 0, 17
                                        if stor27[address(msg.sender)] + 1 < stor27[address(msg.sender)]:
                                            revert with 0, 'SafeMath: addition overflow', mem[_1421 + (6 * ceil32(return_data.size)) + 1028 len 9 * ceil32(return_data.size)]
                                    else:
                                        if balanceOf[this.address] and liquidityPoolFee > -1 / balanceOf[this.address]:
                                            revert with 0, 17
                                        if not balanceOf[this.address]:
                                            revert with 0, 18
                                        if balanceOf[this.address] * liquidityPoolFee / balanceOf[this.address] != liquidityPoolFee:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        mem[_1421 + ceil32(return_data.size) + 320] = 26
                                        mem[_1421 + ceil32(return_data.size) + 352] = 'SafeMath: division by zero'
                                        mem[_1421 + ceil32(return_data.size) + 384] = 26
                                        mem[_1421 + ceil32(return_data.size) + 416] = 'SafeMath: division by zero'
                                        mem[_1421 + ceil32(return_data.size) + 448] = 30
                                        mem[_1421 + ceil32(return_data.size) + 480] = 'SafeMath: subtraction overflow'
                                        if balanceOf[this.address] * liquidityPoolFee / 100 / 2 > balanceOf[this.address] * liquidityPoolFee / 100:
                                            mem[_1421 + ceil32(return_data.size) + 512] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_1421 + ceil32(return_data.size) + 516] = 32
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _1421 + ceil32(return_data.size) + 580] = mem[_1421 + ceil32(return_data.size) + idx + 480]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 32, 30, mem[_1421 + ceil32(return_data.size) + 580 len 30], 0
                                        if balanceOf[this.address] * liquidityPoolFee / 100 < balanceOf[this.address] * liquidityPoolFee / 100 / 2:
                                            revert with 0, 17
                                        mem[_1421 + ceil32(return_data.size) + 512] = 2
                                        mem[_1421 + ceil32(return_data.size) + 544] = this.address
                                        require ext_code.size(uniswapV2RouterAddress)
                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                gas gas_remaining wei
                                        mem[_1421 + ceil32(return_data.size) + 608] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[64] = _1421 + (2 * ceil32(return_data.size)) + 608
                                        require return_data.size >= 32
                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                        mem[_1421 + ceil32(return_data.size) + 576] = ext_call.return_data[12 len 20]
                                        if not this.address:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not uniswapV2RouterAddress:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        mem[0] = uniswapV2RouterAddress
                                        mem[32] = sha3(address(this.address), 1)
                                        allowance[address(this.address)][stor9].field_0 = balanceOf[this.address] * liquidityPoolFee / 100 / 2
                                        allowance[address(this.address)][stor9].field_255 = 0
                                        emit Approval((balanceOf[this.address] * liquidityPoolFee / 100 / 2), this.address, uniswapV2RouterAddress);
                                        mem[_1421 + (2 * ceil32(return_data.size)) + 608] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                        mem[_1421 + (2 * ceil32(return_data.size)) + 612] = balanceOf[this.address] * liquidityPoolFee / 100 / 2
                                        mem[_1421 + (2 * ceil32(return_data.size)) + 644] = 0
                                        mem[_1421 + (2 * ceil32(return_data.size)) + 676] = 160
                                        mem[_1421 + (2 * ceil32(return_data.size)) + 772] = 2
                                        idx = 0
                                        s = _1421 + (2 * ceil32(return_data.size)) + 804
                                        t = _1421 + ceil32(return_data.size) + 544
                                        while idx < mem[_1421 + ceil32(return_data.size) + 512]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_1421 + (2 * ceil32(return_data.size)) + 708] = this.address
                                        mem[_1421 + (2 * ceil32(return_data.size)) + 740] = block.timestamp
                                        require ext_code.size(uniswapV2RouterAddress)
                                        call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _1421 + (2 * ceil32(return_data.size)) + (32 * mem[_1421 + ceil32(return_data.size) + 512]) + -mem[64] + 800]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _4811 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_4811] = 30
                                        mem[_4811 + 32] = 'SafeMath: subtraction overflow'
                                        if eth.balance(this.address) > eth.balance(this.address):
                                            _4829 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _4829 + 68] = mem[_4811 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_4829 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _4829 + -mem[64] + 100
                                        if eth.balance(this.address) < eth.balance(this.address):
                                            revert with 0, 17
                                        if not this.address:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not uniswapV2RouterAddress:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        mem[0] = uniswapV2RouterAddress
                                        mem[32] = sha3(address(this.address), 1)
                                        allowance[address(this.address)][stor9].field_0 = (balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2)
                                        emit Approval(((balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2)), this.address, uniswapV2RouterAddress);
                                        mem[mem[64] + 68] = 0
                                        mem[mem[64] + 100] = 0
                                        mem[mem[64] + 132] = 0
                                        mem[mem[64] + 164] = block.timestamp
                                        require ext_code.size(uniswapV2RouterAddress)
                                        call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                             gas gas_remaining wei
                                            args this.address, (balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2), 0, 0, 0, block.timestamp
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 96
                                        mem[mem[64] + 32] = 0
                                        mem[mem[64] + 64] = (balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2)
                                        emit SwapAndLiquify(Mask(255, 1, balanceOf[this.address] * liquidityPoolFee / 100), 0, (balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2));
                                        mem[0] = this.address
                                        mem[32] = 0
                                        _5239 = mem[64]
                                        mem[mem[64]] = 2
                                        mem[64] = mem[64] + 96
                                        mem[_5239 + 32 len 64] = call.data[calldata.size len 64]
                                        if 0 >= mem[_5239]:
                                            revert with 0, 50
                                        mem[_5239 + 32] = this.address
                                        require ext_code.size(uniswapV2RouterAddress)
                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                gas gas_remaining wei
                                        mem[_5239 + 96] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[64] = _5239 + ceil32(return_data.size) + 96
                                        require return_data.size >= 32
                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                        if 1 >= mem[_5239]:
                                            revert with 0, 50
                                        mem[_5239 + 64] = ext_call.return_data[12 len 20]
                                        if not this.address:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not uniswapV2RouterAddress:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        mem[0] = uniswapV2RouterAddress
                                        mem[32] = sha3(address(this.address), 1)
                                        allowance[address(this.address)][stor9].field_0 = balanceOf[this.address]
                                        emit Approval(balanceOf[this.address], this.address, uniswapV2RouterAddress);
                                        mem[_5239 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                        mem[_5239 + ceil32(return_data.size) + 100] = balanceOf[this.address]
                                        mem[_5239 + ceil32(return_data.size) + 132] = 0
                                        mem[_5239 + ceil32(return_data.size) + 164] = 160
                                        mem[_5239 + ceil32(return_data.size) + 260] = mem[_5239]
                                        idx = 0
                                        s = _5239 + ceil32(return_data.size) + 292
                                        t = _5239 + 32
                                        while idx < mem[_5239]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_5239 + ceil32(return_data.size) + 196] = this.address
                                        mem[_5239 + ceil32(return_data.size) + 228] = block.timestamp
                                        require ext_code.size(uniswapV2RouterAddress)
                                        call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _5239 + ceil32(return_data.size) + (32 * mem[_5239]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _6341 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6341] = 30
                                        mem[_6341 + 32] = 'SafeMath: subtraction overflow'
                                        if eth.balance(this.address) > eth.balance(this.address):
                                            _6359 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _6359 + 68] = mem[_6341 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_6359 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _6359 + -mem[64] + 100
                                        if eth.balance(this.address) < eth.balance(this.address):
                                            revert with 0, 17
                                        call marketingWalletAddress with:
                                             gas 2300 wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        uint8(stor23.field_0) = 0
                                        if not msg.sender:
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not this.address:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        _6513 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_6513] = 38
                                        mem[_6513 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                        mem[32] = 0
                                        if _1038 > balanceOf[address(msg.sender)]:
                                            _6571 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 38
                                            idx = 0
                                            while idx < 38:
                                                mem[idx + _6571 + 68] = mem[_6513 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_6571 + 106] = 0
                                            revert with memory
                                              from mem[64]
                                               len _6571 + -mem[64] + 132
                                        if balanceOf[address(msg.sender)] < _1038:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] -= _1038
                                        if balanceOf[this.address] > !_1038:
                                            revert with 0, 17
                                        if balanceOf[this.address] + _1038 < balanceOf[this.address]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(this.address)] = balanceOf[this.address] + _1038
                                        emit Transfer(_1038, msg.sender, this.address);
                                        if arg1 >= 3:
                                            revert with 0, 50
                                        _6791 = mem[64]
                                        mem[mem[64]] = 0x12b8603f00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 64
                                        _6809 = mem[96]
                                        mem[mem[64] + 68] = mem[96]
                                        idx = 0
                                        while idx < _6809:
                                            mem[idx + mem[64] + 100] = mem[idx + 128]
                                            idx = idx + 32
                                            continue 
                                        if ceil32(_6809) > _6809:
                                            mem[_6791 + _6809 + 100] = 0
                                        require ext_code.size(sub_20eea8b5[arg1])
                                        call sub_20eea8b5[arg1].mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len ceil32(_6809) + _6791 + -mem[64] + 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if stor27[address(msg.sender)] > -2:
                                            revert with 0, 17
                                        if stor27[address(msg.sender)] + 1 < stor27[address(msg.sender)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                else:
                                    if balanceOf[this.address] * rewardsFee / 100 and stor22 > -1 / balanceOf[this.address] * rewardsFee / 100:
                                        revert with 0, 17
                                    if not balanceOf[this.address] * rewardsFee / 100:
                                        revert with 0, 18
                                    if balanceOf[this.address] * rewardsFee / 100 * stor22 / balanceOf[this.address] * rewardsFee / 100 != stor22:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _1382 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_1382] = 26
                                    mem[_1382 + 32] = 'SafeMath: division by zero'
                                    _1455 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    mem[_1455 + 32 len 64] = call.data[calldata.size len 64]
                                    if 0 >= mem[_1455]:
                                        revert with 0, 50
                                    mem[_1455 + 32] = this.address
                                    require ext_code.size(uniswapV2RouterAddress)
                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                            gas gas_remaining wei
                                    mem[_1455 + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = _1455 + ceil32(return_data.size) + 96
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    if 1 >= mem[_1455]:
                                        revert with 0, 50
                                    mem[_1455 + 64] = ext_call.return_data[12 len 20]
                                    if not this.address:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not uniswapV2RouterAddress:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    mem[0] = uniswapV2RouterAddress
                                    mem[32] = sha3(address(this.address), 1)
                                    allowance[address(this.address)][stor9].field_0 = balanceOf[this.address] * rewardsFee / 100 * stor22 / 100
                                    emit Approval((balanceOf[this.address] * rewardsFee / 100 * stor22 / 100), this.address, uniswapV2RouterAddress);
                                    mem[_1455 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                    mem[_1455 + ceil32(return_data.size) + 100] = balanceOf[this.address] * rewardsFee / 100 * stor22 / 100
                                    mem[_1455 + ceil32(return_data.size) + 132] = 0
                                    mem[_1455 + ceil32(return_data.size) + 164] = 160
                                    mem[_1455 + ceil32(return_data.size) + 260] = mem[_1455]
                                    idx = 0
                                    s = _1455 + ceil32(return_data.size) + 292
                                    t = _1455 + 32
                                    while idx < mem[_1455]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_1455 + ceil32(return_data.size) + 196] = this.address
                                    mem[_1455 + ceil32(return_data.size) + 228] = block.timestamp
                                    require ext_code.size(uniswapV2RouterAddress)
                                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _1455 + ceil32(return_data.size) + (32 * mem[_1455]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _2400 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_2400] = 30
                                    mem[_2400 + 32] = 'SafeMath: subtraction overflow'
                                    if eth.balance(this.address) > eth.balance(this.address):
                                        _2424 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _2424 + 68] = mem[_2400 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_2424 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _2424 + -mem[64] + 100
                                    if eth.balance(this.address) < eth.balance(this.address):
                                        revert with 0, 17
                                    call distributionPoolAddress with:
                                         gas 2300 wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _2565 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_2565] = 30
                                    mem[_2565 + 32] = 'SafeMath: subtraction overflow'
                                    if balanceOf[this.address] * rewardsFee / 100 * stor22 / 100 > balanceOf[this.address] * rewardsFee / 100:
                                        _2575 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _2575 + 68] = mem[_2565 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_2575 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _2575 + -mem[64] + 100
                                    if balanceOf[this.address] * rewardsFee / 100 < balanceOf[this.address] * rewardsFee / 100 * stor22 / 100:
                                        revert with 0, 17
                                    if not this.address:
                                        revert with 0, 'ERC20: transfer from the zero address'
                                    if not distributionPoolAddress:
                                        revert with 0, 'ERC20: transfer to the zero address'
                                    _2626 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_2626] = 38
                                    mem[_2626 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                    mem[32] = 0
                                    if (balanceOf[this.address] * rewardsFee / 100) - (balanceOf[this.address] * rewardsFee / 100 * stor22 / 100) > balanceOf[address(this.address)]:
                                        _2658 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 38
                                        idx = 0
                                        while idx < 38:
                                            mem[idx + _2658 + 68] = mem[_2626 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_2658 + 106] = 0
                                        revert with memory
                                          from mem[64]
                                           len _2658 + -mem[64] + 132
                                    if balanceOf[address(this.address)] < (balanceOf[this.address] * rewardsFee / 100) - (balanceOf[this.address] * rewardsFee / 100 * stor22 / 100):
                                        revert with 0, 17
                                    balanceOf[address(this.address)] = balanceOf[address(this.address)] - (balanceOf[this.address] * rewardsFee / 100) + (balanceOf[this.address] * rewardsFee / 100 * stor22 / 100)
                                    if balanceOf[stor12] > !((balanceOf[this.address] * rewardsFee / 100) - (balanceOf[this.address] * rewardsFee / 100 * stor22 / 100)):
                                        revert with 0, 17
                                    if balanceOf[stor12] + (balanceOf[this.address] * rewardsFee / 100) - (balanceOf[this.address] * rewardsFee / 100 * stor22 / 100) < balanceOf[stor12]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = distributionPoolAddress
                                    mem[32] = 0
                                    balanceOf[stor12] = balanceOf[stor12] + (balanceOf[this.address] * rewardsFee / 100) - (balanceOf[this.address] * rewardsFee / 100 * stor22 / 100)
                                    emit Transfer(((balanceOf[this.address] * rewardsFee / 100) - (balanceOf[this.address] * rewardsFee / 100 * stor22 / 100)), this.address, distributionPoolAddress);
                                    if not balanceOf[this.address]:
                                        _2769 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2769] = 26
                                        mem[_2769 + 32] = 'SafeMath: division by zero'
                                        _2805 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2805] = 26
                                        mem[_2805 + 32] = 'SafeMath: division by zero'
                                        _2823 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2823] = 30
                                        mem[_2823 + 32] = 'SafeMath: subtraction overflow'
                                        _2854 = mem[64]
                                        mem[mem[64]] = 2
                                        mem[64] = mem[64] + 96
                                        mem[_2854 + 32 len 64] = call.data[calldata.size len 64]
                                        if 0 >= mem[_2854]:
                                            revert with 0, 50
                                        mem[_2854 + 32] = this.address
                                        require ext_code.size(uniswapV2RouterAddress)
                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                gas gas_remaining wei
                                        mem[_2854 + 96] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[64] = _2854 + ceil32(return_data.size) + 96
                                        require return_data.size >= 32
                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                        if 1 >= mem[_2854]:
                                            revert with 0, 50
                                        mem[_2854 + 64] = ext_call.return_data[12 len 20]
                                        if not this.address:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not uniswapV2RouterAddress:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        mem[0] = uniswapV2RouterAddress
                                        mem[32] = sha3(address(this.address), 1)
                                        allowance[address(this.address)][stor9].field_0 = 0
                                        emit Approval(0, this.address, uniswapV2RouterAddress);
                                        mem[_2854 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                        mem[_2854 + ceil32(return_data.size) + 100] = 0
                                        mem[_2854 + ceil32(return_data.size) + 132] = 0
                                        mem[_2854 + ceil32(return_data.size) + 164] = 160
                                        mem[_2854 + ceil32(return_data.size) + 260] = mem[_2854]
                                        idx = 0
                                        s = _2854 + ceil32(return_data.size) + 292
                                        t = _2854 + 32
                                        while idx < mem[_2854]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_2854 + ceil32(return_data.size) + 196] = this.address
                                        mem[_2854 + ceil32(return_data.size) + 228] = block.timestamp
                                        require ext_code.size(uniswapV2RouterAddress)
                                        call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _2854 + ceil32(return_data.size) + (32 * mem[_2854]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _4810 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_4810] = 30
                                        mem[_4810 + 32] = 'SafeMath: subtraction overflow'
                                        if eth.balance(this.address) > eth.balance(this.address):
                                            _4828 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _4828 + 68] = mem[_4810 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_4828 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _4828 + -mem[64] + 100
                                        if eth.balance(this.address) < eth.balance(this.address):
                                            revert with 0, 17
                                        if not this.address:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not uniswapV2RouterAddress:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        mem[0] = uniswapV2RouterAddress
                                        mem[32] = sha3(address(this.address), 1)
                                        allowance[address(this.address)][stor9].field_0 = 0
                                        emit Approval(0, this.address, uniswapV2RouterAddress);
                                        mem[mem[64] + 68] = 0
                                        mem[mem[64] + 100] = 0
                                        mem[mem[64] + 132] = 0
                                        mem[mem[64] + 164] = block.timestamp
                                        require ext_code.size(uniswapV2RouterAddress)
                                        call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                             gas gas_remaining wei
                                            args this.address, 0, 0, 0, 0, block.timestamp
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 96
                                        mem[mem[64] + 32] = 0
                                        mem[mem[64] + 64] = 0
                                        emit SwapAndLiquify(uint256 arg1, uint256 arg2, uint256 arg3):
                                                            0,
                                        mem[0] = this.address
                                        mem[32] = 0
                                        _5237 = mem[64]
                                        mem[mem[64]] = 2
                                        mem[64] = mem[64] + 96
                                        mem[_5237 + 32 len 64] = call.data[calldata.size len 64]
                                        if 0 >= mem[_5237]:
                                            revert with 0, 50
                                        mem[_5237 + 32] = this.address
                                        require ext_code.size(uniswapV2RouterAddress)
                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                gas gas_remaining wei
                                        mem[_5237 + 96] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[64] = _5237 + ceil32(return_data.size) + 96
                                        require return_data.size >= 32
                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                        if 1 >= mem[_5237]:
                                            revert with 0, 50
                                        mem[_5237 + 64] = ext_call.return_data[12 len 20]
                                        if not this.address:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not uniswapV2RouterAddress:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        mem[0] = uniswapV2RouterAddress
                                        mem[32] = sha3(address(this.address), 1)
                                        allowance[address(this.address)][stor9].field_0 = balanceOf[this.address]
                                        emit Approval(balanceOf[this.address], this.address, uniswapV2RouterAddress);
                                        mem[_5237 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                        mem[_5237 + ceil32(return_data.size) + 100] = balanceOf[this.address]
                                        mem[_5237 + ceil32(return_data.size) + 132] = 0
                                        mem[_5237 + ceil32(return_data.size) + 164] = 160
                                        mem[_5237 + ceil32(return_data.size) + 260] = mem[_5237]
                                        idx = 0
                                        s = _5237 + ceil32(return_data.size) + 292
                                        t = _5237 + 32
                                        while idx < mem[_5237]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_5237 + ceil32(return_data.size) + 228] = block.timestamp
                                        require ext_code.size(uniswapV2RouterAddress)
                                        call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args balanceOf[this.address], 0, 160, address(this.address), block.timestamp, mem[_5237 + ceil32(return_data.size) + 260 len (32 * mem[_5237]) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[_5237 + ceil32(return_data.size) + 96] = 30
                                        mem[_5237 + ceil32(return_data.size) + 128] = 'SafeMath: subtraction overflow'
                                        if eth.balance(this.address) > eth.balance(this.address):
                                            mem[_5237 + ceil32(return_data.size) + 160] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_5237 + ceil32(return_data.size) + 164] = 32
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _5237 + ceil32(return_data.size) + 228] = mem[_5237 + ceil32(return_data.size) + idx + 128]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 32, 30, mem[_5237 + ceil32(return_data.size) + 228 len 30], 0
                                        if eth.balance(this.address) < eth.balance(this.address):
                                            revert with 0, 17
                                        call marketingWalletAddress with:
                                             gas 2300 wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        uint8(stor23.field_0) = 0
                                        if not msg.sender:
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not this.address:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        mem[_5237 + ceil32(return_data.size) + 160] = 38
                                        mem[_5237 + ceil32(return_data.size) + 192 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                        if _1038 > balanceOf[address(msg.sender)]:
                                            mem[_5237 + ceil32(return_data.size) + 256] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_5237 + ceil32(return_data.size) + 260] = 32
                                            idx = 0
                                            while idx < 38:
                                                mem[idx + _5237 + ceil32(return_data.size) + 324] = mem[_5237 + ceil32(return_data.size) + idx + 192]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 32, 38, mem[_5237 + ceil32(return_data.size) + 324 len 38], 0
                                        if balanceOf[address(msg.sender)] < _1038:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] -= _1038
                                        if balanceOf[this.address] > !_1038:
                                            revert with 0, 17
                                        if balanceOf[this.address] + _1038 < balanceOf[this.address]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(this.address)] = balanceOf[this.address] + _1038
                                        emit Transfer(_1038, msg.sender, this.address);
                                        if arg1 >= 3:
                                            revert with 0, 50
                                        mem[_5237 + ceil32(return_data.size) + 256] = 0x12b8603f00000000000000000000000000000000000000000000000000000000
                                        mem[_5237 + ceil32(return_data.size) + 260] = msg.sender
                                        mem[_5237 + ceil32(return_data.size) + 292] = 64
                                        mem[_5237 + ceil32(return_data.size) + 324] = mem[96]
                                        idx = 0
                                        while idx < mem[96]:
                                            mem[idx + _5237 + ceil32(return_data.size) + 356] = mem[idx + 128]
                                            idx = idx + 32
                                            continue 
                                        if ceil32(mem[96]) > mem[96]:
                                            mem[_5237 + ceil32(return_data.size) + mem[96] + 356] = 0
                                        require ext_code.size(sub_20eea8b5[arg1])
                                        call sub_20eea8b5[arg1].createNode(address arg1, string arg2) with:
                                             gas gas_remaining wei
                                            args msg.sender, Array(len=mem[96], data=mem[_5237 + ceil32(return_data.size) + 356 len ceil32(mem[96])])
                                    else:
                                        if balanceOf[this.address] and liquidityPoolFee > -1 / balanceOf[this.address]:
                                            revert with 0, 17
                                        if not balanceOf[this.address]:
                                            revert with 0, 18
                                        if balanceOf[this.address] * liquidityPoolFee / balanceOf[this.address] != liquidityPoolFee:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _2796 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2796] = 26
                                        mem[_2796 + 32] = 'SafeMath: division by zero'
                                        _2814 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2814] = 26
                                        mem[_2814 + 32] = 'SafeMath: division by zero'
                                        _2832 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2832] = 30
                                        mem[_2832 + 32] = 'SafeMath: subtraction overflow'
                                        if balanceOf[this.address] * liquidityPoolFee / 100 / 2 > balanceOf[this.address] * liquidityPoolFee / 100:
                                            _2853 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _2853 + 68] = mem[_2832 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_2853 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _2853 + -mem[64] + 100
                                        if balanceOf[this.address] * liquidityPoolFee / 100 < balanceOf[this.address] * liquidityPoolFee / 100 / 2:
                                            revert with 0, 17
                                        _2928 = mem[64]
                                        mem[mem[64]] = 2
                                        mem[64] = mem[64] + 96
                                        mem[_2928 + 32 len 64] = call.data[calldata.size len 64]
                                        if 0 >= mem[_2928]:
                                            revert with 0, 50
                                        mem[_2928 + 32] = this.address
                                        require ext_code.size(uniswapV2RouterAddress)
                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                gas gas_remaining wei
                                        mem[_2928 + 96] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[64] = _2928 + ceil32(return_data.size) + 96
                                        require return_data.size >= 32
                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                        if 1 >= mem[_2928]:
                                            revert with 0, 50
                                        mem[_2928 + 64] = ext_call.return_data[12 len 20]
                                        if not this.address:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not uniswapV2RouterAddress:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        mem[0] = uniswapV2RouterAddress
                                        mem[32] = sha3(address(this.address), 1)
                                        allowance[address(this.address)][stor9].field_0 = balanceOf[this.address] * liquidityPoolFee / 100 / 2
                                        allowance[address(this.address)][stor9].field_255 = 0
                                        emit Approval((balanceOf[this.address] * liquidityPoolFee / 100 / 2), this.address, uniswapV2RouterAddress);
                                        mem[_2928 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                        mem[_2928 + ceil32(return_data.size) + 100] = balanceOf[this.address] * liquidityPoolFee / 100 / 2
                                        mem[_2928 + ceil32(return_data.size) + 132] = 0
                                        mem[_2928 + ceil32(return_data.size) + 164] = 160
                                        mem[_2928 + ceil32(return_data.size) + 260] = mem[_2928]
                                        idx = 0
                                        s = _2928 + ceil32(return_data.size) + 292
                                        t = _2928 + 32
                                        while idx < mem[_2928]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_2928 + ceil32(return_data.size) + 196] = this.address
                                        mem[_2928 + ceil32(return_data.size) + 228] = block.timestamp
                                        require ext_code.size(uniswapV2RouterAddress)
                                        call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _2928 + ceil32(return_data.size) + (32 * mem[_2928]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _4809 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_4809] = 30
                                        mem[_4809 + 32] = 'SafeMath: subtraction overflow'
                                        if eth.balance(this.address) > eth.balance(this.address):
                                            _4827 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _4827 + 68] = mem[_4809 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_4827 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _4827 + -mem[64] + 100
                                        if eth.balance(this.address) < eth.balance(this.address):
                                            revert with 0, 17
                                        if not this.address:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not uniswapV2RouterAddress:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        mem[0] = uniswapV2RouterAddress
                                        mem[32] = sha3(address(this.address), 1)
                                        allowance[address(this.address)][stor9].field_0 = (balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2)
                                        emit Approval(((balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2)), this.address, uniswapV2RouterAddress);
                                        mem[mem[64] + 68] = 0
                                        mem[mem[64] + 100] = 0
                                        mem[mem[64] + 132] = 0
                                        mem[mem[64] + 164] = block.timestamp
                                        require ext_code.size(uniswapV2RouterAddress)
                                        call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                             gas gas_remaining wei
                                            args this.address, (balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2), 0, 0, 0, block.timestamp
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 96
                                        mem[mem[64] + 32] = 0
                                        mem[mem[64] + 64] = (balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2)
                                        emit SwapAndLiquify(Mask(255, 1, balanceOf[this.address] * liquidityPoolFee / 100), 0, (balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2));
                                        mem[0] = this.address
                                        mem[32] = 0
                                        _5235 = mem[64]
                                        mem[mem[64]] = 2
                                        mem[64] = mem[64] + 96
                                        mem[_5235 + 32 len 64] = call.data[calldata.size len 64]
                                        if 0 >= mem[_5235]:
                                            revert with 0, 50
                                        mem[_5235 + 32] = this.address
                                        require ext_code.size(uniswapV2RouterAddress)
                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                gas gas_remaining wei
                                        mem[_5235 + 96] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[64] = _5235 + ceil32(return_data.size) + 96
                                        require return_data.size >= 32
                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                        if 1 >= mem[_5235]:
                                            revert with 0, 50
                                        mem[_5235 + 64] = ext_call.return_data[12 len 20]
                                        if not this.address:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not uniswapV2RouterAddress:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        mem[0] = uniswapV2RouterAddress
                                        mem[32] = sha3(address(this.address), 1)
                                        allowance[address(this.address)][stor9].field_0 = balanceOf[this.address]
                                        emit Approval(balanceOf[this.address], this.address, uniswapV2RouterAddress);
                                        mem[_5235 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                        mem[_5235 + ceil32(return_data.size) + 100] = balanceOf[this.address]
                                        mem[_5235 + ceil32(return_data.size) + 132] = 0
                                        mem[_5235 + ceil32(return_data.size) + 164] = 160
                                        mem[_5235 + ceil32(return_data.size) + 260] = mem[_5235]
                                        idx = 0
                                        s = _5235 + ceil32(return_data.size) + 292
                                        t = _5235 + 32
                                        while idx < mem[_5235]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_5235 + ceil32(return_data.size) + 196] = this.address
                                        mem[_5235 + ceil32(return_data.size) + 228] = block.timestamp
                                        require ext_code.size(uniswapV2RouterAddress)
                                        call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _5235 + ceil32(return_data.size) + (32 * mem[_5235]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _6339 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6339] = 30
                                        mem[_6339 + 32] = 'SafeMath: subtraction overflow'
                                        if eth.balance(this.address) > eth.balance(this.address):
                                            _6357 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _6357 + 68] = mem[_6339 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_6357 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _6357 + -mem[64] + 100
                                        if eth.balance(this.address) < eth.balance(this.address):
                                            revert with 0, 17
                                        call marketingWalletAddress with:
                                             gas 2300 wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        uint8(stor23.field_0) = 0
                                        if not msg.sender:
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not this.address:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        _6507 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_6507] = 38
                                        mem[_6507 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                        mem[32] = 0
                                        if _1038 > balanceOf[address(msg.sender)]:
                                            _6567 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 38
                                            idx = 0
                                            while idx < 38:
                                                mem[idx + _6567 + 68] = mem[_6507 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_6567 + 106] = 0
                                            revert with memory
                                              from mem[64]
                                               len _6567 + -mem[64] + 132
                                        if balanceOf[address(msg.sender)] < _1038:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] -= _1038
                                        if balanceOf[this.address] > !_1038:
                                            revert with 0, 17
                                        if balanceOf[this.address] + _1038 < balanceOf[this.address]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(this.address)] = balanceOf[this.address] + _1038
                                        emit Transfer(_1038, msg.sender, this.address);
                                        if arg1 >= 3:
                                            revert with 0, 50
                                        _6789 = mem[64]
                                        mem[mem[64]] = 0x12b8603f00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 64
                                        _6807 = mem[96]
                                        mem[mem[64] + 68] = mem[96]
                                        idx = 0
                                        while idx < _6807:
                                            mem[idx + mem[64] + 100] = mem[idx + 128]
                                            idx = idx + 32
                                            continue 
                                        if ceil32(_6807) > _6807:
                                            mem[_6789 + _6807 + 100] = 0
                                        require ext_code.size(sub_20eea8b5[arg1])
                                        call sub_20eea8b5[arg1].mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len ceil32(_6807) + _6789 + -mem[64] + 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if stor27[address(msg.sender)] > -2:
                                        revert with 0, 17
                                    if stor27[address(msg.sender)] + 1 < stor27[address(msg.sender)]:
                                        revert with 0, 'SafeMath: addition overflow'
            ('ge', ('add', 1, ('stor', ('map', ('mask_shl', 160, 0, 0, 'msg.sender'), ('name', 'stor27', 27)))), ('stor', ('map', ('mask_shl', 160, 0, 0, 'msg.sender'), ('name', 'stor27', 27))))
            stor27[address(msg.sender)]++
        if mem[96] <= 3:
            revert with 0, 'NODE CREATION: NAME SIZE INVALID'
        if mem[96] >= 32:
            revert with 0, 'NODE CREATION: NAME SIZE INVALID'
        if sub_6cdc78b3 <= stor27[msg.sender]:
            revert with 0, 'cannot create node more than 100'
        if not msg.sender:
            revert with 0, 'NODE CREATION:  creation from the zero address'
        mem[0] = msg.sender
        mem[32] = 25
        if stor25[address(msg.sender)]:
            revert with 0, 'NODE CREATION: Blacklisted address'
        if futurUsePoolAddress == msg.sender:
            revert with 0, 'NODE CREATION: futur and rewardsPool cannot create node'
        if distributionPoolAddress == msg.sender:
            revert with 0, 'NODE CREATION: futur and rewardsPool cannot create node'
        if arg1 >= 3:
            revert with 0, 50
        require ext_code.size(sub_20eea8b5[arg1])
        staticcall sub_20eea8b5[arg1].nodePrice() with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _529 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _537 = mem[_529]
        if balanceOf[address(msg.sender)] < mem[_529]:
            revert with 0, 'NODE CREATION: Balance too low for creation.'
        mem[0] = this.address
        mem[32] = 0
        if balanceOf[this.address] < swapTokensAmount:
            if not msg.sender:
                revert with 0, 'ERC20: transfer from the zero address'
            if not this.address:
                revert with 0, 'ERC20: transfer to the zero address'
            _592 = mem[64]
            mem[64] = mem[64] + 96
            mem[_592] = 38
            mem[_592 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
            if _537 > balanceOf[address(msg.sender)]:
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 38
                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_592 + 70 len 26]
                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
            if balanceOf[address(msg.sender)] < _537:
                revert with 0, 17
            balanceOf[address(msg.sender)] -= _537
            if balanceOf[this.address] > !_537:
                revert with 0, 17
            if balanceOf[this.address] + _537 < balanceOf[this.address]:
                revert with 0, 'SafeMath: addition overflow'
            balanceOf[address(this.address)] = balanceOf[this.address] + _537
            emit Transfer(_537, msg.sender, this.address);
            if arg1 >= 3:
                revert with 0, 50
            mem[mem[64]] = 0x12b8603f00000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = msg.sender
            mem[mem[64] + 36] = 64
            mem[mem[64] + 68] = mem[96]
            mem[mem[64] + 100 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
            if ceil32(mem[96]) > mem[96]:
                mem[mem[64] + mem[96] + 100] = 0
            require ext_code.size(sub_20eea8b5[arg1])
            call sub_20eea8b5[arg1].createNode(address arg1, string arg2) with:
                 gas gas_remaining wei
                args msg.sender, Array(len=mem[96], data=mem[mem[64] + 100 len ceil32(mem[96])])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if stor27[address(msg.sender)] > -2:
                revert with 0, 17
            if stor27[address(msg.sender)] + 1 < stor27[address(msg.sender)]:
                revert with 0, 'SafeMath: addition overflow'
        else:
            if not uint8(stor23.field_8):
                if not msg.sender:
                    revert with 0, 'ERC20: transfer from the zero address'
                if not this.address:
                    revert with 0, 'ERC20: transfer to the zero address'
                _605 = mem[64]
                mem[64] = mem[64] + 96
                mem[_605] = 38
                mem[_605 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                if _537 > balanceOf[address(msg.sender)]:
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 38
                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_605 + 70 len 26]
                    var68001 = 64
                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                if balanceOf[address(msg.sender)] < _537:
                    revert with 0, 17
                balanceOf[address(msg.sender)] -= _537
                if balanceOf[this.address] > !_537:
                    revert with 0, 17
                if balanceOf[this.address] + _537 < balanceOf[this.address]:
                    revert with 0, 'SafeMath: addition overflow'
                balanceOf[address(this.address)] = balanceOf[this.address] + _537
                emit Transfer(_537, msg.sender, this.address);
                if arg1 >= 3:
                    revert with 0, 50
                mem[mem[64]] = 0x12b8603f00000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = msg.sender
                mem[mem[64] + 36] = 64
                mem[mem[64] + 68] = mem[96]
                mem[mem[64] + 100 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                if ceil32(mem[96]) > mem[96]:
                    mem[mem[64] + mem[96] + 100] = 0
                require ext_code.size(sub_20eea8b5[arg1])
                call sub_20eea8b5[arg1].createNode(address arg1, string arg2) with:
                     gas gas_remaining wei
                    args msg.sender, Array(len=mem[96], data=mem[mem[64] + 100 len ceil32(mem[96])])
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if stor27[address(msg.sender)] > -2:
                    revert with 0, 17
                if stor27[address(msg.sender)] + 1 < stor27[address(msg.sender)]:
                    revert with 0, 'SafeMath: addition overflow'
            else:
                if uint8(stor23.field_0):
                    if not msg.sender:
                        revert with 0, 'ERC20: transfer from the zero address'
                    if not this.address:
                        revert with 0, 'ERC20: transfer to the zero address'
                    _624 = mem[64]
                    mem[64] = mem[64] + 96
                    mem[_624] = 38
                    mem[_624 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                    if _537 > balanceOf[address(msg.sender)]:
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 38
                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_624 + 70 len 26]
                        idx = 64
                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                    if balanceOf[address(msg.sender)] < _537:
                        revert with 0, 17
                    balanceOf[address(msg.sender)] -= _537
                    if balanceOf[this.address] > !_537:
                        revert with 0, 17
                    if balanceOf[this.address] + _537 < balanceOf[this.address]:
                        revert with 0, 'SafeMath: addition overflow'
                    balanceOf[address(this.address)] = balanceOf[this.address] + _537
                    emit Transfer(_537, msg.sender, this.address);
                    if arg1 >= 3:
                        revert with 0, 50
                    mem[mem[64]] = 0x12b8603f00000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = msg.sender
                    mem[mem[64] + 36] = 64
                    mem[mem[64] + 68] = mem[96]
                    mem[mem[64] + 100 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                    if ceil32(mem[96]) > mem[96]:
                        mem[mem[64] + mem[96] + 100] = 0
                    require ext_code.size(sub_20eea8b5[arg1])
                    call sub_20eea8b5[arg1].createNode(address arg1, string arg2) with:
                         gas gas_remaining wei
                        args msg.sender, Array(len=mem[96], data=mem[mem[64] + 100 len ceil32(mem[96])])
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if stor27[address(msg.sender)] > -2:
                        revert with 0, 17
                    if stor27[address(msg.sender)] + 1 < stor27[address(msg.sender)]:
                        revert with 0, 'SafeMath: addition overflow'
                else:
                    if owner == msg.sender:
                        if not msg.sender:
                            revert with 0, 'ERC20: transfer from the zero address'
                        if not this.address:
                            revert with 0, 'ERC20: transfer to the zero address'
                        _641 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_641] = 38
                        mem[_641 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                        if _537 > balanceOf[address(msg.sender)]:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 38
                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_641 + 70 len 26]
                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                        if balanceOf[address(msg.sender)] < _537:
                            revert with 0, 17
                        balanceOf[address(msg.sender)] -= _537
                        if balanceOf[this.address] > !_537:
                            revert with 0, 17
                        if balanceOf[this.address] + _537 < balanceOf[this.address]:
                            revert with 0, 'SafeMath: addition overflow'
                        balanceOf[address(this.address)] = balanceOf[this.address] + _537
                        emit Transfer(_537, msg.sender, this.address);
                        if arg1 >= 3:
                            revert with 0, 50
                        mem[mem[64]] = 0x12b8603f00000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = msg.sender
                        mem[mem[64] + 36] = 64
                        mem[mem[64] + 68] = mem[96]
                        mem[mem[64] + 100 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                        if ceil32(mem[96]) > mem[96]:
                            mem[mem[64] + mem[96] + 100] = 0
                        require ext_code.size(sub_20eea8b5[arg1])
                        call sub_20eea8b5[arg1].createNode(address arg1, string arg2) with:
                             gas gas_remaining wei
                            args msg.sender, Array(len=mem[96], data=mem[mem[64] + 100 len ceil32(mem[96])])
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if stor27[address(msg.sender)] > -2:
                            revert with 0, 17
                        if stor27[address(msg.sender)] + 1 < stor27[address(msg.sender)]:
                            revert with 0, 'SafeMath: addition overflow'
                    else:
                        mem[0] = msg.sender
                        mem[32] = 26
                        if stor26[address(msg.sender)]:
                            if not msg.sender:
                                revert with 0, 'ERC20: transfer from the zero address'
                            if not this.address:
                                revert with 0, 'ERC20: transfer to the zero address'
                            _660 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_660] = 38
                            mem[_660 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                            if _537 > balanceOf[address(msg.sender)]:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 38
                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_660 + 70 len 26]
                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                            if balanceOf[address(msg.sender)] < _537:
                                revert with 0, 17
                            balanceOf[address(msg.sender)] -= _537
                            if balanceOf[this.address] > !_537:
                                revert with 0, 17
                            if balanceOf[this.address] + _537 < balanceOf[this.address]:
                                revert with 0, 'SafeMath: addition overflow'
                            balanceOf[address(this.address)] = balanceOf[this.address] + _537
                            emit Transfer(_537, msg.sender, this.address);
                            if arg1 >= 3:
                                revert with 0, 50
                            mem[mem[64]] = 0x12b8603f00000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = msg.sender
                            mem[mem[64] + 36] = 64
                            mem[mem[64] + 68] = mem[96]
                            mem[mem[64] + 100 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                            var84001 = ceil32(mem[96])
                            if ceil32(mem[96]) > mem[96]:
                                mem[mem[64] + mem[96] + 100] = 0
                            require ext_code.size(sub_20eea8b5[arg1])
                            call sub_20eea8b5[arg1].createNode(address arg1, string arg2) with:
                                 gas gas_remaining wei
                                args msg.sender, Array(len=mem[96], data=mem[mem[64] + 100 len ceil32(mem[96])])
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if stor27[address(msg.sender)] > -2:
                                revert with 0, 17
                            if stor27[address(msg.sender)] + 1 < stor27[address(msg.sender)]:
                                revert with 0, 'SafeMath: addition overflow'
                        else:
                            uint8(stor23.field_0) = 1
                            if not balanceOf[this.address]:
                                _689 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_689] = 26
                                mem[_689 + 32] = 'SafeMath: division by zero'
                                _821 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_821] = 26
                                mem[_821 + 32] = 'SafeMath: division by zero'
                                _886 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                mem[_886 + 32 len 64] = call.data[calldata.size len 64]
                                if 0 >= mem[_886]:
                                    revert with 0, 50
                                mem[_886 + 32] = this.address
                                require ext_code.size(uniswapV2RouterAddress)
                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                        gas gas_remaining wei
                                mem[_886 + 96] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = _886 + ceil32(return_data.size) + 96
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                if 1 >= mem[_886]:
                                    revert with 0, 50
                                mem[_886 + 64] = ext_call.return_data[12 len 20]
                                if not this.address:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not uniswapV2RouterAddress:
                                    revert with 0, 'ERC20: approve to the zero address'
                                mem[0] = uniswapV2RouterAddress
                                mem[32] = sha3(address(this.address), 1)
                                allowance[address(this.address)][stor9].field_0 = 0
                                emit Approval(0, this.address, uniswapV2RouterAddress);
                                mem[_886 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                mem[_886 + ceil32(return_data.size) + 100] = 0
                                mem[_886 + ceil32(return_data.size) + 132] = 0
                                mem[_886 + ceil32(return_data.size) + 164] = 160
                                mem[_886 + ceil32(return_data.size) + 260] = mem[_886]
                                idx = 0
                                s = _886 + ceil32(return_data.size) + 292
                                t = _886 + 32
                                while idx < mem[_886]:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(uniswapV2RouterAddress)
                                call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                     gas gas_remaining wei
                                    args 0, 0, 160, address(this.address), block.timestamp, mem[_886 + ceil32(return_data.size) + 260 len (32 * mem[_886]) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[_886 + ceil32(return_data.size) + 96] = 30
                                mem[_886 + ceil32(return_data.size) + 128] = 'SafeMath: subtraction overflow'
                                if eth.balance(this.address) > eth.balance(this.address):
                                    var118001 = 32
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if eth.balance(this.address) < eth.balance(this.address):
                                    revert with 0, 17
                                call distributionPoolAddress with:
                                     gas 2300 wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[_886 + ceil32(return_data.size) + 160] = 30
                                mem[_886 + ceil32(return_data.size) + 192] = 'SafeMath: subtraction overflow'
                                if not this.address:
                                    revert with 0, 'ERC20: transfer from the zero address'
                                if not distributionPoolAddress:
                                    revert with 0, 'ERC20: transfer to the zero address'
                                mem[_886 + ceil32(return_data.size) + 224] = 38
                                mem[_886 + ceil32(return_data.size) + 256 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                if 0 > balanceOf[address(this.address)]:
                                    var138001 = 64
                                    revert with 0, 
                                                32,
                                                38,
                                                0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_886 + ceil32(return_data.size) + 294 len 26] >> 48,
                                                0
                                if balanceOf[address(this.address)] < 0:
                                    revert with 0, 17
                                if balanceOf[stor12] > -1:
                                    revert with 0, 17
                                if balanceOf[stor12] < balanceOf[stor12]:
                                    revert with 0, 'SafeMath: addition overflow'
                                balanceOf[stor12] = balanceOf[stor12]
                                emit Transfer(0, this.address, distributionPoolAddress);
                                if not balanceOf[this.address]:
                                    mem[_886 + ceil32(return_data.size) + 320] = 26
                                    mem[_886 + ceil32(return_data.size) + 352] = 'SafeMath: division by zero'
                                    mem[_886 + ceil32(return_data.size) + 384] = 26
                                    mem[_886 + ceil32(return_data.size) + 416] = 'SafeMath: division by zero'
                                    mem[_886 + ceil32(return_data.size) + 448] = 30
                                    mem[_886 + ceil32(return_data.size) + 480] = 'SafeMath: subtraction overflow'
                                    mem[_886 + ceil32(return_data.size) + 512] = 2
                                    mem[_886 + ceil32(return_data.size) + 544] = this.address
                                    require ext_code.size(uniswapV2RouterAddress)
                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                            gas gas_remaining wei
                                    mem[_886 + ceil32(return_data.size) + 608] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = _886 + (2 * ceil32(return_data.size)) + 608
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    mem[_886 + ceil32(return_data.size) + 576] = ext_call.return_data[12 len 20]
                                    if not this.address:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not uniswapV2RouterAddress:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    mem[0] = uniswapV2RouterAddress
                                    mem[32] = sha3(address(this.address), 1)
                                    allowance[address(this.address)][stor9].field_0 = 0
                                    emit Approval(0, this.address, uniswapV2RouterAddress);
                                    mem[_886 + (2 * ceil32(return_data.size)) + 608] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                    mem[_886 + (2 * ceil32(return_data.size)) + 612] = 0
                                    mem[_886 + (2 * ceil32(return_data.size)) + 644] = 0
                                    mem[_886 + (2 * ceil32(return_data.size)) + 676] = 160
                                    mem[_886 + (2 * ceil32(return_data.size)) + 772] = 2
                                    idx = 0
                                    s = _886 + (2 * ceil32(return_data.size)) + 804
                                    t = _886 + ceil32(return_data.size) + 544
                                    while idx < mem[_886 + ceil32(return_data.size) + 512]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_886 + (2 * ceil32(return_data.size)) + 708] = this.address
                                    mem[_886 + (2 * ceil32(return_data.size)) + 740] = block.timestamp
                                    require ext_code.size(uniswapV2RouterAddress)
                                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _886 + (2 * ceil32(return_data.size)) + (32 * mem[_886 + ceil32(return_data.size) + 512]) + -mem[64] + 800]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _4808 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4808] = 30
                                    mem[_4808 + 32] = 'SafeMath: subtraction overflow'
                                    if eth.balance(this.address) > eth.balance(this.address):
                                        var206001 = 32
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if eth.balance(this.address) < eth.balance(this.address):
                                        revert with 0, 17
                                    if not this.address:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not uniswapV2RouterAddress:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    mem[0] = uniswapV2RouterAddress
                                    mem[32] = sha3(address(this.address), 1)
                                    allowance[address(this.address)][stor9].field_0 = 0
                                    emit Approval(0, this.address, uniswapV2RouterAddress);
                                    mem[mem[64] + 68] = 0
                                    mem[mem[64] + 100] = 0
                                    mem[mem[64] + 132] = 0
                                    mem[mem[64] + 164] = block.timestamp
                                    require ext_code.size(uniswapV2RouterAddress)
                                    call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                         gas gas_remaining wei
                                        args this.address, 0, 0, 0, 0, block.timestamp
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 96
                                    mem[mem[64] + 32] = 0
                                    mem[mem[64] + 64] = 0
                                    emit SwapAndLiquify(uint256 arg1, uint256 arg2, uint256 arg3):
                                                        0,
                                    mem[0] = this.address
                                    mem[32] = 0
                                    _5233 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    mem[_5233 + 32 len 64] = call.data[calldata.size len 64]
                                    if 0 >= mem[_5233]:
                                        revert with 0, 50
                                    mem[_5233 + 32] = this.address
                                    require ext_code.size(uniswapV2RouterAddress)
                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                            gas gas_remaining wei
                                    mem[_5233 + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = _5233 + ceil32(return_data.size) + 96
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    if 1 >= mem[_5233]:
                                        revert with 0, 50
                                    mem[_5233 + 64] = ext_call.return_data[12 len 20]
                                    if not this.address:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not uniswapV2RouterAddress:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    mem[0] = uniswapV2RouterAddress
                                    mem[32] = sha3(address(this.address), 1)
                                    allowance[address(this.address)][stor9].field_0 = balanceOf[this.address]
                                    emit Approval(balanceOf[this.address], this.address, uniswapV2RouterAddress);
                                    mem[_5233 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                    mem[_5233 + ceil32(return_data.size) + 100] = balanceOf[this.address]
                                    mem[_5233 + ceil32(return_data.size) + 132] = 0
                                    mem[_5233 + ceil32(return_data.size) + 164] = 160
                                    mem[_5233 + ceil32(return_data.size) + 260] = mem[_5233]
                                    idx = 0
                                    s = _5233 + ceil32(return_data.size) + 292
                                    t = _5233 + 32
                                    while idx < mem[_5233]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5233 + ceil32(return_data.size) + 196] = this.address
                                    mem[_5233 + ceil32(return_data.size) + 228] = block.timestamp
                                    require ext_code.size(uniswapV2RouterAddress)
                                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5233 + ceil32(return_data.size) + (32 * mem[_5233]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _6338 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6338] = 30
                                    mem[_6338 + 32] = 'SafeMath: subtraction overflow'
                                    if eth.balance(this.address) > eth.balance(this.address):
                                        var252001 = 32
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if eth.balance(this.address) < eth.balance(this.address):
                                        revert with 0, 17
                                    call marketingWalletAddress with:
                                         gas 2300 wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    uint8(stor23.field_0) = 0
                                    if not msg.sender:
                                        revert with 0, 'ERC20: transfer from the zero address'
                                    if not this.address:
                                        revert with 0, 'ERC20: transfer to the zero address'
                                    _6504 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_6504] = 38
                                    mem[_6504 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                    if _537 > balanceOf[address(msg.sender)]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 38
                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_6504 + 70 len 26]
                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                    if balanceOf[address(msg.sender)] < _537:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)] -= _537
                                    if balanceOf[this.address] > !_537:
                                        revert with 0, 17
                                    if balanceOf[this.address] + _537 < balanceOf[this.address]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(this.address)] = balanceOf[this.address] + _537
                                    emit Transfer(_537, msg.sender, this.address);
                                    if arg1 >= 3:
                                        revert with 0, 50
                                    mem[mem[64]] = 0x12b8603f00000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = 64
                                    mem[mem[64] + 68] = mem[96]
                                    mem[mem[64] + 100 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                                    if ceil32(mem[96]) > mem[96]:
                                        mem[mem[64] + mem[96] + 100] = 0
                                    require ext_code.size(sub_20eea8b5[arg1])
                                    call sub_20eea8b5[arg1].createNode(address arg1, string arg2) with:
                                         gas gas_remaining wei
                                        args msg.sender, Array(len=mem[96], data=mem[mem[64] + 100 len ceil32(mem[96])])
                                else:
                                    if balanceOf[this.address] and liquidityPoolFee > -1 / balanceOf[this.address]:
                                        revert with 0, 17
                                    if not balanceOf[this.address]:
                                        revert with 0, 18
                                    if balanceOf[this.address] * liquidityPoolFee / balanceOf[this.address] != liquidityPoolFee:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[_886 + ceil32(return_data.size) + 320] = 26
                                    mem[_886 + ceil32(return_data.size) + 352] = 'SafeMath: division by zero'
                                    mem[_886 + ceil32(return_data.size) + 384] = 26
                                    mem[_886 + ceil32(return_data.size) + 416] = 'SafeMath: division by zero'
                                    mem[_886 + ceil32(return_data.size) + 448] = 30
                                    mem[_886 + ceil32(return_data.size) + 480] = 'SafeMath: subtraction overflow'
                                    if balanceOf[this.address] * liquidityPoolFee / 100 / 2 > balanceOf[this.address] * liquidityPoolFee / 100:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if balanceOf[this.address] * liquidityPoolFee / 100 < balanceOf[this.address] * liquidityPoolFee / 100 / 2:
                                        revert with 0, 17
                                    mem[_886 + ceil32(return_data.size) + 512] = 2
                                    mem[_886 + ceil32(return_data.size) + 544] = this.address
                                    require ext_code.size(uniswapV2RouterAddress)
                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                            gas gas_remaining wei
                                    mem[_886 + ceil32(return_data.size) + 608] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = _886 + (2 * ceil32(return_data.size)) + 608
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    mem[_886 + ceil32(return_data.size) + 576] = ext_call.return_data[12 len 20]
                                    if not this.address:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not uniswapV2RouterAddress:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    mem[0] = uniswapV2RouterAddress
                                    mem[32] = sha3(address(this.address), 1)
                                    allowance[address(this.address)][stor9].field_0 = balanceOf[this.address] * liquidityPoolFee / 100 / 2
                                    allowance[address(this.address)][stor9].field_255 = 0
                                    emit Approval((balanceOf[this.address] * liquidityPoolFee / 100 / 2), this.address, uniswapV2RouterAddress);
                                    mem[_886 + (2 * ceil32(return_data.size)) + 608] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                    mem[_886 + (2 * ceil32(return_data.size)) + 612] = balanceOf[this.address] * liquidityPoolFee / 100 / 2
                                    mem[_886 + (2 * ceil32(return_data.size)) + 644] = 0
                                    mem[_886 + (2 * ceil32(return_data.size)) + 676] = 160
                                    mem[_886 + (2 * ceil32(return_data.size)) + 772] = 2
                                    idx = 0
                                    s = _886 + (2 * ceil32(return_data.size)) + 804
                                    t = _886 + ceil32(return_data.size) + 544
                                    while idx < mem[_886 + ceil32(return_data.size) + 512]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_886 + (2 * ceil32(return_data.size)) + 708] = this.address
                                    mem[_886 + (2 * ceil32(return_data.size)) + 740] = block.timestamp
                                    require ext_code.size(uniswapV2RouterAddress)
                                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _886 + (2 * ceil32(return_data.size)) + (32 * mem[_886 + ceil32(return_data.size) + 512]) + -mem[64] + 800]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _4807 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4807] = 30
                                    mem[_4807 + 32] = 'SafeMath: subtraction overflow'
                                    if eth.balance(this.address) > eth.balance(this.address):
                                        var212001 = 32
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if eth.balance(this.address) < eth.balance(this.address):
                                        revert with 0, 17
                                    if not this.address:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not uniswapV2RouterAddress:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    mem[0] = uniswapV2RouterAddress
                                    mem[32] = sha3(address(this.address), 1)
                                    allowance[address(this.address)][stor9].field_0 = (balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2)
                                    emit Approval(((balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2)), this.address, uniswapV2RouterAddress);
                                    mem[mem[64] + 68] = 0
                                    mem[mem[64] + 100] = 0
                                    mem[mem[64] + 132] = 0
                                    mem[mem[64] + 164] = block.timestamp
                                    require ext_code.size(uniswapV2RouterAddress)
                                    call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                         gas gas_remaining wei
                                        args this.address, (balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2), 0, 0, 0, block.timestamp
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 96
                                    mem[mem[64] + 32] = 0
                                    mem[mem[64] + 64] = (balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2)
                                    emit SwapAndLiquify(Mask(255, 1, balanceOf[this.address] * liquidityPoolFee / 100), 0, (balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2));
                                    mem[0] = this.address
                                    mem[32] = 0
                                    _5231 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    mem[_5231 + 32 len 64] = call.data[calldata.size len 64]
                                    if 0 >= mem[_5231]:
                                        revert with 0, 50
                                    mem[_5231 + 32] = this.address
                                    require ext_code.size(uniswapV2RouterAddress)
                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                            gas gas_remaining wei
                                    mem[_5231 + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = _5231 + ceil32(return_data.size) + 96
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    if 1 >= mem[_5231]:
                                        revert with 0, 50
                                    mem[_5231 + 64] = ext_call.return_data[12 len 20]
                                    if not this.address:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not uniswapV2RouterAddress:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    mem[0] = uniswapV2RouterAddress
                                    mem[32] = sha3(address(this.address), 1)
                                    allowance[address(this.address)][stor9].field_0 = balanceOf[this.address]
                                    emit Approval(balanceOf[this.address], this.address, uniswapV2RouterAddress);
                                    mem[_5231 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                    mem[_5231 + ceil32(return_data.size) + 100] = balanceOf[this.address]
                                    mem[_5231 + ceil32(return_data.size) + 132] = 0
                                    mem[_5231 + ceil32(return_data.size) + 164] = 160
                                    mem[_5231 + ceil32(return_data.size) + 260] = mem[_5231]
                                    idx = 0
                                    s = _5231 + ceil32(return_data.size) + 292
                                    t = _5231 + 32
                                    while idx < mem[_5231]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5231 + ceil32(return_data.size) + 228] = block.timestamp
                                    require ext_code.size(uniswapV2RouterAddress)
                                    call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args balanceOf[this.address], 0, 160, address(this.address), block.timestamp, mem[_5231 + ceil32(return_data.size) + 260 len (32 * mem[_5231]) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_5231 + ceil32(return_data.size) + 96] = 30
                                    mem[_5231 + ceil32(return_data.size) + 128] = 'SafeMath: subtraction overflow'
                                    if eth.balance(this.address) > eth.balance(this.address):
                                        var258001 = 32
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if eth.balance(this.address) < eth.balance(this.address):
                                        revert with 0, 17
                                    call marketingWalletAddress with:
                                         gas 2300 wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    uint8(stor23.field_0) = 0
                                    if not msg.sender:
                                        revert with 0, 'ERC20: transfer from the zero address'
                                    if not this.address:
                                        revert with 0, 'ERC20: transfer to the zero address'
                                    mem[_5231 + ceil32(return_data.size) + 160] = 38
                                    mem[_5231 + ceil32(return_data.size) + 192 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                    if _537 > balanceOf[address(msg.sender)]:
                                        revert with 0, 
                                                    32,
                                                    38,
                                                    0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, Mask(208, 32, block.timestamp) >> 32 >> 48,
                                                    0
                                    if balanceOf[address(msg.sender)] < _537:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)] -= _537
                                    if balanceOf[this.address] > !_537:
                                        revert with 0, 17
                                    if balanceOf[this.address] + _537 < balanceOf[this.address]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(this.address)] = balanceOf[this.address] + _537
                                    emit Transfer(_537, msg.sender, this.address);
                                    if arg1 >= 3:
                                        revert with 0, 50
                                    mem[_5231 + ceil32(return_data.size) + 256] = 0x12b8603f00000000000000000000000000000000000000000000000000000000
                                    mem[_5231 + ceil32(return_data.size) + 260] = msg.sender
                                    mem[_5231 + ceil32(return_data.size) + 292] = 64
                                    mem[_5231 + ceil32(return_data.size) + 324] = mem[96]
                                    mem[_5231 + ceil32(return_data.size) + 356 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                                    if ceil32(mem[96]) > mem[96]:
                                        mem[_5231 + ceil32(return_data.size) + mem[96] + 356] = 0
                                    require ext_code.size(sub_20eea8b5[arg1])
                                    call sub_20eea8b5[arg1].createNode(address arg1, string arg2) with:
                                         gas gas_remaining wei
                                        args msg.sender, Array(len=mem[96], data=mem[_5231 + ceil32(return_data.size) + 356 len ceil32(mem[96])])
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if stor27[address(msg.sender)] > -2:
                                    revert with 0, 17
                                if stor27[address(msg.sender)] + 1 < stor27[address(msg.sender)]:
                                    revert with 0, 'SafeMath: addition overflow'
                            else:
                                if balanceOf[this.address] and rewardsFee > -1 / balanceOf[this.address]:
                                    revert with 0, 17
                                if not balanceOf[this.address]:
                                    revert with 0, 18
                                if balanceOf[this.address] * rewardsFee / balanceOf[this.address] != rewardsFee:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _755 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_755] = 26
                                mem[_755 + 32] = 'SafeMath: division by zero'
                                if not balanceOf[this.address] * rewardsFee / 100:
                                    _858 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_858] = 26
                                    mem[_858 + 32] = 'SafeMath: division by zero'
                                    _960 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    mem[_960 + 32 len 64] = call.data[calldata.size len 64]
                                    if 0 >= mem[_960]:
                                        revert with 0, 50
                                    mem[_960 + 32] = this.address
                                    require ext_code.size(uniswapV2RouterAddress)
                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                            gas gas_remaining wei
                                    mem[_960 + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = _960 + ceil32(return_data.size) + 96
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    if 1 >= mem[_960]:
                                        revert with 0, 50
                                    mem[_960 + 64] = ext_call.return_data[12 len 20]
                                    if not this.address:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not uniswapV2RouterAddress:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    mem[0] = uniswapV2RouterAddress
                                    mem[32] = sha3(address(this.address), 1)
                                    allowance[address(this.address)][stor9].field_0 = 0
                                    emit Approval(0, this.address, uniswapV2RouterAddress);
                                    mem[_960 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                    mem[_960 + ceil32(return_data.size) + 100] = 0
                                    mem[_960 + ceil32(return_data.size) + 132] = 0
                                    mem[_960 + ceil32(return_data.size) + 164] = 160
                                    mem[_960 + ceil32(return_data.size) + 260] = mem[_960]
                                    idx = 0
                                    s = _960 + ceil32(return_data.size) + 292
                                    t = _960 + 32
                                    while idx < mem[_960]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(uniswapV2RouterAddress)
                                    call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args 0, 0, 160, address(this.address), block.timestamp, mem[_960 + ceil32(return_data.size) + 260 len (32 * mem[_960]) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_960 + ceil32(return_data.size) + 96] = 30
                                    mem[_960 + ceil32(return_data.size) + 128] = 'SafeMath: subtraction overflow'
                                    if eth.balance(this.address) > eth.balance(this.address):
                                        var124001 = 32
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if eth.balance(this.address) < eth.balance(this.address):
                                        revert with 0, 17
                                    call distributionPoolAddress with:
                                         gas 2300 wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_960 + ceil32(return_data.size) + 160] = 30
                                    mem[_960 + ceil32(return_data.size) + 192] = 'SafeMath: subtraction overflow'
                                    if 0 > balanceOf[this.address] * rewardsFee / 100:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if balanceOf[this.address] * rewardsFee / 100 < 0:
                                        revert with 0, 17
                                    if not this.address:
                                        revert with 0, 'ERC20: transfer from the zero address'
                                    if not distributionPoolAddress:
                                        revert with 0, 'ERC20: transfer to the zero address'
                                    mem[_960 + ceil32(return_data.size) + 224] = 38
                                    mem[_960 + ceil32(return_data.size) + 256 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                    if balanceOf[this.address] * rewardsFee / 100 > balanceOf[address(this.address)]:
                                        revert with 0, 
                                                    32,
                                                    38,
                                                    0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_960 + ceil32(return_data.size) + 294 len 26] >> 48,
                                                    0
                                    if balanceOf[address(this.address)] < balanceOf[this.address] * rewardsFee / 100:
                                        revert with 0, 17
                                    balanceOf[address(this.address)] -= balanceOf[this.address] * rewardsFee / 100
                                    if balanceOf[stor12] > !(balanceOf[this.address] * rewardsFee / 100):
                                        revert with 0, 17
                                    if balanceOf[stor12] + (balanceOf[this.address] * rewardsFee / 100) < balanceOf[stor12]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[stor12] += balanceOf[this.address] * rewardsFee / 100
                                    emit Transfer((balanceOf[this.address] * rewardsFee / 100), this.address, distributionPoolAddress);
                                    if not balanceOf[this.address]:
                                        mem[_960 + ceil32(return_data.size) + 320] = 26
                                        mem[_960 + ceil32(return_data.size) + 352] = 'SafeMath: division by zero'
                                        mem[_960 + ceil32(return_data.size) + 384] = 26
                                        mem[_960 + ceil32(return_data.size) + 416] = 'SafeMath: division by zero'
                                        mem[_960 + ceil32(return_data.size) + 448] = 30
                                        mem[_960 + ceil32(return_data.size) + 480] = 'SafeMath: subtraction overflow'
                                        mem[_960 + ceil32(return_data.size) + 512] = 2
                                        mem[_960 + ceil32(return_data.size) + 544] = this.address
                                        require ext_code.size(uniswapV2RouterAddress)
                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                gas gas_remaining wei
                                        mem[_960 + ceil32(return_data.size) + 608] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                        mem[_960 + ceil32(return_data.size) + 576] = ext_call.return_data[12 len 20]
                                        if not this.address:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not uniswapV2RouterAddress:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(this.address)][stor9].field_0 = 0
                                        emit Approval(0, this.address, uniswapV2RouterAddress);
                                        mem[_960 + (2 * ceil32(return_data.size)) + 608] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                        mem[_960 + (2 * ceil32(return_data.size)) + 612] = 0
                                        mem[_960 + (2 * ceil32(return_data.size)) + 644] = 0
                                        mem[_960 + (2 * ceil32(return_data.size)) + 676] = 160
                                        mem[_960 + (2 * ceil32(return_data.size)) + 772] = 2
                                        idx = 0
                                        s = _960 + (2 * ceil32(return_data.size)) + 804
                                        t = _960 + ceil32(return_data.size) + 544
                                        while idx < mem[_960 + ceil32(return_data.size) + 512]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_960 + (2 * ceil32(return_data.size)) + 708] = this.address
                                        mem[_960 + (2 * ceil32(return_data.size)) + 740] = block.timestamp
                                        require ext_code.size(uniswapV2RouterAddress)
                                        call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args 0, 0, 160, address(this.address), block.timestamp, mem[_960 + (2 * ceil32(return_data.size)) + 772 len (32 * mem[_960 + ceil32(return_data.size) + 512]) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[_960 + (2 * ceil32(return_data.size)) + 608] = 30
                                        mem[_960 + (2 * ceil32(return_data.size)) + 640] = 'SafeMath: subtraction overflow'
                                        if eth.balance(this.address) > eth.balance(this.address):
                                            var212001 = 32
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if eth.balance(this.address) < eth.balance(this.address):
                                            revert with 0, 17
                                        if not this.address:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not uniswapV2RouterAddress:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(this.address)][stor9].field_0 = 0
                                        emit Approval(0, this.address, uniswapV2RouterAddress);
                                        mem[_960 + (2 * ceil32(return_data.size)) + 676] = this.address
                                        mem[_960 + (2 * ceil32(return_data.size)) + 708] = 0
                                        mem[_960 + (2 * ceil32(return_data.size)) + 740] = 0
                                        mem[_960 + (2 * ceil32(return_data.size)) + 772] = 0
                                        mem[_960 + (2 * ceil32(return_data.size)) + 804] = 0
                                        mem[_960 + (2 * ceil32(return_data.size)) + 836] = block.timestamp
                                        require ext_code.size(uniswapV2RouterAddress)
                                        call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                             gas gas_remaining wei
                                            args this.address, 0, 0, 0, 0, block.timestamp
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 96
                                        emit SwapAndLiquify(uint256 arg1, uint256 arg2, uint256 arg3):
                                                            0,
                                        mem[_960 + (4 * ceil32(return_data.size)) + 672] = 2
                                        mem[_960 + (4 * ceil32(return_data.size)) + 704] = this.address
                                        require ext_code.size(uniswapV2RouterAddress)
                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                gas gas_remaining wei
                                        mem[_960 + (4 * ceil32(return_data.size)) + 768] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[64] = _960 + (6 * ceil32(return_data.size)) + 768
                                        require return_data.size >= 32
                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                        mem[_960 + (4 * ceil32(return_data.size)) + 736] = ext_call.return_data[12 len 20]
                                        if not this.address:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not uniswapV2RouterAddress:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        mem[0] = uniswapV2RouterAddress
                                        mem[32] = sha3(address(this.address), 1)
                                        allowance[address(this.address)][stor9].field_0 = balanceOf[this.address]
                                        emit Approval(balanceOf[this.address], this.address, uniswapV2RouterAddress);
                                        mem[_960 + (6 * ceil32(return_data.size)) + 768] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                        mem[_960 + (6 * ceil32(return_data.size)) + 772] = balanceOf[this.address]
                                        mem[_960 + (6 * ceil32(return_data.size)) + 804] = 0
                                        mem[_960 + (6 * ceil32(return_data.size)) + 836] = 160
                                        mem[_960 + (6 * ceil32(return_data.size)) + 932] = 2
                                        idx = 0
                                        s = _960 + (6 * ceil32(return_data.size)) + 964
                                        t = _960 + (4 * ceil32(return_data.size)) + 704
                                        while idx < mem[_960 + (4 * ceil32(return_data.size)) + 672]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_960 + (6 * ceil32(return_data.size)) + 868] = this.address
                                        mem[_960 + (6 * ceil32(return_data.size)) + 900] = block.timestamp
                                        require ext_code.size(uniswapV2RouterAddress)
                                        call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _960 + (6 * ceil32(return_data.size)) + (32 * mem[_960 + (4 * ceil32(return_data.size)) + 672]) + -mem[64] + 960]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _6336 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6336] = 30
                                        mem[_6336 + 32] = 'SafeMath: subtraction overflow'
                                        if eth.balance(this.address) > eth.balance(this.address):
                                            var258001 = 32
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if eth.balance(this.address) < eth.balance(this.address):
                                            revert with 0, 17
                                        call marketingWalletAddress with:
                                             gas 2300 wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        uint8(stor23.field_0) = 0
                                        if not msg.sender:
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not this.address:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        _6498 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_6498] = 38
                                        mem[_6498 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                        if _537 > balanceOf[address(msg.sender)]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 38
                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_6498 + 70 len 26]
                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                    else:
                                        if balanceOf[this.address] and liquidityPoolFee > -1 / balanceOf[this.address]:
                                            revert with 0, 17
                                        if not balanceOf[this.address]:
                                            revert with 0, 18
                                        if balanceOf[this.address] * liquidityPoolFee / balanceOf[this.address] != liquidityPoolFee:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        mem[_960 + ceil32(return_data.size) + 320] = 26
                                        mem[_960 + ceil32(return_data.size) + 352] = 'SafeMath: division by zero'
                                        mem[_960 + ceil32(return_data.size) + 384] = 26
                                        mem[_960 + ceil32(return_data.size) + 416] = 'SafeMath: division by zero'
                                        mem[_960 + ceil32(return_data.size) + 448] = 30
                                        mem[_960 + ceil32(return_data.size) + 480] = 'SafeMath: subtraction overflow'
                                        if balanceOf[this.address] * liquidityPoolFee / 100 / 2 > balanceOf[this.address] * liquidityPoolFee / 100:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if balanceOf[this.address] * liquidityPoolFee / 100 < balanceOf[this.address] * liquidityPoolFee / 100 / 2:
                                            revert with 0, 17
                                        mem[_960 + ceil32(return_data.size) + 512] = 2
                                        mem[_960 + ceil32(return_data.size) + 544] = this.address
                                        require ext_code.size(uniswapV2RouterAddress)
                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                gas gas_remaining wei
                                        mem[_960 + ceil32(return_data.size) + 608] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                        mem[_960 + ceil32(return_data.size) + 576] = ext_call.return_data[12 len 20]
                                        if not this.address:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not uniswapV2RouterAddress:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(this.address)][stor9].field_0 = balanceOf[this.address] * liquidityPoolFee / 100 / 2
                                        allowance[address(this.address)][stor9].field_255 = 0
                                        emit Approval((balanceOf[this.address] * liquidityPoolFee / 100 / 2), this.address, uniswapV2RouterAddress);
                                        mem[_960 + (2 * ceil32(return_data.size)) + 608] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                        mem[_960 + (2 * ceil32(return_data.size)) + 612] = balanceOf[this.address] * liquidityPoolFee / 100 / 2
                                        mem[_960 + (2 * ceil32(return_data.size)) + 644] = 0
                                        mem[_960 + (2 * ceil32(return_data.size)) + 676] = 160
                                        mem[_960 + (2 * ceil32(return_data.size)) + 772] = 2
                                        idx = 0
                                        s = _960 + (2 * ceil32(return_data.size)) + 804
                                        t = _960 + ceil32(return_data.size) + 544
                                        while idx < mem[_960 + ceil32(return_data.size) + 512]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_960 + (2 * ceil32(return_data.size)) + 708] = this.address
                                        mem[_960 + (2 * ceil32(return_data.size)) + 740] = block.timestamp
                                        require ext_code.size(uniswapV2RouterAddress)
                                        call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args Mask(255, 1, balanceOf[this.address] * liquidityPoolFee / 100), 0, 160, address(this.address), block.timestamp, mem[_960 + (2 * ceil32(return_data.size)) + 772 len (32 * mem[_960 + ceil32(return_data.size) + 512]) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[_960 + (2 * ceil32(return_data.size)) + 608] = 30
                                        mem[_960 + (2 * ceil32(return_data.size)) + 640] = 'SafeMath: subtraction overflow'
                                        if eth.balance(this.address) > eth.balance(this.address):
                                            mem[_960 + (2 * ceil32(return_data.size)) + 672] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_960 + (2 * ceil32(return_data.size)) + 676] = 32
                                            mem[_960 + (2 * ceil32(return_data.size)) + 708] = 30
                                            mem[_960 + (2 * ceil32(return_data.size)) + 740] = 'SafeMath: subtraction overflow'
                                            mem[_960 + (2 * ceil32(return_data.size)) + 770] = 0
                                            revert with memory
                                              from _960 + (2 * ceil32(return_data.size)) + 672
                                               len ceil32(return_data.size) + 100
                                        if eth.balance(this.address) < eth.balance(this.address):
                                            revert with 0, 17
                                        if not this.address:
                                            mem[_960 + (2 * ceil32(return_data.size)) + 672] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_960 + (2 * ceil32(return_data.size)) + 676] = 32
                                            mem[_960 + (2 * ceil32(return_data.size)) + 708] = 36
                                            mem[_960 + (2 * ceil32(return_data.size)) + 740] = 'ERC20: approve from the zero add'
                                            mem[_960 + (2 * ceil32(return_data.size)) + 772] = 0x7265737300000000000000000000000000000000000000000000000000000000
                                            revert with memory
                                              from _960 + (2 * ceil32(return_data.size)) + 672
                                               len ceil32(return_data.size) + 132
                                        if not uniswapV2RouterAddress:
                                            mem[_960 + (2 * ceil32(return_data.size)) + 672] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_960 + (2 * ceil32(return_data.size)) + 676] = 32
                                            mem[_960 + (2 * ceil32(return_data.size)) + 708] = 34
                                            mem[_960 + (2 * ceil32(return_data.size)) + 740] = 'ERC20: approve to the zero addre'
                                            mem[_960 + (2 * ceil32(return_data.size)) + 772] = 0x7373000000000000000000000000000000000000000000000000000000000000
                                            revert with memory
                                              from _960 + (2 * ceil32(return_data.size)) + 672
                                               len ceil32(return_data.size) + 132
                                        allowance[address(this.address)][stor9].field_0 = (balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2)
                                        emit Approval(((balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2)), this.address, uniswapV2RouterAddress);
                                        mem[_960 + (2 * ceil32(return_data.size)) + 676] = this.address
                                        mem[_960 + (2 * ceil32(return_data.size)) + 708] = (balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2)
                                        mem[_960 + (2 * ceil32(return_data.size)) + 740] = 0
                                        mem[_960 + (2 * ceil32(return_data.size)) + 772] = 0
                                        mem[_960 + (2 * ceil32(return_data.size)) + 804] = 0
                                        mem[_960 + (2 * ceil32(return_data.size)) + 836] = block.timestamp
                                        require ext_code.size(uniswapV2RouterAddress)
                                        call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                             gas gas_remaining wei
                                            args mem[_960 + (2 * ceil32(return_data.size)) + 676 len ceil32(return_data.size) + 192]
                                        mem[_960 + (2 * ceil32(return_data.size)) + 672 len 96] = ext_call.return_data[0 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 96
                                        mem[_960 + (4 * ceil32(return_data.size)) + 672] = balanceOf[this.address] * liquidityPoolFee / 100 / 2
                                        mem[_960 + (4 * ceil32(return_data.size)) + 704] = 0
                                        mem[_960 + (4 * ceil32(return_data.size)) + 736] = (balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2)
                                        emit SwapAndLiquify(uint256 arg1, uint256 arg2, uint256 arg3):
                                                            mem[_960 + (4 * ceil32(return_data.size)) + 672 len (5 * ceil32(return_data.size)) + 96],
                                        mem[_960 + (4 * ceil32(return_data.size)) + 672] = 2
                                        mem[_960 + (4 * ceil32(return_data.size)) + 704] = this.address
                                        require ext_code.size(uniswapV2RouterAddress)
                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                gas gas_remaining wei
                                        mem[_960 + (4 * ceil32(return_data.size)) + 768] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[64] = _960 + (6 * ceil32(return_data.size)) + 768
                                        require return_data.size >= 32
                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                        mem[_960 + (4 * ceil32(return_data.size)) + 736] = ext_call.return_data[12 len 20]
                                        if not this.address:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not uniswapV2RouterAddress:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        mem[0] = uniswapV2RouterAddress
                                        mem[32] = sha3(address(this.address), 1)
                                        allowance[address(this.address)][stor9].field_0 = balanceOf[this.address]
                                        emit Approval(balanceOf[this.address], this.address, uniswapV2RouterAddress);
                                        mem[_960 + (6 * ceil32(return_data.size)) + 768] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                        mem[_960 + (6 * ceil32(return_data.size)) + 772] = balanceOf[this.address]
                                        mem[_960 + (6 * ceil32(return_data.size)) + 804] = 0
                                        mem[_960 + (6 * ceil32(return_data.size)) + 836] = 160
                                        mem[_960 + (6 * ceil32(return_data.size)) + 932] = 2
                                        idx = 0
                                        s = _960 + (6 * ceil32(return_data.size)) + 964
                                        t = _960 + (4 * ceil32(return_data.size)) + 704
                                        while idx < mem[_960 + (4 * ceil32(return_data.size)) + 672]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_960 + (6 * ceil32(return_data.size)) + 868] = this.address
                                        mem[_960 + (6 * ceil32(return_data.size)) + 900] = block.timestamp
                                        require ext_code.size(uniswapV2RouterAddress)
                                        call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _960 + (6 * ceil32(return_data.size)) + (32 * mem[_960 + (4 * ceil32(return_data.size)) + 672]) + -mem[64] + 960]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _6335 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6335] = 30
                                        mem[_6335 + 32] = 'SafeMath: subtraction overflow'
                                        if eth.balance(this.address) > eth.balance(this.address):
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if eth.balance(this.address) < eth.balance(this.address):
                                            revert with 0, 17
                                        call marketingWalletAddress with:
                                             gas 2300 wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        uint8(stor23.field_0) = 0
                                        if not msg.sender:
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not this.address:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        _6495 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_6495] = 38
                                        mem[_6495 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                        if _537 > balanceOf[address(msg.sender)]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 38
                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_6495 + 70 len 26]
                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                    ('le', ('var', '_537'), ('stor', ('map', ('mask_shl', 160, 0, 0, 'msg.sender'), ('name', 'balanceOf', 0))))
                                    if balanceOf[address(msg.sender)] < _537:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)] -= _537
                                    if balanceOf[this.address] > !_537:
                                        revert with 0, 17
                                    if balanceOf[this.address] + _537 < balanceOf[this.address]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(this.address)] = balanceOf[this.address] + _537
                                    emit Transfer(_537, msg.sender, this.address);
                                    if arg1 >= 3:
                                        revert with 0, 50
                                    mem[mem[64]] = 0x12b8603f00000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = 64
                                    mem[mem[64] + 68] = mem[96]
                                    mem[mem[64] + 100 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                                    if ceil32(mem[96]) > mem[96]:
                                        mem[mem[64] + mem[96] + 100] = 0
                                    require ext_code.size(sub_20eea8b5[arg1])
                                    call sub_20eea8b5[arg1].createNode(address arg1, string arg2) with:
                                         gas gas_remaining wei
                                        args msg.sender, Array(len=mem[96], data=mem[mem[64] + 100 len ceil32(mem[96])])
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if stor27[address(msg.sender)] > -2:
                                        revert with 0, 17
                                    if stor27[address(msg.sender)] + 1 < stor27[address(msg.sender)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                else:
                                    if balanceOf[this.address] * rewardsFee / 100 and stor22 > -1 / balanceOf[this.address] * rewardsFee / 100:
                                        revert with 0, 17
                                    if not balanceOf[this.address] * rewardsFee / 100:
                                        revert with 0, 18
                                    if balanceOf[this.address] * rewardsFee / 100 * stor22 / balanceOf[this.address] * rewardsFee / 100 != stor22:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _915 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_915] = 26
                                    mem[_915 + 32] = 'SafeMath: division by zero'
                                    _1001 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    mem[_1001 + 32 len 64] = call.data[calldata.size len 64]
                                    if 0 >= mem[_1001]:
                                        revert with 0, 50
                                    mem[_1001 + 32] = this.address
                                    require ext_code.size(uniswapV2RouterAddress)
                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                            gas gas_remaining wei
                                    mem[_1001 + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = _1001 + ceil32(return_data.size) + 96
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    if 1 >= mem[_1001]:
                                        revert with 0, 50
                                    mem[_1001 + 64] = ext_call.return_data[12 len 20]
                                    if not this.address:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not uniswapV2RouterAddress:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    mem[0] = uniswapV2RouterAddress
                                    mem[32] = sha3(address(this.address), 1)
                                    allowance[address(this.address)][stor9].field_0 = balanceOf[this.address] * rewardsFee / 100 * stor22 / 100
                                    emit Approval((balanceOf[this.address] * rewardsFee / 100 * stor22 / 100), this.address, uniswapV2RouterAddress);
                                    mem[_1001 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                    mem[_1001 + ceil32(return_data.size) + 100] = balanceOf[this.address] * rewardsFee / 100 * stor22 / 100
                                    mem[_1001 + ceil32(return_data.size) + 132] = 0
                                    mem[_1001 + ceil32(return_data.size) + 164] = 160
                                    mem[_1001 + ceil32(return_data.size) + 260] = mem[_1001]
                                    idx = 0
                                    s = _1001 + ceil32(return_data.size) + 292
                                    t = _1001 + 32
                                    while idx < mem[_1001]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(uniswapV2RouterAddress)
                                    call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args balanceOf[this.address] * rewardsFee / 100 * stor22 / 100, 0, 160, address(this.address), block.timestamp, mem[_1001 + ceil32(return_data.size) + 260 len (32 * mem[_1001]) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_1001 + ceil32(return_data.size) + 96] = 30
                                    mem[_1001 + ceil32(return_data.size) + 128] = 'SafeMath: subtraction overflow'
                                    if eth.balance(this.address) > eth.balance(this.address):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if eth.balance(this.address) < eth.balance(this.address):
                                        revert with 0, 17
                                    call distributionPoolAddress with:
                                         gas 2300 wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_1001 + ceil32(return_data.size) + 160] = 30
                                    mem[_1001 + ceil32(return_data.size) + 192] = 'SafeMath: subtraction overflow'
                                    if balanceOf[this.address] * rewardsFee / 100 * stor22 / 100 > balanceOf[this.address] * rewardsFee / 100:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if balanceOf[this.address] * rewardsFee / 100 < balanceOf[this.address] * rewardsFee / 100 * stor22 / 100:
                                        revert with 0, 17
                                    if not this.address:
                                        revert with 0, 'ERC20: transfer from the zero address'
                                    if not distributionPoolAddress:
                                        revert with 0, 'ERC20: transfer to the zero address'
                                    mem[_1001 + ceil32(return_data.size) + 224] = 38
                                    mem[_1001 + ceil32(return_data.size) + 256 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                    if (balanceOf[this.address] * rewardsFee / 100) - (balanceOf[this.address] * rewardsFee / 100 * stor22 / 100) > balanceOf[address(this.address)]:
                                        revert with 0, 
                                                    32,
                                                    38,
                                                    0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_1001 + ceil32(return_data.size) + 294 len 26] >> 48,
                                                    0
                                    if balanceOf[address(this.address)] < (balanceOf[this.address] * rewardsFee / 100) - (balanceOf[this.address] * rewardsFee / 100 * stor22 / 100):
                                        revert with 0, 17
                                    balanceOf[address(this.address)] = balanceOf[address(this.address)] - (balanceOf[this.address] * rewardsFee / 100) + (balanceOf[this.address] * rewardsFee / 100 * stor22 / 100)
                                    if balanceOf[stor12] > !((balanceOf[this.address] * rewardsFee / 100) - (balanceOf[this.address] * rewardsFee / 100 * stor22 / 100)):
                                        revert with 0, 17
                                    if balanceOf[stor12] + (balanceOf[this.address] * rewardsFee / 100) - (balanceOf[this.address] * rewardsFee / 100 * stor22 / 100) < balanceOf[stor12]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[stor12] = balanceOf[stor12] + (balanceOf[this.address] * rewardsFee / 100) - (balanceOf[this.address] * rewardsFee / 100 * stor22 / 100)
                                    emit Transfer(((balanceOf[this.address] * rewardsFee / 100) - (balanceOf[this.address] * rewardsFee / 100 * stor22 / 100)), this.address, distributionPoolAddress);
                                    if not balanceOf[this.address]:
                                        mem[_1001 + ceil32(return_data.size) + 320] = 26
                                        mem[_1001 + ceil32(return_data.size) + 352] = 'SafeMath: division by zero'
                                        mem[_1001 + ceil32(return_data.size) + 384] = 26
                                        mem[_1001 + ceil32(return_data.size) + 416] = 'SafeMath: division by zero'
                                        mem[_1001 + ceil32(return_data.size) + 448] = 30
                                        mem[_1001 + ceil32(return_data.size) + 480] = 'SafeMath: subtraction overflow'
                                        mem[_1001 + ceil32(return_data.size) + 512] = 2
                                        mem[_1001 + ceil32(return_data.size) + 544] = this.address
                                        require ext_code.size(uniswapV2RouterAddress)
                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                gas gas_remaining wei
                                        mem[_1001 + ceil32(return_data.size) + 608] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[64] = _1001 + (2 * ceil32(return_data.size)) + 608
                                        require return_data.size >= 32
                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                        mem[_1001 + ceil32(return_data.size) + 576] = ext_call.return_data[12 len 20]
                                        if not this.address:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not uniswapV2RouterAddress:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        mem[0] = uniswapV2RouterAddress
                                        mem[32] = sha3(address(this.address), 1)
                                        allowance[address(this.address)][stor9].field_0 = 0
                                        emit Approval(0, this.address, uniswapV2RouterAddress);
                                        mem[_1001 + (2 * ceil32(return_data.size)) + 608] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                        mem[_1001 + (2 * ceil32(return_data.size)) + 612] = 0
                                        mem[_1001 + (2 * ceil32(return_data.size)) + 644] = 0
                                        mem[_1001 + (2 * ceil32(return_data.size)) + 676] = 160
                                        mem[_1001 + (2 * ceil32(return_data.size)) + 772] = 2
                                        idx = 0
                                        s = _1001 + (2 * ceil32(return_data.size)) + 804
                                        t = _1001 + ceil32(return_data.size) + 544
                                        while idx < mem[_1001 + ceil32(return_data.size) + 512]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_1001 + (2 * ceil32(return_data.size)) + 708] = this.address
                                        mem[_1001 + (2 * ceil32(return_data.size)) + 740] = block.timestamp
                                        require ext_code.size(uniswapV2RouterAddress)
                                        call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args 0, 0, 160, address(this.address), block.timestamp, mem[_1001 + (2 * ceil32(return_data.size)) + 772 len (32 * mem[_1001 + ceil32(return_data.size) + 512]) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[_1001 + (2 * ceil32(return_data.size)) + 608] = 30
                                        mem[_1001 + (2 * ceil32(return_data.size)) + 640] = 'SafeMath: subtraction overflow'
                                        if eth.balance(this.address) > eth.balance(this.address):
                                            mem[_1001 + (2 * ceil32(return_data.size)) + 672] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_1001 + (2 * ceil32(return_data.size)) + 676] = 32
                                            mem[_1001 + (2 * ceil32(return_data.size)) + 708] = 30
                                            mem[_1001 + (2 * ceil32(return_data.size)) + 740] = 'SafeMath: subtraction overflow'
                                            mem[_1001 + (2 * ceil32(return_data.size)) + 770] = 0
                                            revert with memory
                                              from _1001 + (2 * ceil32(return_data.size)) + 672
                                               len ceil32(return_data.size) + 100
                                        if eth.balance(this.address) < eth.balance(this.address):
                                            revert with 0, 17
                                        if not this.address:
                                            mem[_1001 + (2 * ceil32(return_data.size)) + 672] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_1001 + (2 * ceil32(return_data.size)) + 676] = 32
                                            mem[_1001 + (2 * ceil32(return_data.size)) + 708] = 36
                                            mem[_1001 + (2 * ceil32(return_data.size)) + 740] = 'ERC20: approve from the zero add'
                                            mem[_1001 + (2 * ceil32(return_data.size)) + 772] = 0x7265737300000000000000000000000000000000000000000000000000000000
                                            revert with memory
                                              from _1001 + (2 * ceil32(return_data.size)) + 672
                                               len ceil32(return_data.size) + 132
                                        if not uniswapV2RouterAddress:
                                            mem[_1001 + (2 * ceil32(return_data.size)) + 672] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_1001 + (2 * ceil32(return_data.size)) + 676] = 32
                                            mem[_1001 + (2 * ceil32(return_data.size)) + 708] = 34
                                            mem[_1001 + (2 * ceil32(return_data.size)) + 740] = 'ERC20: approve to the zero addre'
                                            mem[_1001 + (2 * ceil32(return_data.size)) + 772] = 0x7373000000000000000000000000000000000000000000000000000000000000
                                            revert with memory
                                              from _1001 + (2 * ceil32(return_data.size)) + 672
                                               len ceil32(return_data.size) + 132
                                        allowance[address(this.address)][stor9].field_0 = 0
                                        emit Approval(0, this.address, uniswapV2RouterAddress);
                                        mem[_1001 + (2 * ceil32(return_data.size)) + 676] = this.address
                                        mem[_1001 + (2 * ceil32(return_data.size)) + 708] = 0
                                        mem[_1001 + (2 * ceil32(return_data.size)) + 740] = 0
                                        mem[_1001 + (2 * ceil32(return_data.size)) + 772] = 0
                                        mem[_1001 + (2 * ceil32(return_data.size)) + 804] = 0
                                        mem[_1001 + (2 * ceil32(return_data.size)) + 836] = block.timestamp
                                        require ext_code.size(uniswapV2RouterAddress)
                                        call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                             gas gas_remaining wei
                                            args mem[_1001 + (2 * ceil32(return_data.size)) + 676 len ceil32(return_data.size) + 192]
                                        mem[_1001 + (2 * ceil32(return_data.size)) + 672 len 96] = ext_call.return_data[0 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 96
                                        mem[_1001 + (4 * ceil32(return_data.size)) + 672] = 0
                                        mem[_1001 + (4 * ceil32(return_data.size)) + 704] = 0
                                        mem[_1001 + (4 * ceil32(return_data.size)) + 736] = 0
                                        emit SwapAndLiquify(uint256 arg1, uint256 arg2, uint256 arg3):
                                                            mem[_1001 + (4 * ceil32(return_data.size)) + 672 len (5 * ceil32(return_data.size)) + 96],
                                        mem[_1001 + (4 * ceil32(return_data.size)) + 672] = 2
                                        mem[_1001 + (4 * ceil32(return_data.size)) + 704] = this.address
                                        require ext_code.size(uniswapV2RouterAddress)
                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                gas gas_remaining wei
                                        mem[_1001 + (4 * ceil32(return_data.size)) + 768] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[64] = _1001 + (6 * ceil32(return_data.size)) + 768
                                        require return_data.size >= 32
                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                        mem[_1001 + (4 * ceil32(return_data.size)) + 736] = ext_call.return_data[12 len 20]
                                        if not this.address:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not uniswapV2RouterAddress:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        mem[0] = uniswapV2RouterAddress
                                        mem[32] = sha3(address(this.address), 1)
                                        allowance[address(this.address)][stor9].field_0 = balanceOf[this.address]
                                        emit Approval(balanceOf[this.address], this.address, uniswapV2RouterAddress);
                                        mem[_1001 + (6 * ceil32(return_data.size)) + 768] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                        mem[_1001 + (6 * ceil32(return_data.size)) + 772] = balanceOf[this.address]
                                        mem[_1001 + (6 * ceil32(return_data.size)) + 804] = 0
                                        mem[_1001 + (6 * ceil32(return_data.size)) + 836] = 160
                                        mem[_1001 + (6 * ceil32(return_data.size)) + 932] = 2
                                        idx = 0
                                        s = _1001 + (6 * ceil32(return_data.size)) + 964
                                        t = _1001 + (4 * ceil32(return_data.size)) + 704
                                        while idx < mem[_1001 + (4 * ceil32(return_data.size)) + 672]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_1001 + (6 * ceil32(return_data.size)) + 900] = block.timestamp
                                        require ext_code.size(uniswapV2RouterAddress)
                                        call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args balanceOf[this.address], 0, 160, address(this.address), block.timestamp, mem[_1001 + (6 * ceil32(return_data.size)) + 932 len (32 * mem[_1001 + (4 * ceil32(return_data.size)) + 672]) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[_1001 + (6 * ceil32(return_data.size)) + 768] = 30
                                        mem[_1001 + (6 * ceil32(return_data.size)) + 800] = 'SafeMath: subtraction overflow'
                                        if eth.balance(this.address) > eth.balance(this.address):
                                            mem[_1001 + (6 * ceil32(return_data.size)) + 930] = 0
                                            revert with 0, 
                                                        'SafeMath: subtraction overflow',
                                                        mem[_1001 + (6 * ceil32(return_data.size)) + 930 len (9 * ceil32(return_data.size)) + 2]
                                        if eth.balance(this.address) < eth.balance(this.address):
                                            revert with 0, 17
                                        call marketingWalletAddress with:
                                             gas 2300 wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        uint8(stor23.field_0) = 0
                                        if not msg.sender:
                                            revert with 0, 
                                                        'ERC20: transfer from the zero address',
                                                        mem[_1001 + (6 * ceil32(return_data.size)) + 964 len 9 * ceil32(return_data.size)]
                                        if not this.address:
                                            revert with 0, 
                                                        'ERC20: transfer to the zero address',
                                                        mem[_1001 + (6 * ceil32(return_data.size)) + 964 len 9 * ceil32(return_data.size)]
                                        mem[_1001 + (6 * ceil32(return_data.size)) + 832] = 38
                                        mem[_1001 + (6 * ceil32(return_data.size)) + 864 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                        if _537 > balanceOf[address(msg.sender)]:
                                            mem[_1001 + (6 * ceil32(return_data.size)) + 1034] = 0
                                            revert with 0, 
                                                        32,
                                                        38,
                                                        0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, Mask(208, 32, block.timestamp) >> 32 >> 48,
                                                        mem[_1001 + (6 * ceil32(return_data.size)) + 1034 len (9 * ceil32(return_data.size)) + 26]
                                        if balanceOf[address(msg.sender)] < _537:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] -= _537
                                        if balanceOf[this.address] > !_537:
                                            revert with 0, 17
                                        if balanceOf[this.address] + _537 < balanceOf[this.address]:
                                            revert with 0, 'SafeMath: addition overflow', mem[_1001 + (6 * ceil32(return_data.size)) + 1028 len 9 * ceil32(return_data.size)]
                                        balanceOf[address(this.address)] = balanceOf[this.address] + _537
                                        emit Transfer(_537, msg.sender, this.address);
                                        if arg1 >= 3:
                                            revert with 0, 50
                                        mem[_1001 + (6 * ceil32(return_data.size)) + 928] = 0x12b8603f00000000000000000000000000000000000000000000000000000000
                                        mem[_1001 + (6 * ceil32(return_data.size)) + 932] = msg.sender
                                        mem[_1001 + (6 * ceil32(return_data.size)) + 964] = 64
                                        mem[_1001 + (6 * ceil32(return_data.size)) + 996] = mem[96]
                                        mem[_1001 + (6 * ceil32(return_data.size)) + 1028 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                                        if ceil32(mem[96]) > mem[96]:
                                            mem[_1001 + (6 * ceil32(return_data.size)) + mem[96] + 1028] = 0
                                        require ext_code.size(sub_20eea8b5[arg1])
                                        call sub_20eea8b5[arg1].createNode(address arg1, string arg2) with:
                                             gas gas_remaining wei
                                            args msg.sender, Array(len=mem[96], data=mem[_1001 + (6 * ceil32(return_data.size)) + 1028 len (9 * ceil32(return_data.size)) + ceil32(mem[96])])
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if stor27[address(msg.sender)] > -2:
                                            revert with 0, 17
                                        if stor27[address(msg.sender)] + 1 < stor27[address(msg.sender)]:
                                            revert with 0, 'SafeMath: addition overflow', mem[_1001 + (6 * ceil32(return_data.size)) + 1028 len 9 * ceil32(return_data.size)]
                                    else:
                                        if balanceOf[this.address] and liquidityPoolFee > -1 / balanceOf[this.address]:
                                            revert with 0, 17
                                        if not balanceOf[this.address]:
                                            revert with 0, 18
                                        if balanceOf[this.address] * liquidityPoolFee / balanceOf[this.address] != liquidityPoolFee:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        mem[_1001 + ceil32(return_data.size) + 320] = 26
                                        mem[_1001 + ceil32(return_data.size) + 352] = 'SafeMath: division by zero'
                                        mem[_1001 + ceil32(return_data.size) + 384] = 26
                                        mem[_1001 + ceil32(return_data.size) + 416] = 'SafeMath: division by zero'
                                        mem[_1001 + ceil32(return_data.size) + 448] = 30
                                        mem[_1001 + ceil32(return_data.size) + 480] = 'SafeMath: subtraction overflow'
                                        if balanceOf[this.address] * liquidityPoolFee / 100 / 2 > balanceOf[this.address] * liquidityPoolFee / 100:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if balanceOf[this.address] * liquidityPoolFee / 100 < balanceOf[this.address] * liquidityPoolFee / 100 / 2:
                                            revert with 0, 17
                                        mem[_1001 + ceil32(return_data.size) + 512] = 2
                                        mem[_1001 + ceil32(return_data.size) + 544] = this.address
                                        require ext_code.size(uniswapV2RouterAddress)
                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                gas gas_remaining wei
                                        mem[_1001 + ceil32(return_data.size) + 608] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[64] = _1001 + (2 * ceil32(return_data.size)) + 608
                                        require return_data.size >= 32
                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                        mem[_1001 + ceil32(return_data.size) + 576] = ext_call.return_data[12 len 20]
                                        if not this.address:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not uniswapV2RouterAddress:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        mem[0] = uniswapV2RouterAddress
                                        mem[32] = sha3(address(this.address), 1)
                                        allowance[address(this.address)][stor9].field_0 = balanceOf[this.address] * liquidityPoolFee / 100 / 2
                                        allowance[address(this.address)][stor9].field_255 = 0
                                        emit Approval((balanceOf[this.address] * liquidityPoolFee / 100 / 2), this.address, uniswapV2RouterAddress);
                                        mem[_1001 + (2 * ceil32(return_data.size)) + 608] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                        mem[_1001 + (2 * ceil32(return_data.size)) + 612] = balanceOf[this.address] * liquidityPoolFee / 100 / 2
                                        mem[_1001 + (2 * ceil32(return_data.size)) + 644] = 0
                                        mem[_1001 + (2 * ceil32(return_data.size)) + 676] = 160
                                        mem[_1001 + (2 * ceil32(return_data.size)) + 772] = 2
                                        idx = 0
                                        s = _1001 + (2 * ceil32(return_data.size)) + 804
                                        t = _1001 + ceil32(return_data.size) + 544
                                        while idx < mem[_1001 + ceil32(return_data.size) + 512]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_1001 + (2 * ceil32(return_data.size)) + 708] = this.address
                                        mem[_1001 + (2 * ceil32(return_data.size)) + 740] = block.timestamp
                                        require ext_code.size(uniswapV2RouterAddress)
                                        call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args Mask(255, 1, balanceOf[this.address] * liquidityPoolFee / 100), 0, 160, address(this.address), block.timestamp, mem[_1001 + (2 * ceil32(return_data.size)) + 772 len (32 * mem[_1001 + ceil32(return_data.size) + 512]) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[_1001 + (2 * ceil32(return_data.size)) + 608] = 30
                                        mem[_1001 + (2 * ceil32(return_data.size)) + 640] = 'SafeMath: subtraction overflow'
                                        if eth.balance(this.address) > eth.balance(this.address):
                                            mem[_1001 + (2 * ceil32(return_data.size)) + 672] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_1001 + (2 * ceil32(return_data.size)) + 676] = 32
                                            mem[_1001 + (2 * ceil32(return_data.size)) + 708] = 30
                                            mem[_1001 + (2 * ceil32(return_data.size)) + 740] = 'SafeMath: subtraction overflow'
                                            mem[_1001 + (2 * ceil32(return_data.size)) + 770] = 0
                                            revert with memory
                                              from _1001 + (2 * ceil32(return_data.size)) + 672
                                               len ceil32(return_data.size) + 100
                                        if eth.balance(this.address) < eth.balance(this.address):
                                            revert with 0, 17
                                        if not this.address:
                                            mem[_1001 + (2 * ceil32(return_data.size)) + 672] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_1001 + (2 * ceil32(return_data.size)) + 676] = 32
                                            mem[_1001 + (2 * ceil32(return_data.size)) + 708] = 36
                                            mem[_1001 + (2 * ceil32(return_data.size)) + 740] = 'ERC20: approve from the zero add'
                                            mem[_1001 + (2 * ceil32(return_data.size)) + 772] = 0x7265737300000000000000000000000000000000000000000000000000000000
                                            revert with memory
                                              from _1001 + (2 * ceil32(return_data.size)) + 672
                                               len ceil32(return_data.size) + 132
                                        if not uniswapV2RouterAddress:
                                            mem[_1001 + (2 * ceil32(return_data.size)) + 672] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_1001 + (2 * ceil32(return_data.size)) + 676] = 32
                                            mem[_1001 + (2 * ceil32(return_data.size)) + 708] = 34
                                            mem[_1001 + (2 * ceil32(return_data.size)) + 740] = 'ERC20: approve to the zero addre'
                                            mem[_1001 + (2 * ceil32(return_data.size)) + 772] = 0x7373000000000000000000000000000000000000000000000000000000000000
                                            revert with memory
                                              from _1001 + (2 * ceil32(return_data.size)) + 672
                                               len ceil32(return_data.size) + 132
                                        allowance[address(this.address)][stor9].field_0 = (balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2)
                                        emit Approval(((balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2)), this.address, uniswapV2RouterAddress);
                                        mem[_1001 + (2 * ceil32(return_data.size)) + 676] = this.address
                                        mem[_1001 + (2 * ceil32(return_data.size)) + 708] = (balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2)
                                        mem[_1001 + (2 * ceil32(return_data.size)) + 740] = 0
                                        mem[_1001 + (2 * ceil32(return_data.size)) + 772] = 0
                                        mem[_1001 + (2 * ceil32(return_data.size)) + 804] = 0
                                        mem[_1001 + (2 * ceil32(return_data.size)) + 836] = block.timestamp
                                        require ext_code.size(uniswapV2RouterAddress)
                                        call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                             gas gas_remaining wei
                                            args mem[_1001 + (2 * ceil32(return_data.size)) + 676 len ceil32(return_data.size) + 192]
                                        mem[_1001 + (2 * ceil32(return_data.size)) + 672 len 96] = ext_call.return_data[0 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 96
                                        mem[_1001 + (4 * ceil32(return_data.size)) + 672] = balanceOf[this.address] * liquidityPoolFee / 100 / 2
                                        mem[_1001 + (4 * ceil32(return_data.size)) + 704] = 0
                                        mem[_1001 + (4 * ceil32(return_data.size)) + 736] = (balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2)
                                        emit SwapAndLiquify(uint256 arg1, uint256 arg2, uint256 arg3):
                                                            mem[_1001 + (4 * ceil32(return_data.size)) + 672 len (5 * ceil32(return_data.size)) + 96],
                                        mem[_1001 + (4 * ceil32(return_data.size)) + 672] = 2
                                        mem[_1001 + (4 * ceil32(return_data.size)) + 704] = this.address
                                        require ext_code.size(uniswapV2RouterAddress)
                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                gas gas_remaining wei
                                        mem[_1001 + (4 * ceil32(return_data.size)) + 768] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[64] = _1001 + (6 * ceil32(return_data.size)) + 768
                                        require return_data.size >= 32
                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                        mem[_1001 + (4 * ceil32(return_data.size)) + 736] = ext_call.return_data[12 len 20]
                                        if not this.address:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not uniswapV2RouterAddress:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        mem[0] = uniswapV2RouterAddress
                                        mem[32] = sha3(address(this.address), 1)
                                        allowance[address(this.address)][stor9].field_0 = balanceOf[this.address]
                                        emit Approval(balanceOf[this.address], this.address, uniswapV2RouterAddress);
                                        mem[_1001 + (6 * ceil32(return_data.size)) + 768] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                        mem[_1001 + (6 * ceil32(return_data.size)) + 772] = balanceOf[this.address]
                                        mem[_1001 + (6 * ceil32(return_data.size)) + 804] = 0
                                        mem[_1001 + (6 * ceil32(return_data.size)) + 836] = 160
                                        mem[_1001 + (6 * ceil32(return_data.size)) + 932] = 2
                                        idx = 0
                                        s = _1001 + (6 * ceil32(return_data.size)) + 964
                                        t = _1001 + (4 * ceil32(return_data.size)) + 704
                                        while idx < mem[_1001 + (4 * ceil32(return_data.size)) + 672]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_1001 + (6 * ceil32(return_data.size)) + 868] = this.address
                                        mem[_1001 + (6 * ceil32(return_data.size)) + 900] = block.timestamp
                                        require ext_code.size(uniswapV2RouterAddress)
                                        call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _1001 + (6 * ceil32(return_data.size)) + (32 * mem[_1001 + (4 * ceil32(return_data.size)) + 672]) + -mem[64] + 960]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _6333 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6333] = 30
                                        mem[_6333 + 32] = 'SafeMath: subtraction overflow'
                                        if eth.balance(this.address) > eth.balance(this.address):
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if eth.balance(this.address) < eth.balance(this.address):
                                            revert with 0, 17
                                        call marketingWalletAddress with:
                                             gas 2300 wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        uint8(stor23.field_0) = 0
                                        if not msg.sender:
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not this.address:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        _6489 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_6489] = 38
                                        mem[_6489 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                        if _537 > balanceOf[address(msg.sender)]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 38
                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_6489 + 70 len 26]
                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                        if balanceOf[address(msg.sender)] < _537:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] -= _537
                                        if balanceOf[this.address] > !_537:
                                            revert with 0, 17
                                        if balanceOf[this.address] + _537 < balanceOf[this.address]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(this.address)] = balanceOf[this.address] + _537
                                        emit Transfer(_537, msg.sender, this.address);
                                        if arg1 >= 3:
                                            revert with 0, 50
                                        mem[mem[64]] = 0x12b8603f00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 64
                                        mem[mem[64] + 68] = mem[96]
                                        mem[mem[64] + 100 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                                        if ceil32(mem[96]) > mem[96]:
                                            mem[mem[64] + mem[96] + 100] = 0
                                        require ext_code.size(sub_20eea8b5[arg1])
                                        call sub_20eea8b5[arg1].createNode(address arg1, string arg2) with:
                                             gas gas_remaining wei
                                            args msg.sender, Array(len=mem[96], data=mem[mem[64] + 100 len ceil32(mem[96])])
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if stor27[address(msg.sender)] > -2:
                                            revert with 0, 17
                                        if stor27[address(msg.sender)] + 1 < stor27[address(msg.sender)]:
                                            revert with 0, 'SafeMath: addition overflow'
    else:
        idx = 0
        while idx < 3:
            mem[mem[64] + 4] = msg.sender
            mem[mem[64] + 36] = 0
            require ext_code.size(sub_20eea8b5[idx])
            staticcall sub_20eea8b5[idx].0x80e9be34 with:
                    gas gas_remaining wei
                   args msg.sender, 0
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _489 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _501 = mem[_489]
            if not distributionPoolAddress:
                revert with 0, 'ERC20: transfer from the zero address'
            if not msg.sender:
                revert with 0, 'ERC20: transfer to the zero address'
            _521 = mem[64]
            mem[64] = mem[64] + 96
            mem[_521] = 38
            mem[_521 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
            mem[32] = 0
            if _501 > balanceOf[stor12]:
                _531 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 38
                idx = 0
                while idx < 38:
                    mem[idx + _531 + 68] = mem[_521 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_531 + 106] = 0
                revert with memory
                  from mem[64]
                   len _531 + -mem[64] + 132
            if balanceOf[stor12] < _501:
                revert with 0, 17
            balanceOf[stor12] -= _501
            if balanceOf[msg.sender] > !_501:
                revert with 0, 17
            if balanceOf[msg.sender] + _501 < balanceOf[msg.sender]:
                revert with 0, 'SafeMath: addition overflow'
            mem[0] = msg.sender
            mem[32] = 0
            balanceOf[address(msg.sender)] = balanceOf[msg.sender] + _501
            emit Transfer(_501, distributionPoolAddress, msg.sender);
            if idx >= 3:
                revert with 0, 50
            mem[mem[64]] = 0xd74037e500000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = msg.sender
            mem[mem[64] + 36] = 0
            mem[mem[64] + 68] = 0
            require ext_code.size(sub_20eea8b5[idx])
            call sub_20eea8b5[idx].0xd74037e5 with:
                 gas gas_remaining wei
                args msg.sender, 0, 0
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        if mem[96] <= 3:
            revert with 0, 'NODE CREATION: NAME SIZE INVALID'
        if mem[96] >= 32:
            revert with 0, 'NODE CREATION: NAME SIZE INVALID'
        if sub_6cdc78b3 <= stor27[msg.sender]:
            revert with 0, 'cannot create node more than 100'
        if not msg.sender:
            revert with 0, 'NODE CREATION:  creation from the zero address'
        mem[0] = msg.sender
        mem[32] = 25
        if stor25[address(msg.sender)]:
            revert with 0, 'NODE CREATION: Blacklisted address'
        if futurUsePoolAddress == msg.sender:
            revert with 0, 'NODE CREATION: futur and rewardsPool cannot create node'
        if distributionPoolAddress == msg.sender:
            revert with 0, 'NODE CREATION: futur and rewardsPool cannot create node'
        if arg1 >= 3:
            revert with 0, 50
        require ext_code.size(sub_20eea8b5[arg1])
        staticcall sub_20eea8b5[arg1].nodePrice() with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _527 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _536 = mem[_527]
        if balanceOf[address(msg.sender)] < mem[_527]:
            revert with 0, 'NODE CREATION: Balance too low for creation.'
        mem[0] = this.address
        mem[32] = 0
        if balanceOf[this.address] < swapTokensAmount:
            if not msg.sender:
                revert with 0, 'ERC20: transfer from the zero address'
            if not this.address:
                revert with 0, 'ERC20: transfer to the zero address'
            _588 = mem[64]
            mem[64] = mem[64] + 96
            mem[_588] = 38
            mem[_588 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
            if _536 > balanceOf[address(msg.sender)]:
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 38
                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_588 + 70 len 26]
                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
            if balanceOf[address(msg.sender)] < _536:
                revert with 0, 17
            balanceOf[address(msg.sender)] -= _536
            if balanceOf[this.address] > !_536:
                revert with 0, 17
            if balanceOf[this.address] + _536 < balanceOf[this.address]:
                revert with 0, 'SafeMath: addition overflow'
            balanceOf[address(this.address)] = balanceOf[this.address] + _536
            emit Transfer(_536, msg.sender, this.address);
            if arg1 >= 3:
                revert with 0, 50
            mem[mem[64]] = 0x12b8603f00000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = msg.sender
            mem[mem[64] + 36] = 64
            mem[mem[64] + 68] = mem[96]
            mem[mem[64] + 100 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
            if ceil32(mem[96]) > mem[96]:
                mem[mem[64] + mem[96] + 100] = 0
            require ext_code.size(sub_20eea8b5[arg1])
            call sub_20eea8b5[arg1].createNode(address arg1, string arg2) with:
                 gas gas_remaining wei
                args msg.sender, Array(len=mem[96], data=mem[mem[64] + 100 len ceil32(mem[96])])
        else:
            if not uint8(stor23.field_8):
                if not msg.sender:
                    revert with 0, 'ERC20: transfer from the zero address'
                if not this.address:
                    revert with 0, 'ERC20: transfer to the zero address'
                _599 = mem[64]
                mem[64] = mem[64] + 96
                mem[_599] = 38
                mem[_599 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                if _536 > balanceOf[address(msg.sender)]:
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 38
                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_599 + 70 len 26]
                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                if balanceOf[address(msg.sender)] < _536:
                    revert with 0, 17
                balanceOf[address(msg.sender)] -= _536
                if balanceOf[this.address] > !_536:
                    revert with 0, 17
                if balanceOf[this.address] + _536 < balanceOf[this.address]:
                    revert with 0, 'SafeMath: addition overflow'
                balanceOf[address(this.address)] = balanceOf[this.address] + _536
                emit Transfer(_536, msg.sender, this.address);
                if arg1 >= 3:
                    revert with 0, 50
                mem[mem[64]] = 0x12b8603f00000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = msg.sender
                mem[mem[64] + 36] = 64
                mem[mem[64] + 68] = mem[96]
                mem[mem[64] + 100 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                if ceil32(mem[96]) > mem[96]:
                    mem[mem[64] + mem[96] + 100] = 0
                require ext_code.size(sub_20eea8b5[arg1])
                call sub_20eea8b5[arg1].createNode(address arg1, string arg2) with:
                     gas gas_remaining wei
                    args msg.sender, Array(len=mem[96], data=mem[mem[64] + 100 len ceil32(mem[96])])
            else:
                if uint8(stor23.field_0):
                    if not msg.sender:
                        revert with 0, 'ERC20: transfer from the zero address'
                    if not this.address:
                        revert with 0, 'ERC20: transfer to the zero address'
                    _617 = mem[64]
                    mem[64] = mem[64] + 96
                    mem[_617] = 38
                    mem[_617 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                    if _536 > balanceOf[address(msg.sender)]:
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 38
                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_617 + 70 len 26]
                        idx = 64
                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                    if balanceOf[address(msg.sender)] < _536:
                        revert with 0, 17
                    balanceOf[address(msg.sender)] -= _536
                    if balanceOf[this.address] > !_536:
                        revert with 0, 17
                    if balanceOf[this.address] + _536 < balanceOf[this.address]:
                        revert with 0, 'SafeMath: addition overflow'
                    balanceOf[address(this.address)] = balanceOf[this.address] + _536
                    emit Transfer(_536, msg.sender, this.address);
                    if arg1 >= 3:
                        revert with 0, 50
                    mem[mem[64]] = 0x12b8603f00000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = msg.sender
                    mem[mem[64] + 36] = 64
                    mem[mem[64] + 68] = mem[96]
                    mem[mem[64] + 100 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                    if ceil32(mem[96]) > mem[96]:
                        mem[mem[64] + mem[96] + 100] = 0
                    require ext_code.size(sub_20eea8b5[arg1])
                    call sub_20eea8b5[arg1].createNode(address arg1, string arg2) with:
                         gas gas_remaining wei
                        args msg.sender, Array(len=mem[96], data=mem[mem[64] + 100 len ceil32(mem[96])])
                else:
                    if owner == msg.sender:
                        if not msg.sender:
                            revert with 0, 'ERC20: transfer from the zero address'
                        if not this.address:
                            revert with 0, 'ERC20: transfer to the zero address'
                        _633 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_633] = 38
                        mem[_633 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                        if _536 > balanceOf[address(msg.sender)]:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 38
                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_633 + 70 len 26]
                            var69001 = 64
                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                        if balanceOf[address(msg.sender)] < _536:
                            revert with 0, 17
                        balanceOf[address(msg.sender)] -= _536
                        if balanceOf[this.address] > !_536:
                            revert with 0, 17
                        if balanceOf[this.address] + _536 < balanceOf[this.address]:
                            revert with 0, 'SafeMath: addition overflow'
                        balanceOf[address(this.address)] = balanceOf[this.address] + _536
                        emit Transfer(_536, msg.sender, this.address);
                        if arg1 >= 3:
                            revert with 0, 50
                        mem[mem[64]] = 0x12b8603f00000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = msg.sender
                        mem[mem[64] + 36] = 64
                        mem[mem[64] + 68] = mem[96]
                        mem[mem[64] + 100 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                        if ceil32(mem[96]) > mem[96]:
                            mem[mem[64] + mem[96] + 100] = 0
                        require ext_code.size(sub_20eea8b5[arg1])
                        call sub_20eea8b5[arg1].createNode(address arg1, string arg2) with:
                             gas gas_remaining wei
                            args msg.sender, Array(len=mem[96], data=mem[mem[64] + 100 len ceil32(mem[96])])
                    else:
                        mem[0] = msg.sender
                        mem[32] = 26
                        if stor26[address(msg.sender)]:
                            if not msg.sender:
                                revert with 0, 'ERC20: transfer from the zero address'
                            if not this.address:
                                revert with 0, 'ERC20: transfer to the zero address'
                            _653 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_653] = 38
                            mem[_653 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                            if _536 > balanceOf[address(msg.sender)]:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 38
                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_653 + 70 len 26]
                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                            if balanceOf[address(msg.sender)] < _536:
                                revert with 0, 17
                            balanceOf[address(msg.sender)] -= _536
                            if balanceOf[this.address] > !_536:
                                revert with 0, 17
                            if balanceOf[this.address] + _536 < balanceOf[this.address]:
                                revert with 0, 'SafeMath: addition overflow'
                            balanceOf[address(this.address)] = balanceOf[this.address] + _536
                            emit Transfer(_536, msg.sender, this.address);
                            if arg1 >= 3:
                                revert with 0, 50
                            mem[mem[64]] = 0x12b8603f00000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = msg.sender
                            mem[mem[64] + 36] = 64
                            mem[mem[64] + 68] = mem[96]
                            mem[mem[64] + 100 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                            if ceil32(mem[96]) > mem[96]:
                                mem[mem[64] + mem[96] + 100] = 0
                            require ext_code.size(sub_20eea8b5[arg1])
                            call sub_20eea8b5[arg1].createNode(address arg1, string arg2) with:
                                 gas gas_remaining wei
                                args msg.sender, Array(len=mem[96], data=mem[mem[64] + 100 len ceil32(mem[96])])
                        else:
                            uint8(stor23.field_0) = 1
                            if balanceOf[this.address]:
                                if balanceOf[this.address] and rewardsFee > -1 / balanceOf[this.address]:
                                    revert with 0, 17
                                if not balanceOf[this.address]:
                                    revert with 0, 18
                                if balanceOf[this.address] * rewardsFee / balanceOf[this.address] != rewardsFee:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _748 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_748] = 26
                                mem[_748 + 32] = 'SafeMath: division by zero'
                                if not balanceOf[this.address] * rewardsFee / 100:
                                    _854 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_854] = 26
                                    mem[_854 + 32] = 'SafeMath: division by zero'
                                    _952 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    mem[_952 + 32 len 64] = call.data[calldata.size len 64]
                                    if 0 >= mem[_952]:
                                        revert with 0, 50
                                    mem[_952 + 32] = this.address
                                    require ext_code.size(uniswapV2RouterAddress)
                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                            gas gas_remaining wei
                                    mem[_952 + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = _952 + ceil32(return_data.size) + 96
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    if 1 >= mem[_952]:
                                        revert with 0, 50
                                    mem[_952 + 64] = ext_call.return_data[12 len 20]
                                    if not this.address:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not uniswapV2RouterAddress:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    mem[0] = uniswapV2RouterAddress
                                    mem[32] = sha3(address(this.address), 1)
                                    allowance[address(this.address)][stor9].field_0 = 0
                                    emit Approval(0, this.address, uniswapV2RouterAddress);
                                    mem[_952 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                    mem[_952 + ceil32(return_data.size) + 100] = 0
                                    mem[_952 + ceil32(return_data.size) + 132] = 0
                                    mem[_952 + ceil32(return_data.size) + 164] = 160
                                    mem[_952 + ceil32(return_data.size) + 260] = mem[_952]
                                    idx = 0
                                    s = _952 + ceil32(return_data.size) + 292
                                    t = _952 + 32
                                    while idx < mem[_952]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(uniswapV2RouterAddress)
                                    call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args 0, 0, 160, address(this.address), block.timestamp, mem[_952 + ceil32(return_data.size) + 260 len (32 * mem[_952]) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_952 + ceil32(return_data.size) + 96] = 30
                                    mem[_952 + ceil32(return_data.size) + 128] = 'SafeMath: subtraction overflow'
                                    if eth.balance(this.address) > eth.balance(this.address):
                                        var123001 = 32
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if eth.balance(this.address) < eth.balance(this.address):
                                        revert with 0, 17
                                    call distributionPoolAddress with:
                                         gas 2300 wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_952 + ceil32(return_data.size) + 160] = 30
                                    mem[_952 + ceil32(return_data.size) + 192] = 'SafeMath: subtraction overflow'
                                    if 0 > balanceOf[this.address] * rewardsFee / 100:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if balanceOf[this.address] * rewardsFee / 100 < 0:
                                        revert with 0, 17
                                    if not this.address:
                                        revert with 0, 'ERC20: transfer from the zero address'
                                    if not distributionPoolAddress:
                                        revert with 0, 'ERC20: transfer to the zero address'
                                    mem[_952 + ceil32(return_data.size) + 224] = 38
                                    mem[_952 + ceil32(return_data.size) + 256 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                    if balanceOf[this.address] * rewardsFee / 100 > balanceOf[address(this.address)]:
                                        revert with 0, 
                                                    32,
                                                    38,
                                                    0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_952 + ceil32(return_data.size) + 294 len 26] >> 48,
                                                    0
                                    if balanceOf[address(this.address)] < balanceOf[this.address] * rewardsFee / 100:
                                        revert with 0, 17
                                    balanceOf[address(this.address)] -= balanceOf[this.address] * rewardsFee / 100
                                    if balanceOf[stor12] > !(balanceOf[this.address] * rewardsFee / 100):
                                        revert with 0, 17
                                    if balanceOf[stor12] + (balanceOf[this.address] * rewardsFee / 100) < balanceOf[stor12]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[stor12] += balanceOf[this.address] * rewardsFee / 100
                                    emit Transfer((balanceOf[this.address] * rewardsFee / 100), this.address, distributionPoolAddress);
                                    if not balanceOf[this.address]:
                                        mem[_952 + ceil32(return_data.size) + 320] = 26
                                        mem[_952 + ceil32(return_data.size) + 352] = 'SafeMath: division by zero'
                                        mem[_952 + ceil32(return_data.size) + 384] = 26
                                        mem[_952 + ceil32(return_data.size) + 416] = 'SafeMath: division by zero'
                                        mem[_952 + ceil32(return_data.size) + 448] = 30
                                        mem[_952 + ceil32(return_data.size) + 480] = 'SafeMath: subtraction overflow'
                                        mem[_952 + ceil32(return_data.size) + 512] = 2
                                        mem[_952 + ceil32(return_data.size) + 544] = this.address
                                        require ext_code.size(uniswapV2RouterAddress)
                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                gas gas_remaining wei
                                        mem[_952 + ceil32(return_data.size) + 608] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[64] = _952 + (2 * ceil32(return_data.size)) + 608
                                        require return_data.size >= 32
                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                        mem[_952 + ceil32(return_data.size) + 576] = ext_call.return_data[12 len 20]
                                        if not this.address:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not uniswapV2RouterAddress:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        mem[0] = uniswapV2RouterAddress
                                        mem[32] = sha3(address(this.address), 1)
                                        allowance[address(this.address)][stor9].field_0 = 0
                                        emit Approval(0, this.address, uniswapV2RouterAddress);
                                        mem[_952 + (2 * ceil32(return_data.size)) + 608] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                        mem[_952 + (2 * ceil32(return_data.size)) + 612] = 0
                                        mem[_952 + (2 * ceil32(return_data.size)) + 644] = 0
                                        mem[_952 + (2 * ceil32(return_data.size)) + 676] = 160
                                        mem[_952 + (2 * ceil32(return_data.size)) + 772] = 2
                                        idx = 0
                                        s = _952 + (2 * ceil32(return_data.size)) + 804
                                        t = _952 + ceil32(return_data.size) + 544
                                        while idx < mem[_952 + ceil32(return_data.size) + 512]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_952 + (2 * ceil32(return_data.size)) + 708] = this.address
                                        mem[_952 + (2 * ceil32(return_data.size)) + 740] = block.timestamp
                                        require ext_code.size(uniswapV2RouterAddress)
                                        call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args 0, 0, 160, address(this.address), block.timestamp, mem[_952 + (2 * ceil32(return_data.size)) + 772 len (32 * mem[_952 + ceil32(return_data.size) + 512]) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[_952 + (2 * ceil32(return_data.size)) + 608] = 30
                                        mem[_952 + (2 * ceil32(return_data.size)) + 640] = 'SafeMath: subtraction overflow'
                                        if eth.balance(this.address) > eth.balance(this.address):
                                            mem[_952 + (2 * ceil32(return_data.size)) + 672] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_952 + (2 * ceil32(return_data.size)) + 676] = 32
                                            mem[_952 + (2 * ceil32(return_data.size)) + 708] = 30
                                            mem[_952 + (2 * ceil32(return_data.size)) + 740] = 'SafeMath: subtraction overflow'
                                            var211001 = 32
                                            mem[_952 + (2 * ceil32(return_data.size)) + 770] = 0
                                            revert with memory
                                              from _952 + (2 * ceil32(return_data.size)) + 672
                                               len ceil32(return_data.size) + 100
                                        if eth.balance(this.address) < eth.balance(this.address):
                                            revert with 0, 17
                                        if not this.address:
                                            mem[_952 + (2 * ceil32(return_data.size)) + 672] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_952 + (2 * ceil32(return_data.size)) + 676] = 32
                                            mem[_952 + (2 * ceil32(return_data.size)) + 708] = 36
                                            mem[_952 + (2 * ceil32(return_data.size)) + 740] = 'ERC20: approve from the zero add'
                                            mem[_952 + (2 * ceil32(return_data.size)) + 772] = 0x7265737300000000000000000000000000000000000000000000000000000000
                                            revert with memory
                                              from _952 + (2 * ceil32(return_data.size)) + 672
                                               len ceil32(return_data.size) + 132
                                        if not uniswapV2RouterAddress:
                                            mem[_952 + (2 * ceil32(return_data.size)) + 672] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_952 + (2 * ceil32(return_data.size)) + 676] = 32
                                            mem[_952 + (2 * ceil32(return_data.size)) + 708] = 34
                                            mem[_952 + (2 * ceil32(return_data.size)) + 740] = 'ERC20: approve to the zero addre'
                                            mem[_952 + (2 * ceil32(return_data.size)) + 772] = 0x7373000000000000000000000000000000000000000000000000000000000000
                                            revert with memory
                                              from _952 + (2 * ceil32(return_data.size)) + 672
                                               len ceil32(return_data.size) + 132
                                        allowance[address(this.address)][stor9].field_0 = 0
                                        emit Approval(0, this.address, uniswapV2RouterAddress);
                                        mem[_952 + (2 * ceil32(return_data.size)) + 676] = this.address
                                        mem[_952 + (2 * ceil32(return_data.size)) + 708] = 0
                                        mem[_952 + (2 * ceil32(return_data.size)) + 740] = 0
                                        mem[_952 + (2 * ceil32(return_data.size)) + 772] = 0
                                        mem[_952 + (2 * ceil32(return_data.size)) + 804] = 0
                                        mem[_952 + (2 * ceil32(return_data.size)) + 836] = block.timestamp
                                        require ext_code.size(uniswapV2RouterAddress)
                                        call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                             gas gas_remaining wei
                                            args mem[_952 + (2 * ceil32(return_data.size)) + 676 len ceil32(return_data.size) + 192]
                                        mem[_952 + (2 * ceil32(return_data.size)) + 672 len 96] = ext_call.return_data[0 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 96
                                        mem[_952 + (4 * ceil32(return_data.size)) + 672] = 0
                                        mem[_952 + (4 * ceil32(return_data.size)) + 704] = 0
                                        mem[_952 + (4 * ceil32(return_data.size)) + 736] = 0
                                        emit SwapAndLiquify(uint256 arg1, uint256 arg2, uint256 arg3):
                                                            mem[_952 + (4 * ceil32(return_data.size)) + 672 len (5 * ceil32(return_data.size)) + 96],
                                        mem[_952 + (4 * ceil32(return_data.size)) + 672] = 2
                                        mem[_952 + (4 * ceil32(return_data.size)) + 704] = this.address
                                        require ext_code.size(uniswapV2RouterAddress)
                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                gas gas_remaining wei
                                        mem[_952 + (4 * ceil32(return_data.size)) + 768] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[64] = _952 + (6 * ceil32(return_data.size)) + 768
                                        require return_data.size >= 32
                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                        mem[_952 + (4 * ceil32(return_data.size)) + 736] = ext_call.return_data[12 len 20]
                                        if not this.address:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not uniswapV2RouterAddress:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        mem[0] = uniswapV2RouterAddress
                                        mem[32] = sha3(address(this.address), 1)
                                        allowance[address(this.address)][stor9].field_0 = balanceOf[this.address]
                                        emit Approval(balanceOf[this.address], this.address, uniswapV2RouterAddress);
                                        mem[_952 + (6 * ceil32(return_data.size)) + 768] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                        mem[_952 + (6 * ceil32(return_data.size)) + 772] = balanceOf[this.address]
                                        mem[_952 + (6 * ceil32(return_data.size)) + 804] = 0
                                        mem[_952 + (6 * ceil32(return_data.size)) + 836] = 160
                                        mem[_952 + (6 * ceil32(return_data.size)) + 932] = 2
                                        idx = 0
                                        s = _952 + (6 * ceil32(return_data.size)) + 964
                                        t = _952 + (4 * ceil32(return_data.size)) + 704
                                        while idx < mem[_952 + (4 * ceil32(return_data.size)) + 672]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_952 + (6 * ceil32(return_data.size)) + 900] = block.timestamp
                                        require ext_code.size(uniswapV2RouterAddress)
                                        call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args balanceOf[this.address], 0, 160, address(this.address), block.timestamp, mem[_952 + (6 * ceil32(return_data.size)) + 932 len (32 * mem[_952 + (4 * ceil32(return_data.size)) + 672]) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[_952 + (6 * ceil32(return_data.size)) + 768] = 30
                                        mem[_952 + (6 * ceil32(return_data.size)) + 800] = 'SafeMath: subtraction overflow'
                                        if eth.balance(this.address) > eth.balance(this.address):
                                            var257001 = 32
                                            mem[_952 + (6 * ceil32(return_data.size)) + 930] = 0
                                            revert with 0, 
                                                        'SafeMath: subtraction overflow',
                                                        mem[_952 + (6 * ceil32(return_data.size)) + 930 len (9 * ceil32(return_data.size)) + 2]
                                        if eth.balance(this.address) < eth.balance(this.address):
                                            revert with 0, 17
                                        call marketingWalletAddress with:
                                             gas 2300 wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        uint8(stor23.field_0) = 0
                                        if not msg.sender:
                                            revert with 0, 
                                                        'ERC20: transfer from the zero address',
                                                        mem[_952 + (6 * ceil32(return_data.size)) + 964 len 9 * ceil32(return_data.size)]
                                        if not this.address:
                                            revert with 0, 
                                                        'ERC20: transfer to the zero address',
                                                        mem[_952 + (6 * ceil32(return_data.size)) + 964 len 9 * ceil32(return_data.size)]
                                        mem[_952 + (6 * ceil32(return_data.size)) + 832] = 38
                                        mem[_952 + (6 * ceil32(return_data.size)) + 864 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                        if _536 > balanceOf[address(msg.sender)]:
                                            mem[_952 + (6 * ceil32(return_data.size)) + 1034] = 0
                                            revert with 0, 
                                                        32,
                                                        38,
                                                        0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, Mask(208, 32, block.timestamp) >> 32 >> 48,
                                                        mem[_952 + (6 * ceil32(return_data.size)) + 1034 len (9 * ceil32(return_data.size)) + 26]
                                        if balanceOf[address(msg.sender)] < _536:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] -= _536
                                        if balanceOf[this.address] > !_536:
                                            revert with 0, 17
                                        if balanceOf[this.address] + _536 < balanceOf[this.address]:
                                            revert with 0, 'SafeMath: addition overflow', mem[_952 + (6 * ceil32(return_data.size)) + 1028 len 9 * ceil32(return_data.size)]
                                        balanceOf[address(this.address)] = balanceOf[this.address] + _536
                                        emit Transfer(_536, msg.sender, this.address);
                                        if arg1 >= 3:
                                            revert with 0, 50
                                        mem[_952 + (6 * ceil32(return_data.size)) + 928] = 0x12b8603f00000000000000000000000000000000000000000000000000000000
                                        mem[_952 + (6 * ceil32(return_data.size)) + 932] = msg.sender
                                        mem[_952 + (6 * ceil32(return_data.size)) + 964] = 64
                                        mem[_952 + (6 * ceil32(return_data.size)) + 996] = mem[96]
                                        mem[_952 + (6 * ceil32(return_data.size)) + 1028 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                                        if ceil32(mem[96]) > mem[96]:
                                            mem[_952 + (6 * ceil32(return_data.size)) + mem[96] + 1028] = 0
                                        require ext_code.size(sub_20eea8b5[arg1])
                                        call sub_20eea8b5[arg1].createNode(address arg1, string arg2) with:
                                             gas gas_remaining wei
                                            args msg.sender, Array(len=mem[96], data=mem[_952 + (6 * ceil32(return_data.size)) + 1028 len (9 * ceil32(return_data.size)) + ceil32(mem[96])])
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if stor27[address(msg.sender)] > -2:
                                            revert with 0, 17
                                        if stor27[address(msg.sender)] + 1 < stor27[address(msg.sender)]:
                                            revert with 0, 'SafeMath: addition overflow', mem[_952 + (6 * ceil32(return_data.size)) + 1028 len 9 * ceil32(return_data.size)]
                                    else:
                                        if balanceOf[this.address] and liquidityPoolFee > -1 / balanceOf[this.address]:
                                            revert with 0, 17
                                        if not balanceOf[this.address]:
                                            revert with 0, 18
                                        if balanceOf[this.address] * liquidityPoolFee / balanceOf[this.address] != liquidityPoolFee:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        mem[_952 + ceil32(return_data.size) + 320] = 26
                                        mem[_952 + ceil32(return_data.size) + 352] = 'SafeMath: division by zero'
                                        mem[_952 + ceil32(return_data.size) + 384] = 26
                                        mem[_952 + ceil32(return_data.size) + 416] = 'SafeMath: division by zero'
                                        mem[_952 + ceil32(return_data.size) + 448] = 30
                                        mem[_952 + ceil32(return_data.size) + 480] = 'SafeMath: subtraction overflow'
                                        if balanceOf[this.address] * liquidityPoolFee / 100 / 2 > balanceOf[this.address] * liquidityPoolFee / 100:
                                            var185001 = 32
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if balanceOf[this.address] * liquidityPoolFee / 100 < balanceOf[this.address] * liquidityPoolFee / 100 / 2:
                                            revert with 0, 17
                                        mem[_952 + ceil32(return_data.size) + 512] = 2
                                        mem[_952 + ceil32(return_data.size) + 544] = this.address
                                        require ext_code.size(uniswapV2RouterAddress)
                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                gas gas_remaining wei
                                        mem[_952 + ceil32(return_data.size) + 608] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[64] = _952 + (2 * ceil32(return_data.size)) + 608
                                        require return_data.size >= 32
                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                        mem[_952 + ceil32(return_data.size) + 576] = ext_call.return_data[12 len 20]
                                        if not this.address:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not uniswapV2RouterAddress:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        mem[0] = uniswapV2RouterAddress
                                        mem[32] = sha3(address(this.address), 1)
                                        allowance[address(this.address)][stor9].field_0 = balanceOf[this.address] * liquidityPoolFee / 100 / 2
                                        allowance[address(this.address)][stor9].field_255 = 0
                                        emit Approval((balanceOf[this.address] * liquidityPoolFee / 100 / 2), this.address, uniswapV2RouterAddress);
                                        mem[_952 + (2 * ceil32(return_data.size)) + 608] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                        mem[_952 + (2 * ceil32(return_data.size)) + 612] = balanceOf[this.address] * liquidityPoolFee / 100 / 2
                                        mem[_952 + (2 * ceil32(return_data.size)) + 644] = 0
                                        mem[_952 + (2 * ceil32(return_data.size)) + 676] = 160
                                        mem[_952 + (2 * ceil32(return_data.size)) + 772] = 2
                                        idx = 0
                                        s = _952 + (2 * ceil32(return_data.size)) + 804
                                        t = _952 + ceil32(return_data.size) + 544
                                        while idx < mem[_952 + ceil32(return_data.size) + 512]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_952 + (2 * ceil32(return_data.size)) + 708] = this.address
                                        mem[_952 + (2 * ceil32(return_data.size)) + 740] = block.timestamp
                                        require ext_code.size(uniswapV2RouterAddress)
                                        call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _952 + (2 * ceil32(return_data.size)) + (32 * mem[_952 + ceil32(return_data.size) + 512]) + -mem[64] + 800]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _4799 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_4799] = 30
                                        mem[_4799 + 32] = 'SafeMath: subtraction overflow'
                                        if eth.balance(this.address) > eth.balance(this.address):
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if eth.balance(this.address) < eth.balance(this.address):
                                            revert with 0, 17
                                        if not this.address:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not uniswapV2RouterAddress:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        mem[0] = uniswapV2RouterAddress
                                        mem[32] = sha3(address(this.address), 1)
                                        allowance[address(this.address)][stor9].field_0 = (balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2)
                                        emit Approval(((balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2)), this.address, uniswapV2RouterAddress);
                                        mem[mem[64] + 68] = 0
                                        mem[mem[64] + 100] = 0
                                        mem[mem[64] + 132] = 0
                                        mem[mem[64] + 164] = block.timestamp
                                        require ext_code.size(uniswapV2RouterAddress)
                                        call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                             gas gas_remaining wei
                                            args this.address, (balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2), 0, 0, 0, block.timestamp
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 96
                                        mem[mem[64] + 32] = 0
                                        mem[mem[64] + 64] = (balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2)
                                        emit SwapAndLiquify(Mask(255, 1, balanceOf[this.address] * liquidityPoolFee / 100), 0, (balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2));
                                        mem[0] = this.address
                                        mem[32] = 0
                                        _5215 = mem[64]
                                        mem[mem[64]] = 2
                                        mem[64] = mem[64] + 96
                                        mem[_5215 + 32 len 64] = call.data[calldata.size len 64]
                                        if 0 >= mem[_5215]:
                                            revert with 0, 50
                                        mem[_5215 + 32] = this.address
                                        require ext_code.size(uniswapV2RouterAddress)
                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                gas gas_remaining wei
                                        mem[_5215 + 96] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[64] = _5215 + ceil32(return_data.size) + 96
                                        require return_data.size >= 32
                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                        if 1 >= mem[_5215]:
                                            revert with 0, 50
                                        mem[_5215 + 64] = ext_call.return_data[12 len 20]
                                        if not this.address:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not uniswapV2RouterAddress:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        mem[0] = uniswapV2RouterAddress
                                        mem[32] = sha3(address(this.address), 1)
                                        allowance[address(this.address)][stor9].field_0 = balanceOf[this.address]
                                        emit Approval(balanceOf[this.address], this.address, uniswapV2RouterAddress);
                                        mem[_5215 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                        mem[_5215 + ceil32(return_data.size) + 100] = balanceOf[this.address]
                                        mem[_5215 + ceil32(return_data.size) + 132] = 0
                                        mem[_5215 + ceil32(return_data.size) + 164] = 160
                                        mem[_5215 + ceil32(return_data.size) + 260] = mem[_5215]
                                        idx = 0
                                        s = _5215 + ceil32(return_data.size) + 292
                                        t = _5215 + 32
                                        while idx < mem[_5215]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_5215 + ceil32(return_data.size) + 196] = this.address
                                        mem[_5215 + ceil32(return_data.size) + 228] = block.timestamp
                                        require ext_code.size(uniswapV2RouterAddress)
                                        call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _5215 + ceil32(return_data.size) + (32 * mem[_5215]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _6329 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6329] = 30
                                        mem[_6329 + 32] = 'SafeMath: subtraction overflow'
                                        if eth.balance(this.address) > eth.balance(this.address):
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if eth.balance(this.address) < eth.balance(this.address):
                                            revert with 0, 17
                                        call marketingWalletAddress with:
                                             gas 2300 wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        uint8(stor23.field_0) = 0
                                        if not msg.sender:
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not this.address:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        _6477 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_6477] = 38
                                        mem[_6477 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                        if _536 > balanceOf[address(msg.sender)]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 38
                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_6477 + 70 len 26]
                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                        if balanceOf[address(msg.sender)] < _536:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] -= _536
                                        if balanceOf[this.address] > !_536:
                                            revert with 0, 17
                                        if balanceOf[this.address] + _536 < balanceOf[this.address]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(this.address)] = balanceOf[this.address] + _536
                                        emit Transfer(_536, msg.sender, this.address);
                                        if arg1 >= 3:
                                            revert with 0, 50
                                        mem[mem[64]] = 0x12b8603f00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 64
                                        mem[mem[64] + 68] = mem[96]
                                        mem[mem[64] + 100 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                                        if ceil32(mem[96]) > mem[96]:
                                            mem[mem[64] + mem[96] + 100] = 0
                                        require ext_code.size(sub_20eea8b5[arg1])
                                        call sub_20eea8b5[arg1].createNode(address arg1, string arg2) with:
                                             gas gas_remaining wei
                                            args msg.sender, Array(len=mem[96], data=mem[mem[64] + 100 len ceil32(mem[96])])
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if stor27[address(msg.sender)] > -2:
                                            revert with 0, 17
                                        if stor27[address(msg.sender)] + 1 < stor27[address(msg.sender)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                    ('ge', ('add', 1, ('stor', ('map', ('mask_shl', 160, 0, 0, 'msg.sender'), ('name', 'stor27', 27)))), ('stor', ('map', ('mask_shl', 160, 0, 0, 'msg.sender'), ('name', 'stor27', 27))))
                                    stor27[address(msg.sender)]++
                                if balanceOf[this.address] * rewardsFee / 100 and stor22 > -1 / balanceOf[this.address] * rewardsFee / 100:
                                    revert with 0, 17
                                if not balanceOf[this.address] * rewardsFee / 100:
                                    revert with 0, 18
                                if balanceOf[this.address] * rewardsFee / 100 * stor22 / balanceOf[this.address] * rewardsFee / 100 != stor22:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _909 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_909] = 26
                                mem[_909 + 32] = 'SafeMath: division by zero'
                                _998 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                mem[_998 + 32 len 64] = call.data[calldata.size len 64]
                                if 0 >= mem[_998]:
                                    revert with 0, 50
                                mem[_998 + 32] = this.address
                                require ext_code.size(uniswapV2RouterAddress)
                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                        gas gas_remaining wei
                                mem[_998 + 96] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = _998 + ceil32(return_data.size) + 96
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                if 1 >= mem[_998]:
                                    revert with 0, 50
                                mem[_998 + 64] = ext_call.return_data[12 len 20]
                                if not this.address:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not uniswapV2RouterAddress:
                                    revert with 0, 'ERC20: approve to the zero address'
                                mem[0] = uniswapV2RouterAddress
                                mem[32] = sha3(address(this.address), 1)
                                allowance[address(this.address)][stor9].field_0 = balanceOf[this.address] * rewardsFee / 100 * stor22 / 100
                                emit Approval((balanceOf[this.address] * rewardsFee / 100 * stor22 / 100), this.address, uniswapV2RouterAddress);
                                mem[_998 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                mem[_998 + ceil32(return_data.size) + 100] = balanceOf[this.address] * rewardsFee / 100 * stor22 / 100
                                mem[_998 + ceil32(return_data.size) + 132] = 0
                                mem[_998 + ceil32(return_data.size) + 164] = 160
                                mem[_998 + ceil32(return_data.size) + 260] = mem[_998]
                                idx = 0
                                s = _998 + ceil32(return_data.size) + 292
                                t = _998 + 32
                                while idx < mem[_998]:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[_998 + ceil32(return_data.size) + 196] = this.address
                                mem[_998 + ceil32(return_data.size) + 228] = block.timestamp
                                require ext_code.size(uniswapV2RouterAddress)
                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len _998 + ceil32(return_data.size) + (32 * mem[_998]) + -mem[64] + 288]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _2384 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2384] = 30
                                mem[_2384 + 32] = 'SafeMath: subtraction overflow'
                                if eth.balance(this.address) > eth.balance(this.address):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if eth.balance(this.address) < eth.balance(this.address):
                                    revert with 0, 17
                                call distributionPoolAddress with:
                                     gas 2300 wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _2553 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2553] = 30
                                mem[_2553 + 32] = 'SafeMath: subtraction overflow'
                                if balanceOf[this.address] * rewardsFee / 100 * stor22 / 100 > balanceOf[this.address] * rewardsFee / 100:
                                    var139001 = 32
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if balanceOf[this.address] * rewardsFee / 100 < balanceOf[this.address] * rewardsFee / 100 * stor22 / 100:
                                    revert with 0, 17
                                if not this.address:
                                    revert with 0, 'ERC20: transfer from the zero address'
                                if not distributionPoolAddress:
                                    revert with 0, 'ERC20: transfer to the zero address'
                                _2604 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_2604] = 38
                                mem[_2604 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                if (balanceOf[this.address] * rewardsFee / 100) - (balanceOf[this.address] * rewardsFee / 100 * stor22 / 100) > balanceOf[address(this.address)]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 38
                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_2604 + 70 len 26]
                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                if balanceOf[address(this.address)] < (balanceOf[this.address] * rewardsFee / 100) - (balanceOf[this.address] * rewardsFee / 100 * stor22 / 100):
                                    revert with 0, 17
                                balanceOf[address(this.address)] = balanceOf[address(this.address)] - (balanceOf[this.address] * rewardsFee / 100) + (balanceOf[this.address] * rewardsFee / 100 * stor22 / 100)
                                if balanceOf[stor12] > !((balanceOf[this.address] * rewardsFee / 100) - (balanceOf[this.address] * rewardsFee / 100 * stor22 / 100)):
                                    revert with 0, 17
                                if balanceOf[stor12] + (balanceOf[this.address] * rewardsFee / 100) - (balanceOf[this.address] * rewardsFee / 100 * stor22 / 100) < balanceOf[stor12]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = distributionPoolAddress
                                mem[32] = 0
                                balanceOf[stor12] = balanceOf[stor12] + (balanceOf[this.address] * rewardsFee / 100) - (balanceOf[this.address] * rewardsFee / 100 * stor22 / 100)
                                emit Transfer(((balanceOf[this.address] * rewardsFee / 100) - (balanceOf[this.address] * rewardsFee / 100 * stor22 / 100)), this.address, distributionPoolAddress);
                                if not balanceOf[this.address]:
                                    _2763 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_2763] = 26
                                    mem[_2763 + 32] = 'SafeMath: division by zero'
                                    _2799 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_2799] = 26
                                    mem[_2799 + 32] = 'SafeMath: division by zero'
                                    _2817 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_2817] = 30
                                    mem[_2817 + 32] = 'SafeMath: subtraction overflow'
                                    _2836 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    mem[_2836 + 32 len 64] = call.data[calldata.size len 64]
                                    if 0 >= mem[_2836]:
                                        revert with 0, 50
                                    mem[_2836 + 32] = this.address
                                    require ext_code.size(uniswapV2RouterAddress)
                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                            gas gas_remaining wei
                                    mem[_2836 + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = _2836 + ceil32(return_data.size) + 96
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    if 1 >= mem[_2836]:
                                        revert with 0, 50
                                    mem[_2836 + 64] = ext_call.return_data[12 len 20]
                                    if not this.address:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not uniswapV2RouterAddress:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    mem[0] = uniswapV2RouterAddress
                                    mem[32] = sha3(address(this.address), 1)
                                    allowance[address(this.address)][stor9].field_0 = 0
                                    emit Approval(0, this.address, uniswapV2RouterAddress);
                                    mem[_2836 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                    mem[_2836 + ceil32(return_data.size) + 100] = 0
                                    mem[_2836 + ceil32(return_data.size) + 132] = 0
                                    mem[_2836 + ceil32(return_data.size) + 164] = 160
                                    mem[_2836 + ceil32(return_data.size) + 260] = mem[_2836]
                                    idx = 0
                                    s = _2836 + ceil32(return_data.size) + 292
                                    t = _2836 + 32
                                    while idx < mem[_2836]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(uniswapV2RouterAddress)
                                    call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args 0, 0, 160, address(this.address), block.timestamp, mem[_2836 + ceil32(return_data.size) + 260 len (32 * mem[_2836]) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_2836 + ceil32(return_data.size) + 96] = 30
                                    mem[_2836 + ceil32(return_data.size) + 128] = 'SafeMath: subtraction overflow'
                                    if eth.balance(this.address) > eth.balance(this.address):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if eth.balance(this.address) < eth.balance(this.address):
                                        revert with 0, 17
                                    if not this.address:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not uniswapV2RouterAddress:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    allowance[address(this.address)][stor9].field_0 = 0
                                    emit Approval(0, this.address, uniswapV2RouterAddress);
                                    mem[_2836 + ceil32(return_data.size) + 228] = 0
                                    mem[_2836 + ceil32(return_data.size) + 260] = 0
                                    mem[_2836 + ceil32(return_data.size) + 292] = 0
                                    mem[_2836 + ceil32(return_data.size) + 324] = block.timestamp
                                    require ext_code.size(uniswapV2RouterAddress)
                                    call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                         gas gas_remaining wei
                                        args this.address, 0, 0, 0, 0, block.timestamp
                                    mem[_2836 + ceil32(return_data.size) + 160 len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 96
                                    emit SwapAndLiquify(uint256 arg1, uint256 arg2, uint256 arg3):
                                                        0,
                                    mem[_2836 + (2 * ceil32(return_data.size)) + 160] = 2
                                    mem[_2836 + (2 * ceil32(return_data.size)) + 192] = this.address
                                    require ext_code.size(uniswapV2RouterAddress)
                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                            gas gas_remaining wei
                                    mem[_2836 + (2 * ceil32(return_data.size)) + 256] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = _2836 + (4 * ceil32(return_data.size)) + 256
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    mem[_2836 + (2 * ceil32(return_data.size)) + 224] = ext_call.return_data[12 len 20]
                                    if not this.address:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not uniswapV2RouterAddress:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    mem[0] = uniswapV2RouterAddress
                                    mem[32] = sha3(address(this.address), 1)
                                    allowance[address(this.address)][stor9].field_0 = balanceOf[this.address]
                                    emit Approval(balanceOf[this.address], this.address, uniswapV2RouterAddress);
                                    mem[_2836 + (4 * ceil32(return_data.size)) + 256] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                    mem[_2836 + (4 * ceil32(return_data.size)) + 260] = balanceOf[this.address]
                                    mem[_2836 + (4 * ceil32(return_data.size)) + 292] = 0
                                    mem[_2836 + (4 * ceil32(return_data.size)) + 324] = 160
                                    mem[_2836 + (4 * ceil32(return_data.size)) + 420] = 2
                                    idx = 0
                                    s = _2836 + (4 * ceil32(return_data.size)) + 452
                                    t = _2836 + (2 * ceil32(return_data.size)) + 192
                                    while idx < mem[_2836 + (2 * ceil32(return_data.size)) + 160]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_2836 + (4 * ceil32(return_data.size)) + 356] = this.address
                                    mem[_2836 + (4 * ceil32(return_data.size)) + 388] = block.timestamp
                                    require ext_code.size(uniswapV2RouterAddress)
                                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _2836 + (4 * ceil32(return_data.size)) + (32 * mem[_2836 + (2 * ceil32(return_data.size)) + 160]) + -mem[64] + 448]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _6328 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6328] = 30
                                    mem[_6328 + 32] = 'SafeMath: subtraction overflow'
                                    if eth.balance(this.address) > eth.balance(this.address):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if eth.balance(this.address) < eth.balance(this.address):
                                        revert with 0, 17
                                    call marketingWalletAddress with:
                                         gas 2300 wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    uint8(stor23.field_0) = 0
                                    if not msg.sender:
                                        revert with 0, 'ERC20: transfer from the zero address'
                                    if not this.address:
                                        revert with 0, 'ERC20: transfer to the zero address'
                                    _6474 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_6474] = 38
                                    mem[_6474 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                    if _536 > balanceOf[address(msg.sender)]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 38
                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_6474 + 70 len 26]
                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                    if balanceOf[address(msg.sender)] < _536:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)] -= _536
                                    if balanceOf[this.address] > !_536:
                                        revert with 0, 17
                                    if balanceOf[this.address] + _536 < balanceOf[this.address]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(this.address)] = balanceOf[this.address] + _536
                                    emit Transfer(_536, msg.sender, this.address);
                                    if arg1 >= 3:
                                        revert with 0, 50
                                    mem[mem[64]] = 0x12b8603f00000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = 64
                                    mem[mem[64] + 68] = mem[96]
                                    mem[mem[64] + 100 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                                    if ceil32(mem[96]) > mem[96]:
                                        mem[mem[64] + mem[96] + 100] = 0
                                    require ext_code.size(sub_20eea8b5[arg1])
                                    call sub_20eea8b5[arg1].createNode(address arg1, string arg2) with:
                                         gas gas_remaining wei
                                        args msg.sender, Array(len=mem[96], data=mem[mem[64] + 100 len ceil32(mem[96])])
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if stor27[address(msg.sender)] > -2:
                                        revert with 0, 17
                                    if stor27[address(msg.sender)] + 1 < stor27[address(msg.sender)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor27[address(msg.sender)]++
                                if balanceOf[this.address] and liquidityPoolFee > -1 / balanceOf[this.address]:
                                    revert with 0, 17
                                if not balanceOf[this.address]:
                                    revert with 0, 18
                                if balanceOf[this.address] * liquidityPoolFee / balanceOf[this.address] != liquidityPoolFee:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _2790 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2790] = 26
                                mem[_2790 + 32] = 'SafeMath: division by zero'
                                _2808 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2808] = 26
                                mem[_2808 + 32] = 'SafeMath: division by zero'
                                _2826 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2826] = 30
                                mem[_2826 + 32] = 'SafeMath: subtraction overflow'
                                if balanceOf[this.address] * liquidityPoolFee / 100 / 2 > balanceOf[this.address] * liquidityPoolFee / 100:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if balanceOf[this.address] * liquidityPoolFee / 100 < balanceOf[this.address] * liquidityPoolFee / 100 / 2:
                                    revert with 0, 17
                                _2916 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                mem[_2916 + 32 len 64] = call.data[calldata.size len 64]
                                if 0 >= mem[_2916]:
                                    revert with 0, 50
                                mem[_2916 + 32] = this.address
                                require ext_code.size(uniswapV2RouterAddress)
                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                        gas gas_remaining wei
                                mem[_2916 + 96] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = _2916 + ceil32(return_data.size) + 96
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                if 1 >= mem[_2916]:
                                    revert with 0, 50
                                mem[_2916 + 64] = ext_call.return_data[12 len 20]
                                if not this.address:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not uniswapV2RouterAddress:
                                    revert with 0, 'ERC20: approve to the zero address'
                                mem[0] = uniswapV2RouterAddress
                                mem[32] = sha3(address(this.address), 1)
                                allowance[address(this.address)][stor9].field_0 = balanceOf[this.address] * liquidityPoolFee / 100 / 2
                                allowance[address(this.address)][stor9].field_255 = 0
                                emit Approval((balanceOf[this.address] * liquidityPoolFee / 100 / 2), this.address, uniswapV2RouterAddress);
                                mem[_2916 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                mem[_2916 + ceil32(return_data.size) + 100] = balanceOf[this.address] * liquidityPoolFee / 100 / 2
                                mem[_2916 + ceil32(return_data.size) + 132] = 0
                                mem[_2916 + ceil32(return_data.size) + 164] = 160
                                mem[_2916 + ceil32(return_data.size) + 260] = mem[_2916]
                                idx = 0
                                s = _2916 + ceil32(return_data.size) + 292
                                t = _2916 + 32
                                while idx < mem[_2916]:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(uniswapV2RouterAddress)
                                call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                     gas gas_remaining wei
                                    args Mask(255, 1, balanceOf[this.address] * liquidityPoolFee / 100), 0, 160, address(this.address), block.timestamp, mem[_2916 + ceil32(return_data.size) + 260 len (32 * mem[_2916]) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[_2916 + ceil32(return_data.size) + 96] = 30
                                mem[_2916 + ceil32(return_data.size) + 128] = 'SafeMath: subtraction overflow'
                                if eth.balance(this.address) > eth.balance(this.address):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if eth.balance(this.address) < eth.balance(this.address):
                                    revert with 0, 17
                                if not this.address:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not uniswapV2RouterAddress:
                                    revert with 0, 'ERC20: approve to the zero address'
                                allowance[address(this.address)][stor9].field_0 = (balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2)
                                emit Approval(((balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2)), this.address, uniswapV2RouterAddress);
                                mem[_2916 + ceil32(return_data.size) + 228] = 0
                                mem[_2916 + ceil32(return_data.size) + 260] = 0
                                mem[_2916 + ceil32(return_data.size) + 292] = 0
                                mem[_2916 + ceil32(return_data.size) + 324] = block.timestamp
                                require ext_code.size(uniswapV2RouterAddress)
                                call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                     gas gas_remaining wei
                                    args this.address, (balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2), 0, 0, 0, block.timestamp
                                mem[_2916 + ceil32(return_data.size) + 160 len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 96
                                emit SwapAndLiquify(Mask(255, 1, balanceOf[this.address] * liquidityPoolFee / 100), 0, (balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2));
                                mem[_2916 + (2 * ceil32(return_data.size)) + 160] = 2
                                mem[_2916 + (2 * ceil32(return_data.size)) + 192] = this.address
                                require ext_code.size(uniswapV2RouterAddress)
                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                        gas gas_remaining wei
                                mem[_2916 + (2 * ceil32(return_data.size)) + 256] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = _2916 + (4 * ceil32(return_data.size)) + 256
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                mem[_2916 + (2 * ceil32(return_data.size)) + 224] = ext_call.return_data[12 len 20]
                                if not this.address:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not uniswapV2RouterAddress:
                                    revert with 0, 'ERC20: approve to the zero address'
                                mem[0] = uniswapV2RouterAddress
                                mem[32] = sha3(address(this.address), 1)
                                allowance[address(this.address)][stor9].field_0 = balanceOf[this.address]
                                emit Approval(balanceOf[this.address], this.address, uniswapV2RouterAddress);
                                mem[_2916 + (4 * ceil32(return_data.size)) + 256] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                mem[_2916 + (4 * ceil32(return_data.size)) + 260] = balanceOf[this.address]
                                mem[_2916 + (4 * ceil32(return_data.size)) + 292] = 0
                                mem[_2916 + (4 * ceil32(return_data.size)) + 324] = 160
                                mem[_2916 + (4 * ceil32(return_data.size)) + 420] = 2
                                idx = 0
                                s = _2916 + (4 * ceil32(return_data.size)) + 452
                                t = _2916 + (2 * ceil32(return_data.size)) + 192
                                while idx < mem[_2916 + (2 * ceil32(return_data.size)) + 160]:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[_2916 + (4 * ceil32(return_data.size)) + 356] = this.address
                                mem[_2916 + (4 * ceil32(return_data.size)) + 388] = block.timestamp
                                require ext_code.size(uniswapV2RouterAddress)
                                call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                     gas gas_remaining wei
                                    args balanceOf[this.address], 0, 160, address(this.address), block.timestamp, mem[_2916 + (4 * ceil32(return_data.size)) + 420 len (32 * mem[_2916 + (2 * ceil32(return_data.size)) + 160]) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[_2916 + (4 * ceil32(return_data.size)) + 256] = 30
                                mem[_2916 + (4 * ceil32(return_data.size)) + 288] = 'SafeMath: subtraction overflow'
                                if eth.balance(this.address) > eth.balance(this.address):
                                    mem[_2916 + (4 * ceil32(return_data.size)) + 320] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[_2916 + (4 * ceil32(return_data.size)) + 324] = 32
                                    mem[_2916 + (4 * ceil32(return_data.size)) + 356] = 30
                                    mem[_2916 + (4 * ceil32(return_data.size)) + 388] = 'SafeMath: subtraction overflow'
                                    mem[_2916 + (4 * ceil32(return_data.size)) + 418] = 0
                                    revert with memory
                                      from _2916 + (4 * ceil32(return_data.size)) + 320
                                       len (5 * ceil32(return_data.size)) + 100
                                if eth.balance(this.address) < eth.balance(this.address):
                                    revert with 0, 17
                                call marketingWalletAddress with:
                                     gas 2300 wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                uint8(stor23.field_0) = 0
                                if not msg.sender:
                                    mem[_2916 + (4 * ceil32(return_data.size)) + 320] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[_2916 + (4 * ceil32(return_data.size)) + 324] = 32
                                    mem[_2916 + (4 * ceil32(return_data.size)) + 356] = 37
                                    mem[_2916 + (4 * ceil32(return_data.size)) + 388] = 'ERC20: transfer from the zero ad'
                                    mem[_2916 + (4 * ceil32(return_data.size)) + 420] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                    revert with memory
                                      from _2916 + (4 * ceil32(return_data.size)) + 320
                                       len (5 * ceil32(return_data.size)) + 132
                                if not this.address:
                                    mem[_2916 + (4 * ceil32(return_data.size)) + 320] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[_2916 + (4 * ceil32(return_data.size)) + 324] = 32
                                    mem[_2916 + (4 * ceil32(return_data.size)) + 356] = 35
                                    mem[_2916 + (4 * ceil32(return_data.size)) + 388] = 'ERC20: transfer to the zero addr'
                                    mem[_2916 + (4 * ceil32(return_data.size)) + 420] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                    revert with memory
                                      from _2916 + (4 * ceil32(return_data.size)) + 320
                                       len (5 * ceil32(return_data.size)) + 132
                                mem[_2916 + (4 * ceil32(return_data.size)) + 320] = 38
                                mem[_2916 + (4 * ceil32(return_data.size)) + 352 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                if _536 > balanceOf[address(msg.sender)]:
                                    mem[_2916 + (4 * ceil32(return_data.size)) + 416] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[_2916 + (4 * ceil32(return_data.size)) + 420] = 32
                                    mem[_2916 + (4 * ceil32(return_data.size)) + 452] = 38
                                    mem[_2916 + (4 * ceil32(return_data.size)) + 484 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, Mask(208, 32, block.timestamp) >> 32
                                    mem[_2916 + (4 * ceil32(return_data.size)) + 522] = 0
                                    revert with memory
                                      from _2916 + (4 * ceil32(return_data.size)) + 416
                                       len (5 * ceil32(return_data.size)) + 132
                                if balanceOf[address(msg.sender)] < _536:
                                    revert with 0, 17
                                balanceOf[address(msg.sender)] -= _536
                                if balanceOf[this.address] > !_536:
                                    revert with 0, 17
                                if balanceOf[this.address] + _536 >= balanceOf[this.address]:
                                    balanceOf[address(this.address)] = balanceOf[this.address] + _536
                                    emit Transfer(_536, msg.sender, this.address);
                                    if arg1 >= 3:
                                        revert with 0, 50
                                    mem[_2916 + (4 * ceil32(return_data.size)) + 416] = 0x12b8603f00000000000000000000000000000000000000000000000000000000
                                    mem[_2916 + (4 * ceil32(return_data.size)) + 420] = msg.sender
                                    mem[_2916 + (4 * ceil32(return_data.size)) + 452] = 64
                                    mem[_2916 + (4 * ceil32(return_data.size)) + 484] = mem[96]
                                    mem[_2916 + (4 * ceil32(return_data.size)) + 516 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                                    var295001 = ceil32(mem[96])
                                    if ceil32(mem[96]) > mem[96]:
                                        mem[_2916 + (4 * ceil32(return_data.size)) + mem[96] + 516] = 0
                                    require ext_code.size(sub_20eea8b5[arg1])
                                    call sub_20eea8b5[arg1].createNode(address arg1, string arg2) with:
                                         gas gas_remaining wei
                                        args mem[_2916 + (4 * ceil32(return_data.size)) + 420 len ceil32(mem[96]) + (5 * ceil32(return_data.size)) + 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if stor27[address(msg.sender)] > -2:
                                        revert with 0, 17
                                    if stor27[address(msg.sender)] + 1 >= stor27[address(msg.sender)]:
                                        stor27[address(msg.sender)]++
                                mem[_2916 + (4 * ceil32(return_data.size)) + 416] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[_2916 + (4 * ceil32(return_data.size)) + 420] = 32
                                mem[_2916 + (4 * ceil32(return_data.size)) + 452] = 27
                                mem[_2916 + (4 * ceil32(return_data.size)) + 484] = 'SafeMath: addition overflow'
                                revert with memory
                                  from _2916 + (4 * ceil32(return_data.size)) + 416
                                   len (5 * ceil32(return_data.size)) + 100
                            _682 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_682] = 26
                            mem[_682 + 32] = 'SafeMath: division by zero'
                            _818 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_818] = 26
                            mem[_818 + 32] = 'SafeMath: division by zero'
                            _881 = mem[64]
                            mem[mem[64]] = 2
                            mem[64] = mem[64] + 96
                            mem[_881 + 32 len 64] = call.data[calldata.size len 64]
                            if 0 >= mem[_881]:
                                revert with 0, 50
                            mem[_881 + 32] = this.address
                            require ext_code.size(uniswapV2RouterAddress)
                            staticcall uniswapV2RouterAddress.WAVAX() with:
                                    gas gas_remaining wei
                            mem[_881 + 96] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = _881 + ceil32(return_data.size) + 96
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                            if 1 >= mem[_881]:
                                revert with 0, 50
                            mem[_881 + 64] = ext_call.return_data[12 len 20]
                            if not this.address:
                                revert with 0, 'ERC20: approve from the zero address'
                            if not uniswapV2RouterAddress:
                                revert with 0, 'ERC20: approve to the zero address'
                            mem[0] = uniswapV2RouterAddress
                            mem[32] = sha3(address(this.address), 1)
                            allowance[address(this.address)][stor9].field_0 = 0
                            emit Approval(0, this.address, uniswapV2RouterAddress);
                            mem[_881 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                            mem[_881 + ceil32(return_data.size) + 100] = 0
                            mem[_881 + ceil32(return_data.size) + 132] = 0
                            mem[_881 + ceil32(return_data.size) + 164] = 160
                            mem[_881 + ceil32(return_data.size) + 260] = mem[_881]
                            idx = 0
                            s = _881 + ceil32(return_data.size) + 292
                            t = _881 + 32
                            while idx < mem[_881]:
                                mem[s] = mem[t + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[_881 + ceil32(return_data.size) + 196] = this.address
                            mem[_881 + ceil32(return_data.size) + 228] = block.timestamp
                            require ext_code.size(uniswapV2RouterAddress)
                            call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len _881 + ceil32(return_data.size) + (32 * mem[_881]) + -mem[64] + 288]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2386 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2386] = 30
                            mem[_2386 + 32] = 'SafeMath: subtraction overflow'
                            if eth.balance(this.address) > eth.balance(this.address):
                                var117001 = 32
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if eth.balance(this.address) < eth.balance(this.address):
                                revert with 0, 17
                            call distributionPoolAddress with:
                                 gas 2300 wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2557 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2557] = 30
                            mem[_2557 + 32] = 'SafeMath: subtraction overflow'
                            if not this.address:
                                revert with 0, 'ERC20: transfer from the zero address'
                            if not distributionPoolAddress:
                                revert with 0, 'ERC20: transfer to the zero address'
                            _2612 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_2612] = 38
                            mem[_2612 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                            if 0 > balanceOf[address(this.address)]:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 38
                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_2612 + 70 len 26]
                                var137001 = 64
                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                            if balanceOf[address(this.address)] < 0:
                                revert with 0, 17
                            if balanceOf[stor12] > -1:
                                revert with 0, 17
                            if balanceOf[stor12] < balanceOf[stor12]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = distributionPoolAddress
                            mem[32] = 0
                            balanceOf[stor12] = balanceOf[stor12]
                            emit Transfer(0, this.address, distributionPoolAddress);
                            if not balanceOf[this.address]:
                                _2765 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2765] = 26
                                mem[_2765 + 32] = 'SafeMath: division by zero'
                                _2801 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2801] = 26
                                mem[_2801 + 32] = 'SafeMath: division by zero'
                                _2819 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2819] = 30
                                mem[_2819 + 32] = 'SafeMath: subtraction overflow'
                                _2842 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                mem[_2842 + 32 len 64] = call.data[calldata.size len 64]
                                if 0 >= mem[_2842]:
                                    revert with 0, 50
                                mem[_2842 + 32] = this.address
                                require ext_code.size(uniswapV2RouterAddress)
                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                        gas gas_remaining wei
                                mem[_2842 + 96] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = _2842 + ceil32(return_data.size) + 96
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                if 1 >= mem[_2842]:
                                    revert with 0, 50
                                mem[_2842 + 64] = ext_call.return_data[12 len 20]
                                if not this.address:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not uniswapV2RouterAddress:
                                    revert with 0, 'ERC20: approve to the zero address'
                                mem[0] = uniswapV2RouterAddress
                                mem[32] = sha3(address(this.address), 1)
                                allowance[address(this.address)][stor9].field_0 = 0
                                emit Approval(0, this.address, uniswapV2RouterAddress);
                                mem[_2842 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                mem[_2842 + ceil32(return_data.size) + 100] = 0
                                mem[_2842 + ceil32(return_data.size) + 132] = 0
                                mem[_2842 + ceil32(return_data.size) + 164] = 160
                                mem[_2842 + ceil32(return_data.size) + 260] = mem[_2842]
                                idx = 0
                                s = _2842 + ceil32(return_data.size) + 292
                                t = _2842 + 32
                                while idx < mem[_2842]:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[_2842 + ceil32(return_data.size) + 196] = this.address
                                mem[_2842 + ceil32(return_data.size) + 228] = block.timestamp
                                require ext_code.size(uniswapV2RouterAddress)
                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len _2842 + ceil32(return_data.size) + (32 * mem[_2842]) + -mem[64] + 288]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4802 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4802] = 30
                                mem[_4802 + 32] = 'SafeMath: subtraction overflow'
                                if eth.balance(this.address) > eth.balance(this.address):
                                    var205001 = 32
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if eth.balance(this.address) < eth.balance(this.address):
                                    revert with 0, 17
                                if not this.address:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not uniswapV2RouterAddress:
                                    revert with 0, 'ERC20: approve to the zero address'
                                mem[0] = uniswapV2RouterAddress
                                mem[32] = sha3(address(this.address), 1)
                                allowance[address(this.address)][stor9].field_0 = 0
                                emit Approval(0, this.address, uniswapV2RouterAddress);
                                mem[mem[64] + 68] = 0
                                mem[mem[64] + 100] = 0
                                mem[mem[64] + 132] = 0
                                mem[mem[64] + 164] = block.timestamp
                                require ext_code.size(uniswapV2RouterAddress)
                                call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                     gas gas_remaining wei
                                    args this.address, 0, 0, 0, 0, block.timestamp
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                mem[mem[64] + 32] = 0
                                mem[mem[64] + 64] = 0
                                emit SwapAndLiquify(uint256 arg1, uint256 arg2, uint256 arg3):
                                                    0,
                                mem[0] = this.address
                                mem[32] = 0
                                _5221 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                mem[_5221 + 32 len 64] = call.data[calldata.size len 64]
                                if 0 >= mem[_5221]:
                                    revert with 0, 50
                                mem[_5221 + 32] = this.address
                                require ext_code.size(uniswapV2RouterAddress)
                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                        gas gas_remaining wei
                                mem[_5221 + 96] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = _5221 + ceil32(return_data.size) + 96
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                if 1 >= mem[_5221]:
                                    revert with 0, 50
                                mem[_5221 + 64] = ext_call.return_data[12 len 20]
                                if not this.address:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not uniswapV2RouterAddress:
                                    revert with 0, 'ERC20: approve to the zero address'
                                mem[0] = uniswapV2RouterAddress
                                mem[32] = sha3(address(this.address), 1)
                                allowance[address(this.address)][stor9].field_0 = balanceOf[this.address]
                                emit Approval(balanceOf[this.address], this.address, uniswapV2RouterAddress);
                                mem[_5221 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                mem[_5221 + ceil32(return_data.size) + 100] = balanceOf[this.address]
                                mem[_5221 + ceil32(return_data.size) + 132] = 0
                                mem[_5221 + ceil32(return_data.size) + 164] = 160
                                mem[_5221 + ceil32(return_data.size) + 260] = mem[_5221]
                                idx = 0
                                s = _5221 + ceil32(return_data.size) + 292
                                t = _5221 + 32
                                while idx < mem[_5221]:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[_5221 + ceil32(return_data.size) + 196] = this.address
                                mem[_5221 + ceil32(return_data.size) + 228] = block.timestamp
                                require ext_code.size(uniswapV2RouterAddress)
                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len _5221 + ceil32(return_data.size) + (32 * mem[_5221]) + -mem[64] + 288]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _6332 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6332] = 30
                                mem[_6332 + 32] = 'SafeMath: subtraction overflow'
                                if eth.balance(this.address) > eth.balance(this.address):
                                    var251001 = 32
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if eth.balance(this.address) < eth.balance(this.address):
                                    revert with 0, 17
                                call marketingWalletAddress with:
                                     gas 2300 wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                uint8(stor23.field_0) = 0
                                if not msg.sender:
                                    revert with 0, 'ERC20: transfer from the zero address'
                                if not this.address:
                                    revert with 0, 'ERC20: transfer to the zero address'
                                _6486 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_6486] = 38
                                mem[_6486 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                if _536 > balanceOf[address(msg.sender)]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 38
                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_6486 + 70 len 26]
                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                if balanceOf[address(msg.sender)] < _536:
                                    revert with 0, 17
                                balanceOf[address(msg.sender)] -= _536
                                if balanceOf[this.address] > !_536:
                                    revert with 0, 17
                                if balanceOf[this.address] + _536 < balanceOf[this.address]:
                                    revert with 0, 'SafeMath: addition overflow'
                                balanceOf[address(this.address)] = balanceOf[this.address] + _536
                                emit Transfer(_536, msg.sender, this.address);
                                if arg1 >= 3:
                                    revert with 0, 50
                                mem[mem[64]] = 0x12b8603f00000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = msg.sender
                                mem[mem[64] + 36] = 64
                                mem[mem[64] + 68] = mem[96]
                                mem[mem[64] + 100 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                                if ceil32(mem[96]) > mem[96]:
                                    mem[mem[64] + mem[96] + 100] = 0
                                require ext_code.size(sub_20eea8b5[arg1])
                                call sub_20eea8b5[arg1].createNode(address arg1, string arg2) with:
                                     gas gas_remaining wei
                                    args msg.sender, Array(len=mem[96], data=mem[mem[64] + 100 len ceil32(mem[96])])
                            else:
                                if balanceOf[this.address] and liquidityPoolFee > -1 / balanceOf[this.address]:
                                    revert with 0, 17
                                if not balanceOf[this.address]:
                                    revert with 0, 18
                                if balanceOf[this.address] * liquidityPoolFee / balanceOf[this.address] != liquidityPoolFee:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _2792 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2792] = 26
                                mem[_2792 + 32] = 'SafeMath: division by zero'
                                _2810 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2810] = 26
                                mem[_2810 + 32] = 'SafeMath: division by zero'
                                _2828 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2828] = 30
                                mem[_2828 + 32] = 'SafeMath: subtraction overflow'
                                if balanceOf[this.address] * liquidityPoolFee / 100 / 2 > balanceOf[this.address] * liquidityPoolFee / 100:
                                    var179001 = 32
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if balanceOf[this.address] * liquidityPoolFee / 100 < balanceOf[this.address] * liquidityPoolFee / 100 / 2:
                                    revert with 0, 17
                                _2920 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                mem[_2920 + 32 len 64] = call.data[calldata.size len 64]
                                if 0 >= mem[_2920]:
                                    revert with 0, 50
                                mem[_2920 + 32] = this.address
                                require ext_code.size(uniswapV2RouterAddress)
                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                        gas gas_remaining wei
                                mem[_2920 + 96] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = _2920 + ceil32(return_data.size) + 96
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                if 1 >= mem[_2920]:
                                    revert with 0, 50
                                mem[_2920 + 64] = ext_call.return_data[12 len 20]
                                if not this.address:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not uniswapV2RouterAddress:
                                    revert with 0, 'ERC20: approve to the zero address'
                                mem[0] = uniswapV2RouterAddress
                                mem[32] = sha3(address(this.address), 1)
                                allowance[address(this.address)][stor9].field_0 = balanceOf[this.address] * liquidityPoolFee / 100 / 2
                                allowance[address(this.address)][stor9].field_255 = 0
                                emit Approval((balanceOf[this.address] * liquidityPoolFee / 100 / 2), this.address, uniswapV2RouterAddress);
                                mem[_2920 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                mem[_2920 + ceil32(return_data.size) + 100] = balanceOf[this.address] * liquidityPoolFee / 100 / 2
                                mem[_2920 + ceil32(return_data.size) + 132] = 0
                                mem[_2920 + ceil32(return_data.size) + 164] = 160
                                mem[_2920 + ceil32(return_data.size) + 260] = mem[_2920]
                                idx = 0
                                s = _2920 + ceil32(return_data.size) + 292
                                t = _2920 + 32
                                while idx < mem[_2920]:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[_2920 + ceil32(return_data.size) + 196] = this.address
                                mem[_2920 + ceil32(return_data.size) + 228] = block.timestamp
                                require ext_code.size(uniswapV2RouterAddress)
                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len _2920 + ceil32(return_data.size) + (32 * mem[_2920]) + -mem[64] + 288]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4801 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4801] = 30
                                mem[_4801 + 32] = 'SafeMath: subtraction overflow'
                                if eth.balance(this.address) > eth.balance(this.address):
                                    var211001 = 32
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if eth.balance(this.address) < eth.balance(this.address):
                                    revert with 0, 17
                                if not this.address:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not uniswapV2RouterAddress:
                                    revert with 0, 'ERC20: approve to the zero address'
                                mem[0] = uniswapV2RouterAddress
                                mem[32] = sha3(address(this.address), 1)
                                allowance[address(this.address)][stor9].field_0 = (balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2)
                                emit Approval(((balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2)), this.address, uniswapV2RouterAddress);
                                mem[mem[64] + 68] = 0
                                mem[mem[64] + 100] = 0
                                mem[mem[64] + 132] = 0
                                mem[mem[64] + 164] = block.timestamp
                                require ext_code.size(uniswapV2RouterAddress)
                                call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                     gas gas_remaining wei
                                    args this.address, (balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2), 0, 0, 0, block.timestamp
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                mem[mem[64] + 32] = 0
                                mem[mem[64] + 64] = (balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2)
                                emit SwapAndLiquify(Mask(255, 1, balanceOf[this.address] * liquidityPoolFee / 100), 0, (balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2));
                                mem[0] = this.address
                                mem[32] = 0
                                _5219 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                mem[_5219 + 32 len 64] = call.data[calldata.size len 64]
                                if 0 >= mem[_5219]:
                                    revert with 0, 50
                                mem[_5219 + 32] = this.address
                                require ext_code.size(uniswapV2RouterAddress)
                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                        gas gas_remaining wei
                                mem[_5219 + 96] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = _5219 + ceil32(return_data.size) + 96
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                if 1 >= mem[_5219]:
                                    revert with 0, 50
                                mem[_5219 + 64] = ext_call.return_data[12 len 20]
                                if not this.address:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not uniswapV2RouterAddress:
                                    revert with 0, 'ERC20: approve to the zero address'
                                mem[0] = uniswapV2RouterAddress
                                mem[32] = sha3(address(this.address), 1)
                                allowance[address(this.address)][stor9].field_0 = balanceOf[this.address]
                                emit Approval(balanceOf[this.address], this.address, uniswapV2RouterAddress);
                                mem[_5219 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                mem[_5219 + ceil32(return_data.size) + 100] = balanceOf[this.address]
                                mem[_5219 + ceil32(return_data.size) + 132] = 0
                                mem[_5219 + ceil32(return_data.size) + 164] = 160
                                mem[_5219 + ceil32(return_data.size) + 260] = mem[_5219]
                                idx = 0
                                s = _5219 + ceil32(return_data.size) + 292
                                t = _5219 + 32
                                while idx < mem[_5219]:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[_5219 + ceil32(return_data.size) + 228] = block.timestamp
                                require ext_code.size(uniswapV2RouterAddress)
                                call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                     gas gas_remaining wei
                                    args balanceOf[this.address], 0, 160, address(this.address), block.timestamp, mem[_5219 + ceil32(return_data.size) + 260 len (32 * mem[_5219]) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[_5219 + ceil32(return_data.size) + 96] = 30
                                mem[_5219 + ceil32(return_data.size) + 128] = 'SafeMath: subtraction overflow'
                                if eth.balance(this.address) > eth.balance(this.address):
                                    var257001 = 32
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if eth.balance(this.address) < eth.balance(this.address):
                                    revert with 0, 17
                                call marketingWalletAddress with:
                                     gas 2300 wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                uint8(stor23.field_0) = 0
                                if not msg.sender:
                                    revert with 0, 'ERC20: transfer from the zero address'
                                if not this.address:
                                    revert with 0, 'ERC20: transfer to the zero address'
                                mem[_5219 + ceil32(return_data.size) + 160] = 38
                                mem[_5219 + ceil32(return_data.size) + 192 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                if _536 > balanceOf[address(msg.sender)]:
                                    revert with 0, 
                                                32,
                                                38,
                                                0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, Mask(208, 32, block.timestamp) >> 32 >> 48,
                                                0
                                if balanceOf[address(msg.sender)] < _536:
                                    revert with 0, 17
                                balanceOf[address(msg.sender)] -= _536
                                if balanceOf[this.address] > !_536:
                                    revert with 0, 17
                                if balanceOf[this.address] + _536 < balanceOf[this.address]:
                                    revert with 0, 'SafeMath: addition overflow'
                                balanceOf[address(this.address)] = balanceOf[this.address] + _536
                                emit Transfer(_536, msg.sender, this.address);
                                if arg1 >= 3:
                                    revert with 0, 50
                                mem[_5219 + ceil32(return_data.size) + 256] = 0x12b8603f00000000000000000000000000000000000000000000000000000000
                                mem[_5219 + ceil32(return_data.size) + 260] = msg.sender
                                mem[_5219 + ceil32(return_data.size) + 292] = 64
                                mem[_5219 + ceil32(return_data.size) + 324] = mem[96]
                                mem[_5219 + ceil32(return_data.size) + 356 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                                if ceil32(mem[96]) > mem[96]:
                                    mem[_5219 + ceil32(return_data.size) + mem[96] + 356] = 0
                                require ext_code.size(sub_20eea8b5[arg1])
                                call sub_20eea8b5[arg1].createNode(address arg1, string arg2) with:
                                     gas gas_remaining wei
                                    args msg.sender, Array(len=mem[96], data=mem[_5219 + ceil32(return_data.size) + 356 len ceil32(mem[96])])
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        if stor27[address(msg.sender)] > -2:
            revert with 0, 17
        if stor27[address(msg.sender)] + 1 < stor27[address(msg.sender)]:
            revert with 0, 'SafeMath: addition overflow'
    ('ge', ('add', 1, ('stor', ('map', ('mask_shl', 160, 0, 0, 'msg.sender'), ('name', 'stor27', 27)))), ('stor', ('map', ('mask_shl', 160, 0, 0, 'msg.sender'), ('name', 'stor27', 27))))
    stor27[address(msg.sender)]++
}

function _fallback() payable {
    mem[64] = 128
    if calldata.size < 4:
        require not calldata.size
    else:
        if unknown_0x6cdc78b3(?????) > uint32(call.func_hash) >> 224:
            if unknown_0x313ce567(?????) <= uint32(call.func_hash) >> 224:
                if unknown_0x49bd5a5e(?????) > uint32(call.func_hash) >> 224:
                    if unknown_0x39509351(?????) > uint32(call.func_hash) >> 224:
                        if unknown_0x313ce567(?????) == uint32(call.func_hash) >> 224:
                            require not msg.value
                            return 18
                        if unknown_0x340afa77(?????) == uint32(call.func_hash) >> 224:
                            require not msg.value
                            require calldata.size - 4 >= 64
                            require arg1 == address(arg1)
                            if arg2 >= 3:
                                revert with 0, 50
                            require ext_code.size(sub_20eea8b5[arg2])
                            staticcall sub_20eea8b5[arg2].0xf55e6f79 with:
                                    gas gas_remaining wei
                                   args address(arg1)
                        else:
                            if uint32(call.func_hash) >> 224 != unknown_0x34b05227(?????):
                                require unknown_0x378dc3dc(?????) == uint32(call.func_hash) >> 224
                                require not msg.value
                                return initialSupply
                            require not msg.value
                            require calldata.size - 4 >= 64
                            require arg1 == address(arg1)
                            if arg2 >= 3:
                                revert with 0, 50
                            require ext_code.size(sub_20eea8b5[arg2])
                            staticcall sub_20eea8b5[arg2]._getNodeNumberOf(address arg1) with:
                                    gas gas_remaining wei
                                   args address(arg1)
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        return ext_call.return_data[0]
                    if unknown_0x39509351(?????) == uint32(call.func_hash) >> 224:
                        require not msg.value
                        require calldata.size - 4 >= 64
                        require arg1 == address(arg1)
                        if allowance[msg.sender][address(arg1)].field_0 > !arg2:
                            revert with 0, 17
                        if allowance[msg.sender][address(arg1)].field_0 + arg2 < allowance[msg.sender][address(arg1)].field_0:
                            revert with 0, 'SafeMath: addition overflow'
                        if not msg.sender:
                            revert with 0, 'ERC20: approve from the zero address'
                        if not address(arg1):
                            revert with 0, 'ERC20: approve to the zero address'
                        allowance[address(msg.sender)][address(arg1)].field_0 = allowance[msg.sender][address(arg1)].field_0 + arg2
                        emit Approval((allowance[msg.sender][address(arg1)].field_0 + arg2), msg.sender, address(arg1));
                        return 1
                    if unknown_0x4195fbf3(?????) == uint32(call.func_hash) >> 224:
                        require not msg.value
                        require calldata.size - 4 >= 32
                        if owner != msg.sender:
                            revert with 0, 'Ownable: caller is not the owner'
                        if arg1 <= eth.balance(this.address):
                            call owner with:
                               value arg1 wei
                                 gas 2300 * is_zero(value) wei
                        else:
                            call owner with:
                               value eth.balance(this.address) wei
                                 gas 2300 * is_zero(value) wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                    else:
                        if unknown_0x42bc9fca(?????) == uint32(call.func_hash) >> 224:
                            require not msg.value
                            require calldata.size - 4 >= 32
                            if owner != msg.sender:
                                revert with 0, 'Ownable: caller is not the owner'
                            liquidityPoolFee = arg1
                            if rewardsFee > !arg1:
                                revert with 0, 17
                            if rewardsFee + arg1 < rewardsFee:
                                revert with 0, 'SafeMath: addition overflow'
                            totalFees = rewardsFee + arg1
                        else:
                            require unknown_0x43369165(?????) == uint32(call.func_hash) >> 224
                            require not msg.value
                            require calldata.size - 4 >= 64
                            if owner != msg.sender:
                                revert with 0, 'Ownable: caller is not the owner'
                            if arg2 >= 3:
                                revert with 0, 50
                            require ext_code.size(sub_20eea8b5[arg2])
                            call sub_20eea8b5[arg2]._changeNodePrice(uint256 arg1) with:
                                 gas gas_remaining wei
                                args arg1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                else:
                    if unknown_0x5f1c3182(?????) > uint32(call.func_hash) >> 224:
                        if unknown_0x49bd5a5e(?????) == uint32(call.func_hash) >> 224:
                            require not msg.value
                            return uniswapV2PairAddress
                        if uint32(call.func_hash) >> 224 != unknown_0x54557973(?????):
                            if unknown_0x54f12f1f(?????) == uint32(call.func_hash) >> 224:
                                require not msg.value
                                return liquidityPoolFee
                            require unknown_0x583bd7a6(?????) == uint32(call.func_hash) >> 224
                            require not msg.value
                            require calldata.size - 4 >= 32
                            require arg1 == bool(arg1)
                            if owner != msg.sender:
                                revert with 0, 'Ownable: caller is not the owner'
                            Mask(248, 0, stor23.field_8) = Mask(248, 0, bool(arg1))
                        require not msg.value
                        mem[0] = msg.sender
                        mem[32] = 25
                        if stor25[msg.sender]:
                            revert with 0, 'Cashout: Blacklisted address'
                        if not msg.sender:
                            revert with 0, 'MANIA CSHT:  creation from the zero address'
                        if futurUsePoolAddress == msg.sender:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        'MANIA CSHT: futur, marketing and rewardsPool cannot cashout rewards'
                        if distributionPoolAddress == msg.sender:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        'MANIA CSHT: futur, marketing and rewardsPool cannot cashout rewards'
                        if marketingWalletAddress == msg.sender:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        'MANIA CSHT: futur, marketing and rewardsPool cannot cashout rewards'
                        idx = 0
                        while idx < 3:
                            mem[mem[64] + 4] = msg.sender
                            require ext_code.size(sub_20eea8b5[idx])
                            staticcall sub_20eea8b5[idx]._getNodeNumberOf(address arg1) with:
                                    gas gas_remaining wei
                                   args msg.sender
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2288 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if mem[_2288]:
                                if idx >= 3:
                                    revert with 0, 50
                                mem[mem[64] + 4] = msg.sender
                                mem[mem[64] + 36] = 1
                                require ext_code.size(sub_20eea8b5[idx])
                                staticcall sub_20eea8b5[idx].0x80e9be34 with:
                                        gas gas_remaining wei
                                       args msg.sender, 1
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _2512 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _2527 = mem[_2512]
                                if 0 > !mem[_2512]:
                                    revert with 0, 17
                                if mem[_2512] < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if idx >= 3:
                                    revert with 0, 50
                                mem[mem[64] + 4] = msg.sender
                                mem[mem[64] + 36] = 0
                                require ext_code.size(sub_20eea8b5[idx])
                                staticcall sub_20eea8b5[idx].0x80e9be34 with:
                                        gas gas_remaining wei
                                       args msg.sender, 0
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _2664 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if 0 > !mem[_2664]:
                                    revert with 0, 17
                                if mem[_2664] < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if idx >= 3:
                                    revert with 0, 50
                                if not _2527:
                                    _2846 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_2846] = 26
                                    mem[_2846 + 32] = 'SafeMath: division by zero'
                                else:
                                    if _2527 and sub_075dc237[idx] > -1 / _2527:
                                        revert with 0, 17
                                    if not _2527:
                                        revert with 0, 18
                                    if _2527 * sub_075dc237[idx] / _2527 != sub_075dc237[idx]:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _2896 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_2896] = 26
                                    mem[_2896 + 32] = 'SafeMath: division by zero'
                                    if 0 > !(_2527 * sub_075dc237[idx] / 100):
                                        revert with 0, 17
                                    if _2527 * sub_075dc237[idx] / 100 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            continue 
                        revert with 0, 'AgamottoToken: You don't have enough reward to cash out'
                    if unknown_0x5f1c3182(?????) == uint32(call.func_hash) >> 224:
                        require not msg.value
                        return swapTokensAmount
                    if unknown_0x615cf8b8(?????) == uint32(call.func_hash) >> 224:
                        require not msg.value
                        require calldata.size - 4 >= 32
                        if arg1 >= 3:
                            revert with 0, 50
                        require ext_code.size(sub_20eea8b5[arg1])
                        staticcall sub_20eea8b5[arg1].nodePrice() with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        return ext_call.return_data[0]
                    if uint32(call.func_hash) >> 224 != unknown_0x65b8dbc0(?????):
                        require unknown_0x6770474b(?????) == uint32(call.func_hash) >> 224
                        require not msg.value
                        require calldata.size - 4 >= 32
                        if owner != msg.sender:
                            revert with 0, 'Ownable: caller is not the owner'
                        swapTokensAmount = arg1
                    else:
                        require not msg.value
                        require calldata.size - 4 >= 32
                        require arg1 == address(arg1)
                        if owner != msg.sender:
                            revert with 0, 'Ownable: caller is not the owner'
                        if uniswapV2RouterAddress == address(arg1):
                            revert with 0, 'TKN: The router already has that address'
                        emit UpdateUniswapV2Router(address(arg1), uniswapV2RouterAddress);
                        uniswapV2RouterAddress = address(arg1)
                        require ext_code.size(address(arg1))
                        staticcall address(arg1).factory() with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                        require ext_code.size(uniswapV2RouterAddress)
                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).createPair(address arg1, address arg2) with:
                             gas gas_remaining wei
                            args address(this.address), address(ext_call.return_data[0])
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                        uniswapV2PairAddress = ext_call.return_data[12 len 20]
            else:
                if unknown_0x1694505e(?????) > uint32(call.func_hash) >> 224:
                    if approve(address arg1, uint256 arg2) <= uint32(call.func_hash) >> 224:
                        if approve(address arg1, uint256 arg2) == uint32(call.func_hash) >> 224:
                            require not msg.value
                            require calldata.size - 4 >= 64
                            require arg1 == address(arg1)
                            if not msg.sender:
                                revert with 0, 'ERC20: approve from the zero address'
                            if not address(arg1):
                                revert with 0, 'ERC20: approve to the zero address'
                            allowance[address(msg.sender)][address(arg1)].field_0 = arg2
                            emit Approval(arg2, msg.sender, address(arg1));
                            return 1
                        if updateFuturWall(address arg1) == uint32(call.func_hash) >> 224:
                            require not msg.value
                            require calldata.size - 4 >= 32
                            require arg1 == address(arg1)
                            if owner != msg.sender:
                                revert with 0, 'Ownable: caller is not the owner'
                            futurUsePoolAddress = address(arg1)
                        else:
                            if unknown_0x13114a9d(?????) == uint32(call.func_hash) >> 224:
                                require not msg.value
                                return totalFees
                            require unknown_0x15494a58(?????) == uint32(call.func_hash) >> 224
                            require not msg.value
                            require calldata.size - 4 >= 64
                            if owner != msg.sender:
                                revert with 0, 'Ownable: caller is not the owner'
                            if arg2 >= 3:
                                revert with 0, 50
                            require ext_code.size(sub_20eea8b5[arg2])
                            call sub_20eea8b5[arg2].0xe65ce64 with:
                                 gas gas_remaining wei
                                args arg1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                    if uint32(call.func_hash) >> 224 != name():
                        if unknown_0x075dc237(?????) == uint32(call.func_hash) >> 224:
                            require not msg.value
                            require calldata.size - 4 >= 32
                            require arg1 < 3
                            return sub_075dc237[arg1]
                        require updateRewardsFee(uint256 arg1) == uint32(call.func_hash) >> 224
                        require not msg.value
                        require calldata.size - 4 >= 32
                        if owner != msg.sender:
                            revert with 0, 'Ownable: caller is not the owner'
                        rewardsFee = arg1
                        if arg1 > !liquidityPoolFee:
                            revert with 0, 17
                        if arg1 + liquidityPoolFee < arg1:
                            revert with 0, 'SafeMath: addition overflow'
                        totalFees = arg1 + liquidityPoolFee
                    require not msg.value
                    if bool(stor3.length):
                        if bool(stor3.length) == uint255(stor3.length) * 0.5 < 32:
                            revert with 0, 34
                        if bool(stor3.length):
                            if bool(stor3.length) == uint255(stor3.length) * 0.5 < 32:
                                revert with 0, 34
                            if Mask(256, -1, stor3.length):
                                if 31 < uint255(stor3.length) * 0.5:
                                    mem[160] = uint256(stor3.field_0)
                                    idx = 160
                                    s = 0
                                    while (uint255(stor3.length) * 0.5) + 128 > idx:
                                        mem[idx + 32] = stor3[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    return Array(len=2 * Mask(256, -1, stor3.length), data=mem[160 len ceil32(uint255(stor3.length) * 0.5)])
                                mem[160] = 256 * stor3.length.field_8
                        else:
                            if bool(stor3.length) == stor3.length.field_1 < 32:
                                revert with 0, 34
                            if stor3.length.field_1:
                                if 31 < stor3.length.field_1:
                                    mem[160] = uint256(stor3.field_0)
                                    idx = 160
                                    s = 0
                                    while stor3.length.field_1 + 128 > idx:
                                        mem[idx + 32] = stor3[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    return Array(len=2 * Mask(256, -1, stor3.length), data=mem[160 len ceil32(uint255(stor3.length) * 0.5)])
                                mem[160] = 256 * stor3.length.field_8
                        mem[ceil32(uint255(stor3.length) * 0.5) + 224 len ceil32(uint255(stor3.length) * 0.5)] = mem[160 len ceil32(uint255(stor3.length) * 0.5)]
                        if ceil32(uint255(stor3.length) * 0.5) > uint255(stor3.length) * 0.5:
                            mem[ceil32(uint255(stor3.length) * 0.5) + (uint255(stor3.length) * 0.5) + 224] = 0
                        return Array(len=2 * Mask(256, -1, stor3.length), data=mem[160 len ceil32(uint255(stor3.length) * 0.5)], mem[(2 * ceil32(uint255(stor3.length) * 0.5)) + 224 len 2 * ceil32(uint255(stor3.length) * 0.5)]), 
                    if bool(stor3.length) == stor3.length.field_1 < 32:
                        revert with 0, 34
                    if bool(stor3.length):
                        if bool(stor3.length) == uint255(stor3.length) * 0.5 < 32:
                            revert with 0, 34
                        if Mask(256, -1, stor3.length):
                            if 31 < uint255(stor3.length) * 0.5:
                                mem[160] = uint256(stor3.field_0)
                                idx = 160
                                s = 0
                                while (uint255(stor3.length) * 0.5) + 128 > idx:
                                    mem[idx + 32] = stor3[s].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                return Array(len=stor3.length % 128, data=mem[160 len ceil32(stor3.length.field_1)])
                            mem[160] = 256 * stor3.length.field_8
                    else:
                        if bool(stor3.length) == stor3.length.field_1 < 32:
                            revert with 0, 34
                        if stor3.length.field_1:
                            if 31 < stor3.length.field_1:
                                mem[160] = uint256(stor3.field_0)
                                idx = 160
                                s = 0
                                while stor3.length.field_1 + 128 > idx:
                                    mem[idx + 32] = stor3[s].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                return Array(len=stor3.length % 128, data=mem[160 len ceil32(stor3.length.field_1)])
                            mem[160] = 256 * stor3.length.field_8
                    mem[ceil32(stor3.length.field_1) + 224 len ceil32(stor3.length.field_1)] = mem[160 len ceil32(stor3.length.field_1)]
                    if ceil32(stor3.length.field_1) > stor3.length.field_1:
                        mem[ceil32(stor3.length.field_1) + stor3.length.field_1 + 224] = 0
                    return Array(len=stor3.length % 128, data=mem[160 len ceil32(stor3.length.field_1)], mem[(2 * ceil32(stor3.length.field_1)) + 224 len 2 * ceil32(stor3.length.field_1)]), 
                if unknown_0x20eea8b5(?????) <= uint32(call.func_hash) >> 224:
                    if unknown_0x20eea8b5(?????) == uint32(call.func_hash) >> 224:
                        require not msg.value
                        require calldata.size - 4 >= 32
                        require arg1 < 3
                        return sub_20eea8b5[arg1]
                    if unknown_0x2275c385(?????) == uint32(call.func_hash) >> 224:
                        require not msg.value
                        require calldata.size - 4 >= 32
                        if owner != msg.sender:
                            revert with 0, 'Ownable: caller is not the owner'
                        if arg1 <= sub_6cdc78b3:
                            revert with 0, 'Invalid max node number'
                        sub_6cdc78b3 = arg1
                    if uint32(call.func_hash) >> 224 != unknown_0x23b872dd(?????):
                        require unknown_0x2bb14e1d(?????) == uint32(call.func_hash) >> 224
                        require not msg.value
                        return rewardsFee
                    require not msg.value
                    require calldata.size - 4 >= 96
                    require arg1 == address(arg1)
                    require arg2 == address(arg2)
                    if not address(arg1):
                        revert with 0, 'ERC20: transfer from the zero address'
                    if not address(arg2):
                        revert with 0, 'ERC20: transfer to the zero address'
                    if stor25[address(arg1)]:
                        revert with 0, 'Blacklisted address'
                    if stor25[address(arg2)]:
                        revert with 0, 'Blacklisted address'
                    if not address(arg1):
                        revert with 0, 'ERC20: transfer from the zero address'
                    if not address(arg2):
                        revert with 0, 'ERC20: transfer to the zero address'
                    if arg3 > balanceOf[address(arg1)]:
                        revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[198 len 26] >> 48, 0
                    if balanceOf[address(arg1)] < arg3:
                        revert with 0, 17
                    balanceOf[address(arg1)] -= arg3
                    if balanceOf[address(arg2)] > !arg3:
                        revert with 0, 17
                    if balanceOf[address(arg2)] + arg3 < balanceOf[address(arg2)]:
                        revert with 0, 'SafeMath: addition overflow'
                    balanceOf[address(arg2)] += arg3
                    emit Transfer(arg3, address(arg1), address(arg2));
                    if arg3 > allowance[address(arg1)][msg.sender].field_0:
                        revert with 0, 32, 40, 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[296 len 24] >> 64, 0
                    if allowance[address(arg1)][msg.sender].field_0 < arg3:
                        revert with 0, 17
                    if not address(arg1):
                        revert with 0, 'ERC20: approve from the zero address'
                    if not msg.sender:
                        revert with 0, 'ERC20: approve to the zero address'
                    allowance[address(arg1)][address(msg.sender)].field_0 = allowance[address(arg1)][msg.sender].field_0 - arg3
                    emit Approval((allowance[address(arg1)][msg.sender].field_0 - arg3), address(arg1), msg.sender);
                    return 1
                if unknown_0x1694505e(?????) == uint32(call.func_hash) >> 224:
                    require not msg.value
                    return uniswapV2RouterAddress
                if unknown_0x18160ddd(?????) == uint32(call.func_hash) >> 224:
                    require not msg.value
                    return totalSupply
                if unknown_0x1cdd3be3(?????) == uint32(call.func_hash) >> 224:
                    require not msg.value
                    require calldata.size - 4 >= 32
                    require arg1 == address(arg1)
                    return bool(stor25[arg1])
                require unknown_0x1f64e887(?????) == uint32(call.func_hash) >> 224
                require not msg.value
                require calldata.size - 4 >= 64
                require arg2 <= test266151307()
                require arg2 + 35 < calldata.size
                if arg2.length > test266151307():
                    revert with 0, 65
                if ceil32(ceil32(arg2.length)) + 129 < 128 or ceil32(ceil32(arg2.length)) + 129 > test266151307():
                    revert with 0, 65
                mem[128] = arg2.length
                require arg2 + arg2.length + 36 <= calldata.size
                mem[160 len arg2.length] = arg2[all]
                if arg1 >= 3:
                    revert with 0, 50
                mem[ceil32(ceil32(arg2.length)) + 133] = msg.sender
                mem[ceil32(ceil32(arg2.length)) + 165] = 0
                require ext_code.size(sub_20eea8b5[arg1])
                staticcall sub_20eea8b5[arg1].0x80e9be34 with:
                        gas gas_remaining wei
                       args msg.sender, 0
                mem[ceil32(ceil32(arg2.length)) + 129] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if arg1 >= 3:
                    revert with 0, 50
                require ext_code.size(sub_20eea8b5[arg1])
                staticcall sub_20eea8b5[arg1].nodePrice() with:
                        gas gas_remaining wei
                mem[ceil32(ceil32(arg2.length)) + ceil32(return_data.size) + 129] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if ext_call.return_data[0] > !balanceOf[address(msg.sender)]:
                    revert with 0, 17
                if ext_call.return_data[0] + balanceOf[address(msg.sender)] < ext_call.return_data[0]:
                    revert with 0, 'SafeMath: addition overflow'
                if ext_call.return_data[0] + balanceOf[address(msg.sender)] < ext_call.return_data[0]:
                    revert with 0, 'Insufficient balance'
                if not distributionPoolAddress:
                    revert with 0, 'ERC20: transfer from the zero address'
                if not msg.sender:
                    revert with 0, 'ERC20: transfer to the zero address'
                mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + 129] = 38
                mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + 161 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                if ext_call.return_data[0] > balanceOf[stor12]:
                    revert with 0, 
                                32,
                                38,
                                0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + 199 len 26] >> 48,
                                0
                if balanceOf[stor12] < ext_call.return_data[0]:
                    revert with 0, 17
                balanceOf[stor12] -= ext_call.return_data[0]
                if balanceOf[msg.sender] > !ext_call.return_data[0]:
                    revert with 0, 17
                if balanceOf[msg.sender] + ext_call.return_data[0] < balanceOf[msg.sender]:
                    revert with 0, 'SafeMath: addition overflow'
                balanceOf[address(msg.sender)] = balanceOf[msg.sender] + ext_call.return_data[0]
                emit Transfer(ext_call.return_data[0], distributionPoolAddress, msg.sender);
                if arg1 >= 3:
                    revert with 0, 50
                mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + 229] = msg.sender
                mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + 261] = ext_call.return_data[0]
                mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + 293] = 0
                require ext_code.size(sub_20eea8b5[arg1])
                call sub_20eea8b5[arg1].0xd74037e5 with:
                     gas gas_remaining wei
                    args msg.sender, ext_call.return_data[0], 0
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if arg2.length <= 3:
                    revert with 0, 'NODE CREATION: NAME SIZE INVALID'
                if arg2.length >= 32:
                    revert with 0, 'NODE CREATION: NAME SIZE INVALID'
                if sub_6cdc78b3 <= stor27[msg.sender]:
                    revert with 0, 'cannot create node more than 100'
                if not msg.sender:
                    revert with 0, 'NODE CREATION:  creation from the zero address'
                if stor25[address(msg.sender)]:
                    revert with 0, 'NODE CREATION: Blacklisted address'
                if futurUsePoolAddress == msg.sender:
                    revert with 0, 'NODE CREATION: futur and rewardsPool cannot create node'
                if distributionPoolAddress == msg.sender:
                    revert with 0, 'NODE CREATION: futur and rewardsPool cannot create node'
                if arg1 >= 3:
                    revert with 0, 50
                require ext_code.size(sub_20eea8b5[arg1])
                staticcall sub_20eea8b5[arg1].nodePrice() with:
                        gas gas_remaining wei
                mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + 225] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if balanceOf[address(msg.sender)] < ext_call.return_data[0]:
                    revert with 0, 'NODE CREATION: Balance too low for creation.'
                if ext_call.return_data[0] < ext_call.return_data[0]:
                    if balanceOf[this.address] < swapTokensAmount:
                        if not msg.sender:
                            revert with 0, 'ERC20: transfer from the zero address'
                        if not this.address:
                            revert with 0, 'ERC20: transfer to the zero address'
                        if ext_call.return_data[0] > balanceOf[address(msg.sender)]:
                            revert with 0, 
                                        32,
                                        38,
                                        0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + 295 len 26] >> 48,
                                        0
                        if balanceOf[address(msg.sender)] < ext_call.return_data[0]:
                            revert with 0, 17
                        balanceOf[address(msg.sender)] -= ext_call.return_data[0]
                        if balanceOf[this.address] > !ext_call.return_data[0]:
                            revert with 0, 17
                        if balanceOf[this.address] + ext_call.return_data[0] < balanceOf[this.address]:
                            revert with 0, 'SafeMath: addition overflow'
                        balanceOf[address(this.address)] = balanceOf[this.address] + ext_call.return_data[0]
                        emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                        if arg1 >= 3:
                            revert with 0, 50
                        require ext_code.size(sub_20eea8b5[arg1])
                        call sub_20eea8b5[arg1].createNode(address arg1, string arg2) with:
                             gas gas_remaining wei
                            args msg.sender, Array(len=arg2.length, data=arg2[all])
                    else:
                        if not uint8(stor23.field_8):
                            if not msg.sender:
                                revert with 0, 'ERC20: transfer from the zero address'
                            if not this.address:
                                revert with 0, 'ERC20: transfer to the zero address'
                            if ext_call.return_data[0] > balanceOf[address(msg.sender)]:
                                revert with 0, 
                                            32,
                                            38,
                                            0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + 295 len 26] >> 48,
                                            0
                            if balanceOf[address(msg.sender)] < ext_call.return_data[0]:
                                revert with 0, 17
                            balanceOf[address(msg.sender)] -= ext_call.return_data[0]
                            if balanceOf[this.address] > !ext_call.return_data[0]:
                                revert with 0, 17
                            if balanceOf[this.address] + ext_call.return_data[0] < balanceOf[this.address]:
                                revert with 0, 'SafeMath: addition overflow'
                            balanceOf[address(this.address)] = balanceOf[this.address] + ext_call.return_data[0]
                            emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                            if arg1 >= 3:
                                revert with 0, 50
                            require ext_code.size(sub_20eea8b5[arg1])
                            call sub_20eea8b5[arg1].createNode(address arg1, string arg2) with:
                                 gas gas_remaining wei
                                args msg.sender, Array(len=arg2.length, data=arg2[all])
                        else:
                            if uint8(stor23.field_0):
                                if not msg.sender:
                                    revert with 0, 'ERC20: transfer from the zero address'
                                if not this.address:
                                    revert with 0, 'ERC20: transfer to the zero address'
                                if ext_call.return_data[0] > balanceOf[address(msg.sender)]:
                                    revert with 0, 
                                                32,
                                                38,
                                                0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + 295 len 26] >> 48,
                                                0
                                if balanceOf[address(msg.sender)] < ext_call.return_data[0]:
                                    revert with 0, 17
                                balanceOf[address(msg.sender)] -= ext_call.return_data[0]
                                if balanceOf[this.address] > !ext_call.return_data[0]:
                                    revert with 0, 17
                                if balanceOf[this.address] + ext_call.return_data[0] < balanceOf[this.address]:
                                    revert with 0, 'SafeMath: addition overflow'
                                balanceOf[address(this.address)] = balanceOf[this.address] + ext_call.return_data[0]
                                emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                if arg1 >= 3:
                                    revert with 0, 50
                                require ext_code.size(sub_20eea8b5[arg1])
                                call sub_20eea8b5[arg1].createNode(address arg1, string arg2) with:
                                     gas gas_remaining wei
                                    args msg.sender, Array(len=arg2.length, data=arg2[all])
                            else:
                                if owner == msg.sender:
                                    if not msg.sender:
                                        revert with 0, 'ERC20: transfer from the zero address'
                                    if not this.address:
                                        revert with 0, 'ERC20: transfer to the zero address'
                                    if ext_call.return_data[0] > balanceOf[address(msg.sender)]:
                                        revert with 0, 
                                                    32,
                                                    38,
                                                    0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + 295 len 26] >> 48,
                                                    0
                                    if balanceOf[address(msg.sender)] < ext_call.return_data[0]:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)] -= ext_call.return_data[0]
                                    if balanceOf[this.address] > !ext_call.return_data[0]:
                                        revert with 0, 17
                                    if balanceOf[this.address] + ext_call.return_data[0] < balanceOf[this.address]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(this.address)] = balanceOf[this.address] + ext_call.return_data[0]
                                    emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                    if arg1 >= 3:
                                        revert with 0, 50
                                    require ext_code.size(sub_20eea8b5[arg1])
                                    call sub_20eea8b5[arg1].createNode(address arg1, string arg2) with:
                                         gas gas_remaining wei
                                        args msg.sender, Array(len=arg2.length, data=arg2[all])
                                else:
                                    if stor26[address(msg.sender)]:
                                        if not msg.sender:
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not this.address:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        if ext_call.return_data[0] > balanceOf[address(msg.sender)]:
                                            revert with 0, 
                                                        32,
                                                        38,
                                                        0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + 295 len 26] >> 48,
                                                        0
                                        if balanceOf[address(msg.sender)] < ext_call.return_data[0]:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] -= ext_call.return_data[0]
                                        if balanceOf[this.address] > !ext_call.return_data[0]:
                                            revert with 0, 17
                                        if balanceOf[this.address] + ext_call.return_data[0] < balanceOf[this.address]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(this.address)] = balanceOf[this.address] + ext_call.return_data[0]
                                        emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                        if arg1 >= 3:
                                            revert with 0, 50
                                        require ext_code.size(sub_20eea8b5[arg1])
                                        call sub_20eea8b5[arg1].createNode(address arg1, string arg2) with:
                                             gas gas_remaining wei
                                            args msg.sender, Array(len=arg2.length, data=arg2[all])
                                    else:
                                        uint8(stor23.field_0) = 1
                                        if not balanceOf[this.address]:
                                            mem[ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + 225] = 26
                                            mem[ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + 257] = 'SafeMath: division by zero'
                                            mem[ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + 289] = 26
                                            mem[ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + 321] = 'SafeMath: division by zero'
                                            mem[ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + 353] = 2
                                            mem[ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + 385] = this.address
                                            require ext_code.size(uniswapV2RouterAddress)
                                            staticcall uniswapV2RouterAddress.WAVAX() with:
                                                    gas gas_remaining wei
                                            mem[ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + 449] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[64] = ceil32(ceil32(arg2.length)) + (6 * ceil32(return_data.size)) + 449
                                            require return_data.size >= 32
                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                            mem[ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + 417] = ext_call.return_data[12 len 20]
                                            if not this.address:
                                                revert with 0, 
                                                            'ERC20: approve from the zero address',
                                                            mem[ceil32(ceil32(arg2.length)) + (6 * ceil32(return_data.size)) + 581 len 9 * ceil32(return_data.size)]
                                            if not uniswapV2RouterAddress:
                                                revert with 0, 
                                                            'ERC20: approve to the zero address',
                                                            mem[ceil32(ceil32(arg2.length)) + (6 * ceil32(return_data.size)) + 581 len 9 * ceil32(return_data.size)]
                                            mem[0] = uniswapV2RouterAddress
                                            mem[32] = sha3(address(this.address), 1)
                                            allowance[address(this.address)][stor9].field_0 = 0
                                            emit Approval(address arg1, address arg2, uint256 arg3):
                                                          0,
                                                          mem[ceil32(ceil32(arg2.length)) + (6 * ceil32(return_data.size)) + 481 len 9 * ceil32(return_data.size)],
                                                          this.address,
                                                          uniswapV2RouterAddress,
                                            mem[ceil32(ceil32(arg2.length)) + (6 * ceil32(return_data.size)) + 449] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                            mem[ceil32(ceil32(arg2.length)) + (6 * ceil32(return_data.size)) + 453] = 0
                                            mem[ceil32(ceil32(arg2.length)) + (6 * ceil32(return_data.size)) + 485] = 0
                                            mem[ceil32(ceil32(arg2.length)) + (6 * ceil32(return_data.size)) + 517] = 160
                                            mem[ceil32(ceil32(arg2.length)) + (6 * ceil32(return_data.size)) + 613] = 2
                                            idx = 0
                                            s = ceil32(ceil32(arg2.length)) + (6 * ceil32(return_data.size)) + 645
                                            t = ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + 385
                                            while idx < mem[ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + 353]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[ceil32(ceil32(arg2.length)) + (6 * ceil32(return_data.size)) + 549] = this.address
                                            mem[ceil32(ceil32(arg2.length)) + (6 * ceil32(return_data.size)) + 581] = block.timestamp
                                            require ext_code.size(uniswapV2RouterAddress)
                                            call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len ceil32(ceil32(arg2.length)) + (6 * ceil32(return_data.size)) + -mem[64] + 705]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _2279 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2279] = 30
                                            mem[_2279 + 32] = 'SafeMath: subtraction overflow'
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if eth.balance(this.address) < eth.balance(this.address):
                                                revert with 0, 17
                                            call distributionPoolAddress with:
                                                 gas 2300 wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _2504 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2504] = 30
                                            mem[_2504 + 32] = 'SafeMath: subtraction overflow'
                                            if not this.address:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not distributionPoolAddress:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            _2583 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_2583] = 38
                                            mem[_2583 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                            if 0 > balanceOf[address(this.address)]:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 38
                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_2583 + 70 len 26]
                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                            if balanceOf[address(this.address)] < 0:
                                                revert with 0, 17
                                            if balanceOf[stor12] > -1:
                                                revert with 0, 17
                                            if balanceOf[stor12] < balanceOf[stor12]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = distributionPoolAddress
                                            mem[32] = 0
                                            balanceOf[stor12] = balanceOf[stor12]
                                            emit Transfer(0, this.address, distributionPoolAddress);
                                            if balanceOf[this.address]:
                                                if balanceOf[this.address] and liquidityPoolFee > -1 / balanceOf[this.address]:
                                                    revert with 0, 17
                                                if not balanceOf[this.address]:
                                                    revert with 0, 18
                                                if balanceOf[this.address] * liquidityPoolFee / balanceOf[this.address] != liquidityPoolFee:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _2892 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_2892] = 26
                                                mem[_2892 + 32] = 'SafeMath: division by zero'
                                                _2923 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_2923] = 26
                                                mem[_2923 + 32] = 'SafeMath: division by zero'
                                                _2949 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_2949] = 30
                                                mem[_2949 + 32] = 'SafeMath: subtraction overflow'
                                                if balanceOf[this.address] * liquidityPoolFee / 100 / 2 > balanceOf[this.address] * liquidityPoolFee / 100:
                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                if balanceOf[this.address] * liquidityPoolFee / 100 < balanceOf[this.address] * liquidityPoolFee / 100 / 2:
                                                    revert with 0, 17
                                                _3047 = mem[64]
                                                mem[mem[64]] = 2
                                                mem[64] = mem[64] + 96
                                                mem[_3047 + 32 len 64] = call.data[calldata.size len 64]
                                                if 0 >= mem[_3047]:
                                                    revert with 0, 50
                                                mem[_3047 + 32] = this.address
                                                require ext_code.size(uniswapV2RouterAddress)
                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                        gas gas_remaining wei
                                                mem[_3047 + 96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[64] = _3047 + ceil32(return_data.size) + 96
                                                require return_data.size >= 32
                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                if 1 >= mem[_3047]:
                                                    revert with 0, 50
                                                mem[_3047 + 64] = ext_call.return_data[12 len 20]
                                                if not this.address:
                                                    revert with 0, 'ERC20: approve from the zero address'
                                                if not uniswapV2RouterAddress:
                                                    revert with 0, 'ERC20: approve to the zero address'
                                                mem[0] = uniswapV2RouterAddress
                                                mem[32] = sha3(address(this.address), 1)
                                                allowance[address(this.address)][stor9].field_0 = balanceOf[this.address] * liquidityPoolFee / 100 / 2
                                                allowance[address(this.address)][stor9].field_255 = 0
                                                emit Approval((balanceOf[this.address] * liquidityPoolFee / 100 / 2), this.address, uniswapV2RouterAddress);
                                                mem[_3047 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                mem[_3047 + ceil32(return_data.size) + 100] = balanceOf[this.address] * liquidityPoolFee / 100 / 2
                                                mem[_3047 + ceil32(return_data.size) + 132] = 0
                                                mem[_3047 + ceil32(return_data.size) + 164] = 160
                                                mem[_3047 + ceil32(return_data.size) + 260] = mem[_3047]
                                                idx = 0
                                                s = _3047 + ceil32(return_data.size) + 292
                                                t = _3047 + 32
                                                while idx < mem[_3047]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                require ext_code.size(uniswapV2RouterAddress)
                                                call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                     gas gas_remaining wei
                                                    args Mask(255, 1, balanceOf[this.address] * liquidityPoolFee / 100), 0, 160, address(this.address), block.timestamp, mem[_3047 + ceil32(return_data.size) + 260 len (32 * mem[_3047]) + 32]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[_3047 + ceil32(return_data.size) + 96] = 30
                                                mem[_3047 + ceil32(return_data.size) + 128] = 'SafeMath: subtraction overflow'
                                                if eth.balance(this.address) > eth.balance(this.address):
                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                if eth.balance(this.address) < eth.balance(this.address):
                                                    revert with 0, 17
                                                if not this.address:
                                                    revert with 0, 'ERC20: approve from the zero address'
                                                if not uniswapV2RouterAddress:
                                                    revert with 0, 'ERC20: approve to the zero address'
                                                allowance[address(this.address)][stor9].field_0 = (balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2)
                                                emit Approval(((balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2)), this.address, uniswapV2RouterAddress);
                                                mem[_3047 + ceil32(return_data.size) + 228] = 0
                                                mem[_3047 + ceil32(return_data.size) + 260] = 0
                                                mem[_3047 + ceil32(return_data.size) + 292] = 0
                                                mem[_3047 + ceil32(return_data.size) + 324] = block.timestamp
                                                require ext_code.size(uniswapV2RouterAddress)
                                                call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                     gas gas_remaining wei
                                                    args this.address, (balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2), 0, 0, 0, block.timestamp
                                                mem[_3047 + ceil32(return_data.size) + 160 len 96] = ext_call.return_data[0 len 96]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 96
                                                emit SwapAndLiquify(Mask(255, 1, balanceOf[this.address] * liquidityPoolFee / 100), 0, (balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2));
                                                mem[_3047 + (2 * ceil32(return_data.size)) + 160] = 2
                                                mem[_3047 + (2 * ceil32(return_data.size)) + 192] = this.address
                                                require ext_code.size(uniswapV2RouterAddress)
                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                        gas gas_remaining wei
                                                mem[_3047 + (2 * ceil32(return_data.size)) + 256] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                mem[_3047 + (2 * ceil32(return_data.size)) + 224] = ext_call.return_data[12 len 20]
                                                if not this.address:
                                                    revert with 0, 'ERC20: approve from the zero address'
                                                if not uniswapV2RouterAddress:
                                                    revert with 0, 'ERC20: approve to the zero address'
                                                allowance[address(this.address)][stor9].field_0 = balanceOf[this.address]
                                                emit Approval(balanceOf[this.address], this.address, uniswapV2RouterAddress);
                                                mem[_3047 + (4 * ceil32(return_data.size)) + 256] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                mem[_3047 + (4 * ceil32(return_data.size)) + 260] = balanceOf[this.address]
                                                mem[_3047 + (4 * ceil32(return_data.size)) + 292] = 0
                                                mem[_3047 + (4 * ceil32(return_data.size)) + 324] = 160
                                                mem[_3047 + (4 * ceil32(return_data.size)) + 420] = 2
                                                idx = 0
                                                s = _3047 + (4 * ceil32(return_data.size)) + 452
                                                t = _3047 + (2 * ceil32(return_data.size)) + 192
                                                while idx < mem[_3047 + (2 * ceil32(return_data.size)) + 160]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_3047 + (4 * ceil32(return_data.size)) + 356] = this.address
                                                mem[_3047 + (4 * ceil32(return_data.size)) + 388] = block.timestamp
                                                require ext_code.size(uniswapV2RouterAddress)
                                                call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                     gas gas_remaining wei
                                                    args balanceOf[this.address], 0, 160, address(this.address), block.timestamp, mem[_3047 + (4 * ceil32(return_data.size)) + 420 len (32 * mem[_3047 + (2 * ceil32(return_data.size)) + 160]) + 32]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[_3047 + (4 * ceil32(return_data.size)) + 256] = 30
                                                mem[_3047 + (4 * ceil32(return_data.size)) + 288] = 'SafeMath: subtraction overflow'
                                                if eth.balance(this.address) > eth.balance(this.address):
                                                    mem[_3047 + (4 * ceil32(return_data.size)) + 320] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[_3047 + (4 * ceil32(return_data.size)) + 324] = 32
                                                    mem[_3047 + (4 * ceil32(return_data.size)) + 356] = 30
                                                    mem[_3047 + (4 * ceil32(return_data.size)) + 388] = 'SafeMath: subtraction overflow'
                                                    mem[_3047 + (4 * ceil32(return_data.size)) + 418] = 0
                                                    revert with memory
                                                      from _3047 + (4 * ceil32(return_data.size)) + 320
                                                       len (5 * ceil32(return_data.size)) + 100
                                                if eth.balance(this.address) < eth.balance(this.address):
                                                    revert with 0, 17
                                                call marketingWalletAddress with:
                                                     gas 2300 wei
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                uint8(stor23.field_0) = 0
                                                if not msg.sender:
                                                    mem[_3047 + (4 * ceil32(return_data.size)) + 320] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[_3047 + (4 * ceil32(return_data.size)) + 324] = 32
                                                    mem[_3047 + (4 * ceil32(return_data.size)) + 356] = 37
                                                    mem[_3047 + (4 * ceil32(return_data.size)) + 388] = 'ERC20: transfer from the zero ad'
                                                    mem[_3047 + (4 * ceil32(return_data.size)) + 420] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                    revert with memory
                                                      from _3047 + (4 * ceil32(return_data.size)) + 320
                                                       len (5 * ceil32(return_data.size)) + 132
                                                if not this.address:
                                                    mem[_3047 + (4 * ceil32(return_data.size)) + 320] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[_3047 + (4 * ceil32(return_data.size)) + 324] = 32
                                                    mem[_3047 + (4 * ceil32(return_data.size)) + 356] = 35
                                                    mem[_3047 + (4 * ceil32(return_data.size)) + 388] = 'ERC20: transfer to the zero addr'
                                                    mem[_3047 + (4 * ceil32(return_data.size)) + 420] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                    revert with memory
                                                      from _3047 + (4 * ceil32(return_data.size)) + 320
                                                       len (5 * ceil32(return_data.size)) + 132
                                                mem[_3047 + (4 * ceil32(return_data.size)) + 320] = 38
                                                mem[_3047 + (4 * ceil32(return_data.size)) + 352 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                if ext_call.return_data[0] > balanceOf[address(msg.sender)]:
                                                    mem[_3047 + (4 * ceil32(return_data.size)) + 416] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[_3047 + (4 * ceil32(return_data.size)) + 420] = 32
                                                    mem[_3047 + (4 * ceil32(return_data.size)) + 452] = 38
                                                    mem[_3047 + (4 * ceil32(return_data.size)) + 484 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, Mask(208, 32, block.timestamp) >> 32
                                                    mem[_3047 + (4 * ceil32(return_data.size)) + 522] = 0
                                                    revert with memory
                                                      from _3047 + (4 * ceil32(return_data.size)) + 416
                                                       len (5 * ceil32(return_data.size)) + 132
                                                if balanceOf[address(msg.sender)] < ext_call.return_data[0]:
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] -= ext_call.return_data[0]
                                                if balanceOf[this.address] > !ext_call.return_data[0]:
                                                    revert with 0, 17
                                                if balanceOf[this.address] + ext_call.return_data[0] >= balanceOf[this.address]:
                                                    balanceOf[address(this.address)] = balanceOf[this.address] + ext_call.return_data[0]
                                                    emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                                    if arg1 >= 3:
                                                        revert with 0, 50
                                                    mem[_3047 + (4 * ceil32(return_data.size)) + 416] = 0x12b8603f00000000000000000000000000000000000000000000000000000000
                                                    mem[_3047 + (4 * ceil32(return_data.size)) + 420] = msg.sender
                                                    mem[_3047 + (4 * ceil32(return_data.size)) + 452] = 64
                                                    mem[_3047 + (4 * ceil32(return_data.size)) + 484] = mem[128]
                                                    mem[_3047 + (4 * ceil32(return_data.size)) + 516 len ceil32(mem[128])] = mem[160 len ceil32(mem[128])]
                                                    if ceil32(mem[128]) > mem[128]:
                                                        mem[_3047 + (4 * ceil32(return_data.size)) + mem[128] + 516] = 0
                                                    require ext_code.size(sub_20eea8b5[arg1])
                                                    call sub_20eea8b5[arg1].createNode(address arg1, string arg2) with:
                                                         gas gas_remaining wei
                                                        args mem[_3047 + (4 * ceil32(return_data.size)) + 420 len ceil32(mem[128]) + (5 * ceil32(return_data.size)) + 96]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if stor27[address(msg.sender)] > -2:
                                                        revert with 0, 17
                                                    if stor27[address(msg.sender)] + 1 >= stor27[address(msg.sender)]:
                                                        stor27[address(msg.sender)]++
                                                mem[_3047 + (4 * ceil32(return_data.size)) + 416] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[_3047 + (4 * ceil32(return_data.size)) + 420] = 32
                                                mem[_3047 + (4 * ceil32(return_data.size)) + 452] = 27
                                                mem[_3047 + (4 * ceil32(return_data.size)) + 484] = 'SafeMath: addition overflow'
                                                revert with memory
                                                  from _3047 + (4 * ceil32(return_data.size)) + 416
                                                   len (5 * ceil32(return_data.size)) + 100
                                            _2842 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2842] = 26
                                            mem[_2842 + 32] = 'SafeMath: division by zero'
                                            _2906 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2906] = 26
                                            mem[_2906 + 32] = 'SafeMath: division by zero'
                                            _2933 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2933] = 30
                                            mem[_2933 + 32] = 'SafeMath: subtraction overflow'
                                            _2964 = mem[64]
                                            mem[mem[64]] = 2
                                            mem[64] = mem[64] + 96
                                            mem[_2964 + 32 len 64] = call.data[calldata.size len 64]
                                            if 0 >= mem[_2964]:
                                                revert with 0, 50
                                            mem[_2964 + 32] = this.address
                                            require ext_code.size(uniswapV2RouterAddress)
                                            staticcall uniswapV2RouterAddress.WAVAX() with:
                                                    gas gas_remaining wei
                                            mem[_2964 + 96] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[64] = _2964 + ceil32(return_data.size) + 96
                                            require return_data.size >= 32
                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                            if 1 >= mem[_2964]:
                                                revert with 0, 50
                                            mem[_2964 + 64] = ext_call.return_data[12 len 20]
                                            if not this.address:
                                                revert with 0, 'ERC20: approve from the zero address'
                                            if not uniswapV2RouterAddress:
                                                revert with 0, 'ERC20: approve to the zero address'
                                            mem[0] = uniswapV2RouterAddress
                                            mem[32] = sha3(address(this.address), 1)
                                            allowance[address(this.address)][stor9].field_0 = 0
                                            emit Approval(0, this.address, uniswapV2RouterAddress);
                                            mem[_2964 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                            mem[_2964 + ceil32(return_data.size) + 100] = 0
                                            mem[_2964 + ceil32(return_data.size) + 132] = 0
                                            mem[_2964 + ceil32(return_data.size) + 164] = 160
                                            mem[_2964 + ceil32(return_data.size) + 260] = mem[_2964]
                                            idx = 0
                                            s = _2964 + ceil32(return_data.size) + 292
                                            t = _2964 + 32
                                            while idx < mem[_2964]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_2964 + ceil32(return_data.size) + 196] = this.address
                                            mem[_2964 + ceil32(return_data.size) + 228] = block.timestamp
                                            require ext_code.size(uniswapV2RouterAddress)
                                            call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _2964 + ceil32(return_data.size) + (32 * mem[_2964]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5329 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5329] = 30
                                            mem[_5329 + 32] = 'SafeMath: subtraction overflow'
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if eth.balance(this.address) < eth.balance(this.address):
                                                revert with 0, 17
                                            if not this.address:
                                                revert with 0, 'ERC20: approve from the zero address'
                                            if not uniswapV2RouterAddress:
                                                revert with 0, 'ERC20: approve to the zero address'
                                            mem[0] = uniswapV2RouterAddress
                                            mem[32] = sha3(address(this.address), 1)
                                            allowance[address(this.address)][stor9].field_0 = 0
                                            emit Approval(0, this.address, uniswapV2RouterAddress);
                                            mem[mem[64] + 68] = 0
                                            mem[mem[64] + 100] = 0
                                            mem[mem[64] + 132] = 0
                                            mem[mem[64] + 164] = block.timestamp
                                            require ext_code.size(uniswapV2RouterAddress)
                                            call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                 gas gas_remaining wei
                                                args this.address, 0, 0, 0, 0, block.timestamp
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 96
                                            mem[mem[64] + 32] = 0
                                            mem[mem[64] + 64] = 0
                                            emit SwapAndLiquify(uint256 arg1, uint256 arg2, uint256 arg3):
                                                                0,
                                            mem[0] = this.address
                                            mem[32] = 0
                                            _5859 = mem[64]
                                            mem[mem[64]] = 2
                                            mem[64] = mem[64] + 96
                                            mem[_5859 + 32 len 64] = call.data[calldata.size len 64]
                                            if 0 >= mem[_5859]:
                                                revert with 0, 50
                                            mem[_5859 + 32] = this.address
                                            require ext_code.size(uniswapV2RouterAddress)
                                            staticcall uniswapV2RouterAddress.WAVAX() with:
                                                    gas gas_remaining wei
                                            mem[_5859 + 96] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[64] = _5859 + ceil32(return_data.size) + 96
                                            require return_data.size >= 32
                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                            if 1 >= mem[_5859]:
                                                revert with 0, 50
                                            mem[_5859 + 64] = ext_call.return_data[12 len 20]
                                            if not this.address:
                                                revert with 0, 'ERC20: approve from the zero address'
                                            if not uniswapV2RouterAddress:
                                                revert with 0, 'ERC20: approve to the zero address'
                                            mem[0] = uniswapV2RouterAddress
                                            mem[32] = sha3(address(this.address), 1)
                                            allowance[address(this.address)][stor9].field_0 = balanceOf[this.address]
                                            emit Approval(balanceOf[this.address], this.address, uniswapV2RouterAddress);
                                            mem[_5859 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                            mem[_5859 + ceil32(return_data.size) + 100] = balanceOf[this.address]
                                            mem[_5859 + ceil32(return_data.size) + 132] = 0
                                            mem[_5859 + ceil32(return_data.size) + 164] = 160
                                            mem[_5859 + ceil32(return_data.size) + 260] = mem[_5859]
                                            idx = 0
                                            s = _5859 + ceil32(return_data.size) + 292
                                            t = _5859 + 32
                                            while idx < mem[_5859]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5859 + ceil32(return_data.size) + 196] = this.address
                                            mem[_5859 + ceil32(return_data.size) + 228] = block.timestamp
                                            require ext_code.size(uniswapV2RouterAddress)
                                            call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5859 + ceil32(return_data.size) + (32 * mem[_5859]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8751 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8751] = 30
                                            mem[_8751 + 32] = 'SafeMath: subtraction overflow'
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if eth.balance(this.address) < eth.balance(this.address):
                                                revert with 0, 17
                                            call marketingWalletAddress with:
                                                 gas 2300 wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            uint8(stor23.field_0) = 0
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not this.address:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            _9103 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_9103] = 38
                                            mem[_9103 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                            if ext_call.return_data[0] > balanceOf[address(msg.sender)]:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 38
                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_9103 + 70 len 26]
                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                            if balanceOf[address(msg.sender)] < ext_call.return_data[0]:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] -= ext_call.return_data[0]
                                            if balanceOf[this.address] > !ext_call.return_data[0]:
                                                revert with 0, 17
                                            if balanceOf[this.address] + ext_call.return_data[0] < balanceOf[this.address]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(this.address)] = balanceOf[this.address] + ext_call.return_data[0]
                                            emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                            if arg1 >= 3:
                                                revert with 0, 50
                                            mem[mem[64]] = 0x12b8603f00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 64
                                            mem[mem[64] + 68] = mem[128]
                                            mem[mem[64] + 100 len ceil32(mem[128])] = mem[160 len ceil32(mem[128])]
                                            if ceil32(mem[128]) > mem[128]:
                                                mem[mem[64] + mem[128] + 100] = 0
                                            require ext_code.size(sub_20eea8b5[arg1])
                                            call sub_20eea8b5[arg1].createNode(address arg1, string arg2) with:
                                                 gas gas_remaining wei
                                                args msg.sender, Array(len=mem[128], data=mem[mem[64] + 100 len ceil32(mem[128])])
                                        else:
                                            if balanceOf[this.address] and rewardsFee > -1 / balanceOf[this.address]:
                                                revert with 0, 17
                                            if not balanceOf[this.address]:
                                                revert with 0, 18
                                            if balanceOf[this.address] * rewardsFee / balanceOf[this.address] != rewardsFee:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + 225] = 26
                                            mem[ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + 257] = 'SafeMath: division by zero'
                                            if not balanceOf[this.address] * rewardsFee / 100:
                                                mem[ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + 289] = 26
                                                mem[ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + 321] = 'SafeMath: division by zero'
                                                mem[ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + 353] = 2
                                                mem[ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + 385] = this.address
                                                require ext_code.size(uniswapV2RouterAddress)
                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                        gas gas_remaining wei
                                                mem[ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + 449] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[64] = ceil32(ceil32(arg2.length)) + (6 * ceil32(return_data.size)) + 449
                                                require return_data.size >= 32
                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                mem[ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + 417] = ext_call.return_data[12 len 20]
                                                if not this.address:
                                                    revert with 0, 
                                                                'ERC20: approve from the zero address',
                                                                mem[ceil32(ceil32(arg2.length)) + (6 * ceil32(return_data.size)) + 581 len 9 * ceil32(return_data.size)]
                                                if not uniswapV2RouterAddress:
                                                    revert with 0, 
                                                                'ERC20: approve to the zero address',
                                                                mem[ceil32(ceil32(arg2.length)) + (6 * ceil32(return_data.size)) + 581 len 9 * ceil32(return_data.size)]
                                                mem[0] = uniswapV2RouterAddress
                                                mem[32] = sha3(address(this.address), 1)
                                                allowance[address(this.address)][stor9].field_0 = 0
                                                emit Approval(address arg1, address arg2, uint256 arg3):
                                                              0,
                                                              mem[ceil32(ceil32(arg2.length)) + (6 * ceil32(return_data.size)) + 481 len 9 * ceil32(return_data.size)],
                                                              this.address,
                                                              uniswapV2RouterAddress,
                                                mem[ceil32(ceil32(arg2.length)) + (6 * ceil32(return_data.size)) + 449] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                mem[ceil32(ceil32(arg2.length)) + (6 * ceil32(return_data.size)) + 453] = 0
                                                mem[ceil32(ceil32(arg2.length)) + (6 * ceil32(return_data.size)) + 485] = 0
                                                mem[ceil32(ceil32(arg2.length)) + (6 * ceil32(return_data.size)) + 517] = 160
                                                mem[ceil32(ceil32(arg2.length)) + (6 * ceil32(return_data.size)) + 613] = 2
                                                idx = 0
                                                s = ceil32(ceil32(arg2.length)) + (6 * ceil32(return_data.size)) + 645
                                                t = ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + 385
                                                while idx < mem[ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + 353]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[ceil32(ceil32(arg2.length)) + (6 * ceil32(return_data.size)) + 549] = this.address
                                                mem[ceil32(ceil32(arg2.length)) + (6 * ceil32(return_data.size)) + 581] = block.timestamp
                                                require ext_code.size(uniswapV2RouterAddress)
                                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len ceil32(ceil32(arg2.length)) + (6 * ceil32(return_data.size)) + -mem[64] + 705]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _2278 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_2278] = 30
                                                mem[_2278 + 32] = 'SafeMath: subtraction overflow'
                                                if eth.balance(this.address) > eth.balance(this.address):
                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                if eth.balance(this.address) < eth.balance(this.address):
                                                    revert with 0, 17
                                                call distributionPoolAddress with:
                                                     gas 2300 wei
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _2502 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_2502] = 30
                                                mem[_2502 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > balanceOf[this.address] * rewardsFee / 100:
                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                if balanceOf[this.address] * rewardsFee / 100 < 0:
                                                    revert with 0, 17
                                                if not this.address:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not distributionPoolAddress:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                _2579 = mem[64]
                                                mem[64] = mem[64] + 96
                                                mem[_2579] = 38
                                                mem[_2579 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                if balanceOf[this.address] * rewardsFee / 100 > balanceOf[address(this.address)]:
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 38
                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_2579 + 70 len 26]
                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                if balanceOf[address(this.address)] < balanceOf[this.address] * rewardsFee / 100:
                                                    revert with 0, 17
                                                balanceOf[address(this.address)] -= balanceOf[this.address] * rewardsFee / 100
                                                if balanceOf[stor12] > !(balanceOf[this.address] * rewardsFee / 100):
                                                    revert with 0, 17
                                                if balanceOf[stor12] + (balanceOf[this.address] * rewardsFee / 100) < balanceOf[stor12]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = distributionPoolAddress
                                                mem[32] = 0
                                                balanceOf[stor12] += balanceOf[this.address] * rewardsFee / 100
                                                emit Transfer((balanceOf[this.address] * rewardsFee / 100), this.address, distributionPoolAddress);
                                                if balanceOf[this.address]:
                                                    if balanceOf[this.address] and liquidityPoolFee > -1 / balanceOf[this.address]:
                                                        revert with 0, 17
                                                    if not balanceOf[this.address]:
                                                        revert with 0, 18
                                                    if balanceOf[this.address] * liquidityPoolFee / balanceOf[this.address] != liquidityPoolFee:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    _2891 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_2891] = 26
                                                    mem[_2891 + 32] = 'SafeMath: division by zero'
                                                    _2922 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_2922] = 26
                                                    mem[_2922 + 32] = 'SafeMath: division by zero'
                                                    _2948 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_2948] = 30
                                                    mem[_2948 + 32] = 'SafeMath: subtraction overflow'
                                                    if balanceOf[this.address] * liquidityPoolFee / 100 / 2 > balanceOf[this.address] * liquidityPoolFee / 100:
                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                    if balanceOf[this.address] * liquidityPoolFee / 100 < balanceOf[this.address] * liquidityPoolFee / 100 / 2:
                                                        revert with 0, 17
                                                    _3045 = mem[64]
                                                    mem[mem[64]] = 2
                                                    mem[64] = mem[64] + 96
                                                    mem[_3045 + 32 len 64] = call.data[calldata.size len 64]
                                                    if 0 >= mem[_3045]:
                                                        revert with 0, 50
                                                    mem[_3045 + 32] = this.address
                                                    require ext_code.size(uniswapV2RouterAddress)
                                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                                            gas gas_remaining wei
                                                    mem[_3045 + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[64] = _3045 + ceil32(return_data.size) + 96
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                    if 1 >= mem[_3045]:
                                                        revert with 0, 50
                                                    mem[_3045 + 64] = ext_call.return_data[12 len 20]
                                                    if not this.address:
                                                        revert with 0, 'ERC20: approve from the zero address'
                                                    if not uniswapV2RouterAddress:
                                                        revert with 0, 'ERC20: approve to the zero address'
                                                    mem[0] = uniswapV2RouterAddress
                                                    mem[32] = sha3(address(this.address), 1)
                                                    allowance[address(this.address)][stor9].field_0 = balanceOf[this.address] * liquidityPoolFee / 100 / 2
                                                    allowance[address(this.address)][stor9].field_255 = 0
                                                    emit Approval((balanceOf[this.address] * liquidityPoolFee / 100 / 2), this.address, uniswapV2RouterAddress);
                                                    mem[_3045 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                    mem[_3045 + ceil32(return_data.size) + 100] = balanceOf[this.address] * liquidityPoolFee / 100 / 2
                                                    mem[_3045 + ceil32(return_data.size) + 132] = 0
                                                    mem[_3045 + ceil32(return_data.size) + 164] = 160
                                                    mem[_3045 + ceil32(return_data.size) + 260] = mem[_3045]
                                                    idx = 0
                                                    s = _3045 + ceil32(return_data.size) + 292
                                                    t = _3045 + 32
                                                    while idx < mem[_3045]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    require ext_code.size(uniswapV2RouterAddress)
                                                    call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args Mask(255, 1, balanceOf[this.address] * liquidityPoolFee / 100), 0, 160, address(this.address), block.timestamp, mem[_3045 + ceil32(return_data.size) + 260 len (32 * mem[_3045]) + 32]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[_3045 + ceil32(return_data.size) + 96] = 30
                                                    mem[_3045 + ceil32(return_data.size) + 128] = 'SafeMath: subtraction overflow'
                                                    if eth.balance(this.address) > eth.balance(this.address):
                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                    if eth.balance(this.address) < eth.balance(this.address):
                                                        revert with 0, 17
                                                    if not this.address:
                                                        revert with 0, 'ERC20: approve from the zero address'
                                                    if not uniswapV2RouterAddress:
                                                        revert with 0, 'ERC20: approve to the zero address'
                                                    allowance[address(this.address)][stor9].field_0 = (balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2)
                                                    emit Approval(((balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2)), this.address, uniswapV2RouterAddress);
                                                    mem[_3045 + ceil32(return_data.size) + 228] = 0
                                                    mem[_3045 + ceil32(return_data.size) + 260] = 0
                                                    mem[_3045 + ceil32(return_data.size) + 292] = 0
                                                    mem[_3045 + ceil32(return_data.size) + 324] = block.timestamp
                                                    require ext_code.size(uniswapV2RouterAddress)
                                                    call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                         gas gas_remaining wei
                                                        args this.address, (balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2), 0, 0, 0, block.timestamp
                                                    mem[_3045 + ceil32(return_data.size) + 160 len 96] = ext_call.return_data[0 len 96]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 96
                                                    emit SwapAndLiquify(Mask(255, 1, balanceOf[this.address] * liquidityPoolFee / 100), 0, (balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2));
                                                    mem[_3045 + (2 * ceil32(return_data.size)) + 160] = 2
                                                    mem[_3045 + (2 * ceil32(return_data.size)) + 192] = this.address
                                                    require ext_code.size(uniswapV2RouterAddress)
                                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                                            gas gas_remaining wei
                                                    mem[_3045 + (2 * ceil32(return_data.size)) + 256] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                    mem[_3045 + (2 * ceil32(return_data.size)) + 224] = ext_call.return_data[12 len 20]
                                                    if not this.address:
                                                        revert with 0, 'ERC20: approve from the zero address'
                                                    if not uniswapV2RouterAddress:
                                                        revert with 0, 'ERC20: approve to the zero address'
                                                    allowance[address(this.address)][stor9].field_0 = balanceOf[this.address]
                                                    emit Approval(balanceOf[this.address], this.address, uniswapV2RouterAddress);
                                                    mem[_3045 + (4 * ceil32(return_data.size)) + 256] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                    mem[_3045 + (4 * ceil32(return_data.size)) + 260] = balanceOf[this.address]
                                                    mem[_3045 + (4 * ceil32(return_data.size)) + 292] = 0
                                                    mem[_3045 + (4 * ceil32(return_data.size)) + 324] = 160
                                                    mem[_3045 + (4 * ceil32(return_data.size)) + 420] = 2
                                                    idx = 0
                                                    s = _3045 + (4 * ceil32(return_data.size)) + 452
                                                    t = _3045 + (2 * ceil32(return_data.size)) + 192
                                                    while idx < mem[_3045 + (2 * ceil32(return_data.size)) + 160]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_3045 + (4 * ceil32(return_data.size)) + 356] = this.address
                                                    mem[_3045 + (4 * ceil32(return_data.size)) + 388] = block.timestamp
                                                    require ext_code.size(uniswapV2RouterAddress)
                                                    call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args balanceOf[this.address], 0, 160, address(this.address), block.timestamp, mem[_3045 + (4 * ceil32(return_data.size)) + 420 len (32 * mem[_3045 + (2 * ceil32(return_data.size)) + 160]) + 32]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[_3045 + (4 * ceil32(return_data.size)) + 256] = 30
                                                    mem[_3045 + (4 * ceil32(return_data.size)) + 288] = 'SafeMath: subtraction overflow'
                                                    if eth.balance(this.address) > eth.balance(this.address):
                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                    if eth.balance(this.address) < eth.balance(this.address):
                                                        revert with 0, 17
                                                    call marketingWalletAddress with:
                                                         gas 2300 wei
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    uint8(stor23.field_0) = 0
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not this.address:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    mem[_3045 + (4 * ceil32(return_data.size)) + 320] = 38
                                                    mem[_3045 + (4 * ceil32(return_data.size)) + 352 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                    if ext_call.return_data[0] > balanceOf[address(msg.sender)]:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, Mask(208, 32, block.timestamp) >> 32 >> 48,
                                                                    0
                                                    if balanceOf[address(msg.sender)] < ext_call.return_data[0]:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] -= ext_call.return_data[0]
                                                    if balanceOf[this.address] > !ext_call.return_data[0]:
                                                        revert with 0, 17
                                                    if balanceOf[this.address] + ext_call.return_data[0] < balanceOf[this.address]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(this.address)] = balanceOf[this.address] + ext_call.return_data[0]
                                                    emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                                    if arg1 >= 3:
                                                        revert with 0, 50
                                                    mem[_3045 + (4 * ceil32(return_data.size)) + 416] = 0x12b8603f00000000000000000000000000000000000000000000000000000000
                                                    mem[_3045 + (4 * ceil32(return_data.size)) + 420] = msg.sender
                                                    mem[_3045 + (4 * ceil32(return_data.size)) + 452] = 64
                                                    mem[_3045 + (4 * ceil32(return_data.size)) + 484] = mem[128]
                                                    mem[_3045 + (4 * ceil32(return_data.size)) + 516 len ceil32(mem[128])] = mem[160 len ceil32(mem[128])]
                                                    if ceil32(mem[128]) > mem[128]:
                                                        mem[_3045 + (4 * ceil32(return_data.size)) + mem[128] + 516] = 0
                                                    require ext_code.size(sub_20eea8b5[arg1])
                                                    call sub_20eea8b5[arg1].createNode(address arg1, string arg2) with:
                                                         gas gas_remaining wei
                                                        args msg.sender, Array(len=mem[128], data=mem[_3045 + (4 * ceil32(return_data.size)) + 516 len ceil32(mem[128])])
                                                else:
                                                    _2841 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_2841] = 26
                                                    mem[_2841 + 32] = 'SafeMath: division by zero'
                                                    _2905 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_2905] = 26
                                                    mem[_2905 + 32] = 'SafeMath: division by zero'
                                                    _2932 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_2932] = 30
                                                    mem[_2932 + 32] = 'SafeMath: subtraction overflow'
                                                    _2961 = mem[64]
                                                    mem[mem[64]] = 2
                                                    mem[64] = mem[64] + 96
                                                    mem[_2961 + 32 len 64] = call.data[calldata.size len 64]
                                                    if 0 >= mem[_2961]:
                                                        revert with 0, 50
                                                    mem[_2961 + 32] = this.address
                                                    require ext_code.size(uniswapV2RouterAddress)
                                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                                            gas gas_remaining wei
                                                    mem[_2961 + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[64] = _2961 + ceil32(return_data.size) + 96
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                    if 1 >= mem[_2961]:
                                                        revert with 0, 50
                                                    mem[_2961 + 64] = ext_call.return_data[12 len 20]
                                                    if not this.address:
                                                        revert with 0, 'ERC20: approve from the zero address'
                                                    if not uniswapV2RouterAddress:
                                                        revert with 0, 'ERC20: approve to the zero address'
                                                    mem[0] = uniswapV2RouterAddress
                                                    mem[32] = sha3(address(this.address), 1)
                                                    allowance[address(this.address)][stor9].field_0 = 0
                                                    emit Approval(0, this.address, uniswapV2RouterAddress);
                                                    mem[_2961 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                    mem[_2961 + ceil32(return_data.size) + 100] = 0
                                                    mem[_2961 + ceil32(return_data.size) + 132] = 0
                                                    mem[_2961 + ceil32(return_data.size) + 164] = 160
                                                    mem[_2961 + ceil32(return_data.size) + 260] = mem[_2961]
                                                    idx = 0
                                                    s = _2961 + ceil32(return_data.size) + 292
                                                    t = _2961 + 32
                                                    while idx < mem[_2961]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_2961 + ceil32(return_data.size) + 196] = this.address
                                                    mem[_2961 + ceil32(return_data.size) + 228] = block.timestamp
                                                    require ext_code.size(uniswapV2RouterAddress)
                                                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _2961 + ceil32(return_data.size) + (32 * mem[_2961]) + -mem[64] + 288]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _5327 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_5327] = 30
                                                    mem[_5327 + 32] = 'SafeMath: subtraction overflow'
                                                    if eth.balance(this.address) > eth.balance(this.address):
                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                    if eth.balance(this.address) < eth.balance(this.address):
                                                        revert with 0, 17
                                                    if not this.address:
                                                        revert with 0, 'ERC20: approve from the zero address'
                                                    if not uniswapV2RouterAddress:
                                                        revert with 0, 'ERC20: approve to the zero address'
                                                    mem[0] = uniswapV2RouterAddress
                                                    mem[32] = sha3(address(this.address), 1)
                                                    allowance[address(this.address)][stor9].field_0 = 0
                                                    emit Approval(0, this.address, uniswapV2RouterAddress);
                                                    mem[mem[64] + 68] = 0
                                                    mem[mem[64] + 100] = 0
                                                    mem[mem[64] + 132] = 0
                                                    mem[mem[64] + 164] = block.timestamp
                                                    require ext_code.size(uniswapV2RouterAddress)
                                                    call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                         gas gas_remaining wei
                                                        args this.address, 0, 0, 0, 0, block.timestamp
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 96
                                                    mem[mem[64] + 32] = 0
                                                    mem[mem[64] + 64] = 0
                                                    emit SwapAndLiquify(uint256 arg1, uint256 arg2, uint256 arg3):
                                                                        0,
                                                    mem[0] = this.address
                                                    mem[32] = 0
                                                    _5855 = mem[64]
                                                    mem[mem[64]] = 2
                                                    mem[64] = mem[64] + 96
                                                    mem[_5855 + 32 len 64] = call.data[calldata.size len 64]
                                                    if 0 >= mem[_5855]:
                                                        revert with 0, 50
                                                    mem[_5855 + 32] = this.address
                                                    require ext_code.size(uniswapV2RouterAddress)
                                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                                            gas gas_remaining wei
                                                    mem[_5855 + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[64] = _5855 + ceil32(return_data.size) + 96
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                    if 1 >= mem[_5855]:
                                                        revert with 0, 50
                                                    mem[_5855 + 64] = ext_call.return_data[12 len 20]
                                                    if not this.address:
                                                        revert with 0, 'ERC20: approve from the zero address'
                                                    if not uniswapV2RouterAddress:
                                                        revert with 0, 'ERC20: approve to the zero address'
                                                    mem[0] = uniswapV2RouterAddress
                                                    mem[32] = sha3(address(this.address), 1)
                                                    allowance[address(this.address)][stor9].field_0 = balanceOf[this.address]
                                                    emit Approval(balanceOf[this.address], this.address, uniswapV2RouterAddress);
                                                    mem[_5855 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                    mem[_5855 + ceil32(return_data.size) + 100] = balanceOf[this.address]
                                                    mem[_5855 + ceil32(return_data.size) + 132] = 0
                                                    mem[_5855 + ceil32(return_data.size) + 164] = 160
                                                    mem[_5855 + ceil32(return_data.size) + 260] = mem[_5855]
                                                    idx = 0
                                                    s = _5855 + ceil32(return_data.size) + 292
                                                    t = _5855 + 32
                                                    while idx < mem[_5855]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_5855 + ceil32(return_data.size) + 228] = block.timestamp
                                                    require ext_code.size(uniswapV2RouterAddress)
                                                    call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args balanceOf[this.address], 0, 160, address(this.address), block.timestamp, mem[_5855 + ceil32(return_data.size) + 260 len (32 * mem[_5855]) + 32]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[_5855 + ceil32(return_data.size) + 96] = 30
                                                    mem[_5855 + ceil32(return_data.size) + 128] = 'SafeMath: subtraction overflow'
                                                    if eth.balance(this.address) > eth.balance(this.address):
                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                    if eth.balance(this.address) < eth.balance(this.address):
                                                        revert with 0, 17
                                                    call marketingWalletAddress with:
                                                         gas 2300 wei
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    uint8(stor23.field_0) = 0
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not this.address:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    mem[_5855 + ceil32(return_data.size) + 160] = 38
                                                    mem[_5855 + ceil32(return_data.size) + 192 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                    if ext_call.return_data[0] > balanceOf[address(msg.sender)]:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, Mask(208, 32, block.timestamp) >> 32 >> 48,
                                                                    0
                                                    if balanceOf[address(msg.sender)] < ext_call.return_data[0]:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] -= ext_call.return_data[0]
                                                    if balanceOf[this.address] > !ext_call.return_data[0]:
                                                        revert with 0, 17
                                                    if balanceOf[this.address] + ext_call.return_data[0] < balanceOf[this.address]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(this.address)] = balanceOf[this.address] + ext_call.return_data[0]
                                                    emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                                    if arg1 >= 3:
                                                        revert with 0, 50
                                                    mem[_5855 + ceil32(return_data.size) + 256] = 0x12b8603f00000000000000000000000000000000000000000000000000000000
                                                    mem[_5855 + ceil32(return_data.size) + 260] = msg.sender
                                                    mem[_5855 + ceil32(return_data.size) + 292] = 64
                                                    mem[_5855 + ceil32(return_data.size) + 324] = mem[128]
                                                    mem[_5855 + ceil32(return_data.size) + 356 len ceil32(mem[128])] = mem[160 len ceil32(mem[128])]
                                                    if ceil32(mem[128]) > mem[128]:
                                                        mem[_5855 + ceil32(return_data.size) + mem[128] + 356] = 0
                                                    require ext_code.size(sub_20eea8b5[arg1])
                                                    call sub_20eea8b5[arg1].createNode(address arg1, string arg2) with:
                                                         gas gas_remaining wei
                                                        args msg.sender, Array(len=mem[128], data=mem[_5855 + ceil32(return_data.size) + 356 len ceil32(mem[128])])
                                            else:
                                                if balanceOf[this.address] * rewardsFee / 100 and stor22 > -1 / balanceOf[this.address] * rewardsFee / 100:
                                                    revert with 0, 17
                                                if not balanceOf[this.address] * rewardsFee / 100:
                                                    revert with 0, 18
                                                if balanceOf[this.address] * rewardsFee / 100 * stor22 / balanceOf[this.address] * rewardsFee / 100 != stor22:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                mem[ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + 289] = 26
                                                mem[ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + 321] = 'SafeMath: division by zero'
                                                mem[ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + 353] = 2
                                                mem[ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + 385] = this.address
                                                require ext_code.size(uniswapV2RouterAddress)
                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                        gas gas_remaining wei
                                                mem[ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + 449] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[64] = ceil32(ceil32(arg2.length)) + (6 * ceil32(return_data.size)) + 449
                                                require return_data.size >= 32
                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                mem[ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + 417] = ext_call.return_data[12 len 20]
                                                if not this.address:
                                                    revert with 0, 
                                                                'ERC20: approve from the zero address',
                                                                mem[ceil32(ceil32(arg2.length)) + (6 * ceil32(return_data.size)) + 581 len 9 * ceil32(return_data.size)]
                                                if not uniswapV2RouterAddress:
                                                    revert with 0, 
                                                                'ERC20: approve to the zero address',
                                                                mem[ceil32(ceil32(arg2.length)) + (6 * ceil32(return_data.size)) + 581 len 9 * ceil32(return_data.size)]
                                                mem[0] = uniswapV2RouterAddress
                                                mem[32] = sha3(address(this.address), 1)
                                                allowance[address(this.address)][stor9].field_0 = balanceOf[this.address] * rewardsFee / 100 * stor22 / 100
                                                emit Approval(address arg1, address arg2, uint256 arg3):
                                                              balanceOf[this.address] * rewardsFee / 100 * stor22 / 100,
                                                              mem[ceil32(ceil32(arg2.length)) + (6 * ceil32(return_data.size)) + 481 len 9 * ceil32(return_data.size)],
                                                              this.address,
                                                              uniswapV2RouterAddress,
                                                mem[ceil32(ceil32(arg2.length)) + (6 * ceil32(return_data.size)) + 449] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                mem[ceil32(ceil32(arg2.length)) + (6 * ceil32(return_data.size)) + 453] = balanceOf[this.address] * rewardsFee / 100 * stor22 / 100
                                                mem[ceil32(ceil32(arg2.length)) + (6 * ceil32(return_data.size)) + 485] = 0
                                                mem[ceil32(ceil32(arg2.length)) + (6 * ceil32(return_data.size)) + 517] = 160
                                                mem[ceil32(ceil32(arg2.length)) + (6 * ceil32(return_data.size)) + 613] = 2
                                                idx = 0
                                                s = ceil32(ceil32(arg2.length)) + (6 * ceil32(return_data.size)) + 645
                                                t = ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + 385
                                                while idx < mem[ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + 353]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[ceil32(ceil32(arg2.length)) + (6 * ceil32(return_data.size)) + 549] = this.address
                                                mem[ceil32(ceil32(arg2.length)) + (6 * ceil32(return_data.size)) + 581] = block.timestamp
                                                require ext_code.size(uniswapV2RouterAddress)
                                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len ceil32(ceil32(arg2.length)) + (6 * ceil32(return_data.size)) + -mem[64] + 705]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _2277 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_2277] = 30
                                                mem[_2277 + 32] = 'SafeMath: subtraction overflow'
                                                if eth.balance(this.address) > eth.balance(this.address):
                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                if eth.balance(this.address) < eth.balance(this.address):
                                                    revert with 0, 17
                                                call distributionPoolAddress with:
                                                     gas 2300 wei
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _2500 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_2500] = 30
                                                mem[_2500 + 32] = 'SafeMath: subtraction overflow'
                                                if balanceOf[this.address] * rewardsFee / 100 * stor22 / 100 > balanceOf[this.address] * rewardsFee / 100:
                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                if balanceOf[this.address] * rewardsFee / 100 < balanceOf[this.address] * rewardsFee / 100 * stor22 / 100:
                                                    revert with 0, 17
                                                if not this.address:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not distributionPoolAddress:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                _2575 = mem[64]
                                                mem[64] = mem[64] + 96
                                                mem[_2575] = 38
                                                mem[_2575 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                if (balanceOf[this.address] * rewardsFee / 100) - (balanceOf[this.address] * rewardsFee / 100 * stor22 / 100) > balanceOf[address(this.address)]:
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 38
                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_2575 + 70 len 26]
                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                if balanceOf[address(this.address)] < (balanceOf[this.address] * rewardsFee / 100) - (balanceOf[this.address] * rewardsFee / 100 * stor22 / 100):
                                                    revert with 0, 17
                                                balanceOf[address(this.address)] = balanceOf[address(this.address)] - (balanceOf[this.address] * rewardsFee / 100) + (balanceOf[this.address] * rewardsFee / 100 * stor22 / 100)
                                                if balanceOf[stor12] > !((balanceOf[this.address] * rewardsFee / 100) - (balanceOf[this.address] * rewardsFee / 100 * stor22 / 100)):
                                                    revert with 0, 17
                                                if balanceOf[stor12] + (balanceOf[this.address] * rewardsFee / 100) - (balanceOf[this.address] * rewardsFee / 100 * stor22 / 100) < balanceOf[stor12]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = distributionPoolAddress
                                                mem[32] = 0
                                                balanceOf[stor12] = balanceOf[stor12] + (balanceOf[this.address] * rewardsFee / 100) - (balanceOf[this.address] * rewardsFee / 100 * stor22 / 100)
                                                emit Transfer(((balanceOf[this.address] * rewardsFee / 100) - (balanceOf[this.address] * rewardsFee / 100 * stor22 / 100)), this.address, distributionPoolAddress);
                                                if balanceOf[this.address]:
                                                    if balanceOf[this.address] and liquidityPoolFee > -1 / balanceOf[this.address]:
                                                        revert with 0, 17
                                                    if not balanceOf[this.address]:
                                                        revert with 0, 18
                                                    if balanceOf[this.address] * liquidityPoolFee / balanceOf[this.address] != liquidityPoolFee:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    _2890 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_2890] = 26
                                                    mem[_2890 + 32] = 'SafeMath: division by zero'
                                                    _2921 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_2921] = 26
                                                    mem[_2921 + 32] = 'SafeMath: division by zero'
                                                    _2947 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_2947] = 30
                                                    mem[_2947 + 32] = 'SafeMath: subtraction overflow'
                                                    if balanceOf[this.address] * liquidityPoolFee / 100 / 2 > balanceOf[this.address] * liquidityPoolFee / 100:
                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                    if balanceOf[this.address] * liquidityPoolFee / 100 < balanceOf[this.address] * liquidityPoolFee / 100 / 2:
                                                        revert with 0, 17
                                                    _3043 = mem[64]
                                                    mem[mem[64]] = 2
                                                    mem[64] = mem[64] + 96
                                                    mem[_3043 + 32 len 64] = call.data[calldata.size len 64]
                                                    if 0 >= mem[_3043]:
                                                        revert with 0, 50
                                                    mem[_3043 + 32] = this.address
                                                    require ext_code.size(uniswapV2RouterAddress)
                                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                                            gas gas_remaining wei
                                                    mem[_3043 + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[64] = _3043 + ceil32(return_data.size) + 96
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                    if 1 >= mem[_3043]:
                                                        revert with 0, 50
                                                    mem[_3043 + 64] = ext_call.return_data[12 len 20]
                                                    if not this.address:
                                                        revert with 0, 'ERC20: approve from the zero address'
                                                    if not uniswapV2RouterAddress:
                                                        revert with 0, 'ERC20: approve to the zero address'
                                                    mem[0] = uniswapV2RouterAddress
                                                    mem[32] = sha3(address(this.address), 1)
                                                    allowance[address(this.address)][stor9].field_0 = balanceOf[this.address] * liquidityPoolFee / 100 / 2
                                                    allowance[address(this.address)][stor9].field_255 = 0
                                                    emit Approval((balanceOf[this.address] * liquidityPoolFee / 100 / 2), this.address, uniswapV2RouterAddress);
                                                    mem[_3043 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                    mem[_3043 + ceil32(return_data.size) + 100] = balanceOf[this.address] * liquidityPoolFee / 100 / 2
                                                    mem[_3043 + ceil32(return_data.size) + 132] = 0
                                                    mem[_3043 + ceil32(return_data.size) + 164] = 160
                                                    mem[_3043 + ceil32(return_data.size) + 260] = mem[_3043]
                                                    idx = 0
                                                    s = _3043 + ceil32(return_data.size) + 292
                                                    t = _3043 + 32
                                                    while idx < mem[_3043]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    require ext_code.size(uniswapV2RouterAddress)
                                                    call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args Mask(255, 1, balanceOf[this.address] * liquidityPoolFee / 100), 0, 160, address(this.address), block.timestamp, mem[_3043 + ceil32(return_data.size) + 260 len (32 * mem[_3043]) + 32]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[_3043 + ceil32(return_data.size) + 96] = 30
                                                    mem[_3043 + ceil32(return_data.size) + 128] = 'SafeMath: subtraction overflow'
                                                    if eth.balance(this.address) > eth.balance(this.address):
                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                    if eth.balance(this.address) < eth.balance(this.address):
                                                        revert with 0, 17
                                                    if not this.address:
                                                        revert with 0, 'ERC20: approve from the zero address'
                                                    if not uniswapV2RouterAddress:
                                                        revert with 0, 'ERC20: approve to the zero address'
                                                    allowance[address(this.address)][stor9].field_0 = (balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2)
                                                    emit Approval(((balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2)), this.address, uniswapV2RouterAddress);
                                                    mem[_3043 + ceil32(return_data.size) + 228] = 0
                                                    mem[_3043 + ceil32(return_data.size) + 260] = 0
                                                    mem[_3043 + ceil32(return_data.size) + 292] = 0
                                                    mem[_3043 + ceil32(return_data.size) + 324] = block.timestamp
                                                    require ext_code.size(uniswapV2RouterAddress)
                                                    call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                         gas gas_remaining wei
                                                        args this.address, (balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2), 0, 0, 0, block.timestamp
                                                    mem[_3043 + ceil32(return_data.size) + 160 len 96] = ext_call.return_data[0 len 96]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 96
                                                    emit SwapAndLiquify(Mask(255, 1, balanceOf[this.address] * liquidityPoolFee / 100), 0, (balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2));
                                                    mem[_3043 + (2 * ceil32(return_data.size)) + 160] = 2
                                                    mem[_3043 + (2 * ceil32(return_data.size)) + 192] = this.address
                                                    require ext_code.size(uniswapV2RouterAddress)
                                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                                            gas gas_remaining wei
                                                    mem[_3043 + (2 * ceil32(return_data.size)) + 256] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[64] = _3043 + (4 * ceil32(return_data.size)) + 256
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                    mem[_3043 + (2 * ceil32(return_data.size)) + 224] = ext_call.return_data[12 len 20]
                                                    if not this.address:
                                                        revert with 0, 'ERC20: approve from the zero address'
                                                    if not uniswapV2RouterAddress:
                                                        revert with 0, 'ERC20: approve to the zero address'
                                                    mem[0] = uniswapV2RouterAddress
                                                    mem[32] = sha3(address(this.address), 1)
                                                    allowance[address(this.address)][stor9].field_0 = balanceOf[this.address]
                                                    emit Approval(balanceOf[this.address], this.address, uniswapV2RouterAddress);
                                                    mem[_3043 + (4 * ceil32(return_data.size)) + 256] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                    mem[_3043 + (4 * ceil32(return_data.size)) + 260] = balanceOf[this.address]
                                                    mem[_3043 + (4 * ceil32(return_data.size)) + 292] = 0
                                                    mem[_3043 + (4 * ceil32(return_data.size)) + 324] = 160
                                                    mem[_3043 + (4 * ceil32(return_data.size)) + 420] = 2
                                                    idx = 0
                                                    s = _3043 + (4 * ceil32(return_data.size)) + 452
                                                    t = _3043 + (2 * ceil32(return_data.size)) + 192
                                                    while idx < mem[_3043 + (2 * ceil32(return_data.size)) + 160]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_3043 + (4 * ceil32(return_data.size)) + 356] = this.address
                                                    mem[_3043 + (4 * ceil32(return_data.size)) + 388] = block.timestamp
                                                    require ext_code.size(uniswapV2RouterAddress)
                                                    call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args balanceOf[this.address], 0, 160, address(this.address), block.timestamp, mem[_3043 + (4 * ceil32(return_data.size)) + 420 len (32 * mem[_3043 + (2 * ceil32(return_data.size)) + 160]) + 32]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[_3043 + (4 * ceil32(return_data.size)) + 256] = 30
                                                    mem[_3043 + (4 * ceil32(return_data.size)) + 288] = 'SafeMath: subtraction overflow'
                                                    if eth.balance(this.address) > eth.balance(this.address):
                                                        mem[_3043 + (4 * ceil32(return_data.size)) + 320] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_3043 + (4 * ceil32(return_data.size)) + 324] = 32
                                                        mem[_3043 + (4 * ceil32(return_data.size)) + 356] = 30
                                                        mem[_3043 + (4 * ceil32(return_data.size)) + 388] = 'SafeMath: subtraction overflow'
                                                        mem[_3043 + (4 * ceil32(return_data.size)) + 418] = 0
                                                        revert with memory
                                                          from _3043 + (4 * ceil32(return_data.size)) + 320
                                                           len (5 * ceil32(return_data.size)) + 100
                                                    if eth.balance(this.address) < eth.balance(this.address):
                                                        revert with 0, 17
                                                    call marketingWalletAddress with:
                                                         gas 2300 wei
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    uint8(stor23.field_0) = 0
                                                    if not msg.sender:
                                                        mem[_3043 + (4 * ceil32(return_data.size)) + 320] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_3043 + (4 * ceil32(return_data.size)) + 324] = 32
                                                        mem[_3043 + (4 * ceil32(return_data.size)) + 356] = 37
                                                        mem[_3043 + (4 * ceil32(return_data.size)) + 388] = 'ERC20: transfer from the zero ad'
                                                        mem[_3043 + (4 * ceil32(return_data.size)) + 420] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                        revert with memory
                                                          from _3043 + (4 * ceil32(return_data.size)) + 320
                                                           len (5 * ceil32(return_data.size)) + 132
                                                    if not this.address:
                                                        mem[_3043 + (4 * ceil32(return_data.size)) + 320] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_3043 + (4 * ceil32(return_data.size)) + 324] = 32
                                                        mem[_3043 + (4 * ceil32(return_data.size)) + 356] = 35
                                                        mem[_3043 + (4 * ceil32(return_data.size)) + 388] = 'ERC20: transfer to the zero addr'
                                                        mem[_3043 + (4 * ceil32(return_data.size)) + 420] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                        revert with memory
                                                          from _3043 + (4 * ceil32(return_data.size)) + 320
                                                           len (5 * ceil32(return_data.size)) + 132
                                                    mem[_3043 + (4 * ceil32(return_data.size)) + 320] = 38
                                                    mem[_3043 + (4 * ceil32(return_data.size)) + 352 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                    if ext_call.return_data[0] > balanceOf[address(msg.sender)]:
                                                        mem[_3043 + (4 * ceil32(return_data.size)) + 416] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_3043 + (4 * ceil32(return_data.size)) + 420] = 32
                                                        mem[_3043 + (4 * ceil32(return_data.size)) + 452] = 38
                                                        mem[_3043 + (4 * ceil32(return_data.size)) + 484 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, Mask(208, 32, block.timestamp) >> 32
                                                        mem[_3043 + (4 * ceil32(return_data.size)) + 522] = 0
                                                        revert with memory
                                                          from _3043 + (4 * ceil32(return_data.size)) + 416
                                                           len (5 * ceil32(return_data.size)) + 132
                                                    if balanceOf[address(msg.sender)] < ext_call.return_data[0]:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] -= ext_call.return_data[0]
                                                    if balanceOf[this.address] > !ext_call.return_data[0]:
                                                        revert with 0, 17
                                                    if balanceOf[this.address] + ext_call.return_data[0] >= balanceOf[this.address]:
                                                        balanceOf[address(this.address)] = balanceOf[this.address] + ext_call.return_data[0]
                                                        emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                                        if arg1 >= 3:
                                                            revert with 0, 50
                                                        mem[_3043 + (4 * ceil32(return_data.size)) + 416] = 0x12b8603f00000000000000000000000000000000000000000000000000000000
                                                        mem[_3043 + (4 * ceil32(return_data.size)) + 420] = msg.sender
                                                        mem[_3043 + (4 * ceil32(return_data.size)) + 452] = 64
                                                        mem[_3043 + (4 * ceil32(return_data.size)) + 484] = mem[128]
                                                        mem[_3043 + (4 * ceil32(return_data.size)) + 516 len ceil32(mem[128])] = mem[160 len ceil32(mem[128])]
                                                        if ceil32(mem[128]) > mem[128]:
                                                            mem[_3043 + (4 * ceil32(return_data.size)) + mem[128] + 516] = 0
                                                        require ext_code.size(sub_20eea8b5[arg1])
                                                        call sub_20eea8b5[arg1].createNode(address arg1, string arg2) with:
                                                             gas gas_remaining wei
                                                            args mem[_3043 + (4 * ceil32(return_data.size)) + 420 len ceil32(mem[128]) + (5 * ceil32(return_data.size)) + 96]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if stor27[address(msg.sender)] > -2:
                                                            revert with 0, 17
                                                        if stor27[address(msg.sender)] + 1 >= stor27[address(msg.sender)]:
                                                            stor27[address(msg.sender)]++
                                                    mem[_3043 + (4 * ceil32(return_data.size)) + 416] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[_3043 + (4 * ceil32(return_data.size)) + 420] = 32
                                                    mem[_3043 + (4 * ceil32(return_data.size)) + 452] = 27
                                                    mem[_3043 + (4 * ceil32(return_data.size)) + 484] = 'SafeMath: addition overflow'
                                                    revert with memory
                                                      from _3043 + (4 * ceil32(return_data.size)) + 416
                                                       len (5 * ceil32(return_data.size)) + 100
                                                _2840 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_2840] = 26
                                                mem[_2840 + 32] = 'SafeMath: division by zero'
                                                _2904 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_2904] = 26
                                                mem[_2904 + 32] = 'SafeMath: division by zero'
                                                _2931 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_2931] = 30
                                                mem[_2931 + 32] = 'SafeMath: subtraction overflow'
                                                _2958 = mem[64]
                                                mem[mem[64]] = 2
                                                mem[64] = mem[64] + 96
                                                mem[_2958 + 32 len 64] = call.data[calldata.size len 64]
                                                if 0 >= mem[_2958]:
                                                    revert with 0, 50
                                                mem[_2958 + 32] = this.address
                                                require ext_code.size(uniswapV2RouterAddress)
                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                        gas gas_remaining wei
                                                mem[_2958 + 96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[64] = _2958 + ceil32(return_data.size) + 96
                                                require return_data.size >= 32
                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                if 1 >= mem[_2958]:
                                                    revert with 0, 50
                                                mem[_2958 + 64] = ext_call.return_data[12 len 20]
                                                if not this.address:
                                                    revert with 0, 'ERC20: approve from the zero address'
                                                if not uniswapV2RouterAddress:
                                                    revert with 0, 'ERC20: approve to the zero address'
                                                mem[0] = uniswapV2RouterAddress
                                                mem[32] = sha3(address(this.address), 1)
                                                allowance[address(this.address)][stor9].field_0 = 0
                                                emit Approval(0, this.address, uniswapV2RouterAddress);
                                                mem[_2958 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                mem[_2958 + ceil32(return_data.size) + 100] = 0
                                                mem[_2958 + ceil32(return_data.size) + 132] = 0
                                                mem[_2958 + ceil32(return_data.size) + 164] = 160
                                                mem[_2958 + ceil32(return_data.size) + 260] = mem[_2958]
                                                idx = 0
                                                s = _2958 + ceil32(return_data.size) + 292
                                                t = _2958 + 32
                                                while idx < mem[_2958]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_2958 + ceil32(return_data.size) + 196] = this.address
                                                mem[_2958 + ceil32(return_data.size) + 228] = block.timestamp
                                                require ext_code.size(uniswapV2RouterAddress)
                                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _2958 + ceil32(return_data.size) + (32 * mem[_2958]) + -mem[64] + 288]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _5325 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_5325] = 30
                                                mem[_5325 + 32] = 'SafeMath: subtraction overflow'
                                                if eth.balance(this.address) > eth.balance(this.address):
                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                if eth.balance(this.address) < eth.balance(this.address):
                                                    revert with 0, 17
                                                if not this.address:
                                                    revert with 0, 'ERC20: approve from the zero address'
                                                if not uniswapV2RouterAddress:
                                                    revert with 0, 'ERC20: approve to the zero address'
                                                mem[0] = uniswapV2RouterAddress
                                                mem[32] = sha3(address(this.address), 1)
                                                allowance[address(this.address)][stor9].field_0 = 0
                                                emit Approval(0, this.address, uniswapV2RouterAddress);
                                                mem[mem[64] + 68] = 0
                                                mem[mem[64] + 100] = 0
                                                mem[mem[64] + 132] = 0
                                                mem[mem[64] + 164] = block.timestamp
                                                require ext_code.size(uniswapV2RouterAddress)
                                                call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                     gas gas_remaining wei
                                                    args this.address, 0, 0, 0, 0, block.timestamp
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 96
                                                mem[mem[64] + 32] = 0
                                                mem[mem[64] + 64] = 0
                                                emit SwapAndLiquify(uint256 arg1, uint256 arg2, uint256 arg3):
                                                                    0,
                                                mem[0] = this.address
                                                mem[32] = 0
                                                _5851 = mem[64]
                                                mem[mem[64]] = 2
                                                mem[64] = mem[64] + 96
                                                mem[_5851 + 32 len 64] = call.data[calldata.size len 64]
                                                if 0 >= mem[_5851]:
                                                    revert with 0, 50
                                                mem[_5851 + 32] = this.address
                                                require ext_code.size(uniswapV2RouterAddress)
                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                        gas gas_remaining wei
                                                mem[_5851 + 96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[64] = _5851 + ceil32(return_data.size) + 96
                                                require return_data.size >= 32
                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                if 1 >= mem[_5851]:
                                                    revert with 0, 50
                                                mem[_5851 + 64] = ext_call.return_data[12 len 20]
                                                if not this.address:
                                                    revert with 0, 'ERC20: approve from the zero address'
                                                if not uniswapV2RouterAddress:
                                                    revert with 0, 'ERC20: approve to the zero address'
                                                mem[0] = uniswapV2RouterAddress
                                                mem[32] = sha3(address(this.address), 1)
                                                allowance[address(this.address)][stor9].field_0 = balanceOf[this.address]
                                                emit Approval(balanceOf[this.address], this.address, uniswapV2RouterAddress);
                                                mem[_5851 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                mem[_5851 + ceil32(return_data.size) + 100] = balanceOf[this.address]
                                                mem[_5851 + ceil32(return_data.size) + 132] = 0
                                                mem[_5851 + ceil32(return_data.size) + 164] = 160
                                                mem[_5851 + ceil32(return_data.size) + 260] = mem[_5851]
                                                idx = 0
                                                s = _5851 + ceil32(return_data.size) + 292
                                                t = _5851 + 32
                                                while idx < mem[_5851]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_5851 + ceil32(return_data.size) + 196] = this.address
                                                mem[_5851 + ceil32(return_data.size) + 228] = block.timestamp
                                                require ext_code.size(uniswapV2RouterAddress)
                                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _5851 + ceil32(return_data.size) + (32 * mem[_5851]) + -mem[64] + 288]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _8747 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8747] = 30
                                                mem[_8747 + 32] = 'SafeMath: subtraction overflow'
                                                if eth.balance(this.address) > eth.balance(this.address):
                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                if eth.balance(this.address) < eth.balance(this.address):
                                                    revert with 0, 17
                                                call marketingWalletAddress with:
                                                     gas 2300 wei
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                uint8(stor23.field_0) = 0
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not this.address:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                _9091 = mem[64]
                                                mem[64] = mem[64] + 96
                                                mem[_9091] = 38
                                                mem[_9091 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                if ext_call.return_data[0] > balanceOf[address(msg.sender)]:
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 38
                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_9091 + 70 len 26]
                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                if balanceOf[address(msg.sender)] < ext_call.return_data[0]:
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] -= ext_call.return_data[0]
                                                if balanceOf[this.address] > !ext_call.return_data[0]:
                                                    revert with 0, 17
                                                if balanceOf[this.address] + ext_call.return_data[0] < balanceOf[this.address]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(this.address)] = balanceOf[this.address] + ext_call.return_data[0]
                                                emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                                if arg1 >= 3:
                                                    revert with 0, 50
                                                mem[mem[64]] = 0x12b8603f00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 64
                                                mem[mem[64] + 68] = mem[128]
                                                mem[mem[64] + 100 len ceil32(mem[128])] = mem[160 len ceil32(mem[128])]
                                                if ceil32(mem[128]) > mem[128]:
                                                    mem[mem[64] + mem[128] + 100] = 0
                                                require ext_code.size(sub_20eea8b5[arg1])
                                                call sub_20eea8b5[arg1].createNode(address arg1, string arg2) with:
                                                     gas gas_remaining wei
                                                    args msg.sender, Array(len=mem[128], data=mem[mem[64] + 100 len ceil32(mem[128])])
                else:
                    if balanceOf[this.address] < swapTokensAmount:
                        if not msg.sender:
                            revert with 0, 'ERC20: transfer from the zero address'
                        if not this.address:
                            revert with 0, 'ERC20: transfer to the zero address'
                        if ext_call.return_data[0] > balanceOf[address(msg.sender)]:
                            revert with 0, 
                                        32,
                                        38,
                                        0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + 295 len 26] >> 48,
                                        0
                        if balanceOf[address(msg.sender)] < ext_call.return_data[0]:
                            revert with 0, 17
                        balanceOf[address(msg.sender)] -= ext_call.return_data[0]
                        if balanceOf[this.address] > !ext_call.return_data[0]:
                            revert with 0, 17
                        if balanceOf[this.address] + ext_call.return_data[0] < balanceOf[this.address]:
                            revert with 0, 'SafeMath: addition overflow'
                        balanceOf[address(this.address)] = balanceOf[this.address] + ext_call.return_data[0]
                        emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                        if arg1 >= 3:
                            revert with 0, 50
                        require ext_code.size(sub_20eea8b5[arg1])
                        call sub_20eea8b5[arg1].createNode(address arg1, string arg2) with:
                             gas gas_remaining wei
                            args msg.sender, Array(len=arg2.length, data=arg2[all])
                    else:
                        if not uint8(stor23.field_8):
                            if not msg.sender:
                                revert with 0, 'ERC20: transfer from the zero address'
                            if not this.address:
                                revert with 0, 'ERC20: transfer to the zero address'
                            if ext_call.return_data[0] > balanceOf[address(msg.sender)]:
                                revert with 0, 
                                            32,
                                            38,
                                            0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + 295 len 26] >> 48,
                                            0
                            if balanceOf[address(msg.sender)] < ext_call.return_data[0]:
                                revert with 0, 17
                            balanceOf[address(msg.sender)] -= ext_call.return_data[0]
                            if balanceOf[this.address] > !ext_call.return_data[0]:
                                revert with 0, 17
                            if balanceOf[this.address] + ext_call.return_data[0] < balanceOf[this.address]:
                                revert with 0, 'SafeMath: addition overflow'
                            balanceOf[address(this.address)] = balanceOf[this.address] + ext_call.return_data[0]
                            emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                            if arg1 >= 3:
                                revert with 0, 50
                            require ext_code.size(sub_20eea8b5[arg1])
                            call sub_20eea8b5[arg1].createNode(address arg1, string arg2) with:
                                 gas gas_remaining wei
                                args msg.sender, Array(len=arg2.length, data=arg2[all])
                        else:
                            if uint8(stor23.field_0):
                                if not msg.sender:
                                    revert with 0, 'ERC20: transfer from the zero address'
                                if not this.address:
                                    revert with 0, 'ERC20: transfer to the zero address'
                                if ext_call.return_data[0] > balanceOf[address(msg.sender)]:
                                    revert with 0, 
                                                32,
                                                38,
                                                0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + 295 len 26] >> 48,
                                                0
                                if balanceOf[address(msg.sender)] < ext_call.return_data[0]:
                                    revert with 0, 17
                                balanceOf[address(msg.sender)] -= ext_call.return_data[0]
                                if balanceOf[this.address] > !ext_call.return_data[0]:
                                    revert with 0, 17
                                if balanceOf[this.address] + ext_call.return_data[0] < balanceOf[this.address]:
                                    revert with 0, 'SafeMath: addition overflow'
                                balanceOf[address(this.address)] = balanceOf[this.address] + ext_call.return_data[0]
                                emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                if arg1 >= 3:
                                    revert with 0, 50
                                require ext_code.size(sub_20eea8b5[arg1])
                                call sub_20eea8b5[arg1].createNode(address arg1, string arg2) with:
                                     gas gas_remaining wei
                                    args msg.sender, Array(len=arg2.length, data=arg2[all])
                            else:
                                if owner == msg.sender:
                                    if not msg.sender:
                                        revert with 0, 'ERC20: transfer from the zero address'
                                    if not this.address:
                                        revert with 0, 'ERC20: transfer to the zero address'
                                    if ext_call.return_data[0] > balanceOf[address(msg.sender)]:
                                        revert with 0, 
                                                    32,
                                                    38,
                                                    0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + 295 len 26] >> 48,
                                                    0
                                    if balanceOf[address(msg.sender)] < ext_call.return_data[0]:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)] -= ext_call.return_data[0]
                                    if balanceOf[this.address] > !ext_call.return_data[0]:
                                        revert with 0, 17
                                    if balanceOf[this.address] + ext_call.return_data[0] < balanceOf[this.address]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(this.address)] = balanceOf[this.address] + ext_call.return_data[0]
                                    emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                    if arg1 >= 3:
                                        revert with 0, 50
                                    require ext_code.size(sub_20eea8b5[arg1])
                                    call sub_20eea8b5[arg1].createNode(address arg1, string arg2) with:
                                         gas gas_remaining wei
                                        args msg.sender, Array(len=arg2.length, data=arg2[all])
                                else:
                                    if stor26[address(msg.sender)]:
                                        if not msg.sender:
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not this.address:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        if ext_call.return_data[0] > balanceOf[address(msg.sender)]:
                                            revert with 0, 
                                                        32,
                                                        38,
                                                        0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + 295 len 26] >> 48,
                                                        0
                                        if balanceOf[address(msg.sender)] < ext_call.return_data[0]:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] -= ext_call.return_data[0]
                                        if balanceOf[this.address] > !ext_call.return_data[0]:
                                            revert with 0, 17
                                        if balanceOf[this.address] + ext_call.return_data[0] < balanceOf[this.address]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(this.address)] = balanceOf[this.address] + ext_call.return_data[0]
                                        emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                        if arg1 >= 3:
                                            revert with 0, 50
                                        require ext_code.size(sub_20eea8b5[arg1])
                                        call sub_20eea8b5[arg1].createNode(address arg1, string arg2) with:
                                             gas gas_remaining wei
                                            args msg.sender, Array(len=arg2.length, data=arg2[all])
                                    else:
                                        uint8(stor23.field_0) = 1
                                        if not balanceOf[this.address]:
                                            mem[ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + 225] = 26
                                            mem[ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + 257] = 'SafeMath: division by zero'
                                            mem[ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + 289] = 26
                                            mem[ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + 321] = 'SafeMath: division by zero'
                                            mem[ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + 353] = 2
                                            mem[ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + 385] = this.address
                                            require ext_code.size(uniswapV2RouterAddress)
                                            staticcall uniswapV2RouterAddress.WAVAX() with:
                                                    gas gas_remaining wei
                                            mem[ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + 449] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[64] = ceil32(ceil32(arg2.length)) + (6 * ceil32(return_data.size)) + 449
                                            require return_data.size >= 32
                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                            mem[ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + 417] = ext_call.return_data[12 len 20]
                                            if not this.address:
                                                revert with 0, 
                                                            'ERC20: approve from the zero address',
                                                            mem[ceil32(ceil32(arg2.length)) + (6 * ceil32(return_data.size)) + 581 len 9 * ceil32(return_data.size)]
                                            if not uniswapV2RouterAddress:
                                                revert with 0, 
                                                            'ERC20: approve to the zero address',
                                                            mem[ceil32(ceil32(arg2.length)) + (6 * ceil32(return_data.size)) + 581 len 9 * ceil32(return_data.size)]
                                            mem[0] = uniswapV2RouterAddress
                                            mem[32] = sha3(address(this.address), 1)
                                            allowance[address(this.address)][stor9].field_0 = 0
                                            emit Approval(address arg1, address arg2, uint256 arg3):
                                                          0,
                                                          mem[ceil32(ceil32(arg2.length)) + (6 * ceil32(return_data.size)) + 481 len 9 * ceil32(return_data.size)],
                                                          this.address,
                                                          uniswapV2RouterAddress,
                                            mem[ceil32(ceil32(arg2.length)) + (6 * ceil32(return_data.size)) + 449] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                            mem[ceil32(ceil32(arg2.length)) + (6 * ceil32(return_data.size)) + 453] = 0
                                            mem[ceil32(ceil32(arg2.length)) + (6 * ceil32(return_data.size)) + 485] = 0
                                            mem[ceil32(ceil32(arg2.length)) + (6 * ceil32(return_data.size)) + 517] = 160
                                            mem[ceil32(ceil32(arg2.length)) + (6 * ceil32(return_data.size)) + 613] = 2
                                            idx = 0
                                            s = ceil32(ceil32(arg2.length)) + (6 * ceil32(return_data.size)) + 645
                                            t = ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + 385
                                            while idx < mem[ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + 353]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[ceil32(ceil32(arg2.length)) + (6 * ceil32(return_data.size)) + 549] = this.address
                                            mem[ceil32(ceil32(arg2.length)) + (6 * ceil32(return_data.size)) + 581] = block.timestamp
                                            require ext_code.size(uniswapV2RouterAddress)
                                            call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len ceil32(ceil32(arg2.length)) + (6 * ceil32(return_data.size)) + -mem[64] + 705]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _2287 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2287] = 30
                                            mem[_2287 + 32] = 'SafeMath: subtraction overflow'
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if eth.balance(this.address) < eth.balance(this.address):
                                                revert with 0, 17
                                            call distributionPoolAddress with:
                                                 gas 2300 wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _2510 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2510] = 30
                                            mem[_2510 + 32] = 'SafeMath: subtraction overflow'
                                            if not this.address:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not distributionPoolAddress:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            _2594 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_2594] = 38
                                            mem[_2594 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                            if 0 > balanceOf[address(this.address)]:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 38
                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_2594 + 70 len 26]
                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                            if balanceOf[address(this.address)] < 0:
                                                revert with 0, 17
                                            if balanceOf[stor12] > -1:
                                                revert with 0, 17
                                            if balanceOf[stor12] < balanceOf[stor12]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = distributionPoolAddress
                                            mem[32] = 0
                                            balanceOf[stor12] = balanceOf[stor12]
                                            emit Transfer(0, this.address, distributionPoolAddress);
                                            if balanceOf[this.address]:
                                                if balanceOf[this.address] and liquidityPoolFee > -1 / balanceOf[this.address]:
                                                    revert with 0, 17
                                                if not balanceOf[this.address]:
                                                    revert with 0, 18
                                                if balanceOf[this.address] * liquidityPoolFee / balanceOf[this.address] != liquidityPoolFee:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _2895 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_2895] = 26
                                                mem[_2895 + 32] = 'SafeMath: division by zero'
                                                _2926 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_2926] = 26
                                                mem[_2926 + 32] = 'SafeMath: division by zero'
                                                _2952 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_2952] = 30
                                                mem[_2952 + 32] = 'SafeMath: subtraction overflow'
                                                if balanceOf[this.address] * liquidityPoolFee / 100 / 2 > balanceOf[this.address] * liquidityPoolFee / 100:
                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                if balanceOf[this.address] * liquidityPoolFee / 100 < balanceOf[this.address] * liquidityPoolFee / 100 / 2:
                                                    revert with 0, 17
                                                _3053 = mem[64]
                                                mem[mem[64]] = 2
                                                mem[64] = mem[64] + 96
                                                mem[_3053 + 32 len 64] = call.data[calldata.size len 64]
                                                if 0 >= mem[_3053]:
                                                    revert with 0, 50
                                                mem[_3053 + 32] = this.address
                                                require ext_code.size(uniswapV2RouterAddress)
                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                        gas gas_remaining wei
                                                mem[_3053 + 96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[64] = _3053 + ceil32(return_data.size) + 96
                                                require return_data.size >= 32
                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                if 1 >= mem[_3053]:
                                                    revert with 0, 50
                                                mem[_3053 + 64] = ext_call.return_data[12 len 20]
                                                if not this.address:
                                                    revert with 0, 'ERC20: approve from the zero address'
                                                if not uniswapV2RouterAddress:
                                                    revert with 0, 'ERC20: approve to the zero address'
                                                mem[0] = uniswapV2RouterAddress
                                                mem[32] = sha3(address(this.address), 1)
                                                allowance[address(this.address)][stor9].field_0 = balanceOf[this.address] * liquidityPoolFee / 100 / 2
                                                allowance[address(this.address)][stor9].field_255 = 0
                                                emit Approval((balanceOf[this.address] * liquidityPoolFee / 100 / 2), this.address, uniswapV2RouterAddress);
                                                mem[_3053 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                mem[_3053 + ceil32(return_data.size) + 100] = balanceOf[this.address] * liquidityPoolFee / 100 / 2
                                                mem[_3053 + ceil32(return_data.size) + 132] = 0
                                                mem[_3053 + ceil32(return_data.size) + 164] = 160
                                                mem[_3053 + ceil32(return_data.size) + 260] = mem[_3053]
                                                idx = 0
                                                s = _3053 + ceil32(return_data.size) + 292
                                                t = _3053 + 32
                                                while idx < mem[_3053]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                require ext_code.size(uniswapV2RouterAddress)
                                                call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                     gas gas_remaining wei
                                                    args Mask(255, 1, balanceOf[this.address] * liquidityPoolFee / 100), 0, 160, address(this.address), block.timestamp, mem[_3053 + ceil32(return_data.size) + 260 len (32 * mem[_3053]) + 32]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[_3053 + ceil32(return_data.size) + 96] = 30
                                                mem[_3053 + ceil32(return_data.size) + 128] = 'SafeMath: subtraction overflow'
                                                if eth.balance(this.address) > eth.balance(this.address):
                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                if eth.balance(this.address) < eth.balance(this.address):
                                                    revert with 0, 17
                                                if not this.address:
                                                    revert with 0, 'ERC20: approve from the zero address'
                                                if not uniswapV2RouterAddress:
                                                    revert with 0, 'ERC20: approve to the zero address'
                                                allowance[address(this.address)][stor9].field_0 = (balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2)
                                                emit Approval(((balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2)), this.address, uniswapV2RouterAddress);
                                                mem[_3053 + ceil32(return_data.size) + 228] = 0
                                                mem[_3053 + ceil32(return_data.size) + 260] = 0
                                                mem[_3053 + ceil32(return_data.size) + 292] = 0
                                                mem[_3053 + ceil32(return_data.size) + 324] = block.timestamp
                                                require ext_code.size(uniswapV2RouterAddress)
                                                call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                     gas gas_remaining wei
                                                    args this.address, (balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2), 0, 0, 0, block.timestamp
                                                mem[_3053 + ceil32(return_data.size) + 160 len 96] = ext_call.return_data[0 len 96]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 96
                                                emit SwapAndLiquify(Mask(255, 1, balanceOf[this.address] * liquidityPoolFee / 100), 0, (balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2));
                                                mem[_3053 + (2 * ceil32(return_data.size)) + 160] = 2
                                                mem[_3053 + (2 * ceil32(return_data.size)) + 192] = this.address
                                                require ext_code.size(uniswapV2RouterAddress)
                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                        gas gas_remaining wei
                                                mem[_3053 + (2 * ceil32(return_data.size)) + 256] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[64] = _3053 + (4 * ceil32(return_data.size)) + 256
                                                require return_data.size >= 32
                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                mem[_3053 + (2 * ceil32(return_data.size)) + 224] = ext_call.return_data[12 len 20]
                                                if not this.address:
                                                    revert with 0, 'ERC20: approve from the zero address'
                                                if not uniswapV2RouterAddress:
                                                    revert with 0, 'ERC20: approve to the zero address'
                                                mem[0] = uniswapV2RouterAddress
                                                mem[32] = sha3(address(this.address), 1)
                                                allowance[address(this.address)][stor9].field_0 = balanceOf[this.address]
                                                emit Approval(balanceOf[this.address], this.address, uniswapV2RouterAddress);
                                                mem[_3053 + (4 * ceil32(return_data.size)) + 256] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                mem[_3053 + (4 * ceil32(return_data.size)) + 260] = balanceOf[this.address]
                                                mem[_3053 + (4 * ceil32(return_data.size)) + 292] = 0
                                                mem[_3053 + (4 * ceil32(return_data.size)) + 324] = 160
                                                mem[_3053 + (4 * ceil32(return_data.size)) + 420] = 2
                                                idx = 0
                                                s = _3053 + (4 * ceil32(return_data.size)) + 452
                                                t = _3053 + (2 * ceil32(return_data.size)) + 192
                                                while idx < mem[_3053 + (2 * ceil32(return_data.size)) + 160]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_3053 + (4 * ceil32(return_data.size)) + 356] = this.address
                                                mem[_3053 + (4 * ceil32(return_data.size)) + 388] = block.timestamp
                                                require ext_code.size(uniswapV2RouterAddress)
                                                call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                     gas gas_remaining wei
                                                    args balanceOf[this.address], 0, 160, address(this.address), block.timestamp, mem[_3053 + (4 * ceil32(return_data.size)) + 420 len (32 * mem[_3053 + (2 * ceil32(return_data.size)) + 160]) + 32]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[_3053 + (4 * ceil32(return_data.size)) + 256] = 30
                                                mem[_3053 + (4 * ceil32(return_data.size)) + 288] = 'SafeMath: subtraction overflow'
                                                if eth.balance(this.address) > eth.balance(this.address):
                                                    mem[_3053 + (4 * ceil32(return_data.size)) + 320] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[_3053 + (4 * ceil32(return_data.size)) + 324] = 32
                                                    mem[_3053 + (4 * ceil32(return_data.size)) + 356] = 30
                                                    mem[_3053 + (4 * ceil32(return_data.size)) + 388] = 'SafeMath: subtraction overflow'
                                                    mem[_3053 + (4 * ceil32(return_data.size)) + 418] = 0
                                                    revert with memory
                                                      from _3053 + (4 * ceil32(return_data.size)) + 320
                                                       len (5 * ceil32(return_data.size)) + 100
                                                if eth.balance(this.address) < eth.balance(this.address):
                                                    revert with 0, 17
                                                call marketingWalletAddress with:
                                                     gas 2300 wei
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                uint8(stor23.field_0) = 0
                                                if not msg.sender:
                                                    mem[_3053 + (4 * ceil32(return_data.size)) + 320] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[_3053 + (4 * ceil32(return_data.size)) + 324] = 32
                                                    mem[_3053 + (4 * ceil32(return_data.size)) + 356] = 37
                                                    mem[_3053 + (4 * ceil32(return_data.size)) + 388] = 'ERC20: transfer from the zero ad'
                                                    mem[_3053 + (4 * ceil32(return_data.size)) + 420] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                    revert with memory
                                                      from _3053 + (4 * ceil32(return_data.size)) + 320
                                                       len (5 * ceil32(return_data.size)) + 132
                                                if not this.address:
                                                    mem[_3053 + (4 * ceil32(return_data.size)) + 320] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[_3053 + (4 * ceil32(return_data.size)) + 324] = 32
                                                    mem[_3053 + (4 * ceil32(return_data.size)) + 356] = 35
                                                    mem[_3053 + (4 * ceil32(return_data.size)) + 388] = 'ERC20: transfer to the zero addr'
                                                    mem[_3053 + (4 * ceil32(return_data.size)) + 420] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                    revert with memory
                                                      from _3053 + (4 * ceil32(return_data.size)) + 320
                                                       len (5 * ceil32(return_data.size)) + 132
                                                mem[_3053 + (4 * ceil32(return_data.size)) + 320] = 38
                                                mem[_3053 + (4 * ceil32(return_data.size)) + 352 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                if ext_call.return_data[0] > balanceOf[address(msg.sender)]:
                                                    mem[_3053 + (4 * ceil32(return_data.size)) + 416] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[_3053 + (4 * ceil32(return_data.size)) + 420] = 32
                                                    mem[_3053 + (4 * ceil32(return_data.size)) + 452] = 38
                                                    mem[_3053 + (4 * ceil32(return_data.size)) + 484 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, Mask(208, 32, block.timestamp) >> 32
                                                    mem[_3053 + (4 * ceil32(return_data.size)) + 522] = 0
                                                    revert with memory
                                                      from _3053 + (4 * ceil32(return_data.size)) + 416
                                                       len (5 * ceil32(return_data.size)) + 132
                                                if balanceOf[address(msg.sender)] < ext_call.return_data[0]:
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] -= ext_call.return_data[0]
                                                if balanceOf[this.address] > !ext_call.return_data[0]:
                                                    revert with 0, 17
                                                if balanceOf[this.address] + ext_call.return_data[0] >= balanceOf[this.address]:
                                                    balanceOf[address(this.address)] = balanceOf[this.address] + ext_call.return_data[0]
                                                    emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                                    if arg1 >= 3:
                                                        revert with 0, 50
                                                    mem[_3053 + (4 * ceil32(return_data.size)) + 416] = 0x12b8603f00000000000000000000000000000000000000000000000000000000
                                                    mem[_3053 + (4 * ceil32(return_data.size)) + 420] = msg.sender
                                                    mem[_3053 + (4 * ceil32(return_data.size)) + 452] = 64
                                                    mem[_3053 + (4 * ceil32(return_data.size)) + 484] = mem[128]
                                                    mem[_3053 + (4 * ceil32(return_data.size)) + 516 len ceil32(mem[128])] = mem[160 len ceil32(mem[128])]
                                                    if ceil32(mem[128]) > mem[128]:
                                                        mem[_3053 + (4 * ceil32(return_data.size)) + mem[128] + 516] = 0
                                                    require ext_code.size(sub_20eea8b5[arg1])
                                                    call sub_20eea8b5[arg1].createNode(address arg1, string arg2) with:
                                                         gas gas_remaining wei
                                                        args mem[_3053 + (4 * ceil32(return_data.size)) + 420 len ceil32(mem[128]) + (5 * ceil32(return_data.size)) + 96]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if stor27[address(msg.sender)] > -2:
                                                        revert with 0, 17
                                                    if stor27[address(msg.sender)] + 1 >= stor27[address(msg.sender)]:
                                                        stor27[address(msg.sender)]++
                                                mem[_3053 + (4 * ceil32(return_data.size)) + 416] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[_3053 + (4 * ceil32(return_data.size)) + 420] = 32
                                                mem[_3053 + (4 * ceil32(return_data.size)) + 452] = 27
                                                mem[_3053 + (4 * ceil32(return_data.size)) + 484] = 'SafeMath: addition overflow'
                                                revert with memory
                                                  from _3053 + (4 * ceil32(return_data.size)) + 416
                                                   len (5 * ceil32(return_data.size)) + 100
                                            _2845 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2845] = 26
                                            mem[_2845 + 32] = 'SafeMath: division by zero'
                                            _2909 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2909] = 26
                                            mem[_2909 + 32] = 'SafeMath: division by zero'
                                            _2936 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2936] = 30
                                            mem[_2936 + 32] = 'SafeMath: subtraction overflow'
                                            _2973 = mem[64]
                                            mem[mem[64]] = 2
                                            mem[64] = mem[64] + 96
                                            mem[_2973 + 32 len 64] = call.data[calldata.size len 64]
                                            if 0 >= mem[_2973]:
                                                revert with 0, 50
                                            mem[_2973 + 32] = this.address
                                            require ext_code.size(uniswapV2RouterAddress)
                                            staticcall uniswapV2RouterAddress.WAVAX() with:
                                                    gas gas_remaining wei
                                            mem[_2973 + 96] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[64] = _2973 + ceil32(return_data.size) + 96
                                            require return_data.size >= 32
                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                            if 1 >= mem[_2973]:
                                                revert with 0, 50
                                            mem[_2973 + 64] = ext_call.return_data[12 len 20]
                                            if not this.address:
                                                revert with 0, 'ERC20: approve from the zero address'
                                            if not uniswapV2RouterAddress:
                                                revert with 0, 'ERC20: approve to the zero address'
                                            mem[0] = uniswapV2RouterAddress
                                            mem[32] = sha3(address(this.address), 1)
                                            allowance[address(this.address)][stor9].field_0 = 0
                                            emit Approval(0, this.address, uniswapV2RouterAddress);
                                            mem[_2973 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                            mem[_2973 + ceil32(return_data.size) + 100] = 0
                                            mem[_2973 + ceil32(return_data.size) + 132] = 0
                                            mem[_2973 + ceil32(return_data.size) + 164] = 160
                                            mem[_2973 + ceil32(return_data.size) + 260] = mem[_2973]
                                            idx = 0
                                            s = _2973 + ceil32(return_data.size) + 292
                                            t = _2973 + 32
                                            while idx < mem[_2973]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_2973 + ceil32(return_data.size) + 196] = this.address
                                            mem[_2973 + ceil32(return_data.size) + 228] = block.timestamp
                                            require ext_code.size(uniswapV2RouterAddress)
                                            call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _2973 + ceil32(return_data.size) + (32 * mem[_2973]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5335 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5335] = 30
                                            mem[_5335 + 32] = 'SafeMath: subtraction overflow'
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if eth.balance(this.address) < eth.balance(this.address):
                                                revert with 0, 17
                                            if not this.address:
                                                revert with 0, 'ERC20: approve from the zero address'
                                            if not uniswapV2RouterAddress:
                                                revert with 0, 'ERC20: approve to the zero address'
                                            mem[0] = uniswapV2RouterAddress
                                            mem[32] = sha3(address(this.address), 1)
                                            allowance[address(this.address)][stor9].field_0 = 0
                                            emit Approval(0, this.address, uniswapV2RouterAddress);
                                            mem[mem[64] + 68] = 0
                                            mem[mem[64] + 100] = 0
                                            mem[mem[64] + 132] = 0
                                            mem[mem[64] + 164] = block.timestamp
                                            require ext_code.size(uniswapV2RouterAddress)
                                            call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                 gas gas_remaining wei
                                                args this.address, 0, 0, 0, 0, block.timestamp
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 96
                                            mem[mem[64] + 32] = 0
                                            mem[mem[64] + 64] = 0
                                            emit SwapAndLiquify(uint256 arg1, uint256 arg2, uint256 arg3):
                                                                0,
                                            mem[0] = this.address
                                            mem[32] = 0
                                            _5871 = mem[64]
                                            mem[mem[64]] = 2
                                            mem[64] = mem[64] + 96
                                            mem[_5871 + 32 len 64] = call.data[calldata.size len 64]
                                            if 0 >= mem[_5871]:
                                                revert with 0, 50
                                            mem[_5871 + 32] = this.address
                                            require ext_code.size(uniswapV2RouterAddress)
                                            staticcall uniswapV2RouterAddress.WAVAX() with:
                                                    gas gas_remaining wei
                                            mem[_5871 + 96] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[64] = _5871 + ceil32(return_data.size) + 96
                                            require return_data.size >= 32
                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                            if 1 >= mem[_5871]:
                                                revert with 0, 50
                                            mem[_5871 + 64] = ext_call.return_data[12 len 20]
                                            if not this.address:
                                                revert with 0, 'ERC20: approve from the zero address'
                                            if not uniswapV2RouterAddress:
                                                revert with 0, 'ERC20: approve to the zero address'
                                            mem[0] = uniswapV2RouterAddress
                                            mem[32] = sha3(address(this.address), 1)
                                            allowance[address(this.address)][stor9].field_0 = balanceOf[this.address]
                                            emit Approval(balanceOf[this.address], this.address, uniswapV2RouterAddress);
                                            mem[_5871 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                            mem[_5871 + ceil32(return_data.size) + 100] = balanceOf[this.address]
                                            mem[_5871 + ceil32(return_data.size) + 132] = 0
                                            mem[_5871 + ceil32(return_data.size) + 164] = 160
                                            mem[_5871 + ceil32(return_data.size) + 260] = mem[_5871]
                                            idx = 0
                                            s = _5871 + ceil32(return_data.size) + 292
                                            t = _5871 + 32
                                            while idx < mem[_5871]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5871 + ceil32(return_data.size) + 228] = block.timestamp
                                            require ext_code.size(uniswapV2RouterAddress)
                                            call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                 gas gas_remaining wei
                                                args balanceOf[this.address], 0, 160, address(this.address), block.timestamp, mem[_5871 + ceil32(return_data.size) + 260 len (32 * mem[_5871]) + 32]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[_5871 + ceil32(return_data.size) + 96] = 30
                                            mem[_5871 + ceil32(return_data.size) + 128] = 'SafeMath: subtraction overflow'
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if eth.balance(this.address) < eth.balance(this.address):
                                                revert with 0, 17
                                            call marketingWalletAddress with:
                                                 gas 2300 wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            uint8(stor23.field_0) = 0
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not this.address:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            mem[_5871 + ceil32(return_data.size) + 160] = 38
                                            mem[_5871 + ceil32(return_data.size) + 192 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                            if ext_call.return_data[0] > balanceOf[address(msg.sender)]:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, Mask(208, 32, block.timestamp) >> 32 >> 48,
                                                            0
                                            if balanceOf[address(msg.sender)] < ext_call.return_data[0]:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] -= ext_call.return_data[0]
                                            if balanceOf[this.address] > !ext_call.return_data[0]:
                                                revert with 0, 17
                                            if balanceOf[this.address] + ext_call.return_data[0] < balanceOf[this.address]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(this.address)] = balanceOf[this.address] + ext_call.return_data[0]
                                            emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                            if arg1 >= 3:
                                                revert with 0, 50
                                            mem[_5871 + ceil32(return_data.size) + 256] = 0x12b8603f00000000000000000000000000000000000000000000000000000000
                                            mem[_5871 + ceil32(return_data.size) + 260] = msg.sender
                                            mem[_5871 + ceil32(return_data.size) + 292] = 64
                                            mem[_5871 + ceil32(return_data.size) + 324] = mem[128]
                                            mem[_5871 + ceil32(return_data.size) + 356 len ceil32(mem[128])] = mem[160 len ceil32(mem[128])]
                                            if ceil32(mem[128]) > mem[128]:
                                                mem[_5871 + ceil32(return_data.size) + mem[128] + 356] = 0
                                            require ext_code.size(sub_20eea8b5[arg1])
                                            call sub_20eea8b5[arg1].createNode(address arg1, string arg2) with:
                                                 gas gas_remaining wei
                                                args msg.sender, Array(len=mem[128], data=mem[_5871 + ceil32(return_data.size) + 356 len ceil32(mem[128])])
                                        else:
                                            if balanceOf[this.address] and rewardsFee > -1 / balanceOf[this.address]:
                                                revert with 0, 17
                                            if not balanceOf[this.address]:
                                                revert with 0, 18
                                            if balanceOf[this.address] * rewardsFee / balanceOf[this.address] != rewardsFee:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + 225] = 26
                                            mem[ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + 257] = 'SafeMath: division by zero'
                                            if not balanceOf[this.address] * rewardsFee / 100:
                                                mem[ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + 289] = 26
                                                mem[ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + 321] = 'SafeMath: division by zero'
                                                mem[ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + 353] = 2
                                                mem[ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + 385] = this.address
                                                require ext_code.size(uniswapV2RouterAddress)
                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                        gas gas_remaining wei
                                                mem[ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + 449] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[64] = ceil32(ceil32(arg2.length)) + (6 * ceil32(return_data.size)) + 449
                                                require return_data.size >= 32
                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                mem[ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + 417] = ext_call.return_data[12 len 20]
                                                if not this.address:
                                                    revert with 0, 
                                                                'ERC20: approve from the zero address',
                                                                mem[ceil32(ceil32(arg2.length)) + (6 * ceil32(return_data.size)) + 581 len 9 * ceil32(return_data.size)]
                                                if not uniswapV2RouterAddress:
                                                    revert with 0, 
                                                                'ERC20: approve to the zero address',
                                                                mem[ceil32(ceil32(arg2.length)) + (6 * ceil32(return_data.size)) + 581 len 9 * ceil32(return_data.size)]
                                                mem[0] = uniswapV2RouterAddress
                                                mem[32] = sha3(address(this.address), 1)
                                                allowance[address(this.address)][stor9].field_0 = 0
                                                emit Approval(address arg1, address arg2, uint256 arg3):
                                                              0,
                                                              mem[ceil32(ceil32(arg2.length)) + (6 * ceil32(return_data.size)) + 481 len 9 * ceil32(return_data.size)],
                                                              this.address,
                                                              uniswapV2RouterAddress,
                                                mem[ceil32(ceil32(arg2.length)) + (6 * ceil32(return_data.size)) + 449] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                mem[ceil32(ceil32(arg2.length)) + (6 * ceil32(return_data.size)) + 453] = 0
                                                mem[ceil32(ceil32(arg2.length)) + (6 * ceil32(return_data.size)) + 485] = 0
                                                mem[ceil32(ceil32(arg2.length)) + (6 * ceil32(return_data.size)) + 517] = 160
                                                mem[ceil32(ceil32(arg2.length)) + (6 * ceil32(return_data.size)) + 613] = 2
                                                idx = 0
                                                s = ceil32(ceil32(arg2.length)) + (6 * ceil32(return_data.size)) + 645
                                                t = ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + 385
                                                while idx < mem[ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + 353]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[ceil32(ceil32(arg2.length)) + (6 * ceil32(return_data.size)) + 549] = this.address
                                                mem[ceil32(ceil32(arg2.length)) + (6 * ceil32(return_data.size)) + 581] = block.timestamp
                                                require ext_code.size(uniswapV2RouterAddress)
                                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len ceil32(ceil32(arg2.length)) + (6 * ceil32(return_data.size)) + -mem[64] + 705]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _2286 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_2286] = 30
                                                mem[_2286 + 32] = 'SafeMath: subtraction overflow'
                                                if eth.balance(this.address) > eth.balance(this.address):
                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                if eth.balance(this.address) < eth.balance(this.address):
                                                    revert with 0, 17
                                                call distributionPoolAddress with:
                                                     gas 2300 wei
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _2508 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_2508] = 30
                                                mem[_2508 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > balanceOf[this.address] * rewardsFee / 100:
                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                if balanceOf[this.address] * rewardsFee / 100 < 0:
                                                    revert with 0, 17
                                                if not this.address:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not distributionPoolAddress:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                _2590 = mem[64]
                                                mem[64] = mem[64] + 96
                                                mem[_2590] = 38
                                                mem[_2590 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                if balanceOf[this.address] * rewardsFee / 100 > balanceOf[address(this.address)]:
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 38
                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_2590 + 70 len 26]
                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                if balanceOf[address(this.address)] < balanceOf[this.address] * rewardsFee / 100:
                                                    revert with 0, 17
                                                balanceOf[address(this.address)] -= balanceOf[this.address] * rewardsFee / 100
                                                if balanceOf[stor12] > !(balanceOf[this.address] * rewardsFee / 100):
                                                    revert with 0, 17
                                                if balanceOf[stor12] + (balanceOf[this.address] * rewardsFee / 100) < balanceOf[stor12]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = distributionPoolAddress
                                                mem[32] = 0
                                                balanceOf[stor12] += balanceOf[this.address] * rewardsFee / 100
                                                emit Transfer((balanceOf[this.address] * rewardsFee / 100), this.address, distributionPoolAddress);
                                                if balanceOf[this.address]:
                                                    if balanceOf[this.address] and liquidityPoolFee > -1 / balanceOf[this.address]:
                                                        revert with 0, 17
                                                    if not balanceOf[this.address]:
                                                        revert with 0, 18
                                                    if balanceOf[this.address] * liquidityPoolFee / balanceOf[this.address] != liquidityPoolFee:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    _2894 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_2894] = 26
                                                    mem[_2894 + 32] = 'SafeMath: division by zero'
                                                    _2925 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_2925] = 26
                                                    mem[_2925 + 32] = 'SafeMath: division by zero'
                                                    _2951 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_2951] = 30
                                                    mem[_2951 + 32] = 'SafeMath: subtraction overflow'
                                                    if balanceOf[this.address] * liquidityPoolFee / 100 / 2 > balanceOf[this.address] * liquidityPoolFee / 100:
                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                    if balanceOf[this.address] * liquidityPoolFee / 100 < balanceOf[this.address] * liquidityPoolFee / 100 / 2:
                                                        revert with 0, 17
                                                    _3051 = mem[64]
                                                    mem[mem[64]] = 2
                                                    mem[64] = mem[64] + 96
                                                    mem[_3051 + 32 len 64] = call.data[calldata.size len 64]
                                                    if 0 >= mem[_3051]:
                                                        revert with 0, 50
                                                    mem[_3051 + 32] = this.address
                                                    require ext_code.size(uniswapV2RouterAddress)
                                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                                            gas gas_remaining wei
                                                    mem[_3051 + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[64] = _3051 + ceil32(return_data.size) + 96
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                    if 1 >= mem[_3051]:
                                                        revert with 0, 50
                                                    mem[_3051 + 64] = ext_call.return_data[12 len 20]
                                                    if not this.address:
                                                        revert with 0, 'ERC20: approve from the zero address'
                                                    if not uniswapV2RouterAddress:
                                                        revert with 0, 'ERC20: approve to the zero address'
                                                    mem[0] = uniswapV2RouterAddress
                                                    mem[32] = sha3(address(this.address), 1)
                                                    allowance[address(this.address)][stor9].field_0 = balanceOf[this.address] * liquidityPoolFee / 100 / 2
                                                    allowance[address(this.address)][stor9].field_255 = 0
                                                    emit Approval((balanceOf[this.address] * liquidityPoolFee / 100 / 2), this.address, uniswapV2RouterAddress);
                                                    mem[_3051 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                    mem[_3051 + ceil32(return_data.size) + 100] = balanceOf[this.address] * liquidityPoolFee / 100 / 2
                                                    mem[_3051 + ceil32(return_data.size) + 132] = 0
                                                    mem[_3051 + ceil32(return_data.size) + 164] = 160
                                                    mem[_3051 + ceil32(return_data.size) + 260] = mem[_3051]
                                                    idx = 0
                                                    s = _3051 + ceil32(return_data.size) + 292
                                                    t = _3051 + 32
                                                    while idx < mem[_3051]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    require ext_code.size(uniswapV2RouterAddress)
                                                    call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args Mask(255, 1, balanceOf[this.address] * liquidityPoolFee / 100), 0, 160, address(this.address), block.timestamp, mem[_3051 + ceil32(return_data.size) + 260 len (32 * mem[_3051]) + 32]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[_3051 + ceil32(return_data.size) + 96] = 30
                                                    mem[_3051 + ceil32(return_data.size) + 128] = 'SafeMath: subtraction overflow'
                                                    if eth.balance(this.address) > eth.balance(this.address):
                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                    if eth.balance(this.address) < eth.balance(this.address):
                                                        revert with 0, 17
                                                    if not this.address:
                                                        revert with 0, 'ERC20: approve from the zero address'
                                                    if not uniswapV2RouterAddress:
                                                        revert with 0, 'ERC20: approve to the zero address'
                                                    allowance[address(this.address)][stor9].field_0 = (balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2)
                                                    emit Approval(((balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2)), this.address, uniswapV2RouterAddress);
                                                    mem[_3051 + ceil32(return_data.size) + 228] = 0
                                                    mem[_3051 + ceil32(return_data.size) + 260] = 0
                                                    mem[_3051 + ceil32(return_data.size) + 292] = 0
                                                    mem[_3051 + ceil32(return_data.size) + 324] = block.timestamp
                                                    require ext_code.size(uniswapV2RouterAddress)
                                                    call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                         gas gas_remaining wei
                                                        args this.address, (balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2), 0, 0, 0, block.timestamp
                                                    mem[_3051 + ceil32(return_data.size) + 160 len 96] = ext_call.return_data[0 len 96]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 96
                                                    emit SwapAndLiquify(Mask(255, 1, balanceOf[this.address] * liquidityPoolFee / 100), 0, (balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2));
                                                    mem[_3051 + (2 * ceil32(return_data.size)) + 160] = 2
                                                    mem[_3051 + (2 * ceil32(return_data.size)) + 192] = this.address
                                                    require ext_code.size(uniswapV2RouterAddress)
                                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                                            gas gas_remaining wei
                                                    mem[_3051 + (2 * ceil32(return_data.size)) + 256] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[64] = _3051 + (4 * ceil32(return_data.size)) + 256
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                    mem[_3051 + (2 * ceil32(return_data.size)) + 224] = ext_call.return_data[12 len 20]
                                                    if not this.address:
                                                        revert with 0, 'ERC20: approve from the zero address'
                                                    if not uniswapV2RouterAddress:
                                                        revert with 0, 'ERC20: approve to the zero address'
                                                    mem[0] = uniswapV2RouterAddress
                                                    mem[32] = sha3(address(this.address), 1)
                                                    allowance[address(this.address)][stor9].field_0 = balanceOf[this.address]
                                                    emit Approval(balanceOf[this.address], this.address, uniswapV2RouterAddress);
                                                    mem[_3051 + (4 * ceil32(return_data.size)) + 256] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                    mem[_3051 + (4 * ceil32(return_data.size)) + 260] = balanceOf[this.address]
                                                    mem[_3051 + (4 * ceil32(return_data.size)) + 292] = 0
                                                    mem[_3051 + (4 * ceil32(return_data.size)) + 324] = 160
                                                    mem[_3051 + (4 * ceil32(return_data.size)) + 420] = 2
                                                    idx = 0
                                                    s = _3051 + (4 * ceil32(return_data.size)) + 452
                                                    t = _3051 + (2 * ceil32(return_data.size)) + 192
                                                    while idx < mem[_3051 + (2 * ceil32(return_data.size)) + 160]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_3051 + (4 * ceil32(return_data.size)) + 356] = this.address
                                                    mem[_3051 + (4 * ceil32(return_data.size)) + 388] = block.timestamp
                                                    require ext_code.size(uniswapV2RouterAddress)
                                                    call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args balanceOf[this.address], 0, 160, address(this.address), block.timestamp, mem[_3051 + (4 * ceil32(return_data.size)) + 420 len (32 * mem[_3051 + (2 * ceil32(return_data.size)) + 160]) + 32]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[_3051 + (4 * ceil32(return_data.size)) + 256] = 30
                                                    mem[_3051 + (4 * ceil32(return_data.size)) + 288] = 'SafeMath: subtraction overflow'
                                                    if eth.balance(this.address) > eth.balance(this.address):
                                                        mem[_3051 + (4 * ceil32(return_data.size)) + 320] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_3051 + (4 * ceil32(return_data.size)) + 324] = 32
                                                        mem[_3051 + (4 * ceil32(return_data.size)) + 356] = 30
                                                        mem[_3051 + (4 * ceil32(return_data.size)) + 388] = 'SafeMath: subtraction overflow'
                                                        mem[_3051 + (4 * ceil32(return_data.size)) + 418] = 0
                                                        revert with memory
                                                          from _3051 + (4 * ceil32(return_data.size)) + 320
                                                           len (5 * ceil32(return_data.size)) + 100
                                                    if eth.balance(this.address) < eth.balance(this.address):
                                                        revert with 0, 17
                                                    call marketingWalletAddress with:
                                                         gas 2300 wei
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    uint8(stor23.field_0) = 0
                                                    if not msg.sender:
                                                        mem[_3051 + (4 * ceil32(return_data.size)) + 320] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_3051 + (4 * ceil32(return_data.size)) + 324] = 32
                                                        mem[_3051 + (4 * ceil32(return_data.size)) + 356] = 37
                                                        mem[_3051 + (4 * ceil32(return_data.size)) + 388] = 'ERC20: transfer from the zero ad'
                                                        mem[_3051 + (4 * ceil32(return_data.size)) + 420] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                        revert with memory
                                                          from _3051 + (4 * ceil32(return_data.size)) + 320
                                                           len (5 * ceil32(return_data.size)) + 132
                                                    if not this.address:
                                                        mem[_3051 + (4 * ceil32(return_data.size)) + 320] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_3051 + (4 * ceil32(return_data.size)) + 324] = 32
                                                        mem[_3051 + (4 * ceil32(return_data.size)) + 356] = 35
                                                        mem[_3051 + (4 * ceil32(return_data.size)) + 388] = 'ERC20: transfer to the zero addr'
                                                        mem[_3051 + (4 * ceil32(return_data.size)) + 420] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                        revert with memory
                                                          from _3051 + (4 * ceil32(return_data.size)) + 320
                                                           len (5 * ceil32(return_data.size)) + 132
                                                    mem[_3051 + (4 * ceil32(return_data.size)) + 320] = 38
                                                    mem[_3051 + (4 * ceil32(return_data.size)) + 352 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                    if ext_call.return_data[0] > balanceOf[address(msg.sender)]:
                                                        mem[_3051 + (4 * ceil32(return_data.size)) + 416] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_3051 + (4 * ceil32(return_data.size)) + 420] = 32
                                                        mem[_3051 + (4 * ceil32(return_data.size)) + 452] = 38
                                                        mem[_3051 + (4 * ceil32(return_data.size)) + 484 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, Mask(208, 32, block.timestamp) >> 32
                                                        mem[_3051 + (4 * ceil32(return_data.size)) + 522] = 0
                                                        revert with memory
                                                          from _3051 + (4 * ceil32(return_data.size)) + 416
                                                           len (5 * ceil32(return_data.size)) + 132
                                                    if balanceOf[address(msg.sender)] < ext_call.return_data[0]:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] -= ext_call.return_data[0]
                                                    if balanceOf[this.address] > !ext_call.return_data[0]:
                                                        revert with 0, 17
                                                    if balanceOf[this.address] + ext_call.return_data[0] >= balanceOf[this.address]:
                                                        balanceOf[address(this.address)] = balanceOf[this.address] + ext_call.return_data[0]
                                                        emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                                        if arg1 >= 3:
                                                            revert with 0, 50
                                                        mem[_3051 + (4 * ceil32(return_data.size)) + 416] = 0x12b8603f00000000000000000000000000000000000000000000000000000000
                                                        mem[_3051 + (4 * ceil32(return_data.size)) + 420] = msg.sender
                                                        mem[_3051 + (4 * ceil32(return_data.size)) + 452] = 64
                                                        mem[_3051 + (4 * ceil32(return_data.size)) + 484] = mem[128]
                                                        mem[_3051 + (4 * ceil32(return_data.size)) + 516 len ceil32(mem[128])] = mem[160 len ceil32(mem[128])]
                                                        if ceil32(mem[128]) > mem[128]:
                                                            mem[_3051 + (4 * ceil32(return_data.size)) + mem[128] + 516] = 0
                                                        require ext_code.size(sub_20eea8b5[arg1])
                                                        call sub_20eea8b5[arg1].createNode(address arg1, string arg2) with:
                                                             gas gas_remaining wei
                                                            args mem[_3051 + (4 * ceil32(return_data.size)) + 420 len ceil32(mem[128]) + (5 * ceil32(return_data.size)) + 96]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if stor27[address(msg.sender)] > -2:
                                                            revert with 0, 17
                                                        if stor27[address(msg.sender)] + 1 >= stor27[address(msg.sender)]:
                                                            stor27[address(msg.sender)]++
                                                    mem[_3051 + (4 * ceil32(return_data.size)) + 416] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[_3051 + (4 * ceil32(return_data.size)) + 420] = 32
                                                    mem[_3051 + (4 * ceil32(return_data.size)) + 452] = 27
                                                    mem[_3051 + (4 * ceil32(return_data.size)) + 484] = 'SafeMath: addition overflow'
                                                    revert with memory
                                                      from _3051 + (4 * ceil32(return_data.size)) + 416
                                                       len (5 * ceil32(return_data.size)) + 100
                                                _2844 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_2844] = 26
                                                mem[_2844 + 32] = 'SafeMath: division by zero'
                                                _2908 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_2908] = 26
                                                mem[_2908 + 32] = 'SafeMath: division by zero'
                                                _2935 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_2935] = 30
                                                mem[_2935 + 32] = 'SafeMath: subtraction overflow'
                                                _2970 = mem[64]
                                                mem[mem[64]] = 2
                                                mem[64] = mem[64] + 96
                                                mem[_2970 + 32 len 64] = call.data[calldata.size len 64]
                                                if 0 >= mem[_2970]:
                                                    revert with 0, 50
                                                mem[_2970 + 32] = this.address
                                                require ext_code.size(uniswapV2RouterAddress)
                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                        gas gas_remaining wei
                                                mem[_2970 + 96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[64] = _2970 + ceil32(return_data.size) + 96
                                                require return_data.size >= 32
                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                if 1 >= mem[_2970]:
                                                    revert with 0, 50
                                                mem[_2970 + 64] = ext_call.return_data[12 len 20]
                                                if not this.address:
                                                    revert with 0, 'ERC20: approve from the zero address'
                                                if not uniswapV2RouterAddress:
                                                    revert with 0, 'ERC20: approve to the zero address'
                                                mem[0] = uniswapV2RouterAddress
                                                mem[32] = sha3(address(this.address), 1)
                                                allowance[address(this.address)][stor9].field_0 = 0
                                                emit Approval(0, this.address, uniswapV2RouterAddress);
                                                mem[_2970 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                mem[_2970 + ceil32(return_data.size) + 100] = 0
                                                mem[_2970 + ceil32(return_data.size) + 132] = 0
                                                mem[_2970 + ceil32(return_data.size) + 164] = 160
                                                mem[_2970 + ceil32(return_data.size) + 260] = mem[_2970]
                                                idx = 0
                                                s = _2970 + ceil32(return_data.size) + 292
                                                t = _2970 + 32
                                                while idx < mem[_2970]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_2970 + ceil32(return_data.size) + 196] = this.address
                                                mem[_2970 + ceil32(return_data.size) + 228] = block.timestamp
                                                require ext_code.size(uniswapV2RouterAddress)
                                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _2970 + ceil32(return_data.size) + (32 * mem[_2970]) + -mem[64] + 288]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _5333 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_5333] = 30
                                                mem[_5333 + 32] = 'SafeMath: subtraction overflow'
                                                if eth.balance(this.address) > eth.balance(this.address):
                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                if eth.balance(this.address) < eth.balance(this.address):
                                                    revert with 0, 17
                                                if not this.address:
                                                    revert with 0, 'ERC20: approve from the zero address'
                                                if not uniswapV2RouterAddress:
                                                    revert with 0, 'ERC20: approve to the zero address'
                                                mem[0] = uniswapV2RouterAddress
                                                mem[32] = sha3(address(this.address), 1)
                                                allowance[address(this.address)][stor9].field_0 = 0
                                                emit Approval(0, this.address, uniswapV2RouterAddress);
                                                mem[mem[64] + 68] = 0
                                                mem[mem[64] + 100] = 0
                                                mem[mem[64] + 132] = 0
                                                mem[mem[64] + 164] = block.timestamp
                                                require ext_code.size(uniswapV2RouterAddress)
                                                call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                     gas gas_remaining wei
                                                    args this.address, 0, 0, 0, 0, block.timestamp
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 96
                                                mem[mem[64] + 32] = 0
                                                mem[mem[64] + 64] = 0
                                                emit SwapAndLiquify(uint256 arg1, uint256 arg2, uint256 arg3):
                                                                    0,
                                                mem[0] = this.address
                                                mem[32] = 0
                                                _5867 = mem[64]
                                                mem[mem[64]] = 2
                                                mem[64] = mem[64] + 96
                                                mem[_5867 + 32 len 64] = call.data[calldata.size len 64]
                                                if 0 >= mem[_5867]:
                                                    revert with 0, 50
                                                mem[_5867 + 32] = this.address
                                                require ext_code.size(uniswapV2RouterAddress)
                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                        gas gas_remaining wei
                                                mem[_5867 + 96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[64] = _5867 + ceil32(return_data.size) + 96
                                                require return_data.size >= 32
                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                if 1 >= mem[_5867]:
                                                    revert with 0, 50
                                                mem[_5867 + 64] = ext_call.return_data[12 len 20]
                                                if not this.address:
                                                    revert with 0, 'ERC20: approve from the zero address'
                                                if not uniswapV2RouterAddress:
                                                    revert with 0, 'ERC20: approve to the zero address'
                                                mem[0] = uniswapV2RouterAddress
                                                mem[32] = sha3(address(this.address), 1)
                                                allowance[address(this.address)][stor9].field_0 = balanceOf[this.address]
                                                emit Approval(balanceOf[this.address], this.address, uniswapV2RouterAddress);
                                                mem[_5867 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                mem[_5867 + ceil32(return_data.size) + 100] = balanceOf[this.address]
                                                mem[_5867 + ceil32(return_data.size) + 132] = 0
                                                mem[_5867 + ceil32(return_data.size) + 164] = 160
                                                mem[_5867 + ceil32(return_data.size) + 260] = mem[_5867]
                                                idx = 0
                                                s = _5867 + ceil32(return_data.size) + 292
                                                t = _5867 + 32
                                                while idx < mem[_5867]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_5867 + ceil32(return_data.size) + 196] = this.address
                                                mem[_5867 + ceil32(return_data.size) + 228] = block.timestamp
                                                require ext_code.size(uniswapV2RouterAddress)
                                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _5867 + ceil32(return_data.size) + (32 * mem[_5867]) + -mem[64] + 288]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _8755 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8755] = 30
                                                mem[_8755 + 32] = 'SafeMath: subtraction overflow'
                                                if eth.balance(this.address) > eth.balance(this.address):
                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                if eth.balance(this.address) < eth.balance(this.address):
                                                    revert with 0, 17
                                                call marketingWalletAddress with:
                                                     gas 2300 wei
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                uint8(stor23.field_0) = 0
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not this.address:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                _9115 = mem[64]
                                                mem[64] = mem[64] + 96
                                                mem[_9115] = 38
                                                mem[_9115 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                if ext_call.return_data[0] > balanceOf[address(msg.sender)]:
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 38
                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_9115 + 70 len 26]
                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                            else:
                                                if balanceOf[this.address] * rewardsFee / 100 and stor22 > -1 / balanceOf[this.address] * rewardsFee / 100:
                                                    revert with 0, 17
                                                if not balanceOf[this.address] * rewardsFee / 100:
                                                    revert with 0, 18
                                                if balanceOf[this.address] * rewardsFee / 100 * stor22 / balanceOf[this.address] * rewardsFee / 100 != stor22:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                mem[ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + 289] = 26
                                                mem[ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + 321] = 'SafeMath: division by zero'
                                                mem[ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + 353] = 2
                                                mem[ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + 385] = this.address
                                                require ext_code.size(uniswapV2RouterAddress)
                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                        gas gas_remaining wei
                                                mem[ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + 449] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[64] = ceil32(ceil32(arg2.length)) + (6 * ceil32(return_data.size)) + 449
                                                require return_data.size >= 32
                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                mem[ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + 417] = ext_call.return_data[12 len 20]
                                                if not this.address:
                                                    revert with 0, 
                                                                'ERC20: approve from the zero address',
                                                                mem[ceil32(ceil32(arg2.length)) + (6 * ceil32(return_data.size)) + 581 len 9 * ceil32(return_data.size)]
                                                if not uniswapV2RouterAddress:
                                                    revert with 0, 
                                                                'ERC20: approve to the zero address',
                                                                mem[ceil32(ceil32(arg2.length)) + (6 * ceil32(return_data.size)) + 581 len 9 * ceil32(return_data.size)]
                                                mem[0] = uniswapV2RouterAddress
                                                mem[32] = sha3(address(this.address), 1)
                                                allowance[address(this.address)][stor9].field_0 = balanceOf[this.address] * rewardsFee / 100 * stor22 / 100
                                                emit Approval(address arg1, address arg2, uint256 arg3):
                                                              balanceOf[this.address] * rewardsFee / 100 * stor22 / 100,
                                                              mem[ceil32(ceil32(arg2.length)) + (6 * ceil32(return_data.size)) + 481 len 9 * ceil32(return_data.size)],
                                                              this.address,
                                                              uniswapV2RouterAddress,
                                                mem[ceil32(ceil32(arg2.length)) + (6 * ceil32(return_data.size)) + 449] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                mem[ceil32(ceil32(arg2.length)) + (6 * ceil32(return_data.size)) + 453] = balanceOf[this.address] * rewardsFee / 100 * stor22 / 100
                                                mem[ceil32(ceil32(arg2.length)) + (6 * ceil32(return_data.size)) + 485] = 0
                                                mem[ceil32(ceil32(arg2.length)) + (6 * ceil32(return_data.size)) + 517] = 160
                                                mem[ceil32(ceil32(arg2.length)) + (6 * ceil32(return_data.size)) + 613] = 2
                                                idx = 0
                                                s = ceil32(ceil32(arg2.length)) + (6 * ceil32(return_data.size)) + 645
                                                t = ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + 385
                                                while idx < mem[ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + 353]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[ceil32(ceil32(arg2.length)) + (6 * ceil32(return_data.size)) + 549] = this.address
                                                mem[ceil32(ceil32(arg2.length)) + (6 * ceil32(return_data.size)) + 581] = block.timestamp
                                                require ext_code.size(uniswapV2RouterAddress)
                                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len ceil32(ceil32(arg2.length)) + (6 * ceil32(return_data.size)) + -mem[64] + 705]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _2285 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_2285] = 30
                                                mem[_2285 + 32] = 'SafeMath: subtraction overflow'
                                                if eth.balance(this.address) > eth.balance(this.address):
                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                if eth.balance(this.address) < eth.balance(this.address):
                                                    revert with 0, 17
                                                call distributionPoolAddress with:
                                                     gas 2300 wei
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _2506 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_2506] = 30
                                                mem[_2506 + 32] = 'SafeMath: subtraction overflow'
                                                if balanceOf[this.address] * rewardsFee / 100 * stor22 / 100 > balanceOf[this.address] * rewardsFee / 100:
                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                if balanceOf[this.address] * rewardsFee / 100 < balanceOf[this.address] * rewardsFee / 100 * stor22 / 100:
                                                    revert with 0, 17
                                                if not this.address:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not distributionPoolAddress:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                _2586 = mem[64]
                                                mem[64] = mem[64] + 96
                                                mem[_2586] = 38
                                                mem[_2586 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                if (balanceOf[this.address] * rewardsFee / 100) - (balanceOf[this.address] * rewardsFee / 100 * stor22 / 100) > balanceOf[address(this.address)]:
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 38
                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_2586 + 70 len 26]
                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                if balanceOf[address(this.address)] < (balanceOf[this.address] * rewardsFee / 100) - (balanceOf[this.address] * rewardsFee / 100 * stor22 / 100):
                                                    revert with 0, 17
                                                balanceOf[address(this.address)] = balanceOf[address(this.address)] - (balanceOf[this.address] * rewardsFee / 100) + (balanceOf[this.address] * rewardsFee / 100 * stor22 / 100)
                                                if balanceOf[stor12] > !((balanceOf[this.address] * rewardsFee / 100) - (balanceOf[this.address] * rewardsFee / 100 * stor22 / 100)):
                                                    revert with 0, 17
                                                if balanceOf[stor12] + (balanceOf[this.address] * rewardsFee / 100) - (balanceOf[this.address] * rewardsFee / 100 * stor22 / 100) < balanceOf[stor12]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = distributionPoolAddress
                                                mem[32] = 0
                                                balanceOf[stor12] = balanceOf[stor12] + (balanceOf[this.address] * rewardsFee / 100) - (balanceOf[this.address] * rewardsFee / 100 * stor22 / 100)
                                                emit Transfer(((balanceOf[this.address] * rewardsFee / 100) - (balanceOf[this.address] * rewardsFee / 100 * stor22 / 100)), this.address, distributionPoolAddress);
                                                if balanceOf[this.address]:
                                                    if balanceOf[this.address] and liquidityPoolFee > -1 / balanceOf[this.address]:
                                                        revert with 0, 17
                                                    if not balanceOf[this.address]:
                                                        revert with 0, 18
                                                    if balanceOf[this.address] * liquidityPoolFee / balanceOf[this.address] != liquidityPoolFee:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    _2893 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_2893] = 26
                                                    mem[_2893 + 32] = 'SafeMath: division by zero'
                                                    _2924 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_2924] = 26
                                                    mem[_2924 + 32] = 'SafeMath: division by zero'
                                                    _2950 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_2950] = 30
                                                    mem[_2950 + 32] = 'SafeMath: subtraction overflow'
                                                    if balanceOf[this.address] * liquidityPoolFee / 100 / 2 > balanceOf[this.address] * liquidityPoolFee / 100:
                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                    if balanceOf[this.address] * liquidityPoolFee / 100 < balanceOf[this.address] * liquidityPoolFee / 100 / 2:
                                                        revert with 0, 17
                                                    _3049 = mem[64]
                                                    mem[mem[64]] = 2
                                                    mem[64] = mem[64] + 96
                                                    mem[_3049 + 32 len 64] = call.data[calldata.size len 64]
                                                    if 0 >= mem[_3049]:
                                                        revert with 0, 50
                                                    mem[_3049 + 32] = this.address
                                                    require ext_code.size(uniswapV2RouterAddress)
                                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                                            gas gas_remaining wei
                                                    mem[_3049 + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[64] = _3049 + ceil32(return_data.size) + 96
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                    if 1 >= mem[_3049]:
                                                        revert with 0, 50
                                                    mem[_3049 + 64] = ext_call.return_data[12 len 20]
                                                    if not this.address:
                                                        revert with 0, 'ERC20: approve from the zero address'
                                                    if not uniswapV2RouterAddress:
                                                        revert with 0, 'ERC20: approve to the zero address'
                                                    mem[0] = uniswapV2RouterAddress
                                                    mem[32] = sha3(address(this.address), 1)
                                                    allowance[address(this.address)][stor9].field_0 = balanceOf[this.address] * liquidityPoolFee / 100 / 2
                                                    allowance[address(this.address)][stor9].field_255 = 0
                                                    emit Approval((balanceOf[this.address] * liquidityPoolFee / 100 / 2), this.address, uniswapV2RouterAddress);
                                                    mem[_3049 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                    mem[_3049 + ceil32(return_data.size) + 100] = balanceOf[this.address] * liquidityPoolFee / 100 / 2
                                                    mem[_3049 + ceil32(return_data.size) + 132] = 0
                                                    mem[_3049 + ceil32(return_data.size) + 164] = 160
                                                    mem[_3049 + ceil32(return_data.size) + 260] = mem[_3049]
                                                    idx = 0
                                                    s = _3049 + ceil32(return_data.size) + 292
                                                    t = _3049 + 32
                                                    while idx < mem[_3049]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    require ext_code.size(uniswapV2RouterAddress)
                                                    call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args Mask(255, 1, balanceOf[this.address] * liquidityPoolFee / 100), 0, 160, address(this.address), block.timestamp, mem[_3049 + ceil32(return_data.size) + 260 len (32 * mem[_3049]) + 32]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[_3049 + ceil32(return_data.size) + 96] = 30
                                                    mem[_3049 + ceil32(return_data.size) + 128] = 'SafeMath: subtraction overflow'
                                                    if eth.balance(this.address) > eth.balance(this.address):
                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                    if eth.balance(this.address) < eth.balance(this.address):
                                                        revert with 0, 17
                                                    if not this.address:
                                                        revert with 0, 'ERC20: approve from the zero address'
                                                    if not uniswapV2RouterAddress:
                                                        revert with 0, 'ERC20: approve to the zero address'
                                                    allowance[address(this.address)][stor9].field_0 = (balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2)
                                                    emit Approval(((balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2)), this.address, uniswapV2RouterAddress);
                                                    mem[_3049 + ceil32(return_data.size) + 228] = 0
                                                    mem[_3049 + ceil32(return_data.size) + 260] = 0
                                                    mem[_3049 + ceil32(return_data.size) + 292] = 0
                                                    mem[_3049 + ceil32(return_data.size) + 324] = block.timestamp
                                                    require ext_code.size(uniswapV2RouterAddress)
                                                    call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                         gas gas_remaining wei
                                                        args this.address, (balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2), 0, 0, 0, block.timestamp
                                                    mem[_3049 + ceil32(return_data.size) + 160 len 96] = ext_call.return_data[0 len 96]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 96
                                                    emit SwapAndLiquify(Mask(255, 1, balanceOf[this.address] * liquidityPoolFee / 100), 0, (balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2));
                                                    mem[_3049 + (2 * ceil32(return_data.size)) + 160] = 2
                                                    mem[_3049 + (2 * ceil32(return_data.size)) + 192] = this.address
                                                    require ext_code.size(uniswapV2RouterAddress)
                                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                                            gas gas_remaining wei
                                                    mem[_3049 + (2 * ceil32(return_data.size)) + 256] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[64] = _3049 + (4 * ceil32(return_data.size)) + 256
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                    mem[_3049 + (2 * ceil32(return_data.size)) + 224] = ext_call.return_data[12 len 20]
                                                    if not this.address:
                                                        revert with 0, 'ERC20: approve from the zero address'
                                                    if not uniswapV2RouterAddress:
                                                        revert with 0, 'ERC20: approve to the zero address'
                                                    mem[0] = uniswapV2RouterAddress
                                                    mem[32] = sha3(address(this.address), 1)
                                                    allowance[address(this.address)][stor9].field_0 = balanceOf[this.address]
                                                    emit Approval(balanceOf[this.address], this.address, uniswapV2RouterAddress);
                                                    mem[_3049 + (4 * ceil32(return_data.size)) + 256] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                    mem[_3049 + (4 * ceil32(return_data.size)) + 260] = balanceOf[this.address]
                                                    mem[_3049 + (4 * ceil32(return_data.size)) + 292] = 0
                                                    mem[_3049 + (4 * ceil32(return_data.size)) + 324] = 160
                                                    mem[_3049 + (4 * ceil32(return_data.size)) + 420] = 2
                                                    idx = 0
                                                    s = _3049 + (4 * ceil32(return_data.size)) + 452
                                                    t = _3049 + (2 * ceil32(return_data.size)) + 192
                                                    while idx < mem[_3049 + (2 * ceil32(return_data.size)) + 160]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_3049 + (4 * ceil32(return_data.size)) + 356] = this.address
                                                    mem[_3049 + (4 * ceil32(return_data.size)) + 388] = block.timestamp
                                                    require ext_code.size(uniswapV2RouterAddress)
                                                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _3049 + (4 * ceil32(return_data.size)) + (32 * mem[_3049 + (2 * ceil32(return_data.size)) + 160]) + -mem[64] + 448]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _8752 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_8752] = 30
                                                    mem[_8752 + 32] = 'SafeMath: subtraction overflow'
                                                    if eth.balance(this.address) > eth.balance(this.address):
                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                    if eth.balance(this.address) < eth.balance(this.address):
                                                        revert with 0, 17
                                                    call marketingWalletAddress with:
                                                         gas 2300 wei
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    uint8(stor23.field_0) = 0
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not this.address:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    _9106 = mem[64]
                                                    mem[64] = mem[64] + 96
                                                    mem[_9106] = 38
                                                    mem[_9106 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                    if ext_call.return_data[0] > balanceOf[address(msg.sender)]:
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 38
                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_9106 + 70 len 26]
                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                else:
                                                    _2843 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_2843] = 26
                                                    mem[_2843 + 32] = 'SafeMath: division by zero'
                                                    _2907 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_2907] = 26
                                                    mem[_2907 + 32] = 'SafeMath: division by zero'
                                                    _2934 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_2934] = 30
                                                    mem[_2934 + 32] = 'SafeMath: subtraction overflow'
                                                    _2967 = mem[64]
                                                    mem[mem[64]] = 2
                                                    mem[64] = mem[64] + 96
                                                    mem[_2967 + 32 len 64] = call.data[calldata.size len 64]
                                                    if 0 >= mem[_2967]:
                                                        revert with 0, 50
                                                    mem[_2967 + 32] = this.address
                                                    require ext_code.size(uniswapV2RouterAddress)
                                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                                            gas gas_remaining wei
                                                    mem[_2967 + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[64] = _2967 + ceil32(return_data.size) + 96
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                    if 1 >= mem[_2967]:
                                                        revert with 0, 50
                                                    mem[_2967 + 64] = ext_call.return_data[12 len 20]
                                                    if not this.address:
                                                        revert with 0, 'ERC20: approve from the zero address'
                                                    if not uniswapV2RouterAddress:
                                                        revert with 0, 'ERC20: approve to the zero address'
                                                    mem[0] = uniswapV2RouterAddress
                                                    mem[32] = sha3(address(this.address), 1)
                                                    allowance[address(this.address)][stor9].field_0 = 0
                                                    emit Approval(0, this.address, uniswapV2RouterAddress);
                                                    mem[_2967 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                    mem[_2967 + ceil32(return_data.size) + 100] = 0
                                                    mem[_2967 + ceil32(return_data.size) + 132] = 0
                                                    mem[_2967 + ceil32(return_data.size) + 164] = 160
                                                    mem[_2967 + ceil32(return_data.size) + 260] = mem[_2967]
                                                    idx = 0
                                                    s = _2967 + ceil32(return_data.size) + 292
                                                    t = _2967 + 32
                                                    while idx < mem[_2967]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_2967 + ceil32(return_data.size) + 196] = this.address
                                                    mem[_2967 + ceil32(return_data.size) + 228] = block.timestamp
                                                    require ext_code.size(uniswapV2RouterAddress)
                                                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _2967 + ceil32(return_data.size) + (32 * mem[_2967]) + -mem[64] + 288]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _5331 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_5331] = 30
                                                    mem[_5331 + 32] = 'SafeMath: subtraction overflow'
                                                    if eth.balance(this.address) > eth.balance(this.address):
                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                    if eth.balance(this.address) < eth.balance(this.address):
                                                        revert with 0, 17
                                                    if not this.address:
                                                        revert with 0, 'ERC20: approve from the zero address'
                                                    if not uniswapV2RouterAddress:
                                                        revert with 0, 'ERC20: approve to the zero address'
                                                    mem[0] = uniswapV2RouterAddress
                                                    mem[32] = sha3(address(this.address), 1)
                                                    allowance[address(this.address)][stor9].field_0 = 0
                                                    emit Approval(0, this.address, uniswapV2RouterAddress);
                                                    mem[mem[64] + 68] = 0
                                                    mem[mem[64] + 100] = 0
                                                    mem[mem[64] + 132] = 0
                                                    mem[mem[64] + 164] = block.timestamp
                                                    require ext_code.size(uniswapV2RouterAddress)
                                                    call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                         gas gas_remaining wei
                                                        args this.address, 0, 0, 0, 0, block.timestamp
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 96
                                                    mem[mem[64] + 32] = 0
                                                    mem[mem[64] + 64] = 0
                                                    emit SwapAndLiquify(uint256 arg1, uint256 arg2, uint256 arg3):
                                                                        0,
                                                    mem[0] = this.address
                                                    mem[32] = 0
                                                    _5863 = mem[64]
                                                    mem[mem[64]] = 2
                                                    mem[64] = mem[64] + 96
                                                    mem[_5863 + 32 len 64] = call.data[calldata.size len 64]
                                                    if 0 >= mem[_5863]:
                                                        revert with 0, 50
                                                    mem[_5863 + 32] = this.address
                                                    require ext_code.size(uniswapV2RouterAddress)
                                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                                            gas gas_remaining wei
                                                    mem[_5863 + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[64] = _5863 + ceil32(return_data.size) + 96
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                    if 1 >= mem[_5863]:
                                                        revert with 0, 50
                                                    mem[_5863 + 64] = ext_call.return_data[12 len 20]
                                                    if not this.address:
                                                        revert with 0, 'ERC20: approve from the zero address'
                                                    if not uniswapV2RouterAddress:
                                                        revert with 0, 'ERC20: approve to the zero address'
                                                    mem[0] = uniswapV2RouterAddress
                                                    mem[32] = sha3(address(this.address), 1)
                                                    allowance[address(this.address)][stor9].field_0 = balanceOf[this.address]
                                                    emit Approval(balanceOf[this.address], this.address, uniswapV2RouterAddress);
                                                    mem[_5863 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                    mem[_5863 + ceil32(return_data.size) + 100] = balanceOf[this.address]
                                                    mem[_5863 + ceil32(return_data.size) + 132] = 0
                                                    mem[_5863 + ceil32(return_data.size) + 164] = 160
                                                    mem[_5863 + ceil32(return_data.size) + 260] = mem[_5863]
                                                    idx = 0
                                                    s = _5863 + ceil32(return_data.size) + 292
                                                    t = _5863 + 32
                                                    while idx < mem[_5863]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_5863 + ceil32(return_data.size) + 196] = this.address
                                                    mem[_5863 + ceil32(return_data.size) + 228] = block.timestamp
                                                    require ext_code.size(uniswapV2RouterAddress)
                                                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _5863 + ceil32(return_data.size) + (32 * mem[_5863]) + -mem[64] + 288]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _8753 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_8753] = 30
                                                    mem[_8753 + 32] = 'SafeMath: subtraction overflow'
                                                    if eth.balance(this.address) > eth.balance(this.address):
                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                    if eth.balance(this.address) < eth.balance(this.address):
                                                        revert with 0, 17
                                                    call marketingWalletAddress with:
                                                         gas 2300 wei
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    uint8(stor23.field_0) = 0
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not this.address:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    _9109 = mem[64]
                                                    mem[64] = mem[64] + 96
                                                    mem[_9109] = 38
                                                    mem[_9109 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                    if ext_call.return_data[0] > balanceOf[address(msg.sender)]:
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 38
                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_9109 + 70 len 26]
                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                            ('le', ('ext_call.return_data', 0, 32), ('stor', ('map', ('mask_shl', 160, 0, 0, 'msg.sender'), ('name', 'balanceOf', 0))))
                                            if balanceOf[address(msg.sender)] < ext_call.return_data[0]:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] -= ext_call.return_data[0]
                                            if balanceOf[this.address] > !ext_call.return_data[0]:
                                                revert with 0, 17
                                            if balanceOf[this.address] + ext_call.return_data[0] < balanceOf[this.address]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(this.address)] = balanceOf[this.address] + ext_call.return_data[0]
                                            emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                            if arg1 >= 3:
                                                revert with 0, 50
                                            mem[mem[64]] = 0x12b8603f00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 64
                                            mem[mem[64] + 68] = mem[128]
                                            mem[mem[64] + 100 len ceil32(mem[128])] = mem[160 len ceil32(mem[128])]
                                            if ceil32(mem[128]) > mem[128]:
                                                mem[mem[64] + mem[128] + 100] = 0
                                            require ext_code.size(sub_20eea8b5[arg1])
                                            call sub_20eea8b5[arg1].createNode(address arg1, string arg2) with:
                                                 gas gas_remaining wei
                                                args msg.sender, Array(len=mem[128], data=mem[mem[64] + 100 len ceil32(mem[128])])
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if stor27[address(msg.sender)] > -2:
                    revert with 0, 17
                if stor27[address(msg.sender)] + 1 < stor27[address(msg.sender)]:
                    revert with 0, 'SafeMath: addition overflow'
                stor27[address(msg.sender)]++
        else:
            if unknown_0xa87ec2f7(?????) > uint32(call.func_hash) >> 224:
                if unknown_0x95d89b41(?????) > uint32(call.func_hash) >> 224:
                    if unknown_0x7977061e(?????) > uint32(call.func_hash) >> 224:
                        if unknown_0x6cdc78b3(?????) == uint32(call.func_hash) >> 224:
                            require not msg.value
                            return sub_6cdc78b3
                        if unknown_0x70a08231(?????) == uint32(call.func_hash) >> 224:
                            require not msg.value
                            require calldata.size - 4 >= 32
                            require arg1 == address(arg1)
                            return balanceOf[address(arg1)]
                        if uint32(call.func_hash) >> 224 != unknown_0x715018a6(?????):
                            require unknown_0x75f0a874(?????) == uint32(call.func_hash) >> 224
                            require not msg.value
                            return marketingWalletAddress
                        require not msg.value
                        if owner != msg.sender:
                            revert with 0, 'Ownable: caller is not the owner'
                        emit OwnershipTransferred(owner, 0);
                        owner = 0
                    else:
                        if unknown_0x7977061e(?????) == uint32(call.func_hash) >> 224:
                            require not msg.value
                            require calldata.size - 4 >= 32
                            if arg1 >= 3:
                                revert with 0, 50
                            require ext_code.size(sub_20eea8b5[arg1])
                            staticcall sub_20eea8b5[arg1].0xde72f0ba with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            return ext_call.return_data[0]
                        if unknown_0x8bc9c7b0(?????) == uint32(call.func_hash) >> 224:
                            require not msg.value
                            require calldata.size - 4 >= 32
                            if owner != msg.sender:
                                revert with 0, 'Ownable: caller is not the owner'
                            stor22 = arg1
                        else:
                            if unknown_0x8da5cb5b(?????) == uint32(call.func_hash) >> 224:
                                require not msg.value
                                return owner
                            require unknown_0x9349c47d(?????) == uint32(call.func_hash) >> 224
                            require not msg.value
                            require calldata.size - 4 >= 32
                            require arg1 == address(arg1)
                            if owner != msg.sender:
                                revert with 0, 'Ownable: caller is not the owner'
                            distributionPoolAddress = address(arg1)
                else:
                    if unknown_0xa0a8fe65(?????) <= uint32(call.func_hash) >> 224:
                        if unknown_0xa0a8fe65(?????) == uint32(call.func_hash) >> 224:
                            require not msg.value
                            idx = 0
                            s = 0
                            while idx < 3:
                                require ext_code.size(sub_20eea8b5[idx])
                                staticcall sub_20eea8b5[idx].totalNodesCreated() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _2185 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if s > !mem[_2185]:
                                    revert with 0, 17
                                if s + mem[_2185] < s:
                                    revert with 0, 'SafeMath: addition overflow'
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + mem[_2185]
                                continue 
                            return (0x6f32f1ef8b18a2bc3cea59789c79d441 * s)
                        if uint32(call.func_hash) >> 224 != unknown_0xa457c2d7(?????):
                            if unknown_0xa538ddf2(?????) == uint32(call.func_hash) >> 224:
                                require not msg.value
                                return futurUsePoolAddress
                            require unknown_0xa8682e1c(?????) == uint32(call.func_hash) >> 224
                            require not msg.value
                            require calldata.size - 4 >= 64
                            require arg1 == address(arg1)
                            if owner != msg.sender:
                                revert with 0, 'Ownable: caller is not the owner'
                            if arg2 >= 3:
                                revert with 0, 50
                            sub_20eea8b5[arg2] = address(arg1)
                        require not msg.value
                        require calldata.size - 4 >= 64
                        require arg1 == address(arg1)
                        if arg2 > allowance[msg.sender][address(arg1)].field_0:
                            revert with 0, 32, 37, 0x6545524332303a2064656372656173656420616c6c6f77616e63652062656c6f77207a6572, mem[197 len 27] >> 40, 0
                        if allowance[msg.sender][address(arg1)].field_0 < arg2:
                            revert with 0, 17
                        if not msg.sender:
                            revert with 0, 'ERC20: approve from the zero address'
                        if not address(arg1):
                            revert with 0, 'ERC20: approve to the zero address'
                        allowance[address(msg.sender)][address(arg1)].field_0 = allowance[msg.sender][address(arg1)].field_0 - arg2
                        emit Approval((allowance[msg.sender][address(arg1)].field_0 - arg2), msg.sender, address(arg1));
                        return 1
                    if unknown_0x95d89b41(?????) == uint32(call.func_hash) >> 224:
                        require not msg.value
                        if bool(stor4.length):
                            if bool(stor4.length) == uint255(stor4.length) * 0.5 < 32:
                                revert with 0, 34
                            if bool(stor4.length):
                                if bool(stor4.length) == uint255(stor4.length) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor4.length):
                                    if 31 < uint255(stor4.length) * 0.5:
                                        mem[160] = uint256(stor4.field_0)
                                        idx = 160
                                        s = 0
                                        while (uint255(stor4.length) * 0.5) + 128 > idx:
                                            mem[idx + 32] = stor4[s].field_256
                                            idx = idx + 32
                                            s = s + 1
                                            continue 
                                        return Array(len=2 * Mask(256, -1, stor4.length), data=mem[160 len ceil32(uint255(stor4.length) * 0.5)])
                                    mem[160] = 256 * stor4.length.field_8
                            else:
                                if bool(stor4.length) == stor4.length.field_1 < 32:
                                    revert with 0, 34
                                if stor4.length.field_1:
                                    if 31 < stor4.length.field_1:
                                        mem[160] = uint256(stor4.field_0)
                                        idx = 160
                                        s = 0
                                        while stor4.length.field_1 + 128 > idx:
                                            mem[idx + 32] = stor4[s].field_256
                                            idx = idx + 32
                                            s = s + 1
                                            continue 
                                        return Array(len=2 * Mask(256, -1, stor4.length), data=mem[160 len ceil32(uint255(stor4.length) * 0.5)])
                                    mem[160] = 256 * stor4.length.field_8
                            mem[ceil32(uint255(stor4.length) * 0.5) + 224 len ceil32(uint255(stor4.length) * 0.5)] = mem[160 len ceil32(uint255(stor4.length) * 0.5)]
                            if ceil32(uint255(stor4.length) * 0.5) > uint255(stor4.length) * 0.5:
                                mem[ceil32(uint255(stor4.length) * 0.5) + (uint255(stor4.length) * 0.5) + 224] = 0
                            return Array(len=2 * Mask(256, -1, stor4.length), data=mem[160 len ceil32(uint255(stor4.length) * 0.5)], mem[(2 * ceil32(uint255(stor4.length) * 0.5)) + 224 len 2 * ceil32(uint255(stor4.length) * 0.5)]), 
                        if bool(stor4.length) == stor4.length.field_1 < 32:
                            revert with 0, 34
                        if bool(stor4.length):
                            if bool(stor4.length) == uint255(stor4.length) * 0.5 < 32:
                                revert with 0, 34
                            if Mask(256, -1, stor4.length):
                                if 31 < uint255(stor4.length) * 0.5:
                                    mem[160] = uint256(stor4.field_0)
                                    idx = 160
                                    s = 0
                                    while (uint255(stor4.length) * 0.5) + 128 > idx:
                                        mem[idx + 32] = stor4[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    return Array(len=stor4.length % 128, data=mem[160 len ceil32(stor4.length.field_1)])
                                mem[160] = 256 * stor4.length.field_8
                        else:
                            if bool(stor4.length) == stor4.length.field_1 < 32:
                                revert with 0, 34
                            if stor4.length.field_1:
                                if 31 < stor4.length.field_1:
                                    mem[160] = uint256(stor4.field_0)
                                    idx = 160
                                    s = 0
                                    while stor4.length.field_1 + 128 > idx:
                                        mem[idx + 32] = stor4[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    return Array(len=stor4.length % 128, data=mem[160 len ceil32(stor4.length.field_1)])
                                mem[160] = 256 * stor4.length.field_8
                        mem[ceil32(stor4.length.field_1) + 224 len ceil32(stor4.length.field_1)] = mem[160 len ceil32(stor4.length.field_1)]
                        if ceil32(stor4.length.field_1) > stor4.length.field_1:
                            mem[ceil32(stor4.length.field_1) + stor4.length.field_1 + 224] = 0
                        return Array(len=stor4.length % 128, data=mem[160 len ceil32(stor4.length.field_1)], mem[(2 * ceil32(stor4.length.field_1)) + 224 len 2 * ceil32(stor4.length.field_1)]), 
                    if unknown_0x9a7a23d6(?????) == uint32(call.func_hash) >> 224:
                        require not msg.value
                        require calldata.size - 4 >= 64
                        require arg1 == address(arg1)
                        require arg2 == bool(arg2)
                        if owner != msg.sender:
                            revert with 0, 'Ownable: caller is not the owner'
                        if uniswapV2PairAddress == address(arg1):
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        'TKN: The PancakeSwap pair cannot be removed from automatedMarketMakerPairs'
                        if bool(arg2) == bool(stor26[address(arg1)]):
                            revert with 0, 'TKN: Automated market maker pair is already set to that value'
                        stor26[address(arg1)] = uint8(bool(arg2))
                        emit SetAutomatedMarketMakerPair(address(arg1), bool(arg2));
                    else:
                        if unknown_0x9ceb5c48(?????) == uint32(call.func_hash) >> 224:
                            require not msg.value
                            require calldata.size - 4 >= 64
                            require arg1 == address(arg1)
                            if arg2 >= 3:
                                revert with 0, 50
                            require ext_code.size(sub_20eea8b5[arg2])
                            staticcall sub_20eea8b5[arg2].0x80e9be34 with:
                                    gas gas_remaining wei
                                   args address(arg1), 1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            return ext_call.return_data[0]
                        require unknown_0xa0712d68(?????) == uint32(call.func_hash) >> 224
                        require not msg.value
                        require calldata.size - 4 >= 32
                        if owner != msg.sender:
                            revert with 0, 'Ownable: caller is not the owner'
                        if arg1 <= 0:
                            revert with 0, 'Invalid amount'
                        if not owner:
                            revert with 0, 'ERC20: mint to the zero address'
                        if totalSupply > !arg1:
                            revert with 0, 17
                        if totalSupply + arg1 < totalSupply:
                            revert with 0, 'SafeMath: addition overflow'
                        totalSupply += arg1
                        if balanceOf[stor5] > !arg1:
                            revert with 0, 17
                        if balanceOf[stor5] + arg1 < balanceOf[stor5]:
                            revert with 0, 'SafeMath: addition overflow'
                        balanceOf[stor5] += arg1
                        emit Transfer(arg1, 0, owner);
            else:
                if unknown_0xc84993af(?????) <= uint32(call.func_hash) >> 224:
                    if unknown_0xdd62ed3e(?????) > uint32(call.func_hash) >> 224:
                        if uint32(call.func_hash) >> 224 != unknown_0xc84993af(?????):
                            if unknown_0xcc9850a4(?????) == uint32(call.func_hash) >> 224:
                                require not msg.value
                                require calldata.size - 4 >= 64
                                if owner != msg.sender:
                                    revert with 0, 'Ownable: caller is not the owner'
                                if arg1 >= 3:
                                    revert with 0, 'Invalid rune id'
                                sub_075dc237[arg1] = arg2
                            if unknown_0xd8929342(?????) == uint32(call.func_hash) >> 224:
                                require not msg.value
                                require calldata.size - 4 >= 64
                                require arg1 == address(arg1)
                                require arg2 == bool(arg2)
                                if owner != msg.sender:
                                    revert with 0, 'Ownable: caller is not the owner'
                                stor25[address(arg1)] = uint8(bool(arg2))
                            require unknown_0xd8eb77f7(?????) == uint32(call.func_hash) >> 224
                            require not msg.value
                            require calldata.size - 4 >= 32
                            if arg1 >= 3:
                                revert with 0, 50
                            require ext_code.size(sub_20eea8b5[arg1])
                            staticcall sub_20eea8b5[arg1].rewardPerSec() with:
                                    gas gas_remaining wei
                        else:
                            require not msg.value
                            require calldata.size - 4 >= 32
                            if not msg.sender:
                                revert with 0, 'SENDER CAN'T BE ZERO'
                            if arg1 >= 3:
                                revert with 0, 50
                            require ext_code.size(sub_20eea8b5[arg1])
                            staticcall sub_20eea8b5[arg1]._isNodeOwner(address arg1) with:
                                    gas gas_remaining wei
                                   args msg.sender
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                            if not ext_call.return_data[0]:
                                revert with 0, 'NO NODE OWNER'
                            if arg1 >= 3:
                                revert with 0, 50
                            require ext_code.size(sub_20eea8b5[arg1])
                            staticcall sub_20eea8b5[arg1].0x80e9be34 with:
                                    gas gas_remaining wei
                                   args msg.sender, 1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        return ext_call.return_data[0]
                    if unknown_0xdd62ed3e(?????) == uint32(call.func_hash) >> 224:
                        require not msg.value
                        require calldata.size - 4 >= 64
                        require arg1 == address(arg1)
                        require arg2 == address(arg2)
                        return allowance[address(arg1)][address(arg2)].field_0
                    if unknown_0xe6e9b2b9(?????) == uint32(call.func_hash) >> 224:
                        require not msg.value
                        require calldata.size - 4 >= 64
                        if owner != msg.sender:
                            revert with 0, 'Ownable: caller is not the owner'
                        if arg2 >= 3:
                            revert with 0, 50
                        require ext_code.size(sub_20eea8b5[arg2])
                        call sub_20eea8b5[arg2].0x6da3c5c4 with:
                             gas gas_remaining wei
                            args arg1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                    else:
                        if uint32(call.func_hash) >> 224 != unknown_0xef690f34(?????):
                            require unknown_0xf2fde38b(?????) == uint32(call.func_hash) >> 224
                            require not msg.value
                            require calldata.size - 4 >= 32
                            require arg1 == address(arg1)
                            if owner != msg.sender:
                                revert with 0, 'Ownable: caller is not the owner'
                            if not address(arg1):
                                revert with 0, 'Ownable: new owner is the zero address'
                            emit OwnershipTransferred(owner, address(arg1));
                            owner = address(arg1)
                        else:
                            require not msg.value
                            require calldata.size - 4 >= 64
                            if not msg.sender:
                                revert with 0, 'AgamottoToken:  creation from the zero address'
                            if stor25[address(msg.sender)]:
                                revert with 0, 'Cashout: Blacklisted address'
                            if futurUsePoolAddress == msg.sender:
                                revert with 0, 'CSHT: futur, marketing and rewardsPool cannot cashout rewards'
                            if distributionPoolAddress == msg.sender:
                                revert with 0, 'CSHT: futur, marketing and rewardsPool cannot cashout rewards'
                            if marketingWalletAddress == msg.sender:
                                revert with 0, 'CSHT: futur, marketing and rewardsPool cannot cashout rewards'
                            if arg1 >= 3:
                                revert with 0, 50
                            mem[132] = msg.sender
                            require ext_code.size(sub_20eea8b5[arg1])
                            staticcall sub_20eea8b5[arg1]._getNodeNumberOf(address arg1) with:
                                    gas gas_remaining wei
                                   args msg.sender
                            mem[128] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if ext_call.return_data[0]:
                                if arg1 >= 3:
                                    revert with 0, 50
                                mem[ceil32(return_data.size) + 132] = msg.sender
                                mem[ceil32(return_data.size) + 164] = arg2
                                mem[ceil32(return_data.size) + 196] = 1
                                require ext_code.size(sub_20eea8b5[arg1])
                                staticcall sub_20eea8b5[arg1].0x288d8855 with:
                                        gas gas_remaining wei
                                       args msg.sender, arg2, 1
                                mem[ceil32(return_data.size) + 128] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if arg1 >= 3:
                                    revert with 0, 50
                                mem[(2 * ceil32(return_data.size)) + 132] = msg.sender
                                mem[(2 * ceil32(return_data.size)) + 164] = arg2
                                mem[(2 * ceil32(return_data.size)) + 196] = 0
                                require ext_code.size(sub_20eea8b5[arg1])
                                staticcall sub_20eea8b5[arg1].0x288d8855 with:
                                        gas gas_remaining wei
                                       args msg.sender, arg2, 0
                                mem[(2 * ceil32(return_data.size)) + 128] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                mem[(4 * ceil32(return_data.size)) + 128] = 30
                                mem[(4 * ceil32(return_data.size)) + 160] = 'SafeMath: subtraction overflow'
                                if ext_call.return_data[0] > ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if ext_call.return_data[0] < ext_call.return_data[0]:
                                    revert with 0, 17
                                if ext_call.return_data[0] <= 0:
                                    revert with 0, 'CSHT: You don't have enough reward to cash out'
                                if not uint8(stor23.field_8):
                                    if not distributionPoolAddress:
                                        revert with 0, 'ERC20: transfer from the zero address'
                                    if not msg.sender:
                                        revert with 0, 'ERC20: transfer to the zero address'
                                    if ext_call.return_data[0] > balanceOf[stor12]:
                                        revert with 0, 
                                                    32,
                                                    38,
                                                    0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[(4 * ceil32(return_data.size)) + 262 len 26] >> 48,
                                                    0
                                    if balanceOf[stor12] < ext_call.return_data[0]:
                                        revert with 0, 17
                                    balanceOf[stor12] -= ext_call.return_data[0]
                                    if balanceOf[msg.sender] > !ext_call.return_data[0]:
                                        revert with 0, 17
                                    if balanceOf[msg.sender] + ext_call.return_data[0] < balanceOf[msg.sender]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(msg.sender)] = balanceOf[msg.sender] + ext_call.return_data[0]
                                    emit Transfer(ext_call.return_data[0], distributionPoolAddress, msg.sender);
                                else:
                                    if arg1 >= 3:
                                        revert with 0, 50
                                    if sub_075dc237[arg1] <= 0:
                                        if 0 > ext_call.return_data[0]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if ext_call.return_data[0] < 0:
                                            revert with 0, 17
                                        if not distributionPoolAddress:
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        if ext_call.return_data[0] > balanceOf[stor12]:
                                            revert with 0, 
                                                        32,
                                                        38,
                                                        0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[(4 * ceil32(return_data.size)) + 326 len 26] >> 48,
                                                        0
                                        if balanceOf[stor12] < ext_call.return_data[0]:
                                            revert with 0, 17
                                        balanceOf[stor12] -= ext_call.return_data[0]
                                        if balanceOf[msg.sender] > !ext_call.return_data[0]:
                                            revert with 0, 17
                                        if balanceOf[msg.sender] + ext_call.return_data[0] < balanceOf[msg.sender]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(msg.sender)] = balanceOf[msg.sender] + ext_call.return_data[0]
                                        emit Transfer(ext_call.return_data[0], distributionPoolAddress, msg.sender);
                                    else:
                                        if arg1 >= 3:
                                            revert with 0, 50
                                        if not ext_call.return_data[0]:
                                            mem[(4 * ceil32(return_data.size)) + 192] = 26
                                            mem[(4 * ceil32(return_data.size)) + 224] = 'SafeMath: division by zero'
                                            if not distributionPoolAddress:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not this.address:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            mem[(4 * ceil32(return_data.size)) + 256] = 38
                                            mem[(4 * ceil32(return_data.size)) + 288 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                            if 0 > balanceOf[stor12]:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[(4 * ceil32(return_data.size)) + 326 len 26] >> 48,
                                                            0
                                            if balanceOf[stor12] < 0:
                                                revert with 0, 17
                                            if balanceOf[this.address] > !0:
                                                revert with 0, 17
                                            if balanceOf[this.address] < balanceOf[this.address]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(this.address)] = balanceOf[this.address]
                                            emit Transfer(0, distributionPoolAddress, this.address);
                                            mem[(4 * ceil32(return_data.size)) + 352] = 2
                                            mem[(4 * ceil32(return_data.size)) + 384] = this.address
                                            require ext_code.size(uniswapV2RouterAddress)
                                            staticcall uniswapV2RouterAddress.WAVAX() with:
                                                    gas gas_remaining wei
                                            mem[(4 * ceil32(return_data.size)) + 448] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[64] = (6 * ceil32(return_data.size)) + 448
                                            require return_data.size >= 32
                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                            mem[(4 * ceil32(return_data.size)) + 416] = ext_call.return_data[12 len 20]
                                            if not this.address:
                                                revert with 0, 'ERC20: approve from the zero address', mem[(6 * ceil32(return_data.size)) + 580 len 9 * ceil32(return_data.size)]
                                            if not uniswapV2RouterAddress:
                                                revert with 0, 'ERC20: approve to the zero address', mem[(6 * ceil32(return_data.size)) + 580 len 9 * ceil32(return_data.size)]
                                            mem[0] = uniswapV2RouterAddress
                                            mem[32] = sha3(address(this.address), 1)
                                            allowance[address(this.address)][stor9].field_0 = 0
                                            emit Approval(address arg1, address arg2, uint256 arg3):
                                                          0,
                                                          mem[(6 * ceil32(return_data.size)) + 480 len 9 * ceil32(return_data.size)],
                                                          this.address,
                                                          uniswapV2RouterAddress,
                                            mem[(6 * ceil32(return_data.size)) + 448] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                            mem[(6 * ceil32(return_data.size)) + 452] = 0
                                            mem[(6 * ceil32(return_data.size)) + 484] = 0
                                            mem[(6 * ceil32(return_data.size)) + 516] = 160
                                            mem[(6 * ceil32(return_data.size)) + 612] = 2
                                            idx = 0
                                            s = (6 * ceil32(return_data.size)) + 644
                                            t = (4 * ceil32(return_data.size)) + 384
                                            while idx < mem[(4 * ceil32(return_data.size)) + 352]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[(6 * ceil32(return_data.size)) + 548] = this.address
                                            mem[(6 * ceil32(return_data.size)) + 580] = block.timestamp
                                            require ext_code.size(uniswapV2RouterAddress)
                                            call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (6 * ceil32(return_data.size)) + -mem[64] + 704]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _2301 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2301] = 30
                                            mem[_2301 + 32] = 'SafeMath: subtraction overflow'
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if eth.balance(this.address) < eth.balance(this.address):
                                                revert with 0, 17
                                            call futurUsePoolAddress with:
                                                 gas 2300 wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _2521 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2521] = 30
                                            mem[_2521 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > ext_call.return_data[0]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if ext_call.return_data[0] < 0:
                                                revert with 0, 17
                                            if not distributionPoolAddress:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            _2625 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_2625] = 38
                                            mem[_2625 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                            if ext_call.return_data[0] > balanceOf[stor12]:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 38
                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_2625 + 70 len 26]
                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                            if balanceOf[stor12] < ext_call.return_data[0]:
                                                revert with 0, 17
                                            balanceOf[stor12] -= ext_call.return_data[0]
                                            if balanceOf[msg.sender] > !ext_call.return_data[0]:
                                                revert with 0, 17
                                            if balanceOf[msg.sender] + ext_call.return_data[0] < balanceOf[msg.sender]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(msg.sender)] = balanceOf[msg.sender] + ext_call.return_data[0]
                                            emit Transfer(ext_call.return_data[0], distributionPoolAddress, msg.sender);
                                        else:
                                            if ext_call.return_data[0] and sub_075dc237[arg1] > -1 / ext_call.return_data[0]:
                                                revert with 0, 17
                                            if not ext_call.return_data[0]:
                                                revert with 0, 18
                                            if ext_call.return_data[0] * sub_075dc237[arg1] / ext_call.return_data[0] != sub_075dc237[arg1]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[(4 * ceil32(return_data.size)) + 192] = 26
                                            mem[(4 * ceil32(return_data.size)) + 224] = 'SafeMath: division by zero'
                                            if ext_call.return_data[0] * sub_075dc237[arg1] / 100 > !0:
                                                revert with 0, 17
                                            if ext_call.return_data[0] * sub_075dc237[arg1] / 100 < ext_call.return_data[0] * sub_075dc237[arg1] / 100:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not distributionPoolAddress:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not this.address:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            mem[(4 * ceil32(return_data.size)) + 256] = 38
                                            mem[(4 * ceil32(return_data.size)) + 288 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                            if ext_call.return_data[0] * sub_075dc237[arg1] / 100 > balanceOf[stor12]:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[(4 * ceil32(return_data.size)) + 326 len 26] >> 48,
                                                            0
                                            if balanceOf[stor12] < ext_call.return_data[0] * sub_075dc237[arg1] / 100:
                                                revert with 0, 17
                                            balanceOf[stor12] -= ext_call.return_data[0] * sub_075dc237[arg1] / 100
                                            if balanceOf[this.address] > !(ext_call.return_data[0] * sub_075dc237[arg1] / 100):
                                                revert with 0, 17
                                            if balanceOf[this.address] + (ext_call.return_data[0] * sub_075dc237[arg1] / 100) < balanceOf[this.address]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(this.address)] = balanceOf[this.address] + (ext_call.return_data[0] * sub_075dc237[arg1] / 100)
                                            emit Transfer((ext_call.return_data[0] * sub_075dc237[arg1] / 100), distributionPoolAddress, this.address);
                                            if ext_call.return_data[0] * sub_075dc237[arg1] / 100 > !0:
                                                revert with 0, 17
                                            if ext_call.return_data[0] * sub_075dc237[arg1] / 100 < ext_call.return_data[0] * sub_075dc237[arg1] / 100:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[(4 * ceil32(return_data.size)) + 352] = 2
                                            mem[(4 * ceil32(return_data.size)) + 384] = this.address
                                            require ext_code.size(uniswapV2RouterAddress)
                                            staticcall uniswapV2RouterAddress.WAVAX() with:
                                                    gas gas_remaining wei
                                            mem[(4 * ceil32(return_data.size)) + 448] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[64] = (6 * ceil32(return_data.size)) + 448
                                            require return_data.size >= 32
                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                            mem[(4 * ceil32(return_data.size)) + 416] = ext_call.return_data[12 len 20]
                                            if not this.address:
                                                revert with 0, 'ERC20: approve from the zero address', mem[(6 * ceil32(return_data.size)) + 580 len 9 * ceil32(return_data.size)]
                                            if not uniswapV2RouterAddress:
                                                revert with 0, 'ERC20: approve to the zero address', mem[(6 * ceil32(return_data.size)) + 580 len 9 * ceil32(return_data.size)]
                                            mem[0] = uniswapV2RouterAddress
                                            mem[32] = sha3(address(this.address), 1)
                                            allowance[address(this.address)][stor9].field_0 = ext_call.return_data[0] * sub_075dc237[arg1] / 100
                                            emit Approval(address arg1, address arg2, uint256 arg3):
                                                          ext_call.return_data[0] * sub_075dc237[arg1] / 100,
                                                          mem[(6 * ceil32(return_data.size)) + 480 len 9 * ceil32(return_data.size)],
                                                          this.address,
                                                          uniswapV2RouterAddress,
                                            mem[(6 * ceil32(return_data.size)) + 448] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                            mem[(6 * ceil32(return_data.size)) + 452] = ext_call.return_data[0] * sub_075dc237[arg1] / 100
                                            mem[(6 * ceil32(return_data.size)) + 484] = 0
                                            mem[(6 * ceil32(return_data.size)) + 516] = 160
                                            mem[(6 * ceil32(return_data.size)) + 612] = 2
                                            idx = 0
                                            s = (6 * ceil32(return_data.size)) + 644
                                            t = (4 * ceil32(return_data.size)) + 384
                                            while idx < mem[(4 * ceil32(return_data.size)) + 352]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[(6 * ceil32(return_data.size)) + 548] = this.address
                                            mem[(6 * ceil32(return_data.size)) + 580] = block.timestamp
                                            require ext_code.size(uniswapV2RouterAddress)
                                            call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len (6 * ceil32(return_data.size)) + -mem[64] + 704]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _2300 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2300] = 30
                                            mem[_2300 + 32] = 'SafeMath: subtraction overflow'
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if eth.balance(this.address) < eth.balance(this.address):
                                                revert with 0, 17
                                            call futurUsePoolAddress with:
                                                 gas 2300 wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _2519 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2519] = 30
                                            mem[_2519 + 32] = 'SafeMath: subtraction overflow'
                                            if ext_call.return_data[0] * sub_075dc237[arg1] / 100 > ext_call.return_data[0]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if ext_call.return_data[0] < ext_call.return_data[0] * sub_075dc237[arg1] / 100:
                                                revert with 0, 17
                                            if not distributionPoolAddress:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            _2622 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_2622] = 38
                                            mem[_2622 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                            if ext_call.return_data[0] - (ext_call.return_data[0] * sub_075dc237[arg1] / 100) > balanceOf[stor12]:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 38
                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_2622 + 70 len 26]
                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                            if balanceOf[stor12] < ext_call.return_data[0] - (ext_call.return_data[0] * sub_075dc237[arg1] / 100):
                                                revert with 0, 17
                                            balanceOf[stor12] = balanceOf[stor12] - ext_call.return_data[0] + (ext_call.return_data[0] * sub_075dc237[arg1] / 100)
                                            if balanceOf[msg.sender] > !(ext_call.return_data[0] - (ext_call.return_data[0] * sub_075dc237[arg1] / 100)):
                                                revert with 0, 17
                                            if balanceOf[msg.sender] + ext_call.return_data[0] - (ext_call.return_data[0] * sub_075dc237[arg1] / 100) < balanceOf[msg.sender]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(msg.sender)] = balanceOf[msg.sender] + ext_call.return_data[0] - (ext_call.return_data[0] * sub_075dc237[arg1] / 100)
                                            emit Transfer((ext_call.return_data[0] - (ext_call.return_data[0] * sub_075dc237[arg1] / 100)), distributionPoolAddress, msg.sender);
                                if arg1 >= 3:
                                    revert with 0, 50
                                require ext_code.size(sub_20eea8b5[arg1])
                                call sub_20eea8b5[arg1]._cashoutNodeReward(address arg1, uint256 arg2) with:
                                     gas gas_remaining wei
                                    args msg.sender, arg2
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                else:
                    if unknown_0xbbc67998(?????) > uint32(call.func_hash) >> 224:
                        if unknown_0xa87ec2f7(?????) == uint32(call.func_hash) >> 224:
                            require not msg.value
                            require calldata.size - 4 >= 32
                            if arg1 >= 3:
                                revert with 0, 50
                            require ext_code.size(sub_20eea8b5[arg1])
                            staticcall sub_20eea8b5[arg1].0xcc0915d with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            return ext_call.return_data[0]
                        if uint32(call.func_hash) >> 224 != unknown_0xa9059cbb(?????):
                            if uint32(call.func_hash) >> 224 != unknown_0xaacebbe3(?????):
                                require unknown_0xb62496f5(?????) == uint32(call.func_hash) >> 224
                                require not msg.value
                                require calldata.size - 4 >= 32
                                require arg1 == address(arg1)
                                return bool(stor26[arg1])
                            require not msg.value
                            require calldata.size - 4 >= 32
                            require arg1 == address(arg1)
                            if owner != msg.sender:
                                revert with 0, 'Ownable: caller is not the owner'
                            marketingWalletAddress = address(arg1)
                        require not msg.value
                        require calldata.size - 4 >= 64
                        require arg1 == address(arg1)
                        if not msg.sender:
                            revert with 0, 'ERC20: transfer from the zero address'
                        if not address(arg1):
                            revert with 0, 'ERC20: transfer to the zero address'
                        if stor25[address(msg.sender)]:
                            revert with 0, 'Blacklisted address'
                        if stor25[address(arg1)]:
                            revert with 0, 'Blacklisted address'
                        if not msg.sender:
                            revert with 0, 'ERC20: transfer from the zero address'
                        if not address(arg1):
                            revert with 0, 'ERC20: transfer to the zero address'
                        if arg2 > balanceOf[address(msg.sender)]:
                            revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[198 len 26] >> 48, 0
                        if balanceOf[address(msg.sender)] < arg2:
                            revert with 0, 17
                        balanceOf[address(msg.sender)] -= arg2
                        if balanceOf[address(arg1)] > !arg2:
                            revert with 0, 17
                        if balanceOf[address(arg1)] + arg2 < balanceOf[address(arg1)]:
                            revert with 0, 'SafeMath: addition overflow'
                        balanceOf[address(arg1)] += arg2
                        emit Transfer(arg2, msg.sender, address(arg1));
                        return 1
                    if unknown_0xbbc67998(?????) == uint32(call.func_hash) >> 224:
                        require not msg.value
                        require calldata.size - 4 >= 64
                        require arg1 <= test266151307()
                        require arg1 + 35 < calldata.size
                        if arg1.length > test266151307():
                            revert with 0, 65
                        if ceil32(ceil32(arg1.length)) + 129 < 128 or ceil32(ceil32(arg1.length)) + 129 > test266151307():
                            revert with 0, 65
                        mem[128] = arg1.length
                        require arg1 + arg1.length + 36 <= calldata.size
                        mem[160 len arg1.length] = arg1[all]
                        mem[arg1.length + 160] = 0
                        if arg1.length <= 3:
                            revert with 0, 'NODE CREATION: NAME SIZE INVALID'
                        if arg1.length >= 32:
                            revert with 0, 'NODE CREATION: NAME SIZE INVALID'
                        if sub_6cdc78b3 <= stor27[msg.sender]:
                            revert with 0, 'cannot create node more than 100'
                        if not msg.sender:
                            revert with 0, 'NODE CREATION:  creation from the zero address'
                        if stor25[address(msg.sender)]:
                            revert with 0, 'NODE CREATION: Blacklisted address'
                        if futurUsePoolAddress == msg.sender:
                            revert with 0, 'NODE CREATION: futur and rewardsPool cannot create node'
                        if distributionPoolAddress == msg.sender:
                            revert with 0, 'NODE CREATION: futur and rewardsPool cannot create node'
                        if arg2 >= 3:
                            revert with 0, 50
                        require ext_code.size(sub_20eea8b5[arg2])
                        staticcall sub_20eea8b5[arg2].nodePrice() with:
                                gas gas_remaining wei
                        mem[ceil32(ceil32(arg1.length)) + 129] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if balanceOf[address(msg.sender)] < ext_call.return_data[0]:
                            revert with 0, 'NODE CREATION: Balance too low for creation.'
                        if balanceOf[this.address] < swapTokensAmount:
                            if not msg.sender:
                                revert with 0, 'ERC20: transfer from the zero address'
                            if not this.address:
                                revert with 0, 'ERC20: transfer to the zero address'
                            if ext_call.return_data[0] > balanceOf[address(msg.sender)]:
                                revert with 0, 
                                            32,
                                            38,
                                            0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(ceil32(arg1.length)) + ceil32(return_data.size) + 199 len 26] >> 48,
                                            0
                            if balanceOf[address(msg.sender)] < ext_call.return_data[0]:
                                revert with 0, 17
                            balanceOf[address(msg.sender)] -= ext_call.return_data[0]
                            if balanceOf[this.address] > !ext_call.return_data[0]:
                                revert with 0, 17
                            if balanceOf[this.address] + ext_call.return_data[0] < balanceOf[this.address]:
                                revert with 0, 'SafeMath: addition overflow'
                            balanceOf[address(this.address)] = balanceOf[this.address] + ext_call.return_data[0]
                            emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                            if arg2 >= 3:
                                revert with 0, 50
                            require ext_code.size(sub_20eea8b5[arg2])
                            call sub_20eea8b5[arg2].createNode(address arg1, string arg2) with:
                                 gas gas_remaining wei
                                args msg.sender, Array(len=arg1.length, data=arg1[all])
                        else:
                            if not uint8(stor23.field_8):
                                if not msg.sender:
                                    revert with 0, 'ERC20: transfer from the zero address'
                                if not this.address:
                                    revert with 0, 'ERC20: transfer to the zero address'
                                if ext_call.return_data[0] > balanceOf[address(msg.sender)]:
                                    revert with 0, 
                                                32,
                                                38,
                                                0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(ceil32(arg1.length)) + ceil32(return_data.size) + 199 len 26] >> 48,
                                                0
                                if balanceOf[address(msg.sender)] < ext_call.return_data[0]:
                                    revert with 0, 17
                                balanceOf[address(msg.sender)] -= ext_call.return_data[0]
                                if balanceOf[this.address] > !ext_call.return_data[0]:
                                    revert with 0, 17
                                if balanceOf[this.address] + ext_call.return_data[0] < balanceOf[this.address]:
                                    revert with 0, 'SafeMath: addition overflow'
                                balanceOf[address(this.address)] = balanceOf[this.address] + ext_call.return_data[0]
                                emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                if arg2 >= 3:
                                    revert with 0, 50
                                require ext_code.size(sub_20eea8b5[arg2])
                                call sub_20eea8b5[arg2].createNode(address arg1, string arg2) with:
                                     gas gas_remaining wei
                                    args msg.sender, Array(len=arg1.length, data=arg1[all])
                            else:
                                if uint8(stor23.field_0):
                                    if not msg.sender:
                                        revert with 0, 'ERC20: transfer from the zero address'
                                    if not this.address:
                                        revert with 0, 'ERC20: transfer to the zero address'
                                    if ext_call.return_data[0] > balanceOf[address(msg.sender)]:
                                        revert with 0, 
                                                    32,
                                                    38,
                                                    0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(ceil32(arg1.length)) + ceil32(return_data.size) + 199 len 26] >> 48,
                                                    0
                                    if balanceOf[address(msg.sender)] < ext_call.return_data[0]:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)] -= ext_call.return_data[0]
                                    if balanceOf[this.address] > !ext_call.return_data[0]:
                                        revert with 0, 17
                                    if balanceOf[this.address] + ext_call.return_data[0] < balanceOf[this.address]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(this.address)] = balanceOf[this.address] + ext_call.return_data[0]
                                    emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                    if arg2 >= 3:
                                        revert with 0, 50
                                    require ext_code.size(sub_20eea8b5[arg2])
                                    call sub_20eea8b5[arg2].createNode(address arg1, string arg2) with:
                                         gas gas_remaining wei
                                        args msg.sender, Array(len=arg1.length, data=arg1[all])
                                else:
                                    if owner == msg.sender:
                                        if not msg.sender:
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not this.address:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        if ext_call.return_data[0] > balanceOf[address(msg.sender)]:
                                            revert with 0, 
                                                        32,
                                                        38,
                                                        0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(ceil32(arg1.length)) + ceil32(return_data.size) + 199 len 26] >> 48,
                                                        0
                                        if balanceOf[address(msg.sender)] < ext_call.return_data[0]:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] -= ext_call.return_data[0]
                                        if balanceOf[this.address] > !ext_call.return_data[0]:
                                            revert with 0, 17
                                        if balanceOf[this.address] + ext_call.return_data[0] < balanceOf[this.address]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(this.address)] = balanceOf[this.address] + ext_call.return_data[0]
                                        emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                        if arg2 >= 3:
                                            revert with 0, 50
                                        require ext_code.size(sub_20eea8b5[arg2])
                                        call sub_20eea8b5[arg2].createNode(address arg1, string arg2) with:
                                             gas gas_remaining wei
                                            args msg.sender, Array(len=arg1.length, data=arg1[all])
                                    else:
                                        if stor26[address(msg.sender)]:
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not this.address:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            if ext_call.return_data[0] > balanceOf[address(msg.sender)]:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(ceil32(arg1.length)) + ceil32(return_data.size) + 199 len 26] >> 48,
                                                            0
                                            if balanceOf[address(msg.sender)] < ext_call.return_data[0]:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] -= ext_call.return_data[0]
                                            if balanceOf[this.address] > !ext_call.return_data[0]:
                                                revert with 0, 17
                                            if balanceOf[this.address] + ext_call.return_data[0] < balanceOf[this.address]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(this.address)] = balanceOf[this.address] + ext_call.return_data[0]
                                            emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                            if arg2 >= 3:
                                                revert with 0, 50
                                            require ext_code.size(sub_20eea8b5[arg2])
                                            call sub_20eea8b5[arg2].createNode(address arg1, string arg2) with:
                                                 gas gas_remaining wei
                                                args msg.sender, Array(len=arg1.length, data=arg1[all])
                                        else:
                                            uint8(stor23.field_0) = 1
                                            if balanceOf[this.address]:
                                                if balanceOf[this.address] and rewardsFee > -1 / balanceOf[this.address]:
                                                    revert with 0, 17
                                                if not balanceOf[this.address]:
                                                    revert with 0, 18
                                                if balanceOf[this.address] * rewardsFee / balanceOf[this.address] != rewardsFee:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                mem[ceil32(ceil32(arg1.length)) + ceil32(return_data.size) + 129] = 26
                                                mem[ceil32(ceil32(arg1.length)) + ceil32(return_data.size) + 161] = 'SafeMath: division by zero'
                                                if not balanceOf[this.address] * rewardsFee / 100:
                                                    mem[ceil32(ceil32(arg1.length)) + ceil32(return_data.size) + 193] = 26
                                                    mem[ceil32(ceil32(arg1.length)) + ceil32(return_data.size) + 225] = 'SafeMath: division by zero'
                                                    mem[ceil32(ceil32(arg1.length)) + ceil32(return_data.size) + 257] = 2
                                                    mem[ceil32(ceil32(arg1.length)) + ceil32(return_data.size) + 289] = this.address
                                                    require ext_code.size(uniswapV2RouterAddress)
                                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                                            gas gas_remaining wei
                                                    mem[ceil32(ceil32(arg1.length)) + ceil32(return_data.size) + 353] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[64] = ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 353
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                    mem[ceil32(ceil32(arg1.length)) + ceil32(return_data.size) + 321] = ext_call.return_data[12 len 20]
                                                    if not this.address:
                                                        mem[ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 353] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 357] = 32
                                                        mem[ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 389] = 36
                                                        mem[ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 421] = 'ERC20: approve from the zero add'
                                                        mem[ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 453] = 0x7265737300000000000000000000000000000000000000000000000000000000
                                                        revert with memory
                                                          from ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 353
                                                           len ceil32(return_data.size) + 132
                                                    if not uniswapV2RouterAddress:
                                                        mem[ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 353] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 357] = 32
                                                        mem[ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 389] = 34
                                                        mem[ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 421] = 'ERC20: approve to the zero addre'
                                                        mem[ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 453] = 0x7373000000000000000000000000000000000000000000000000000000000000
                                                        revert with memory
                                                          from ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 353
                                                           len ceil32(return_data.size) + 132
                                                    mem[0] = uniswapV2RouterAddress
                                                    mem[32] = sha3(address(this.address), 1)
                                                    allowance[address(this.address)][stor9].field_0 = 0
                                                    mem[ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 353] = 0
                                                    emit Approval(mem[ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 353 len ceil32(return_data.size) + 32], this.address, uniswapV2RouterAddress);
                                                    mem[ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 353] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                    mem[ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 357] = 0
                                                    mem[ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 389] = 0
                                                    mem[ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 421] = 160
                                                    mem[ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 517] = 2
                                                    idx = 0
                                                    s = ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 549
                                                    t = ceil32(ceil32(arg1.length)) + ceil32(return_data.size) + 289
                                                    while idx < mem[ceil32(ceil32(arg1.length)) + ceil32(return_data.size) + 257]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 453] = this.address
                                                    mem[ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 485] = block.timestamp
                                                    require ext_code.size(uniswapV2RouterAddress)
                                                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + -mem[64] + 609]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _2296 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_2296] = 30
                                                    mem[_2296 + 32] = 'SafeMath: subtraction overflow'
                                                    if eth.balance(this.address) > eth.balance(this.address):
                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                    if eth.balance(this.address) < eth.balance(this.address):
                                                        revert with 0, 17
                                                    call distributionPoolAddress with:
                                                         gas 2300 wei
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _2515 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_2515] = 30
                                                    mem[_2515 + 32] = 'SafeMath: subtraction overflow'
                                                    if 0 > balanceOf[this.address] * rewardsFee / 100:
                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                    if balanceOf[this.address] * rewardsFee / 100 < 0:
                                                        revert with 0, 17
                                                    if not this.address:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not distributionPoolAddress:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    _2602 = mem[64]
                                                    mem[64] = mem[64] + 96
                                                    mem[_2602] = 38
                                                    mem[_2602 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                    if balanceOf[this.address] * rewardsFee / 100 > balanceOf[address(this.address)]:
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 38
                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_2602 + 70 len 26]
                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                    if balanceOf[address(this.address)] < balanceOf[this.address] * rewardsFee / 100:
                                                        revert with 0, 17
                                                    balanceOf[address(this.address)] -= balanceOf[this.address] * rewardsFee / 100
                                                    if balanceOf[stor12] > !(balanceOf[this.address] * rewardsFee / 100):
                                                        revert with 0, 17
                                                    if balanceOf[stor12] + (balanceOf[this.address] * rewardsFee / 100) < balanceOf[stor12]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = distributionPoolAddress
                                                    mem[32] = 0
                                                    balanceOf[stor12] += balanceOf[this.address] * rewardsFee / 100
                                                    emit Transfer((balanceOf[this.address] * rewardsFee / 100), this.address, distributionPoolAddress);
                                                    if not balanceOf[this.address]:
                                                        _2848 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_2848] = 26
                                                        mem[_2848 + 32] = 'SafeMath: division by zero'
                                                        _2911 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_2911] = 26
                                                        mem[_2911 + 32] = 'SafeMath: division by zero'
                                                        _2938 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_2938] = 30
                                                        mem[_2938 + 32] = 'SafeMath: subtraction overflow'
                                                        _2979 = mem[64]
                                                        mem[mem[64]] = 2
                                                        mem[64] = mem[64] + 96
                                                        mem[_2979 + 32 len 64] = call.data[calldata.size len 64]
                                                        if 0 >= mem[_2979]:
                                                            revert with 0, 50
                                                        mem[_2979 + 32] = this.address
                                                        require ext_code.size(uniswapV2RouterAddress)
                                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                gas gas_remaining wei
                                                        mem[_2979 + 96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[64] = _2979 + ceil32(return_data.size) + 96
                                                        require return_data.size >= 32
                                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                        if 1 >= mem[_2979]:
                                                            revert with 0, 50
                                                        mem[_2979 + 64] = ext_call.return_data[12 len 20]
                                                        if not this.address:
                                                            revert with 0, 'ERC20: approve from the zero address'
                                                        if not uniswapV2RouterAddress:
                                                            revert with 0, 'ERC20: approve to the zero address'
                                                        mem[0] = uniswapV2RouterAddress
                                                        mem[32] = sha3(address(this.address), 1)
                                                        allowance[address(this.address)][stor9].field_0 = 0
                                                        emit Approval(0, this.address, uniswapV2RouterAddress);
                                                        mem[_2979 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                        mem[_2979 + ceil32(return_data.size) + 100] = 0
                                                        mem[_2979 + ceil32(return_data.size) + 132] = 0
                                                        mem[_2979 + ceil32(return_data.size) + 164] = 160
                                                        mem[_2979 + ceil32(return_data.size) + 260] = mem[_2979]
                                                        idx = 0
                                                        s = _2979 + ceil32(return_data.size) + 292
                                                        t = _2979 + 32
                                                        while idx < mem[_2979]:
                                                            mem[s] = mem[t + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        require ext_code.size(uniswapV2RouterAddress)
                                                        call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                             gas gas_remaining wei
                                                            args 0, 0, 160, address(this.address), block.timestamp, mem[_2979 + ceil32(return_data.size) + 260 len (32 * mem[_2979]) + 32]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[_2979 + ceil32(return_data.size) + 96] = 30
                                                        mem[_2979 + ceil32(return_data.size) + 128] = 'SafeMath: subtraction overflow'
                                                        if eth.balance(this.address) > eth.balance(this.address):
                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                        if eth.balance(this.address) < eth.balance(this.address):
                                                            revert with 0, 17
                                                        if not this.address:
                                                            revert with 0, 'ERC20: approve from the zero address'
                                                        if not uniswapV2RouterAddress:
                                                            revert with 0, 'ERC20: approve to the zero address'
                                                        allowance[address(this.address)][stor9].field_0 = 0
                                                        emit Approval(0, this.address, uniswapV2RouterAddress);
                                                        mem[_2979 + ceil32(return_data.size) + 228] = 0
                                                        mem[_2979 + ceil32(return_data.size) + 260] = 0
                                                        mem[_2979 + ceil32(return_data.size) + 292] = 0
                                                        mem[_2979 + ceil32(return_data.size) + 324] = block.timestamp
                                                        require ext_code.size(uniswapV2RouterAddress)
                                                        call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                             gas gas_remaining wei
                                                            args this.address, 0, 0, 0, 0, block.timestamp
                                                        mem[_2979 + ceil32(return_data.size) + 160 len 96] = ext_call.return_data[0 len 96]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 96
                                                        emit SwapAndLiquify(uint256 arg1, uint256 arg2, uint256 arg3):
                                                                            0,
                                                        mem[_2979 + (2 * ceil32(return_data.size)) + 160] = 2
                                                        mem[_2979 + (2 * ceil32(return_data.size)) + 192] = this.address
                                                        require ext_code.size(uniswapV2RouterAddress)
                                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                gas gas_remaining wei
                                                        mem[_2979 + (2 * ceil32(return_data.size)) + 256] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[64] = _2979 + (4 * ceil32(return_data.size)) + 256
                                                        require return_data.size >= 32
                                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                        mem[_2979 + (2 * ceil32(return_data.size)) + 224] = ext_call.return_data[12 len 20]
                                                        if not this.address:
                                                            revert with 0, 'ERC20: approve from the zero address'
                                                        if not uniswapV2RouterAddress:
                                                            revert with 0, 'ERC20: approve to the zero address'
                                                        mem[0] = uniswapV2RouterAddress
                                                        mem[32] = sha3(address(this.address), 1)
                                                        allowance[address(this.address)][stor9].field_0 = balanceOf[this.address]
                                                        emit Approval(balanceOf[this.address], this.address, uniswapV2RouterAddress);
                                                        mem[_2979 + (4 * ceil32(return_data.size)) + 256] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                        mem[_2979 + (4 * ceil32(return_data.size)) + 260] = balanceOf[this.address]
                                                        mem[_2979 + (4 * ceil32(return_data.size)) + 292] = 0
                                                        mem[_2979 + (4 * ceil32(return_data.size)) + 324] = 160
                                                        mem[_2979 + (4 * ceil32(return_data.size)) + 420] = 2
                                                        idx = 0
                                                        s = _2979 + (4 * ceil32(return_data.size)) + 452
                                                        t = _2979 + (2 * ceil32(return_data.size)) + 192
                                                        while idx < mem[_2979 + (2 * ceil32(return_data.size)) + 160]:
                                                            mem[s] = mem[t + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[_2979 + (4 * ceil32(return_data.size)) + 356] = this.address
                                                        mem[_2979 + (4 * ceil32(return_data.size)) + 388] = block.timestamp
                                                        require ext_code.size(uniswapV2RouterAddress)
                                                        call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                             gas gas_remaining wei
                                                            args mem[mem[64] + 4 len _2979 + (4 * ceil32(return_data.size)) + (32 * mem[_2979 + (2 * ceil32(return_data.size)) + 160]) + -mem[64] + 448]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _8761 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_8761] = 30
                                                        mem[_8761 + 32] = 'SafeMath: subtraction overflow'
                                                        if eth.balance(this.address) > eth.balance(this.address):
                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                        if eth.balance(this.address) < eth.balance(this.address):
                                                            revert with 0, 17
                                                        call marketingWalletAddress with:
                                                             gas 2300 wei
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        uint8(stor23.field_0) = 0
                                                        if not msg.sender:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not this.address:
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        _9133 = mem[64]
                                                        mem[64] = mem[64] + 96
                                                        mem[_9133] = 38
                                                        mem[_9133 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                        if ext_call.return_data[0] > balanceOf[address(msg.sender)]:
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 38
                                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_9133 + 70 len 26]
                                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                        if balanceOf[address(msg.sender)] < ext_call.return_data[0]:
                                                            revert with 0, 17
                                                        balanceOf[address(msg.sender)] -= ext_call.return_data[0]
                                                        if balanceOf[this.address] > !ext_call.return_data[0]:
                                                            revert with 0, 17
                                                        if balanceOf[this.address] + ext_call.return_data[0] < balanceOf[this.address]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        balanceOf[address(this.address)] = balanceOf[this.address] + ext_call.return_data[0]
                                                        emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                                        if arg2 >= 3:
                                                            revert with 0, 50
                                                        mem[mem[64]] = 0x12b8603f00000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = msg.sender
                                                        mem[mem[64] + 36] = 64
                                                        mem[mem[64] + 68] = mem[128]
                                                        mem[mem[64] + 100 len ceil32(mem[128])] = mem[160 len ceil32(mem[128])]
                                                        if ceil32(mem[128]) > mem[128]:
                                                            mem[mem[64] + mem[128] + 100] = 0
                                                        require ext_code.size(sub_20eea8b5[arg2])
                                                        call sub_20eea8b5[arg2].createNode(address arg1, string arg2) with:
                                                             gas gas_remaining wei
                                                            args msg.sender, Array(len=mem[128], data=mem[mem[64] + 100 len ceil32(mem[128])])
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if stor27[address(msg.sender)] > -2:
                                                            revert with 0, 17
                                                        if stor27[address(msg.sender)] + 1 < stor27[address(msg.sender)]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        stor27[address(msg.sender)]++
                                                    if balanceOf[this.address] and liquidityPoolFee > -1 / balanceOf[this.address]:
                                                        revert with 0, 17
                                                    if not balanceOf[this.address]:
                                                        revert with 0, 18
                                                    if balanceOf[this.address] * liquidityPoolFee / balanceOf[this.address] != liquidityPoolFee:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    _2898 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_2898] = 26
                                                    mem[_2898 + 32] = 'SafeMath: division by zero'
                                                    _2928 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_2928] = 26
                                                    mem[_2928 + 32] = 'SafeMath: division by zero'
                                                    _2954 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_2954] = 30
                                                    mem[_2954 + 32] = 'SafeMath: subtraction overflow'
                                                    if balanceOf[this.address] * liquidityPoolFee / 100 / 2 > balanceOf[this.address] * liquidityPoolFee / 100:
                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                    if balanceOf[this.address] * liquidityPoolFee / 100 < balanceOf[this.address] * liquidityPoolFee / 100 / 2:
                                                        revert with 0, 17
                                                    _3057 = mem[64]
                                                    mem[mem[64]] = 2
                                                    mem[64] = mem[64] + 96
                                                    mem[_3057 + 32 len 64] = call.data[calldata.size len 64]
                                                    if 0 >= mem[_3057]:
                                                        revert with 0, 50
                                                    mem[_3057 + 32] = this.address
                                                    require ext_code.size(uniswapV2RouterAddress)
                                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                                            gas gas_remaining wei
                                                    mem[_3057 + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[64] = _3057 + ceil32(return_data.size) + 96
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                    if 1 >= mem[_3057]:
                                                        revert with 0, 50
                                                    mem[_3057 + 64] = ext_call.return_data[12 len 20]
                                                    if not this.address:
                                                        revert with 0, 'ERC20: approve from the zero address'
                                                    if not uniswapV2RouterAddress:
                                                        revert with 0, 'ERC20: approve to the zero address'
                                                    mem[0] = uniswapV2RouterAddress
                                                    mem[32] = sha3(address(this.address), 1)
                                                    allowance[address(this.address)][stor9].field_0 = balanceOf[this.address] * liquidityPoolFee / 100 / 2
                                                    allowance[address(this.address)][stor9].field_255 = 0
                                                    emit Approval((balanceOf[this.address] * liquidityPoolFee / 100 / 2), this.address, uniswapV2RouterAddress);
                                                    mem[_3057 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                    mem[_3057 + ceil32(return_data.size) + 100] = balanceOf[this.address] * liquidityPoolFee / 100 / 2
                                                    mem[_3057 + ceil32(return_data.size) + 132] = 0
                                                    mem[_3057 + ceil32(return_data.size) + 164] = 160
                                                    mem[_3057 + ceil32(return_data.size) + 260] = mem[_3057]
                                                    idx = 0
                                                    s = _3057 + ceil32(return_data.size) + 292
                                                    t = _3057 + 32
                                                    while idx < mem[_3057]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    require ext_code.size(uniswapV2RouterAddress)
                                                    call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args Mask(255, 1, balanceOf[this.address] * liquidityPoolFee / 100), 0, 160, address(this.address), block.timestamp, mem[_3057 + ceil32(return_data.size) + 260 len (32 * mem[_3057]) + 32]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[_3057 + ceil32(return_data.size) + 96] = 30
                                                    mem[_3057 + ceil32(return_data.size) + 128] = 'SafeMath: subtraction overflow'
                                                    if eth.balance(this.address) > eth.balance(this.address):
                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                    if eth.balance(this.address) < eth.balance(this.address):
                                                        revert with 0, 17
                                                    if not this.address:
                                                        revert with 0, 'ERC20: approve from the zero address'
                                                    if not uniswapV2RouterAddress:
                                                        revert with 0, 'ERC20: approve to the zero address'
                                                    allowance[address(this.address)][stor9].field_0 = (balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2)
                                                    emit Approval(((balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2)), this.address, uniswapV2RouterAddress);
                                                    mem[_3057 + ceil32(return_data.size) + 228] = 0
                                                    mem[_3057 + ceil32(return_data.size) + 260] = 0
                                                    mem[_3057 + ceil32(return_data.size) + 292] = 0
                                                    mem[_3057 + ceil32(return_data.size) + 324] = block.timestamp
                                                    require ext_code.size(uniswapV2RouterAddress)
                                                    call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                         gas gas_remaining wei
                                                        args this.address, (balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2), 0, 0, 0, block.timestamp
                                                    mem[_3057 + ceil32(return_data.size) + 160 len 96] = ext_call.return_data[0 len 96]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 96
                                                    emit SwapAndLiquify(Mask(255, 1, balanceOf[this.address] * liquidityPoolFee / 100), 0, (balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2));
                                                    mem[_3057 + (2 * ceil32(return_data.size)) + 160] = 2
                                                    mem[_3057 + (2 * ceil32(return_data.size)) + 192] = this.address
                                                    require ext_code.size(uniswapV2RouterAddress)
                                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                                            gas gas_remaining wei
                                                    mem[_3057 + (2 * ceil32(return_data.size)) + 256] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[64] = _3057 + (4 * ceil32(return_data.size)) + 256
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                    mem[_3057 + (2 * ceil32(return_data.size)) + 224] = ext_call.return_data[12 len 20]
                                                    if not this.address:
                                                        revert with 0, 'ERC20: approve from the zero address'
                                                    if not uniswapV2RouterAddress:
                                                        revert with 0, 'ERC20: approve to the zero address'
                                                    mem[0] = uniswapV2RouterAddress
                                                    mem[32] = sha3(address(this.address), 1)
                                                    allowance[address(this.address)][stor9].field_0 = balanceOf[this.address]
                                                    emit Approval(balanceOf[this.address], this.address, uniswapV2RouterAddress);
                                                    mem[_3057 + (4 * ceil32(return_data.size)) + 256] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                    mem[_3057 + (4 * ceil32(return_data.size)) + 260] = balanceOf[this.address]
                                                    mem[_3057 + (4 * ceil32(return_data.size)) + 292] = 0
                                                    mem[_3057 + (4 * ceil32(return_data.size)) + 324] = 160
                                                    mem[_3057 + (4 * ceil32(return_data.size)) + 420] = 2
                                                    idx = 0
                                                    s = _3057 + (4 * ceil32(return_data.size)) + 452
                                                    t = _3057 + (2 * ceil32(return_data.size)) + 192
                                                    while idx < mem[_3057 + (2 * ceil32(return_data.size)) + 160]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_3057 + (4 * ceil32(return_data.size)) + 356] = this.address
                                                    mem[_3057 + (4 * ceil32(return_data.size)) + 388] = block.timestamp
                                                    require ext_code.size(uniswapV2RouterAddress)
                                                    call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args balanceOf[this.address], 0, 160, address(this.address), block.timestamp, mem[_3057 + (4 * ceil32(return_data.size)) + 420 len (32 * mem[_3057 + (2 * ceil32(return_data.size)) + 160]) + 32]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[_3057 + (4 * ceil32(return_data.size)) + 256] = 30
                                                    mem[_3057 + (4 * ceil32(return_data.size)) + 288] = 'SafeMath: subtraction overflow'
                                                    if eth.balance(this.address) > eth.balance(this.address):
                                                        mem[_3057 + (4 * ceil32(return_data.size)) + 320] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_3057 + (4 * ceil32(return_data.size)) + 324] = 32
                                                        mem[_3057 + (4 * ceil32(return_data.size)) + 356] = 30
                                                        mem[_3057 + (4 * ceil32(return_data.size)) + 388] = 'SafeMath: subtraction overflow'
                                                        mem[_3057 + (4 * ceil32(return_data.size)) + 418] = 0
                                                        revert with memory
                                                          from _3057 + (4 * ceil32(return_data.size)) + 320
                                                           len (5 * ceil32(return_data.size)) + 100
                                                    if eth.balance(this.address) < eth.balance(this.address):
                                                        revert with 0, 17
                                                    call marketingWalletAddress with:
                                                         gas 2300 wei
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    uint8(stor23.field_0) = 0
                                                    if not msg.sender:
                                                        mem[_3057 + (4 * ceil32(return_data.size)) + 320] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_3057 + (4 * ceil32(return_data.size)) + 324] = 32
                                                        mem[_3057 + (4 * ceil32(return_data.size)) + 356] = 37
                                                        mem[_3057 + (4 * ceil32(return_data.size)) + 388] = 'ERC20: transfer from the zero ad'
                                                        mem[_3057 + (4 * ceil32(return_data.size)) + 420] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                        revert with memory
                                                          from _3057 + (4 * ceil32(return_data.size)) + 320
                                                           len (5 * ceil32(return_data.size)) + 132
                                                    if not this.address:
                                                        mem[_3057 + (4 * ceil32(return_data.size)) + 320] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_3057 + (4 * ceil32(return_data.size)) + 324] = 32
                                                        mem[_3057 + (4 * ceil32(return_data.size)) + 356] = 35
                                                        mem[_3057 + (4 * ceil32(return_data.size)) + 388] = 'ERC20: transfer to the zero addr'
                                                        mem[_3057 + (4 * ceil32(return_data.size)) + 420] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                        revert with memory
                                                          from _3057 + (4 * ceil32(return_data.size)) + 320
                                                           len (5 * ceil32(return_data.size)) + 132
                                                    mem[_3057 + (4 * ceil32(return_data.size)) + 320] = 38
                                                    mem[_3057 + (4 * ceil32(return_data.size)) + 352 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                    if ext_call.return_data[0] > balanceOf[address(msg.sender)]:
                                                        mem[_3057 + (4 * ceil32(return_data.size)) + 416] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_3057 + (4 * ceil32(return_data.size)) + 420] = 32
                                                        mem[_3057 + (4 * ceil32(return_data.size)) + 452] = 38
                                                        mem[_3057 + (4 * ceil32(return_data.size)) + 484 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, Mask(208, 32, block.timestamp) >> 32
                                                        mem[_3057 + (4 * ceil32(return_data.size)) + 522] = 0
                                                        revert with memory
                                                          from _3057 + (4 * ceil32(return_data.size)) + 416
                                                           len (5 * ceil32(return_data.size)) + 132
                                                    if balanceOf[address(msg.sender)] < ext_call.return_data[0]:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] -= ext_call.return_data[0]
                                                    if balanceOf[this.address] > !ext_call.return_data[0]:
                                                        revert with 0, 17
                                                    if balanceOf[this.address] + ext_call.return_data[0] >= balanceOf[this.address]:
                                                        balanceOf[address(this.address)] = balanceOf[this.address] + ext_call.return_data[0]
                                                        emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                                        if arg2 >= 3:
                                                            revert with 0, 50
                                                        mem[_3057 + (4 * ceil32(return_data.size)) + 416] = 0x12b8603f00000000000000000000000000000000000000000000000000000000
                                                        mem[_3057 + (4 * ceil32(return_data.size)) + 420] = msg.sender
                                                        mem[_3057 + (4 * ceil32(return_data.size)) + 452] = 64
                                                        mem[_3057 + (4 * ceil32(return_data.size)) + 484] = mem[128]
                                                        mem[_3057 + (4 * ceil32(return_data.size)) + 516 len ceil32(mem[128])] = mem[160 len ceil32(mem[128])]
                                                        if ceil32(mem[128]) > mem[128]:
                                                            mem[_3057 + (4 * ceil32(return_data.size)) + mem[128] + 516] = 0
                                                        require ext_code.size(sub_20eea8b5[arg2])
                                                        call sub_20eea8b5[arg2].createNode(address arg1, string arg2) with:
                                                             gas gas_remaining wei
                                                            args mem[_3057 + (4 * ceil32(return_data.size)) + 420 len ceil32(mem[128]) + (5 * ceil32(return_data.size)) + 96]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if stor27[address(msg.sender)] > -2:
                                                            revert with 0, 17
                                                        if stor27[address(msg.sender)] + 1 >= stor27[address(msg.sender)]:
                                                            stor27[address(msg.sender)]++
                                                    mem[_3057 + (4 * ceil32(return_data.size)) + 416] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[_3057 + (4 * ceil32(return_data.size)) + 420] = 32
                                                    mem[_3057 + (4 * ceil32(return_data.size)) + 452] = 27
                                                    mem[_3057 + (4 * ceil32(return_data.size)) + 484] = 'SafeMath: addition overflow'
                                                    revert with memory
                                                      from _3057 + (4 * ceil32(return_data.size)) + 416
                                                       len (5 * ceil32(return_data.size)) + 100
                                                if balanceOf[this.address] * rewardsFee / 100 and stor22 > -1 / balanceOf[this.address] * rewardsFee / 100:
                                                    revert with 0, 17
                                                if not balanceOf[this.address] * rewardsFee / 100:
                                                    revert with 0, 18
                                                if balanceOf[this.address] * rewardsFee / 100 * stor22 / balanceOf[this.address] * rewardsFee / 100 != stor22:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                mem[ceil32(ceil32(arg1.length)) + ceil32(return_data.size) + 193] = 26
                                                mem[ceil32(ceil32(arg1.length)) + ceil32(return_data.size) + 225] = 'SafeMath: division by zero'
                                                mem[ceil32(ceil32(arg1.length)) + ceil32(return_data.size) + 257] = 2
                                                mem[ceil32(ceil32(arg1.length)) + ceil32(return_data.size) + 289] = this.address
                                                require ext_code.size(uniswapV2RouterAddress)
                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                        gas gas_remaining wei
                                                mem[ceil32(ceil32(arg1.length)) + ceil32(return_data.size) + 353] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[64] = ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 353
                                                require return_data.size >= 32
                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                mem[ceil32(ceil32(arg1.length)) + ceil32(return_data.size) + 321] = ext_call.return_data[12 len 20]
                                                if not this.address:
                                                    mem[ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 353] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 357] = 32
                                                    mem[ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 389] = 36
                                                    mem[ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 421] = 'ERC20: approve from the zero add'
                                                    mem[ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 453] = 0x7265737300000000000000000000000000000000000000000000000000000000
                                                    revert with memory
                                                      from ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 353
                                                       len ceil32(return_data.size) + 132
                                                if not uniswapV2RouterAddress:
                                                    mem[ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 353] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 357] = 32
                                                    mem[ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 389] = 34
                                                    mem[ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 421] = 'ERC20: approve to the zero addre'
                                                    mem[ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 453] = 0x7373000000000000000000000000000000000000000000000000000000000000
                                                    revert with memory
                                                      from ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 353
                                                       len ceil32(return_data.size) + 132
                                                mem[0] = uniswapV2RouterAddress
                                                mem[32] = sha3(address(this.address), 1)
                                                allowance[address(this.address)][stor9].field_0 = balanceOf[this.address] * rewardsFee / 100 * stor22 / 100
                                                mem[ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 353] = balanceOf[this.address] * rewardsFee / 100 * stor22 / 100
                                                emit Approval(mem[ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 353 len ceil32(return_data.size) + 32], this.address, uniswapV2RouterAddress);
                                                mem[ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 353] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                mem[ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 357] = balanceOf[this.address] * rewardsFee / 100 * stor22 / 100
                                                mem[ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 389] = 0
                                                mem[ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 421] = 160
                                                mem[ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 517] = 2
                                                idx = 0
                                                s = ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 549
                                                t = ceil32(ceil32(arg1.length)) + ceil32(return_data.size) + 289
                                                while idx < mem[ceil32(ceil32(arg1.length)) + ceil32(return_data.size) + 257]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 453] = this.address
                                                mem[ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 485] = block.timestamp
                                                require ext_code.size(uniswapV2RouterAddress)
                                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + -mem[64] + 609]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _2295 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_2295] = 30
                                                mem[_2295 + 32] = 'SafeMath: subtraction overflow'
                                                if eth.balance(this.address) > eth.balance(this.address):
                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                if eth.balance(this.address) < eth.balance(this.address):
                                                    revert with 0, 17
                                                call distributionPoolAddress with:
                                                     gas 2300 wei
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _2513 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_2513] = 30
                                                mem[_2513 + 32] = 'SafeMath: subtraction overflow'
                                                if balanceOf[this.address] * rewardsFee / 100 * stor22 / 100 > balanceOf[this.address] * rewardsFee / 100:
                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                if balanceOf[this.address] * rewardsFee / 100 < balanceOf[this.address] * rewardsFee / 100 * stor22 / 100:
                                                    revert with 0, 17
                                                if not this.address:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not distributionPoolAddress:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                _2598 = mem[64]
                                                mem[64] = mem[64] + 96
                                                mem[_2598] = 38
                                                mem[_2598 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                if (balanceOf[this.address] * rewardsFee / 100) - (balanceOf[this.address] * rewardsFee / 100 * stor22 / 100) > balanceOf[address(this.address)]:
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 38
                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_2598 + 70 len 26]
                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                if balanceOf[address(this.address)] < (balanceOf[this.address] * rewardsFee / 100) - (balanceOf[this.address] * rewardsFee / 100 * stor22 / 100):
                                                    revert with 0, 17
                                                balanceOf[address(this.address)] = balanceOf[address(this.address)] - (balanceOf[this.address] * rewardsFee / 100) + (balanceOf[this.address] * rewardsFee / 100 * stor22 / 100)
                                                if balanceOf[stor12] > !((balanceOf[this.address] * rewardsFee / 100) - (balanceOf[this.address] * rewardsFee / 100 * stor22 / 100)):
                                                    revert with 0, 17
                                                if balanceOf[stor12] + (balanceOf[this.address] * rewardsFee / 100) - (balanceOf[this.address] * rewardsFee / 100 * stor22 / 100) < balanceOf[stor12]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = distributionPoolAddress
                                                mem[32] = 0
                                                balanceOf[stor12] = balanceOf[stor12] + (balanceOf[this.address] * rewardsFee / 100) - (balanceOf[this.address] * rewardsFee / 100 * stor22 / 100)
                                                emit Transfer(((balanceOf[this.address] * rewardsFee / 100) - (balanceOf[this.address] * rewardsFee / 100 * stor22 / 100)), this.address, distributionPoolAddress);
                                                if not balanceOf[this.address]:
                                                    _2847 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_2847] = 26
                                                    mem[_2847 + 32] = 'SafeMath: division by zero'
                                                    _2910 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_2910] = 26
                                                    mem[_2910 + 32] = 'SafeMath: division by zero'
                                                    _2937 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_2937] = 30
                                                    mem[_2937 + 32] = 'SafeMath: subtraction overflow'
                                                    _2976 = mem[64]
                                                    mem[mem[64]] = 2
                                                    mem[64] = mem[64] + 96
                                                    mem[_2976 + 32 len 64] = call.data[calldata.size len 64]
                                                    if 0 >= mem[_2976]:
                                                        revert with 0, 50
                                                    mem[_2976 + 32] = this.address
                                                    require ext_code.size(uniswapV2RouterAddress)
                                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                                            gas gas_remaining wei
                                                    mem[_2976 + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[64] = _2976 + ceil32(return_data.size) + 96
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                    if 1 >= mem[_2976]:
                                                        revert with 0, 50
                                                    mem[_2976 + 64] = ext_call.return_data[12 len 20]
                                                    if not this.address:
                                                        revert with 0, 'ERC20: approve from the zero address'
                                                    if not uniswapV2RouterAddress:
                                                        revert with 0, 'ERC20: approve to the zero address'
                                                    mem[0] = uniswapV2RouterAddress
                                                    mem[32] = sha3(address(this.address), 1)
                                                    allowance[address(this.address)][stor9].field_0 = 0
                                                    emit Approval(0, this.address, uniswapV2RouterAddress);
                                                    mem[_2976 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                    mem[_2976 + ceil32(return_data.size) + 100] = 0
                                                    mem[_2976 + ceil32(return_data.size) + 132] = 0
                                                    mem[_2976 + ceil32(return_data.size) + 164] = 160
                                                    mem[_2976 + ceil32(return_data.size) + 260] = mem[_2976]
                                                    idx = 0
                                                    s = _2976 + ceil32(return_data.size) + 292
                                                    t = _2976 + 32
                                                    while idx < mem[_2976]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    require ext_code.size(uniswapV2RouterAddress)
                                                    call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args 0, 0, 160, address(this.address), block.timestamp, mem[_2976 + ceil32(return_data.size) + 260 len (32 * mem[_2976]) + 32]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[_2976 + ceil32(return_data.size) + 96] = 30
                                                    mem[_2976 + ceil32(return_data.size) + 128] = 'SafeMath: subtraction overflow'
                                                    if eth.balance(this.address) > eth.balance(this.address):
                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                    if eth.balance(this.address) < eth.balance(this.address):
                                                        revert with 0, 17
                                                    if not this.address:
                                                        revert with 0, 'ERC20: approve from the zero address'
                                                    if not uniswapV2RouterAddress:
                                                        revert with 0, 'ERC20: approve to the zero address'
                                                    allowance[address(this.address)][stor9].field_0 = 0
                                                    emit Approval(0, this.address, uniswapV2RouterAddress);
                                                    mem[_2976 + ceil32(return_data.size) + 228] = 0
                                                    mem[_2976 + ceil32(return_data.size) + 260] = 0
                                                    mem[_2976 + ceil32(return_data.size) + 292] = 0
                                                    mem[_2976 + ceil32(return_data.size) + 324] = block.timestamp
                                                    require ext_code.size(uniswapV2RouterAddress)
                                                    call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                         gas gas_remaining wei
                                                        args this.address, 0, 0, 0, 0, block.timestamp
                                                    mem[_2976 + ceil32(return_data.size) + 160 len 96] = ext_call.return_data[0 len 96]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 96
                                                    emit SwapAndLiquify(uint256 arg1, uint256 arg2, uint256 arg3):
                                                                        0,
                                                    mem[_2976 + (2 * ceil32(return_data.size)) + 160] = 2
                                                    mem[_2976 + (2 * ceil32(return_data.size)) + 192] = this.address
                                                    require ext_code.size(uniswapV2RouterAddress)
                                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                                            gas gas_remaining wei
                                                    mem[_2976 + (2 * ceil32(return_data.size)) + 256] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                    mem[_2976 + (2 * ceil32(return_data.size)) + 224] = ext_call.return_data[12 len 20]
                                                    if not this.address:
                                                        revert with 0, 'ERC20: approve from the zero address'
                                                    if not uniswapV2RouterAddress:
                                                        revert with 0, 'ERC20: approve to the zero address'
                                                    allowance[address(this.address)][stor9].field_0 = balanceOf[this.address]
                                                    emit Approval(balanceOf[this.address], this.address, uniswapV2RouterAddress);
                                                    mem[_2976 + (4 * ceil32(return_data.size)) + 256] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                    mem[_2976 + (4 * ceil32(return_data.size)) + 260] = balanceOf[this.address]
                                                    mem[_2976 + (4 * ceil32(return_data.size)) + 292] = 0
                                                    mem[_2976 + (4 * ceil32(return_data.size)) + 324] = 160
                                                    mem[_2976 + (4 * ceil32(return_data.size)) + 420] = 2
                                                    idx = 0
                                                    s = _2976 + (4 * ceil32(return_data.size)) + 452
                                                    t = _2976 + (2 * ceil32(return_data.size)) + 192
                                                    while idx < mem[_2976 + (2 * ceil32(return_data.size)) + 160]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_2976 + (4 * ceil32(return_data.size)) + 356] = this.address
                                                    mem[_2976 + (4 * ceil32(return_data.size)) + 388] = block.timestamp
                                                    require ext_code.size(uniswapV2RouterAddress)
                                                    call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args balanceOf[this.address], 0, 160, address(this.address), block.timestamp, mem[_2976 + (4 * ceil32(return_data.size)) + 420 len (32 * mem[_2976 + (2 * ceil32(return_data.size)) + 160]) + 32]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[_2976 + (4 * ceil32(return_data.size)) + 256] = 30
                                                    mem[_2976 + (4 * ceil32(return_data.size)) + 288] = 'SafeMath: subtraction overflow'
                                                    if eth.balance(this.address) > eth.balance(this.address):
                                                        mem[_2976 + (4 * ceil32(return_data.size)) + 320] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_2976 + (4 * ceil32(return_data.size)) + 324] = 32
                                                        mem[_2976 + (4 * ceil32(return_data.size)) + 356] = 30
                                                        mem[_2976 + (4 * ceil32(return_data.size)) + 388] = 'SafeMath: subtraction overflow'
                                                        mem[_2976 + (4 * ceil32(return_data.size)) + 418] = 0
                                                        revert with memory
                                                          from _2976 + (4 * ceil32(return_data.size)) + 320
                                                           len (5 * ceil32(return_data.size)) + 100
                                                    if eth.balance(this.address) < eth.balance(this.address):
                                                        revert with 0, 17
                                                    call marketingWalletAddress with:
                                                         gas 2300 wei
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    uint8(stor23.field_0) = 0
                                                    if not msg.sender:
                                                        mem[_2976 + (4 * ceil32(return_data.size)) + 320] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_2976 + (4 * ceil32(return_data.size)) + 324] = 32
                                                        mem[_2976 + (4 * ceil32(return_data.size)) + 356] = 37
                                                        mem[_2976 + (4 * ceil32(return_data.size)) + 388] = 'ERC20: transfer from the zero ad'
                                                        mem[_2976 + (4 * ceil32(return_data.size)) + 420] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                        revert with memory
                                                          from _2976 + (4 * ceil32(return_data.size)) + 320
                                                           len (5 * ceil32(return_data.size)) + 132
                                                    if not this.address:
                                                        mem[_2976 + (4 * ceil32(return_data.size)) + 320] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_2976 + (4 * ceil32(return_data.size)) + 324] = 32
                                                        mem[_2976 + (4 * ceil32(return_data.size)) + 356] = 35
                                                        mem[_2976 + (4 * ceil32(return_data.size)) + 388] = 'ERC20: transfer to the zero addr'
                                                        mem[_2976 + (4 * ceil32(return_data.size)) + 420] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                        revert with memory
                                                          from _2976 + (4 * ceil32(return_data.size)) + 320
                                                           len (5 * ceil32(return_data.size)) + 132
                                                    mem[_2976 + (4 * ceil32(return_data.size)) + 320] = 38
                                                    mem[_2976 + (4 * ceil32(return_data.size)) + 352 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                    if ext_call.return_data[0] > balanceOf[address(msg.sender)]:
                                                        mem[_2976 + (4 * ceil32(return_data.size)) + 416] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_2976 + (4 * ceil32(return_data.size)) + 420] = 32
                                                        mem[_2976 + (4 * ceil32(return_data.size)) + 452] = 38
                                                        mem[_2976 + (4 * ceil32(return_data.size)) + 484 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, Mask(208, 32, block.timestamp) >> 32
                                                        mem[_2976 + (4 * ceil32(return_data.size)) + 522] = 0
                                                        revert with memory
                                                          from _2976 + (4 * ceil32(return_data.size)) + 416
                                                           len (5 * ceil32(return_data.size)) + 132
                                                    if balanceOf[address(msg.sender)] < ext_call.return_data[0]:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] -= ext_call.return_data[0]
                                                    if balanceOf[this.address] > !ext_call.return_data[0]:
                                                        revert with 0, 17
                                                    if balanceOf[this.address] + ext_call.return_data[0] >= balanceOf[this.address]:
                                                        balanceOf[address(this.address)] = balanceOf[this.address] + ext_call.return_data[0]
                                                        emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                                        if arg2 >= 3:
                                                            revert with 0, 50
                                                        mem[_2976 + (4 * ceil32(return_data.size)) + 416] = 0x12b8603f00000000000000000000000000000000000000000000000000000000
                                                        mem[_2976 + (4 * ceil32(return_data.size)) + 420] = msg.sender
                                                        mem[_2976 + (4 * ceil32(return_data.size)) + 452] = 64
                                                        mem[_2976 + (4 * ceil32(return_data.size)) + 484] = mem[128]
                                                        mem[_2976 + (4 * ceil32(return_data.size)) + 516 len ceil32(mem[128])] = mem[160 len ceil32(mem[128])]
                                                        if ceil32(mem[128]) > mem[128]:
                                                            mem[_2976 + (4 * ceil32(return_data.size)) + mem[128] + 516] = 0
                                                        require ext_code.size(sub_20eea8b5[arg2])
                                                        call sub_20eea8b5[arg2].createNode(address arg1, string arg2) with:
                                                             gas gas_remaining wei
                                                            args mem[_2976 + (4 * ceil32(return_data.size)) + 420 len ceil32(mem[128]) + (5 * ceil32(return_data.size)) + 96]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if stor27[address(msg.sender)] > -2:
                                                            revert with 0, 17
                                                        if stor27[address(msg.sender)] + 1 >= stor27[address(msg.sender)]:
                                                            stor27[address(msg.sender)]++
                                                    mem[_2976 + (4 * ceil32(return_data.size)) + 416] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[_2976 + (4 * ceil32(return_data.size)) + 420] = 32
                                                    mem[_2976 + (4 * ceil32(return_data.size)) + 452] = 27
                                                    mem[_2976 + (4 * ceil32(return_data.size)) + 484] = 'SafeMath: addition overflow'
                                                    revert with memory
                                                      from _2976 + (4 * ceil32(return_data.size)) + 416
                                                       len (5 * ceil32(return_data.size)) + 100
                                                if balanceOf[this.address] and liquidityPoolFee > -1 / balanceOf[this.address]:
                                                    revert with 0, 17
                                                if not balanceOf[this.address]:
                                                    revert with 0, 18
                                                if balanceOf[this.address] * liquidityPoolFee / balanceOf[this.address] != liquidityPoolFee:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _2897 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_2897] = 26
                                                mem[_2897 + 32] = 'SafeMath: division by zero'
                                                _2927 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_2927] = 26
                                                mem[_2927 + 32] = 'SafeMath: division by zero'
                                                _2953 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_2953] = 30
                                                mem[_2953 + 32] = 'SafeMath: subtraction overflow'
                                                if balanceOf[this.address] * liquidityPoolFee / 100 / 2 > balanceOf[this.address] * liquidityPoolFee / 100:
                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                if balanceOf[this.address] * liquidityPoolFee / 100 < balanceOf[this.address] * liquidityPoolFee / 100 / 2:
                                                    revert with 0, 17
                                                _3055 = mem[64]
                                                mem[mem[64]] = 2
                                                mem[64] = mem[64] + 96
                                                mem[_3055 + 32 len 64] = call.data[calldata.size len 64]
                                                if 0 >= mem[_3055]:
                                                    revert with 0, 50
                                                mem[_3055 + 32] = this.address
                                                require ext_code.size(uniswapV2RouterAddress)
                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                        gas gas_remaining wei
                                                mem[_3055 + 96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[64] = _3055 + ceil32(return_data.size) + 96
                                                require return_data.size >= 32
                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                if 1 >= mem[_3055]:
                                                    revert with 0, 50
                                                mem[_3055 + 64] = ext_call.return_data[12 len 20]
                                                if not this.address:
                                                    revert with 0, 'ERC20: approve from the zero address'
                                                if not uniswapV2RouterAddress:
                                                    revert with 0, 'ERC20: approve to the zero address'
                                                mem[0] = uniswapV2RouterAddress
                                                mem[32] = sha3(address(this.address), 1)
                                                allowance[address(this.address)][stor9].field_0 = balanceOf[this.address] * liquidityPoolFee / 100 / 2
                                                allowance[address(this.address)][stor9].field_255 = 0
                                                emit Approval((balanceOf[this.address] * liquidityPoolFee / 100 / 2), this.address, uniswapV2RouterAddress);
                                                mem[_3055 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                mem[_3055 + ceil32(return_data.size) + 100] = balanceOf[this.address] * liquidityPoolFee / 100 / 2
                                                mem[_3055 + ceil32(return_data.size) + 132] = 0
                                                mem[_3055 + ceil32(return_data.size) + 164] = 160
                                                mem[_3055 + ceil32(return_data.size) + 260] = mem[_3055]
                                                idx = 0
                                                s = _3055 + ceil32(return_data.size) + 292
                                                t = _3055 + 32
                                                while idx < mem[_3055]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                require ext_code.size(uniswapV2RouterAddress)
                                                call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                     gas gas_remaining wei
                                                    args Mask(255, 1, balanceOf[this.address] * liquidityPoolFee / 100), 0, 160, address(this.address), block.timestamp, mem[_3055 + ceil32(return_data.size) + 260 len (32 * mem[_3055]) + 32]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[_3055 + ceil32(return_data.size) + 96] = 30
                                                mem[_3055 + ceil32(return_data.size) + 128] = 'SafeMath: subtraction overflow'
                                                if eth.balance(this.address) > eth.balance(this.address):
                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                if eth.balance(this.address) < eth.balance(this.address):
                                                    revert with 0, 17
                                                if not this.address:
                                                    revert with 0, 'ERC20: approve from the zero address'
                                                if not uniswapV2RouterAddress:
                                                    revert with 0, 'ERC20: approve to the zero address'
                                                allowance[address(this.address)][stor9].field_0 = (balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2)
                                                emit Approval(((balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2)), this.address, uniswapV2RouterAddress);
                                                mem[_3055 + ceil32(return_data.size) + 228] = 0
                                                mem[_3055 + ceil32(return_data.size) + 260] = 0
                                                mem[_3055 + ceil32(return_data.size) + 292] = 0
                                                mem[_3055 + ceil32(return_data.size) + 324] = block.timestamp
                                                require ext_code.size(uniswapV2RouterAddress)
                                                call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                     gas gas_remaining wei
                                                    args this.address, (balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2), 0, 0, 0, block.timestamp
                                                mem[_3055 + ceil32(return_data.size) + 160 len 96] = ext_call.return_data[0 len 96]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 96
                                                emit SwapAndLiquify(Mask(255, 1, balanceOf[this.address] * liquidityPoolFee / 100), 0, (balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2));
                                                mem[_3055 + (2 * ceil32(return_data.size)) + 160] = 2
                                                mem[_3055 + (2 * ceil32(return_data.size)) + 192] = this.address
                                                require ext_code.size(uniswapV2RouterAddress)
                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                        gas gas_remaining wei
                                                mem[_3055 + (2 * ceil32(return_data.size)) + 256] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[64] = _3055 + (4 * ceil32(return_data.size)) + 256
                                                require return_data.size >= 32
                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                mem[_3055 + (2 * ceil32(return_data.size)) + 224] = ext_call.return_data[12 len 20]
                                                if not this.address:
                                                    revert with 0, 'ERC20: approve from the zero address'
                                                if not uniswapV2RouterAddress:
                                                    revert with 0, 'ERC20: approve to the zero address'
                                                mem[0] = uniswapV2RouterAddress
                                                mem[32] = sha3(address(this.address), 1)
                                                allowance[address(this.address)][stor9].field_0 = balanceOf[this.address]
                                                emit Approval(balanceOf[this.address], this.address, uniswapV2RouterAddress);
                                                mem[_3055 + (4 * ceil32(return_data.size)) + 256] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                mem[_3055 + (4 * ceil32(return_data.size)) + 260] = balanceOf[this.address]
                                                mem[_3055 + (4 * ceil32(return_data.size)) + 292] = 0
                                                mem[_3055 + (4 * ceil32(return_data.size)) + 324] = 160
                                                mem[_3055 + (4 * ceil32(return_data.size)) + 420] = 2
                                                idx = 0
                                                s = _3055 + (4 * ceil32(return_data.size)) + 452
                                                t = _3055 + (2 * ceil32(return_data.size)) + 192
                                                while idx < mem[_3055 + (2 * ceil32(return_data.size)) + 160]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_3055 + (4 * ceil32(return_data.size)) + 356] = this.address
                                                mem[_3055 + (4 * ceil32(return_data.size)) + 388] = block.timestamp
                                                require ext_code.size(uniswapV2RouterAddress)
                                                call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                     gas gas_remaining wei
                                                    args balanceOf[this.address], 0, 160, address(this.address), block.timestamp, mem[_3055 + (4 * ceil32(return_data.size)) + 420 len (32 * mem[_3055 + (2 * ceil32(return_data.size)) + 160]) + 32]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[_3055 + (4 * ceil32(return_data.size)) + 256] = 30
                                                mem[_3055 + (4 * ceil32(return_data.size)) + 288] = 'SafeMath: subtraction overflow'
                                                if eth.balance(this.address) > eth.balance(this.address):
                                                    mem[_3055 + (4 * ceil32(return_data.size)) + 320] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[_3055 + (4 * ceil32(return_data.size)) + 324] = 32
                                                    mem[_3055 + (4 * ceil32(return_data.size)) + 356] = 30
                                                    mem[_3055 + (4 * ceil32(return_data.size)) + 388] = 'SafeMath: subtraction overflow'
                                                    mem[_3055 + (4 * ceil32(return_data.size)) + 418] = 0
                                                    revert with memory
                                                      from _3055 + (4 * ceil32(return_data.size)) + 320
                                                       len (5 * ceil32(return_data.size)) + 100
                                                if eth.balance(this.address) < eth.balance(this.address):
                                                    revert with 0, 17
                                                call marketingWalletAddress with:
                                                     gas 2300 wei
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                uint8(stor23.field_0) = 0
                                                if not msg.sender:
                                                    mem[_3055 + (4 * ceil32(return_data.size)) + 320] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[_3055 + (4 * ceil32(return_data.size)) + 324] = 32
                                                    mem[_3055 + (4 * ceil32(return_data.size)) + 356] = 37
                                                    mem[_3055 + (4 * ceil32(return_data.size)) + 388] = 'ERC20: transfer from the zero ad'
                                                    mem[_3055 + (4 * ceil32(return_data.size)) + 420] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                    revert with memory
                                                      from _3055 + (4 * ceil32(return_data.size)) + 320
                                                       len (5 * ceil32(return_data.size)) + 132
                                                if not this.address:
                                                    mem[_3055 + (4 * ceil32(return_data.size)) + 320] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[_3055 + (4 * ceil32(return_data.size)) + 324] = 32
                                                    mem[_3055 + (4 * ceil32(return_data.size)) + 356] = 35
                                                    mem[_3055 + (4 * ceil32(return_data.size)) + 388] = 'ERC20: transfer to the zero addr'
                                                    mem[_3055 + (4 * ceil32(return_data.size)) + 420] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                    revert with memory
                                                      from _3055 + (4 * ceil32(return_data.size)) + 320
                                                       len (5 * ceil32(return_data.size)) + 132
                                                mem[_3055 + (4 * ceil32(return_data.size)) + 320] = 38
                                                mem[_3055 + (4 * ceil32(return_data.size)) + 352 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                if ext_call.return_data[0] > balanceOf[address(msg.sender)]:
                                                    mem[_3055 + (4 * ceil32(return_data.size)) + 416] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[_3055 + (4 * ceil32(return_data.size)) + 420] = 32
                                                    mem[_3055 + (4 * ceil32(return_data.size)) + 452] = 38
                                                    mem[_3055 + (4 * ceil32(return_data.size)) + 484 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, Mask(208, 32, block.timestamp) >> 32
                                                    mem[_3055 + (4 * ceil32(return_data.size)) + 522] = 0
                                                    revert with memory
                                                      from _3055 + (4 * ceil32(return_data.size)) + 416
                                                       len (5 * ceil32(return_data.size)) + 132
                                                if balanceOf[address(msg.sender)] < ext_call.return_data[0]:
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] -= ext_call.return_data[0]
                                                if balanceOf[this.address] > !ext_call.return_data[0]:
                                                    revert with 0, 17
                                                if balanceOf[this.address] + ext_call.return_data[0] >= balanceOf[this.address]:
                                                    balanceOf[address(this.address)] = balanceOf[this.address] + ext_call.return_data[0]
                                                    emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                                    if arg2 >= 3:
                                                        revert with 0, 50
                                                    mem[_3055 + (4 * ceil32(return_data.size)) + 416] = 0x12b8603f00000000000000000000000000000000000000000000000000000000
                                                    mem[_3055 + (4 * ceil32(return_data.size)) + 420] = msg.sender
                                                    mem[_3055 + (4 * ceil32(return_data.size)) + 452] = 64
                                                    mem[_3055 + (4 * ceil32(return_data.size)) + 484] = mem[128]
                                                    mem[_3055 + (4 * ceil32(return_data.size)) + 516 len ceil32(mem[128])] = mem[160 len ceil32(mem[128])]
                                                    if ceil32(mem[128]) > mem[128]:
                                                        mem[_3055 + (4 * ceil32(return_data.size)) + mem[128] + 516] = 0
                                                    require ext_code.size(sub_20eea8b5[arg2])
                                                    call sub_20eea8b5[arg2].createNode(address arg1, string arg2) with:
                                                         gas gas_remaining wei
                                                        args mem[_3055 + (4 * ceil32(return_data.size)) + 420 len ceil32(mem[128]) + (5 * ceil32(return_data.size)) + 96]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if stor27[address(msg.sender)] > -2:
                                                        revert with 0, 17
                                                    if stor27[address(msg.sender)] + 1 >= stor27[address(msg.sender)]:
                                                        stor27[address(msg.sender)]++
                                                mem[_3055 + (4 * ceil32(return_data.size)) + 416] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[_3055 + (4 * ceil32(return_data.size)) + 420] = 32
                                                mem[_3055 + (4 * ceil32(return_data.size)) + 452] = 27
                                                mem[_3055 + (4 * ceil32(return_data.size)) + 484] = 'SafeMath: addition overflow'
                                                revert with memory
                                                  from _3055 + (4 * ceil32(return_data.size)) + 416
                                                   len (5 * ceil32(return_data.size)) + 100
                                            mem[ceil32(ceil32(arg1.length)) + ceil32(return_data.size) + 129] = 26
                                            mem[ceil32(ceil32(arg1.length)) + ceil32(return_data.size) + 161] = 'SafeMath: division by zero'
                                            mem[ceil32(ceil32(arg1.length)) + ceil32(return_data.size) + 193] = 26
                                            mem[ceil32(ceil32(arg1.length)) + ceil32(return_data.size) + 225] = 'SafeMath: division by zero'
                                            mem[ceil32(ceil32(arg1.length)) + ceil32(return_data.size) + 257] = 2
                                            mem[ceil32(ceil32(arg1.length)) + ceil32(return_data.size) + 289] = this.address
                                            require ext_code.size(uniswapV2RouterAddress)
                                            staticcall uniswapV2RouterAddress.WAVAX() with:
                                                    gas gas_remaining wei
                                            mem[ceil32(ceil32(arg1.length)) + ceil32(return_data.size) + 353] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[64] = ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 353
                                            require return_data.size >= 32
                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                            mem[ceil32(ceil32(arg1.length)) + ceil32(return_data.size) + 321] = ext_call.return_data[12 len 20]
                                            if not this.address:
                                                mem[ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 353] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 357] = 32
                                                mem[ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 389] = 36
                                                mem[ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 421] = 'ERC20: approve from the zero add'
                                                mem[ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 453] = 0x7265737300000000000000000000000000000000000000000000000000000000
                                                revert with memory
                                                  from ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 353
                                                   len ceil32(return_data.size) + 132
                                            if not uniswapV2RouterAddress:
                                                mem[ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 353] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 357] = 32
                                                mem[ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 389] = 34
                                                mem[ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 421] = 'ERC20: approve to the zero addre'
                                                mem[ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 453] = 0x7373000000000000000000000000000000000000000000000000000000000000
                                                revert with memory
                                                  from ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 353
                                                   len ceil32(return_data.size) + 132
                                            mem[0] = uniswapV2RouterAddress
                                            mem[32] = sha3(address(this.address), 1)
                                            allowance[address(this.address)][stor9].field_0 = 0
                                            mem[ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 353] = 0
                                            emit Approval(mem[ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 353 len ceil32(return_data.size) + 32], this.address, uniswapV2RouterAddress);
                                            mem[ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 353] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                            mem[ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 357] = 0
                                            mem[ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 389] = 0
                                            mem[ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 421] = 160
                                            mem[ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 517] = 2
                                            idx = 0
                                            s = ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 549
                                            t = ceil32(ceil32(arg1.length)) + ceil32(return_data.size) + 289
                                            while idx < mem[ceil32(ceil32(arg1.length)) + ceil32(return_data.size) + 257]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 453] = this.address
                                            mem[ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + 485] = block.timestamp
                                            require ext_code.size(uniswapV2RouterAddress)
                                            call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len ceil32(ceil32(arg1.length)) + (2 * ceil32(return_data.size)) + -mem[64] + 609]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _2297 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2297] = 30
                                            mem[_2297 + 32] = 'SafeMath: subtraction overflow'
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if eth.balance(this.address) < eth.balance(this.address):
                                                revert with 0, 17
                                            call distributionPoolAddress with:
                                                 gas 2300 wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _2517 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2517] = 30
                                            mem[_2517 + 32] = 'SafeMath: subtraction overflow'
                                            if not this.address:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not distributionPoolAddress:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            _2606 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_2606] = 38
                                            mem[_2606 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                            if 0 > balanceOf[address(this.address)]:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 38
                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_2606 + 70 len 26]
                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                            if balanceOf[address(this.address)] < 0:
                                                revert with 0, 17
                                            if balanceOf[stor12] > -1:
                                                revert with 0, 17
                                            if balanceOf[stor12] < balanceOf[stor12]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = distributionPoolAddress
                                            mem[32] = 0
                                            balanceOf[stor12] = balanceOf[stor12]
                                            emit Transfer(0, this.address, distributionPoolAddress);
                                            if not balanceOf[this.address]:
                                                _2849 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_2849] = 26
                                                mem[_2849 + 32] = 'SafeMath: division by zero'
                                                _2912 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_2912] = 26
                                                mem[_2912 + 32] = 'SafeMath: division by zero'
                                                _2939 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_2939] = 30
                                                mem[_2939 + 32] = 'SafeMath: subtraction overflow'
                                                _2982 = mem[64]
                                                mem[mem[64]] = 2
                                                mem[64] = mem[64] + 96
                                                mem[_2982 + 32 len 64] = call.data[calldata.size len 64]
                                                if 0 >= mem[_2982]:
                                                    revert with 0, 50
                                                mem[_2982 + 32] = this.address
                                                require ext_code.size(uniswapV2RouterAddress)
                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                        gas gas_remaining wei
                                                mem[_2982 + 96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[64] = _2982 + ceil32(return_data.size) + 96
                                                require return_data.size >= 32
                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                if 1 >= mem[_2982]:
                                                    revert with 0, 50
                                                mem[_2982 + 64] = ext_call.return_data[12 len 20]
                                                if not this.address:
                                                    revert with 0, 'ERC20: approve from the zero address'
                                                if not uniswapV2RouterAddress:
                                                    revert with 0, 'ERC20: approve to the zero address'
                                                mem[0] = uniswapV2RouterAddress
                                                mem[32] = sha3(address(this.address), 1)
                                                allowance[address(this.address)][stor9].field_0 = 0
                                                emit Approval(0, this.address, uniswapV2RouterAddress);
                                                mem[_2982 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                mem[_2982 + ceil32(return_data.size) + 100] = 0
                                                mem[_2982 + ceil32(return_data.size) + 132] = 0
                                                mem[_2982 + ceil32(return_data.size) + 164] = 160
                                                mem[_2982 + ceil32(return_data.size) + 260] = mem[_2982]
                                                idx = 0
                                                s = _2982 + ceil32(return_data.size) + 292
                                                t = _2982 + 32
                                                while idx < mem[_2982]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_2982 + ceil32(return_data.size) + 196] = this.address
                                                mem[_2982 + ceil32(return_data.size) + 228] = block.timestamp
                                                require ext_code.size(uniswapV2RouterAddress)
                                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _2982 + ceil32(return_data.size) + (32 * mem[_2982]) + -mem[64] + 288]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _5341 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_5341] = 30
                                                mem[_5341 + 32] = 'SafeMath: subtraction overflow'
                                                if eth.balance(this.address) > eth.balance(this.address):
                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                if eth.balance(this.address) < eth.balance(this.address):
                                                    revert with 0, 17
                                                if not this.address:
                                                    revert with 0, 'ERC20: approve from the zero address'
                                                if not uniswapV2RouterAddress:
                                                    revert with 0, 'ERC20: approve to the zero address'
                                                mem[0] = uniswapV2RouterAddress
                                                mem[32] = sha3(address(this.address), 1)
                                                allowance[address(this.address)][stor9].field_0 = 0
                                                emit Approval(0, this.address, uniswapV2RouterAddress);
                                                mem[mem[64] + 68] = 0
                                                mem[mem[64] + 100] = 0
                                                mem[mem[64] + 132] = 0
                                                mem[mem[64] + 164] = block.timestamp
                                                require ext_code.size(uniswapV2RouterAddress)
                                                call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                     gas gas_remaining wei
                                                    args this.address, 0, 0, 0, 0, block.timestamp
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 96
                                                mem[mem[64] + 32] = 0
                                                mem[mem[64] + 64] = 0
                                                emit SwapAndLiquify(uint256 arg1, uint256 arg2, uint256 arg3):
                                                                    0,
                                                mem[0] = this.address
                                                mem[32] = 0
                                                _5883 = mem[64]
                                                mem[mem[64]] = 2
                                                mem[64] = mem[64] + 96
                                                mem[_5883 + 32 len 64] = call.data[calldata.size len 64]
                                                if 0 >= mem[_5883]:
                                                    revert with 0, 50
                                                mem[_5883 + 32] = this.address
                                                require ext_code.size(uniswapV2RouterAddress)
                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                        gas gas_remaining wei
                                                mem[_5883 + 96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[64] = _5883 + ceil32(return_data.size) + 96
                                                require return_data.size >= 32
                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                if 1 >= mem[_5883]:
                                                    revert with 0, 50
                                                mem[_5883 + 64] = ext_call.return_data[12 len 20]
                                                if not this.address:
                                                    revert with 0, 'ERC20: approve from the zero address'
                                                if not uniswapV2RouterAddress:
                                                    revert with 0, 'ERC20: approve to the zero address'
                                                mem[0] = uniswapV2RouterAddress
                                                mem[32] = sha3(address(this.address), 1)
                                                allowance[address(this.address)][stor9].field_0 = balanceOf[this.address]
                                                emit Approval(balanceOf[this.address], this.address, uniswapV2RouterAddress);
                                                mem[_5883 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                mem[_5883 + ceil32(return_data.size) + 100] = balanceOf[this.address]
                                                mem[_5883 + ceil32(return_data.size) + 132] = 0
                                                mem[_5883 + ceil32(return_data.size) + 164] = 160
                                                mem[_5883 + ceil32(return_data.size) + 260] = mem[_5883]
                                                idx = 0
                                                s = _5883 + ceil32(return_data.size) + 292
                                                t = _5883 + 32
                                                while idx < mem[_5883]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_5883 + ceil32(return_data.size) + 196] = this.address
                                                mem[_5883 + ceil32(return_data.size) + 228] = block.timestamp
                                                require ext_code.size(uniswapV2RouterAddress)
                                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _5883 + ceil32(return_data.size) + (32 * mem[_5883]) + -mem[64] + 288]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _8763 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8763] = 30
                                                mem[_8763 + 32] = 'SafeMath: subtraction overflow'
                                                if eth.balance(this.address) > eth.balance(this.address):
                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                if eth.balance(this.address) < eth.balance(this.address):
                                                    revert with 0, 17
                                                call marketingWalletAddress with:
                                                     gas 2300 wei
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                uint8(stor23.field_0) = 0
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not this.address:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                _9139 = mem[64]
                                                mem[64] = mem[64] + 96
                                                mem[_9139] = 38
                                                mem[_9139 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                if ext_call.return_data[0] > balanceOf[address(msg.sender)]:
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 38
                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_9139 + 70 len 26]
                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                if balanceOf[address(msg.sender)] < ext_call.return_data[0]:
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] -= ext_call.return_data[0]
                                                if balanceOf[this.address] > !ext_call.return_data[0]:
                                                    revert with 0, 17
                                                if balanceOf[this.address] + ext_call.return_data[0] < balanceOf[this.address]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(this.address)] = balanceOf[this.address] + ext_call.return_data[0]
                                                emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                                if arg2 >= 3:
                                                    revert with 0, 50
                                                mem[mem[64]] = 0x12b8603f00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 64
                                                mem[mem[64] + 68] = mem[128]
                                                mem[mem[64] + 100 len ceil32(mem[128])] = mem[160 len ceil32(mem[128])]
                                                if ceil32(mem[128]) > mem[128]:
                                                    mem[mem[64] + mem[128] + 100] = 0
                                                require ext_code.size(sub_20eea8b5[arg2])
                                                call sub_20eea8b5[arg2].createNode(address arg1, string arg2) with:
                                                     gas gas_remaining wei
                                                    args msg.sender, Array(len=mem[128], data=mem[mem[64] + 100 len ceil32(mem[128])])
                                            else:
                                                if balanceOf[this.address] and liquidityPoolFee > -1 / balanceOf[this.address]:
                                                    revert with 0, 17
                                                if not balanceOf[this.address]:
                                                    revert with 0, 18
                                                if balanceOf[this.address] * liquidityPoolFee / balanceOf[this.address] != liquidityPoolFee:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _2899 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_2899] = 26
                                                mem[_2899 + 32] = 'SafeMath: division by zero'
                                                _2929 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_2929] = 26
                                                mem[_2929 + 32] = 'SafeMath: division by zero'
                                                _2955 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_2955] = 30
                                                mem[_2955 + 32] = 'SafeMath: subtraction overflow'
                                                if balanceOf[this.address] * liquidityPoolFee / 100 / 2 > balanceOf[this.address] * liquidityPoolFee / 100:
                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                if balanceOf[this.address] * liquidityPoolFee / 100 < balanceOf[this.address] * liquidityPoolFee / 100 / 2:
                                                    revert with 0, 17
                                                _3059 = mem[64]
                                                mem[mem[64]] = 2
                                                mem[64] = mem[64] + 96
                                                mem[_3059 + 32 len 64] = call.data[calldata.size len 64]
                                                if 0 >= mem[_3059]:
                                                    revert with 0, 50
                                                mem[_3059 + 32] = this.address
                                                require ext_code.size(uniswapV2RouterAddress)
                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                        gas gas_remaining wei
                                                mem[_3059 + 96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[64] = _3059 + ceil32(return_data.size) + 96
                                                require return_data.size >= 32
                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                if 1 >= mem[_3059]:
                                                    revert with 0, 50
                                                mem[_3059 + 64] = ext_call.return_data[12 len 20]
                                                if not this.address:
                                                    revert with 0, 'ERC20: approve from the zero address'
                                                if not uniswapV2RouterAddress:
                                                    revert with 0, 'ERC20: approve to the zero address'
                                                mem[0] = uniswapV2RouterAddress
                                                mem[32] = sha3(address(this.address), 1)
                                                allowance[address(this.address)][stor9].field_0 = balanceOf[this.address] * liquidityPoolFee / 100 / 2
                                                allowance[address(this.address)][stor9].field_255 = 0
                                                emit Approval((balanceOf[this.address] * liquidityPoolFee / 100 / 2), this.address, uniswapV2RouterAddress);
                                                mem[_3059 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                mem[_3059 + ceil32(return_data.size) + 100] = balanceOf[this.address] * liquidityPoolFee / 100 / 2
                                                mem[_3059 + ceil32(return_data.size) + 132] = 0
                                                mem[_3059 + ceil32(return_data.size) + 164] = 160
                                                mem[_3059 + ceil32(return_data.size) + 260] = mem[_3059]
                                                idx = 0
                                                s = _3059 + ceil32(return_data.size) + 292
                                                t = _3059 + 32
                                                while idx < mem[_3059]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_3059 + ceil32(return_data.size) + 196] = this.address
                                                mem[_3059 + ceil32(return_data.size) + 228] = block.timestamp
                                                require ext_code.size(uniswapV2RouterAddress)
                                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _3059 + ceil32(return_data.size) + (32 * mem[_3059]) + -mem[64] + 288]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _5340 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_5340] = 30
                                                mem[_5340 + 32] = 'SafeMath: subtraction overflow'
                                                if eth.balance(this.address) > eth.balance(this.address):
                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                if eth.balance(this.address) < eth.balance(this.address):
                                                    revert with 0, 17
                                                if not this.address:
                                                    revert with 0, 'ERC20: approve from the zero address'
                                                if not uniswapV2RouterAddress:
                                                    revert with 0, 'ERC20: approve to the zero address'
                                                mem[0] = uniswapV2RouterAddress
                                                mem[32] = sha3(address(this.address), 1)
                                                allowance[address(this.address)][stor9].field_0 = (balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2)
                                                emit Approval(((balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2)), this.address, uniswapV2RouterAddress);
                                                mem[mem[64] + 68] = 0
                                                mem[mem[64] + 100] = 0
                                                mem[mem[64] + 132] = 0
                                                mem[mem[64] + 164] = block.timestamp
                                                require ext_code.size(uniswapV2RouterAddress)
                                                call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                     gas gas_remaining wei
                                                    args this.address, (balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2), 0, 0, 0, block.timestamp
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 96
                                                mem[mem[64] + 32] = 0
                                                mem[mem[64] + 64] = (balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2)
                                                emit SwapAndLiquify(Mask(255, 1, balanceOf[this.address] * liquidityPoolFee / 100), 0, (balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2));
                                                mem[0] = this.address
                                                mem[32] = 0
                                                _5881 = mem[64]
                                                mem[mem[64]] = 2
                                                mem[64] = mem[64] + 96
                                                mem[_5881 + 32 len 64] = call.data[calldata.size len 64]
                                                if 0 >= mem[_5881]:
                                                    revert with 0, 50
                                                mem[_5881 + 32] = this.address
                                                require ext_code.size(uniswapV2RouterAddress)
                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                        gas gas_remaining wei
                                                mem[_5881 + 96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[64] = _5881 + ceil32(return_data.size) + 96
                                                require return_data.size >= 32
                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                if 1 >= mem[_5881]:
                                                    revert with 0, 50
                                                mem[_5881 + 64] = ext_call.return_data[12 len 20]
                                                if not this.address:
                                                    revert with 0, 'ERC20: approve from the zero address'
                                                if not uniswapV2RouterAddress:
                                                    revert with 0, 'ERC20: approve to the zero address'
                                                mem[0] = uniswapV2RouterAddress
                                                mem[32] = sha3(address(this.address), 1)
                                                allowance[address(this.address)][stor9].field_0 = balanceOf[this.address]
                                                emit Approval(balanceOf[this.address], this.address, uniswapV2RouterAddress);
                                                mem[_5881 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                mem[_5881 + ceil32(return_data.size) + 100] = balanceOf[this.address]
                                                mem[_5881 + ceil32(return_data.size) + 132] = 0
                                                mem[_5881 + ceil32(return_data.size) + 164] = 160
                                                mem[_5881 + ceil32(return_data.size) + 260] = mem[_5881]
                                                idx = 0
                                                s = _5881 + ceil32(return_data.size) + 292
                                                t = _5881 + 32
                                                while idx < mem[_5881]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_5881 + ceil32(return_data.size) + 228] = block.timestamp
                                                require ext_code.size(uniswapV2RouterAddress)
                                                call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                     gas gas_remaining wei
                                                    args balanceOf[this.address], 0, 160, address(this.address), block.timestamp, mem[_5881 + ceil32(return_data.size) + 260 len (32 * mem[_5881]) + 32]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[_5881 + ceil32(return_data.size) + 96] = 30
                                                mem[_5881 + ceil32(return_data.size) + 128] = 'SafeMath: subtraction overflow'
                                                if eth.balance(this.address) > eth.balance(this.address):
                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                if eth.balance(this.address) < eth.balance(this.address):
                                                    revert with 0, 17
                                                call marketingWalletAddress with:
                                                     gas 2300 wei
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                uint8(stor23.field_0) = 0
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not this.address:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                mem[_5881 + ceil32(return_data.size) + 160] = 38
                                                mem[_5881 + ceil32(return_data.size) + 192 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                if ext_call.return_data[0] > balanceOf[address(msg.sender)]:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, Mask(208, 32, block.timestamp) >> 32 >> 48,
                                                                0
                                                if balanceOf[address(msg.sender)] < ext_call.return_data[0]:
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] -= ext_call.return_data[0]
                                                if balanceOf[this.address] > !ext_call.return_data[0]:
                                                    revert with 0, 17
                                                if balanceOf[this.address] + ext_call.return_data[0] < balanceOf[this.address]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(this.address)] = balanceOf[this.address] + ext_call.return_data[0]
                                                emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                                if arg2 >= 3:
                                                    revert with 0, 50
                                                mem[_5881 + ceil32(return_data.size) + 256] = 0x12b8603f00000000000000000000000000000000000000000000000000000000
                                                mem[_5881 + ceil32(return_data.size) + 260] = msg.sender
                                                mem[_5881 + ceil32(return_data.size) + 292] = 64
                                                mem[_5881 + ceil32(return_data.size) + 324] = mem[128]
                                                mem[_5881 + ceil32(return_data.size) + 356 len ceil32(mem[128])] = mem[160 len ceil32(mem[128])]
                                                if ceil32(mem[128]) > mem[128]:
                                                    mem[_5881 + ceil32(return_data.size) + mem[128] + 356] = 0
                                                require ext_code.size(sub_20eea8b5[arg2])
                                                call sub_20eea8b5[arg2].createNode(address arg1, string arg2) with:
                                                     gas gas_remaining wei
                                                    args msg.sender, Array(len=mem[128], data=mem[_5881 + ceil32(return_data.size) + 356 len ceil32(mem[128])])
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if stor27[address(msg.sender)] > -2:
                            revert with 0, 17
                        if stor27[address(msg.sender)] + 1 < stor27[address(msg.sender)]:
                            revert with 0, 'SafeMath: addition overflow'
                        stor27[address(msg.sender)]++
                    else:
                        if uint32(call.func_hash) >> 224 != unknown_0xc16aaecf(?????):
                            if uint32(call.func_hash) >> 224 != unknown_0xc239eec5(?????):
                                require unknown_0xc5ca7d6d(?????) == uint32(call.func_hash) >> 224
                                require not msg.value
                                return distributionPoolAddress
                            require not msg.value
                            require calldata.size - 4 >= 64
                            if owner != msg.sender:
                                revert with 0, 'Ownable: caller is not the owner'
                            if arg2 >= 3:
                                revert with 0, 50
                            require ext_code.size(sub_20eea8b5[arg2])
                            call sub_20eea8b5[arg2].0x81958c5c with:
                                 gas gas_remaining wei
                                args arg1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                        else:
                            require not msg.value
                            require calldata.size - 4 >= 64
                            require arg2 <= test266151307()
                            require arg2 + 35 < calldata.size
                            if arg2.length > test266151307():
                                revert with 0, 65
                            if ceil32(ceil32(arg2.length)) + 129 < 128 or ceil32(ceil32(arg2.length)) + 129 > test266151307():
                                revert with 0, 65
                            mem[64] = ceil32(ceil32(arg2.length)) + 129
                            mem[128] = arg2.length
                            require arg2 + arg2.length + 36 <= calldata.size
                            mem[160 len arg2.length] = arg2[all]
                            mem[arg2.length + 160] = 0
                            idx = 0
                            s = 0
                            while idx < 3:
                                mem[mem[64] + 4] = msg.sender
                                mem[mem[64] + 36] = 0
                                require ext_code.size(sub_20eea8b5[idx])
                                staticcall sub_20eea8b5[idx].0x80e9be34 with:
                                        gas gas_remaining wei
                                       args msg.sender, 0
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _2299 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if s > !mem[_2299]:
                                    revert with 0, 17
                                if s + mem[_2299] < s:
                                    revert with 0, 'SafeMath: addition overflow'
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + mem[_2299]
                                continue 
                            mem[0] = msg.sender
                            mem[32] = 0
                            if arg1 >= 3:
                                revert with 0, 50
                            require ext_code.size(sub_20eea8b5[arg1])
                            staticcall sub_20eea8b5[arg1].nodePrice() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2198 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _2298 = mem[_2198]
                            if 0x6f32f1ef8b18a2bc3cea59789c79d441 * s > !balanceOf[address(msg.sender)]:
                                revert with 0, 17
                            if (0x6f32f1ef8b18a2bc3cea59789c79d441 * s) + balanceOf[address(msg.sender)] < 0x6f32f1ef8b18a2bc3cea59789c79d441 * s:
                                revert with 0, 'SafeMath: addition overflow'
                            if (0x6f32f1ef8b18a2bc3cea59789c79d441 * s) + balanceOf[address(msg.sender)] < mem[_2198]:
                                revert with 0, 'Insufficient balance'
                            if 0x6f32f1ef8b18a2bc3cea59789c79d441 * s >= mem[_2198]:
                                idx = 0
                                while idx < 3:
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = 0
                                    require ext_code.size(sub_20eea8b5[idx])
                                    staticcall sub_20eea8b5[idx].0x80e9be34 with:
                                            gas gas_remaining wei
                                           args msg.sender, 0
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5347 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _5377 = mem[_5347]
                                    if not _2298:
                                        if not distributionPoolAddress:
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        _5433 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_5433] = 38
                                        mem[_5433 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                        mem[32] = 0
                                        if _5377 > balanceOf[stor12]:
                                            _5461 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 38
                                            idx = 0
                                            while idx < 38:
                                                mem[idx + _5461 + 68] = mem[_5433 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_5461 + 106] = 0
                                            revert with memory
                                              from mem[64]
                                               len _5461 + -mem[64] + 132
                                        if balanceOf[stor12] < _5377:
                                            revert with 0, 17
                                        balanceOf[stor12] -= _5377
                                        if balanceOf[msg.sender] > !_5377:
                                            revert with 0, 17
                                        if balanceOf[msg.sender] + _5377 < balanceOf[msg.sender]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 0
                                        balanceOf[address(msg.sender)] = balanceOf[msg.sender] + _5377
                                        emit Transfer(_5377, distributionPoolAddress, msg.sender);
                                        if idx >= 3:
                                            revert with 0, 50
                                        mem[mem[64]] = 0xd74037e500000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = 0
                                        require ext_code.size(sub_20eea8b5[idx])
                                        call sub_20eea8b5[idx].0xd74037e5 with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    if 0 > !mem[_5347]:
                                        revert with 0, 17
                                    if mem[_5347] < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if mem[_5347] < _2298:
                                        if not distributionPoolAddress:
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        _5683 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_5683] = 38
                                        mem[_5683 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                        mem[32] = 0
                                        if _5377 > balanceOf[stor12]:
                                            _5707 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 38
                                            idx = 0
                                            while idx < 38:
                                                mem[idx + _5707 + 68] = mem[_5683 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_5707 + 106] = 0
                                            revert with memory
                                              from mem[64]
                                               len _5707 + -mem[64] + 132
                                        if balanceOf[stor12] < _5377:
                                            revert with 0, 17
                                        balanceOf[stor12] -= _5377
                                        if balanceOf[msg.sender] > !_5377:
                                            revert with 0, 17
                                        if balanceOf[msg.sender] + _5377 < balanceOf[msg.sender]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 0
                                        balanceOf[address(msg.sender)] = balanceOf[msg.sender] + _5377
                                        emit Transfer(_5377, distributionPoolAddress, msg.sender);
                                        if idx >= 3:
                                            revert with 0, 50
                                        mem[mem[64]] = 0xd74037e500000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = 0
                                        require ext_code.size(sub_20eea8b5[idx])
                                        call sub_20eea8b5[idx].0xd74037e5 with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if 0 > !_5377:
                                            revert with 0, 17
                                        if _5377 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    _5632 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5632] = 30
                                    mem[_5632 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > _2298:
                                        _5682 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _5682 + 68] = mem[_5632 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_5682 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _5682 + -mem[64] + 100
                                    if _2298 < 0:
                                        revert with 0, 17
                                    if not distributionPoolAddress:
                                        revert with 0, 'ERC20: transfer from the zero address'
                                    if not msg.sender:
                                        revert with 0, 'ERC20: transfer to the zero address'
                                    _5896 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_5896] = 38
                                    mem[_5896 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                    mem[32] = 0
                                    if _2298 > balanceOf[stor12]:
                                        _5968 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 38
                                        idx = 0
                                        while idx < 38:
                                            mem[idx + _5968 + 68] = mem[_5896 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_5968 + 106] = 0
                                        revert with memory
                                          from mem[64]
                                           len _5968 + -mem[64] + 132
                                    if balanceOf[stor12] < _2298:
                                        revert with 0, 17
                                    balanceOf[stor12] -= _2298
                                    if balanceOf[msg.sender] > !_2298:
                                        revert with 0, 17
                                    if balanceOf[msg.sender] + _2298 < balanceOf[msg.sender]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 0
                                    balanceOf[address(msg.sender)] = balanceOf[msg.sender] + _2298
                                    emit Transfer(_2298, distributionPoolAddress, msg.sender);
                                    if idx >= 3:
                                        revert with 0, 50
                                    _6372 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6372] = 30
                                    mem[_6372 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > _2298:
                                        _6404 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _6404 + 68] = mem[_6372 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_6404 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _6404 + -mem[64] + 100
                                    if _2298 < 0:
                                        revert with 0, 17
                                    mem[mem[64]] = 0xd74037e500000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = _2298
                                    mem[mem[64] + 68] = 0
                                    require ext_code.size(sub_20eea8b5[idx])
                                    call sub_20eea8b5[idx].0xd74037e5 with:
                                         gas gas_remaining wei
                                        args msg.sender, _2298, 0
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if mem[128] <= 3:
                                        revert with 0, 'NODE CREATION: NAME SIZE INVALID'
                                    if mem[128] >= 32:
                                        revert with 0, 'NODE CREATION: NAME SIZE INVALID'
                                    if sub_6cdc78b3 <= stor27[msg.sender]:
                                        revert with 0, 'cannot create node more than 100'
                                    if not msg.sender:
                                        revert with 0, 'NODE CREATION:  creation from the zero address'
                                    mem[0] = msg.sender
                                    mem[32] = 25
                                    if stor25[address(msg.sender)]:
                                        revert with 0, 'NODE CREATION: Blacklisted address'
                                    if futurUsePoolAddress == msg.sender:
                                        revert with 0, 'NODE CREATION: futur and rewardsPool cannot create node'
                                    if distributionPoolAddress == msg.sender:
                                        revert with 0, 'NODE CREATION: futur and rewardsPool cannot create node'
                                    if arg1 >= 3:
                                        revert with 0, 50
                                    require ext_code.size(sub_20eea8b5[arg1])
                                    staticcall sub_20eea8b5[arg1].nodePrice() with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _6896 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _6955 = mem[_6896]
                                    if balanceOf[address(msg.sender)] < mem[_6896]:
                                        revert with 0, 'NODE CREATION: Balance too low for creation.'
                                    mem[0] = this.address
                                    mem[32] = 0
                                    if balanceOf[this.address] < swapTokensAmount:
                                        if not msg.sender:
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not this.address:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        _7180 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_7180] = 38
                                        mem[_7180 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                        mem[32] = 0
                                        if _6955 > balanceOf[address(msg.sender)]:
                                            _7215 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 38
                                            idx = 0
                                            while idx < 38:
                                                mem[idx + _7215 + 68] = mem[_7180 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_7215 + 106] = 0
                                            revert with memory
                                              from mem[64]
                                               len _7215 + -mem[64] + 132
                                        if balanceOf[address(msg.sender)] < _6955:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] -= _6955
                                        if balanceOf[this.address] > !_6955:
                                            revert with 0, 17
                                        if balanceOf[this.address] + _6955 < balanceOf[this.address]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(this.address)] = balanceOf[this.address] + _6955
                                        emit Transfer(_6955, msg.sender, this.address);
                                        if arg1 >= 3:
                                            revert with 0, 50
                                        mem[mem[64]] = 0x12b8603f00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 64
                                        mem[mem[64] + 68] = mem[128]
                                        idx = 0
                                        while idx < mem[128]:
                                            mem[idx + mem[64] + 100] = mem[idx + 160]
                                            idx = idx + 32
                                            continue 
                                        if ceil32(mem[128]) > mem[128]:
                                            mem[mem[64] + mem[128] + 100] = 0
                                        require ext_code.size(sub_20eea8b5[arg1])
                                        call sub_20eea8b5[arg1].createNode(address arg1, string arg2) with:
                                             gas gas_remaining wei
                                            args msg.sender, Array(len=mem[128], data=mem[mem[64] + 100 len ceil32(mem[128])])
                                    else:
                                        if not uint8(stor23.field_8):
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not this.address:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            _7207 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_7207] = 38
                                            mem[_7207 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                            mem[32] = 0
                                            if _6955 > balanceOf[address(msg.sender)]:
                                                _7226 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 38
                                                idx = 0
                                                while idx < 38:
                                                    mem[idx + _7226 + 68] = mem[_7207 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_7226 + 106] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _7226 + -mem[64] + 132
                                            if balanceOf[address(msg.sender)] < _6955:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] -= _6955
                                            if balanceOf[this.address] > !_6955:
                                                revert with 0, 17
                                            if balanceOf[this.address] + _6955 < balanceOf[this.address]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(this.address)] = balanceOf[this.address] + _6955
                                            emit Transfer(_6955, msg.sender, this.address);
                                            if arg1 >= 3:
                                                revert with 0, 50
                                            mem[mem[64]] = 0x12b8603f00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 64
                                            mem[mem[64] + 68] = mem[128]
                                            idx = 0
                                            while idx < mem[128]:
                                                mem[idx + mem[64] + 100] = mem[idx + 160]
                                                idx = idx + 32
                                                continue 
                                            if ceil32(mem[128]) > mem[128]:
                                                mem[mem[64] + mem[128] + 100] = 0
                                            require ext_code.size(sub_20eea8b5[arg1])
                                            call sub_20eea8b5[arg1].createNode(address arg1, string arg2) with:
                                                 gas gas_remaining wei
                                                args msg.sender, Array(len=mem[128], data=mem[mem[64] + 100 len ceil32(mem[128])])
                                        else:
                                            if uint8(stor23.field_0):
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not this.address:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                _7218 = mem[64]
                                                mem[64] = mem[64] + 96
                                                mem[_7218] = 38
                                                mem[_7218 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                mem[32] = 0
                                                if _6955 > balanceOf[address(msg.sender)]:
                                                    _7254 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 38
                                                    idx = 0
                                                    while idx < 38:
                                                        mem[idx + _7254 + 68] = mem[_7218 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_7254 + 106] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _7254 + -mem[64] + 132
                                                if balanceOf[address(msg.sender)] < _6955:
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] -= _6955
                                                if balanceOf[this.address] > !_6955:
                                                    revert with 0, 17
                                                if balanceOf[this.address] + _6955 < balanceOf[this.address]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(this.address)] = balanceOf[this.address] + _6955
                                                emit Transfer(_6955, msg.sender, this.address);
                                                if arg1 >= 3:
                                                    revert with 0, 50
                                                mem[mem[64]] = 0x12b8603f00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 64
                                                mem[mem[64] + 68] = mem[128]
                                                idx = 0
                                                while idx < mem[128]:
                                                    mem[idx + mem[64] + 100] = mem[idx + 160]
                                                    idx = idx + 32
                                                    continue 
                                                if ceil32(mem[128]) > mem[128]:
                                                    mem[mem[64] + mem[128] + 100] = 0
                                                require ext_code.size(sub_20eea8b5[arg1])
                                                call sub_20eea8b5[arg1].createNode(address arg1, string arg2) with:
                                                     gas gas_remaining wei
                                                    args msg.sender, Array(len=mem[128], data=mem[mem[64] + 100 len ceil32(mem[128])])
                                            else:
                                                if owner == msg.sender:
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not this.address:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    _7229 = mem[64]
                                                    mem[64] = mem[64] + 96
                                                    mem[_7229] = 38
                                                    mem[_7229 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                    mem[32] = 0
                                                    if _6955 > balanceOf[address(msg.sender)]:
                                                        _7285 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 38
                                                        idx = 0
                                                        while idx < 38:
                                                            mem[idx + _7285 + 68] = mem[_7229 + idx + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_7285 + 106] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _7285 + -mem[64] + 132
                                                    if balanceOf[address(msg.sender)] < _6955:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] -= _6955
                                                    if balanceOf[this.address] > !_6955:
                                                        revert with 0, 17
                                                    if balanceOf[this.address] + _6955 < balanceOf[this.address]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(this.address)] = balanceOf[this.address] + _6955
                                                    emit Transfer(_6955, msg.sender, this.address);
                                                    if arg1 >= 3:
                                                        revert with 0, 50
                                                    mem[mem[64]] = 0x12b8603f00000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = msg.sender
                                                    mem[mem[64] + 36] = 64
                                                    mem[mem[64] + 68] = mem[128]
                                                    idx = 0
                                                    while idx < mem[128]:
                                                        mem[idx + mem[64] + 100] = mem[idx + 160]
                                                        idx = idx + 32
                                                        continue 
                                                    if ceil32(mem[128]) > mem[128]:
                                                        mem[mem[64] + mem[128] + 100] = 0
                                                    require ext_code.size(sub_20eea8b5[arg1])
                                                    call sub_20eea8b5[arg1].createNode(address arg1, string arg2) with:
                                                         gas gas_remaining wei
                                                        args msg.sender, Array(len=mem[128], data=mem[mem[64] + 100 len ceil32(mem[128])])
                                                else:
                                                    mem[0] = msg.sender
                                                    mem[32] = 26
                                                    if stor26[address(msg.sender)]:
                                                        if not msg.sender:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not this.address:
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        _7257 = mem[64]
                                                        mem[64] = mem[64] + 96
                                                        mem[_7257] = 38
                                                        mem[_7257 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                        mem[32] = 0
                                                        if _6955 > balanceOf[address(msg.sender)]:
                                                            _7310 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 38
                                                            idx = 0
                                                            while idx < 38:
                                                                mem[idx + _7310 + 68] = mem[_7257 + idx + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_7310 + 106] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _7310 + -mem[64] + 132
                                                        if balanceOf[address(msg.sender)] < _6955:
                                                            revert with 0, 17
                                                        balanceOf[address(msg.sender)] -= _6955
                                                        if balanceOf[this.address] > !_6955:
                                                            revert with 0, 17
                                                        if balanceOf[this.address] + _6955 < balanceOf[this.address]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        balanceOf[address(this.address)] = balanceOf[this.address] + _6955
                                                        emit Transfer(_6955, msg.sender, this.address);
                                                        if arg1 >= 3:
                                                            revert with 0, 50
                                                        _7550 = mem[64]
                                                        mem[mem[64]] = 0x12b8603f00000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = msg.sender
                                                        mem[mem[64] + 36] = 64
                                                        _7574 = mem[128]
                                                        mem[mem[64] + 68] = mem[128]
                                                        idx = 0
                                                        while idx < _7574:
                                                            mem[idx + mem[64] + 100] = mem[idx + 160]
                                                            idx = idx + 32
                                                            continue 
                                                        if ceil32(_7574) > _7574:
                                                            mem[_7550 + _7574 + 100] = 0
                                                        require ext_code.size(sub_20eea8b5[arg1])
                                                        call sub_20eea8b5[arg1].mem[mem[64] len 4] with:
                                                             gas gas_remaining wei
                                                            args mem[mem[64] + 4 len ceil32(_7574) + _7550 + -mem[64] + 96]
                                                    else:
                                                        uint8(stor23.field_0) = 1
                                                        if not balanceOf[this.address]:
                                                            _7312 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_7312] = 26
                                                            mem[_7312 + 32] = 'SafeMath: division by zero'
                                                            _7543 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_7543] = 26
                                                            mem[_7543 + 32] = 'SafeMath: division by zero'
                                                            _7635 = mem[64]
                                                            mem[mem[64]] = 2
                                                            mem[64] = mem[64] + 96
                                                            mem[_7635 + 32 len 64] = call.data[calldata.size len 64]
                                                            if 0 >= mem[_7635]:
                                                                revert with 0, 50
                                                            mem[_7635 + 32] = this.address
                                                            require ext_code.size(uniswapV2RouterAddress)
                                                            staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                    gas gas_remaining wei
                                                            mem[_7635 + 96] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[64] = _7635 + ceil32(return_data.size) + 96
                                                            require return_data.size >= 32
                                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                            if 1 >= mem[_7635]:
                                                                revert with 0, 50
                                                            mem[_7635 + 64] = ext_call.return_data[12 len 20]
                                                            if not this.address:
                                                                revert with 0, 'ERC20: approve from the zero address'
                                                            if not uniswapV2RouterAddress:
                                                                revert with 0, 'ERC20: approve to the zero address'
                                                            mem[0] = uniswapV2RouterAddress
                                                            mem[32] = sha3(address(this.address), 1)
                                                            allowance[address(this.address)][stor9].field_0 = 0
                                                            emit Approval(0, this.address, uniswapV2RouterAddress);
                                                            mem[_7635 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                            mem[_7635 + ceil32(return_data.size) + 100] = 0
                                                            mem[_7635 + ceil32(return_data.size) + 132] = 0
                                                            mem[_7635 + ceil32(return_data.size) + 164] = 160
                                                            mem[_7635 + ceil32(return_data.size) + 260] = mem[_7635]
                                                            idx = 0
                                                            s = _7635 + ceil32(return_data.size) + 292
                                                            t = _7635 + 32
                                                            while idx < mem[_7635]:
                                                                mem[s] = mem[t + 12 len 20]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[_7635 + ceil32(return_data.size) + 196] = this.address
                                                            mem[_7635 + ceil32(return_data.size) + 228] = block.timestamp
                                                            require ext_code.size(uniswapV2RouterAddress)
                                                            call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                 gas gas_remaining wei
                                                                args mem[mem[64] + 4 len _7635 + ceil32(return_data.size) + (32 * mem[_7635]) + -mem[64] + 288]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _8787 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_8787] = 30
                                                            mem[_8787 + 32] = 'SafeMath: subtraction overflow'
                                                            if eth.balance(this.address) > eth.balance(this.address):
                                                                _8829 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 30
                                                                idx = 0
                                                                while idx < 30:
                                                                    mem[idx + _8829 + 68] = mem[_8787 + idx + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_8829 + 98] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _8829 + -mem[64] + 100
                                                            if eth.balance(this.address) < eth.balance(this.address):
                                                                revert with 0, 17
                                                            call distributionPoolAddress with:
                                                                 gas 2300 wei
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _9062 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_9062] = 30
                                                            mem[_9062 + 32] = 'SafeMath: subtraction overflow'
                                                            if not this.address:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not distributionPoolAddress:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            _9325 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_9325] = 38
                                                            mem[_9325 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                            mem[32] = 0
                                                            if 0 > balanceOf[address(this.address)]:
                                                                _9371 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 38
                                                                idx = 0
                                                                while idx < 38:
                                                                    mem[idx + _9371 + 68] = mem[_9325 + idx + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_9371 + 106] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _9371 + -mem[64] + 132
                                                            if balanceOf[address(this.address)] < 0:
                                                                revert with 0, 17
                                                            if balanceOf[stor12] > -1:
                                                                revert with 0, 17
                                                            if balanceOf[stor12] < balanceOf[stor12]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = distributionPoolAddress
                                                            mem[32] = 0
                                                            balanceOf[stor12] = balanceOf[stor12]
                                                            emit Transfer(0, this.address, distributionPoolAddress);
                                                            if not balanceOf[this.address]:
                                                                _9714 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_9714] = 26
                                                                mem[_9714 + 32] = 'SafeMath: division by zero'
                                                                _9858 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_9858] = 26
                                                                mem[_9858 + 32] = 'SafeMath: division by zero'
                                                                _9876 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_9876] = 30
                                                                mem[_9876 + 32] = 'SafeMath: subtraction overflow'
                                                                _9911 = mem[64]
                                                                mem[mem[64]] = 2
                                                                mem[64] = mem[64] + 96
                                                                mem[_9911 + 32 len 64] = call.data[calldata.size len 64]
                                                                if 0 >= mem[_9911]:
                                                                    revert with 0, 50
                                                                mem[_9911 + 32] = this.address
                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                        gas gas_remaining wei
                                                                mem[_9911 + 96] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[64] = _9911 + ceil32(return_data.size) + 96
                                                                require return_data.size >= 32
                                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                if 1 >= mem[_9911]:
                                                                    revert with 0, 50
                                                                mem[_9911 + 64] = ext_call.return_data[12 len 20]
                                                                if not this.address:
                                                                    revert with 0, 'ERC20: approve from the zero address'
                                                                if not uniswapV2RouterAddress:
                                                                    revert with 0, 'ERC20: approve to the zero address'
                                                                mem[0] = uniswapV2RouterAddress
                                                                mem[32] = sha3(address(this.address), 1)
                                                                allowance[address(this.address)][stor9].field_0 = 0
                                                                emit Approval(0, this.address, uniswapV2RouterAddress);
                                                                mem[_9911 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                mem[_9911 + ceil32(return_data.size) + 100] = 0
                                                                mem[_9911 + ceil32(return_data.size) + 132] = 0
                                                                mem[_9911 + ceil32(return_data.size) + 164] = 160
                                                                mem[_9911 + ceil32(return_data.size) + 260] = mem[_9911]
                                                                idx = 0
                                                                s = _9911 + ceil32(return_data.size) + 292
                                                                t = _9911 + 32
                                                                while idx < mem[_9911]:
                                                                    mem[s] = mem[t + 12 len 20]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[_9911 + ceil32(return_data.size) + 228] = block.timestamp
                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args 0, 0, 160, address(this.address), block.timestamp, mem[_9911 + ceil32(return_data.size) + 260 len (32 * mem[_9911]) + 32]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[_9911 + ceil32(return_data.size) + 96] = 30
                                                                mem[_9911 + ceil32(return_data.size) + 128] = 'SafeMath: subtraction overflow'
                                                                if eth.balance(this.address) > eth.balance(this.address):
                                                                    mem[_9911 + ceil32(return_data.size) + 160] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[_9911 + ceil32(return_data.size) + 164] = 32
                                                                    idx = 0
                                                                    while idx < 30:
                                                                        mem[idx + _9911 + ceil32(return_data.size) + 228] = mem[_9911 + ceil32(return_data.size) + idx + 128]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    revert with 0, 32, 30, mem[_9911 + ceil32(return_data.size) + 228 len 30], 0
                                                                if eth.balance(this.address) < eth.balance(this.address):
                                                                    revert with 0, 17
                                                                if not this.address:
                                                                    revert with 0, 'ERC20: approve from the zero address'
                                                                if not uniswapV2RouterAddress:
                                                                    revert with 0, 'ERC20: approve to the zero address'
                                                                allowance[address(this.address)][stor9].field_0 = 0
                                                                emit Approval(0, this.address, uniswapV2RouterAddress);
                                                                mem[_9911 + ceil32(return_data.size) + 228] = 0
                                                                mem[_9911 + ceil32(return_data.size) + 260] = 0
                                                                mem[_9911 + ceil32(return_data.size) + 292] = 0
                                                                mem[_9911 + ceil32(return_data.size) + 324] = block.timestamp
                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                                     gas gas_remaining wei
                                                                    args this.address, 0, 0, 0, 0, block.timestamp
                                                                mem[_9911 + ceil32(return_data.size) + 160 len 96] = ext_call.return_data[0 len 96]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                require return_data.size >= 96
                                                                emit SwapAndLiquify(uint256 arg1, uint256 arg2, uint256 arg3):
                                                                                    0,
                                                                mem[_9911 + (2 * ceil32(return_data.size)) + 160] = 2
                                                                mem[_9911 + (2 * ceil32(return_data.size)) + 192] = this.address
                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                        gas gas_remaining wei
                                                                mem[_9911 + (2 * ceil32(return_data.size)) + 256] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[64] = _9911 + (4 * ceil32(return_data.size)) + 256
                                                                require return_data.size >= 32
                                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                mem[_9911 + (2 * ceil32(return_data.size)) + 224] = ext_call.return_data[12 len 20]
                                                                if not this.address:
                                                                    revert with 0, 'ERC20: approve from the zero address'
                                                                if not uniswapV2RouterAddress:
                                                                    revert with 0, 'ERC20: approve to the zero address'
                                                                mem[0] = uniswapV2RouterAddress
                                                                mem[32] = sha3(address(this.address), 1)
                                                                allowance[address(this.address)][stor9].field_0 = balanceOf[this.address]
                                                                emit Approval(balanceOf[this.address], this.address, uniswapV2RouterAddress);
                                                                mem[_9911 + (4 * ceil32(return_data.size)) + 256] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                mem[_9911 + (4 * ceil32(return_data.size)) + 260] = balanceOf[this.address]
                                                                mem[_9911 + (4 * ceil32(return_data.size)) + 292] = 0
                                                                mem[_9911 + (4 * ceil32(return_data.size)) + 324] = 160
                                                                mem[_9911 + (4 * ceil32(return_data.size)) + 420] = 2
                                                                idx = 0
                                                                s = _9911 + (4 * ceil32(return_data.size)) + 452
                                                                t = _9911 + (2 * ceil32(return_data.size)) + 192
                                                                while idx < mem[_9911 + (2 * ceil32(return_data.size)) + 160]:
                                                                    mem[s] = mem[t + 12 len 20]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[_9911 + (4 * ceil32(return_data.size)) + 356] = this.address
                                                                mem[_9911 + (4 * ceil32(return_data.size)) + 388] = block.timestamp
                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                     gas gas_remaining wei
                                                                    args mem[mem[64] + 4 len _9911 + (4 * ceil32(return_data.size)) + (32 * mem[_9911 + (2 * ceil32(return_data.size)) + 160]) + -mem[64] + 448]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _13701 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_13701] = 30
                                                                mem[_13701 + 32] = 'SafeMath: subtraction overflow'
                                                                if eth.balance(this.address) > eth.balance(this.address):
                                                                    _13719 = mem[64]
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 30
                                                                    idx = 0
                                                                    while idx < 30:
                                                                        mem[idx + _13719 + 68] = mem[_13701 + idx + 32]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    mem[_13719 + 98] = 0
                                                                    revert with memory
                                                                      from mem[64]
                                                                       len _13719 + -mem[64] + 100
                                                                if eth.balance(this.address) < eth.balance(this.address):
                                                                    revert with 0, 17
                                                                call marketingWalletAddress with:
                                                                     gas 2300 wei
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                uint8(stor23.field_0) = 0
                                                                if not msg.sender:
                                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                                if not this.address:
                                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                                _13879 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_13879] = 38
                                                                mem[_13879 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                                mem[32] = 0
                                                                if _6955 > balanceOf[address(msg.sender)]:
                                                                    _13934 = mem[64]
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 38
                                                                    idx = 0
                                                                    while idx < 38:
                                                                        mem[idx + _13934 + 68] = mem[_13879 + idx + 32]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    mem[_13934 + 106] = 0
                                                                    revert with memory
                                                                      from mem[64]
                                                                       len _13934 + -mem[64] + 132
                                                                if balanceOf[address(msg.sender)] < _6955:
                                                                    revert with 0, 17
                                                                balanceOf[address(msg.sender)] -= _6955
                                                                if balanceOf[this.address] > !_6955:
                                                                    revert with 0, 17
                                                                if balanceOf[this.address] + _6955 < balanceOf[this.address]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                balanceOf[address(this.address)] = balanceOf[this.address] + _6955
                                                                emit Transfer(_6955, msg.sender, this.address);
                                                                if arg1 >= 3:
                                                                    revert with 0, 50
                                                                mem[mem[64]] = 0x12b8603f00000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = msg.sender
                                                                mem[mem[64] + 36] = 64
                                                                mem[mem[64] + 68] = mem[128]
                                                                idx = 0
                                                                while idx < mem[128]:
                                                                    mem[idx + mem[64] + 100] = mem[idx + 160]
                                                                    idx = idx + 32
                                                                    continue 
                                                                if ceil32(mem[128]) > mem[128]:
                                                                    mem[mem[64] + mem[128] + 100] = 0
                                                                require ext_code.size(sub_20eea8b5[arg1])
                                                                call sub_20eea8b5[arg1].createNode(address arg1, string arg2) with:
                                                                     gas gas_remaining wei
                                                                    args msg.sender, Array(len=mem[128], data=mem[mem[64] + 100 len ceil32(mem[128])])
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                if stor27[address(msg.sender)] > -2:
                                                                    revert with 0, 17
                                                                if stor27[address(msg.sender)] + 1 < stor27[address(msg.sender)]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                stor27[address(msg.sender)]++
                                                            if balanceOf[this.address] and liquidityPoolFee > -1 / balanceOf[this.address]:
                                                                revert with 0, 17
                                                            if not balanceOf[this.address]:
                                                                revert with 0, 18
                                                            if balanceOf[this.address] * liquidityPoolFee / balanceOf[this.address] != liquidityPoolFee:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            _9849 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_9849] = 26
                                                            mem[_9849 + 32] = 'SafeMath: division by zero'
                                                            _9867 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_9867] = 26
                                                            mem[_9867 + 32] = 'SafeMath: division by zero'
                                                            _9885 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_9885] = 30
                                                            mem[_9885 + 32] = 'SafeMath: subtraction overflow'
                                                            if balanceOf[this.address] * liquidityPoolFee / 100 / 2 > balanceOf[this.address] * liquidityPoolFee / 100:
                                                                _9910 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 30
                                                                idx = 0
                                                                while idx < 30:
                                                                    mem[idx + _9910 + 68] = mem[_9885 + idx + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_9910 + 98] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _9910 + -mem[64] + 100
                                                            if balanceOf[this.address] * liquidityPoolFee / 100 < balanceOf[this.address] * liquidityPoolFee / 100 / 2:
                                                                revert with 0, 17
                                                            _9983 = mem[64]
                                                            mem[mem[64]] = 2
                                                            mem[64] = mem[64] + 96
                                                            mem[_9983 + 32 len 64] = call.data[calldata.size len 64]
                                                            if 0 >= mem[_9983]:
                                                                revert with 0, 50
                                                            mem[_9983 + 32] = this.address
                                                            require ext_code.size(uniswapV2RouterAddress)
                                                            staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                    gas gas_remaining wei
                                                            mem[_9983 + 96] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[64] = _9983 + ceil32(return_data.size) + 96
                                                            require return_data.size >= 32
                                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                            if 1 >= mem[_9983]:
                                                                revert with 0, 50
                                                            mem[_9983 + 64] = ext_call.return_data[12 len 20]
                                                            if not this.address:
                                                                revert with 0, 'ERC20: approve from the zero address'
                                                            if not uniswapV2RouterAddress:
                                                                revert with 0, 'ERC20: approve to the zero address'
                                                            mem[0] = uniswapV2RouterAddress
                                                            mem[32] = sha3(address(this.address), 1)
                                                            allowance[address(this.address)][stor9].field_0 = balanceOf[this.address] * liquidityPoolFee / 100 / 2
                                                            allowance[address(this.address)][stor9].field_255 = 0
                                                            emit Approval((balanceOf[this.address] * liquidityPoolFee / 100 / 2), this.address, uniswapV2RouterAddress);
                                                            mem[_9983 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                            mem[_9983 + ceil32(return_data.size) + 100] = balanceOf[this.address] * liquidityPoolFee / 100 / 2
                                                            mem[_9983 + ceil32(return_data.size) + 132] = 0
                                                            mem[_9983 + ceil32(return_data.size) + 164] = 160
                                                            mem[_9983 + ceil32(return_data.size) + 260] = mem[_9983]
                                                            idx = 0
                                                            s = _9983 + ceil32(return_data.size) + 292
                                                            t = _9983 + 32
                                                            while idx < mem[_9983]:
                                                                mem[s] = mem[t + 12 len 20]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[_9983 + ceil32(return_data.size) + 228] = block.timestamp
                                                            require ext_code.size(uniswapV2RouterAddress)
                                                            call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args Mask(255, 1, balanceOf[this.address] * liquidityPoolFee / 100), 0, 160, address(this.address), block.timestamp, mem[_9983 + ceil32(return_data.size) + 260 len (32 * mem[_9983]) + 32]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[_9983 + ceil32(return_data.size) + 96] = 30
                                                            mem[_9983 + ceil32(return_data.size) + 128] = 'SafeMath: subtraction overflow'
                                                            if eth.balance(this.address) > eth.balance(this.address):
                                                                mem[_9983 + ceil32(return_data.size) + 160] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_9983 + ceil32(return_data.size) + 164] = 32
                                                                idx = 0
                                                                while idx < 30:
                                                                    mem[idx + _9983 + ceil32(return_data.size) + 228] = mem[_9983 + ceil32(return_data.size) + idx + 128]
                                                                    idx = idx + 32
                                                                    continue 
                                                                revert with 0, 32, 30, mem[_9983 + ceil32(return_data.size) + 228 len 30], 0
                                                            if eth.balance(this.address) < eth.balance(this.address):
                                                                revert with 0, 17
                                                            if not this.address:
                                                                revert with 0, 'ERC20: approve from the zero address'
                                                            if not uniswapV2RouterAddress:
                                                                revert with 0, 'ERC20: approve to the zero address'
                                                            allowance[address(this.address)][stor9].field_0 = (balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2)
                                                            emit Approval(((balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2)), this.address, uniswapV2RouterAddress);
                                                            mem[_9983 + ceil32(return_data.size) + 228] = 0
                                                            mem[_9983 + ceil32(return_data.size) + 260] = 0
                                                            mem[_9983 + ceil32(return_data.size) + 292] = 0
                                                            mem[_9983 + ceil32(return_data.size) + 324] = block.timestamp
                                                            require ext_code.size(uniswapV2RouterAddress)
                                                            call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                                 gas gas_remaining wei
                                                                args this.address, (balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2), 0, 0, 0, block.timestamp
                                                            mem[_9983 + ceil32(return_data.size) + 160 len 96] = ext_call.return_data[0 len 96]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 96
                                                            emit SwapAndLiquify(Mask(255, 1, balanceOf[this.address] * liquidityPoolFee / 100), 0, (balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2));
                                                            mem[_9983 + (2 * ceil32(return_data.size)) + 160] = 2
                                                            mem[_9983 + (2 * ceil32(return_data.size)) + 192] = this.address
                                                            require ext_code.size(uniswapV2RouterAddress)
                                                            staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                    gas gas_remaining wei
                                                            mem[_9983 + (2 * ceil32(return_data.size)) + 256] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                            mem[_9983 + (2 * ceil32(return_data.size)) + 224] = ext_call.return_data[12 len 20]
                                                            if not this.address:
                                                                revert with 0, 'ERC20: approve from the zero address'
                                                            if not uniswapV2RouterAddress:
                                                                revert with 0, 'ERC20: approve to the zero address'
                                                            allowance[address(this.address)][stor9].field_0 = balanceOf[this.address]
                                                            emit Approval(balanceOf[this.address], this.address, uniswapV2RouterAddress);
                                                            mem[_9983 + (4 * ceil32(return_data.size)) + 256] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                            mem[_9983 + (4 * ceil32(return_data.size)) + 260] = balanceOf[this.address]
                                                            mem[_9983 + (4 * ceil32(return_data.size)) + 292] = 0
                                                            mem[_9983 + (4 * ceil32(return_data.size)) + 324] = 160
                                                            mem[_9983 + (4 * ceil32(return_data.size)) + 420] = 2
                                                            idx = 0
                                                            s = _9983 + (4 * ceil32(return_data.size)) + 452
                                                            t = _9983 + (2 * ceil32(return_data.size)) + 192
                                                            while idx < mem[_9983 + (2 * ceil32(return_data.size)) + 160]:
                                                                mem[s] = mem[t + 12 len 20]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[_9983 + (4 * ceil32(return_data.size)) + 356] = this.address
                                                            mem[_9983 + (4 * ceil32(return_data.size)) + 388] = block.timestamp
                                                            require ext_code.size(uniswapV2RouterAddress)
                                                            call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args balanceOf[this.address], 0, 160, address(this.address), block.timestamp, mem[_9983 + (4 * ceil32(return_data.size)) + 420 len (32 * mem[_9983 + (2 * ceil32(return_data.size)) + 160]) + 32]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[_9983 + (4 * ceil32(return_data.size)) + 256] = 30
                                                            mem[_9983 + (4 * ceil32(return_data.size)) + 288] = 'SafeMath: subtraction overflow'
                                                            if eth.balance(this.address) > eth.balance(this.address):
                                                                mem[_9983 + (4 * ceil32(return_data.size)) + 320] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_9983 + (4 * ceil32(return_data.size)) + 324] = 32
                                                                idx = 0
                                                                while idx < 30:
                                                                    mem[idx + _9983 + (4 * ceil32(return_data.size)) + 388] = mem[_9983 + (4 * ceil32(return_data.size)) + idx + 288]
                                                                    idx = idx + 32
                                                                    continue 
                                                                revert with 0, 32, 30, mem[_9983 + (4 * ceil32(return_data.size)) + 388 len 30], 0
                                                            if eth.balance(this.address) < eth.balance(this.address):
                                                                revert with 0, 17
                                                            call marketingWalletAddress with:
                                                                 gas 2300 wei
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            uint8(stor23.field_0) = 0
                                                            if not msg.sender:
                                                                mem[_9983 + (4 * ceil32(return_data.size)) + 320] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_9983 + (4 * ceil32(return_data.size)) + 324] = 32
                                                                mem[_9983 + (4 * ceil32(return_data.size)) + 356] = 37
                                                                mem[_9983 + (4 * ceil32(return_data.size)) + 388] = 'ERC20: transfer from the zero ad'
                                                                mem[_9983 + (4 * ceil32(return_data.size)) + 420] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                                revert with memory
                                                                  from _9983 + (4 * ceil32(return_data.size)) + 320
                                                                   len (5 * ceil32(return_data.size)) + 132
                                                            if not this.address:
                                                                mem[_9983 + (4 * ceil32(return_data.size)) + 320] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_9983 + (4 * ceil32(return_data.size)) + 324] = 32
                                                                mem[_9983 + (4 * ceil32(return_data.size)) + 356] = 35
                                                                mem[_9983 + (4 * ceil32(return_data.size)) + 388] = 'ERC20: transfer to the zero addr'
                                                                mem[_9983 + (4 * ceil32(return_data.size)) + 420] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                                revert with memory
                                                                  from _9983 + (4 * ceil32(return_data.size)) + 320
                                                                   len (5 * ceil32(return_data.size)) + 132
                                                            mem[_9983 + (4 * ceil32(return_data.size)) + 320] = 38
                                                            mem[_9983 + (4 * ceil32(return_data.size)) + 352 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                            if _6955 > balanceOf[address(msg.sender)]:
                                                                mem[_9983 + (4 * ceil32(return_data.size)) + 416] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_9983 + (4 * ceil32(return_data.size)) + 420] = 32
                                                                idx = 0
                                                                while idx < 38:
                                                                    mem[idx + _9983 + (4 * ceil32(return_data.size)) + 484] = mem[_9983 + (4 * ceil32(return_data.size)) + idx + 352]
                                                                    idx = idx + 32
                                                                    continue 
                                                                revert with 0, 32, 38, mem[_9983 + (4 * ceil32(return_data.size)) + 484 len 38], 0
                                                            if balanceOf[address(msg.sender)] < _6955:
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] -= _6955
                                                            if balanceOf[this.address] > !_6955:
                                                                revert with 0, 17
                                                            if balanceOf[this.address] + _6955 >= balanceOf[this.address]:
                                                                balanceOf[address(this.address)] = balanceOf[this.address] + _6955
                                                                emit Transfer(_6955, msg.sender, this.address);
                                                                if arg1 >= 3:
                                                                    revert with 0, 50
                                                                mem[_9983 + (4 * ceil32(return_data.size)) + 416] = 0x12b8603f00000000000000000000000000000000000000000000000000000000
                                                                mem[_9983 + (4 * ceil32(return_data.size)) + 420] = msg.sender
                                                                mem[_9983 + (4 * ceil32(return_data.size)) + 452] = 64
                                                                mem[_9983 + (4 * ceil32(return_data.size)) + 484] = mem[128]
                                                                idx = 0
                                                                while idx < mem[128]:
                                                                    mem[idx + _9983 + (4 * ceil32(return_data.size)) + 516] = mem[idx + 160]
                                                                    idx = idx + 32
                                                                    continue 
                                                                if ceil32(mem[128]) > mem[128]:
                                                                    mem[_9983 + (4 * ceil32(return_data.size)) + mem[128] + 516] = 0
                                                                require ext_code.size(sub_20eea8b5[arg1])
                                                                call sub_20eea8b5[arg1].createNode(address arg1, string arg2) with:
                                                                     gas gas_remaining wei
                                                                    args mem[_9983 + (4 * ceil32(return_data.size)) + 420 len ceil32(mem[128]) + (5 * ceil32(return_data.size)) + 96]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                if stor27[address(msg.sender)] > -2:
                                                                    revert with 0, 17
                                                                if stor27[address(msg.sender)] + 1 >= stor27[address(msg.sender)]:
                                                                    stor27[address(msg.sender)]++
                                                            mem[_9983 + (4 * ceil32(return_data.size)) + 416] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_9983 + (4 * ceil32(return_data.size)) + 420] = 32
                                                            mem[_9983 + (4 * ceil32(return_data.size)) + 452] = 27
                                                            mem[_9983 + (4 * ceil32(return_data.size)) + 484] = 'SafeMath: addition overflow'
                                                            revert with memory
                                                              from _9983 + (4 * ceil32(return_data.size)) + 416
                                                               len (5 * ceil32(return_data.size)) + 100
                                                        if balanceOf[this.address] and rewardsFee > -1 / balanceOf[this.address]:
                                                            revert with 0, 17
                                                        if not balanceOf[this.address]:
                                                            revert with 0, 18
                                                        if balanceOf[this.address] * rewardsFee / balanceOf[this.address] != rewardsFee:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _7447 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_7447] = 26
                                                        mem[_7447 + 32] = 'SafeMath: division by zero'
                                                        if not balanceOf[this.address] * rewardsFee / 100:
                                                            _7593 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_7593] = 26
                                                            mem[_7593 + 32] = 'SafeMath: division by zero'
                                                            _7698 = mem[64]
                                                            mem[mem[64]] = 2
                                                            mem[64] = mem[64] + 96
                                                            mem[_7698 + 32 len 64] = call.data[calldata.size len 64]
                                                            if 0 >= mem[_7698]:
                                                                revert with 0, 50
                                                            mem[_7698 + 32] = this.address
                                                            require ext_code.size(uniswapV2RouterAddress)
                                                            staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                    gas gas_remaining wei
                                                            mem[_7698 + 96] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[64] = _7698 + ceil32(return_data.size) + 96
                                                            require return_data.size >= 32
                                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                            if 1 >= mem[_7698]:
                                                                revert with 0, 50
                                                            mem[_7698 + 64] = ext_call.return_data[12 len 20]
                                                            if not this.address:
                                                                revert with 0, 'ERC20: approve from the zero address'
                                                            if not uniswapV2RouterAddress:
                                                                revert with 0, 'ERC20: approve to the zero address'
                                                            mem[0] = uniswapV2RouterAddress
                                                            mem[32] = sha3(address(this.address), 1)
                                                            allowance[address(this.address)][stor9].field_0 = 0
                                                            emit Approval(0, this.address, uniswapV2RouterAddress);
                                                            mem[_7698 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                            mem[_7698 + ceil32(return_data.size) + 100] = 0
                                                            mem[_7698 + ceil32(return_data.size) + 132] = 0
                                                            mem[_7698 + ceil32(return_data.size) + 164] = 160
                                                            mem[_7698 + ceil32(return_data.size) + 260] = mem[_7698]
                                                            idx = 0
                                                            s = _7698 + ceil32(return_data.size) + 292
                                                            t = _7698 + 32
                                                            while idx < mem[_7698]:
                                                                mem[s] = mem[t + 12 len 20]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[_7698 + ceil32(return_data.size) + 228] = block.timestamp
                                                            require ext_code.size(uniswapV2RouterAddress)
                                                            call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args 0, 0, 160, address(this.address), block.timestamp, mem[_7698 + ceil32(return_data.size) + 260 len (32 * mem[_7698]) + 32]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[_7698 + ceil32(return_data.size) + 96] = 30
                                                            mem[_7698 + ceil32(return_data.size) + 128] = 'SafeMath: subtraction overflow'
                                                            if eth.balance(this.address) > eth.balance(this.address):
                                                                mem[_7698 + ceil32(return_data.size) + 160] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_7698 + ceil32(return_data.size) + 164] = 32
                                                                idx = 0
                                                                while idx < 30:
                                                                    mem[idx + _7698 + ceil32(return_data.size) + 228] = mem[_7698 + ceil32(return_data.size) + idx + 128]
                                                                    idx = idx + 32
                                                                    continue 
                                                                revert with 0, 32, 30, mem[_7698 + ceil32(return_data.size) + 228 len 30], 0
                                                            if eth.balance(this.address) < eth.balance(this.address):
                                                                revert with 0, 17
                                                            call distributionPoolAddress with:
                                                                 gas 2300 wei
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[_7698 + ceil32(return_data.size) + 160] = 30
                                                            mem[_7698 + ceil32(return_data.size) + 192] = 'SafeMath: subtraction overflow'
                                                            if 0 > balanceOf[this.address] * rewardsFee / 100:
                                                                mem[_7698 + ceil32(return_data.size) + 224] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_7698 + ceil32(return_data.size) + 228] = 32
                                                                idx = 0
                                                                while idx < 30:
                                                                    mem[idx + _7698 + ceil32(return_data.size) + 292] = mem[_7698 + ceil32(return_data.size) + idx + 192]
                                                                    idx = idx + 32
                                                                    continue 
                                                                revert with 0, 32, 30, mem[_7698 + ceil32(return_data.size) + 292 len 30], 0
                                                            if balanceOf[this.address] * rewardsFee / 100 < 0:
                                                                revert with 0, 17
                                                            if not this.address:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not distributionPoolAddress:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            mem[_7698 + ceil32(return_data.size) + 224] = 38
                                                            mem[_7698 + ceil32(return_data.size) + 256 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                            if balanceOf[this.address] * rewardsFee / 100 > balanceOf[address(this.address)]:
                                                                mem[_7698 + ceil32(return_data.size) + 320] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_7698 + ceil32(return_data.size) + 324] = 32
                                                                idx = 0
                                                                while idx < 38:
                                                                    mem[idx + _7698 + ceil32(return_data.size) + 388] = mem[_7698 + ceil32(return_data.size) + idx + 256]
                                                                    idx = idx + 32
                                                                    continue 
                                                                revert with 0, 32, 38, mem[_7698 + ceil32(return_data.size) + 388 len 38], 0
                                                            if balanceOf[address(this.address)] < balanceOf[this.address] * rewardsFee / 100:
                                                                revert with 0, 17
                                                            balanceOf[address(this.address)] -= balanceOf[this.address] * rewardsFee / 100
                                                            if balanceOf[stor12] > !(balanceOf[this.address] * rewardsFee / 100):
                                                                revert with 0, 17
                                                            if balanceOf[stor12] + (balanceOf[this.address] * rewardsFee / 100) < balanceOf[stor12]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            balanceOf[stor12] += balanceOf[this.address] * rewardsFee / 100
                                                            emit Transfer((balanceOf[this.address] * rewardsFee / 100), this.address, distributionPoolAddress);
                                                            if not balanceOf[this.address]:
                                                                mem[_7698 + ceil32(return_data.size) + 320] = 26
                                                                mem[_7698 + ceil32(return_data.size) + 352] = 'SafeMath: division by zero'
                                                                mem[_7698 + ceil32(return_data.size) + 384] = 26
                                                                mem[_7698 + ceil32(return_data.size) + 416] = 'SafeMath: division by zero'
                                                                mem[_7698 + ceil32(return_data.size) + 448] = 30
                                                                mem[_7698 + ceil32(return_data.size) + 480] = 'SafeMath: subtraction overflow'
                                                                mem[_7698 + ceil32(return_data.size) + 512] = 2
                                                                mem[_7698 + ceil32(return_data.size) + 544] = this.address
                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                        gas gas_remaining wei
                                                                mem[_7698 + ceil32(return_data.size) + 608] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[64] = _7698 + (2 * ceil32(return_data.size)) + 608
                                                                require return_data.size >= 32
                                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                mem[_7698 + ceil32(return_data.size) + 576] = ext_call.return_data[12 len 20]
                                                                if not this.address:
                                                                    revert with 0, 'ERC20: approve from the zero address'
                                                                if not uniswapV2RouterAddress:
                                                                    revert with 0, 'ERC20: approve to the zero address'
                                                                mem[0] = uniswapV2RouterAddress
                                                                mem[32] = sha3(address(this.address), 1)
                                                                allowance[address(this.address)][stor9].field_0 = 0
                                                                emit Approval(0, this.address, uniswapV2RouterAddress);
                                                                mem[_7698 + (2 * ceil32(return_data.size)) + 608] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                mem[_7698 + (2 * ceil32(return_data.size)) + 612] = 0
                                                                mem[_7698 + (2 * ceil32(return_data.size)) + 644] = 0
                                                                mem[_7698 + (2 * ceil32(return_data.size)) + 676] = 160
                                                                mem[_7698 + (2 * ceil32(return_data.size)) + 772] = 2
                                                                idx = 0
                                                                s = _7698 + (2 * ceil32(return_data.size)) + 804
                                                                t = _7698 + ceil32(return_data.size) + 544
                                                                while idx < mem[_7698 + ceil32(return_data.size) + 512]:
                                                                    mem[s] = mem[t + 12 len 20]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[_7698 + (2 * ceil32(return_data.size)) + 708] = this.address
                                                                mem[_7698 + (2 * ceil32(return_data.size)) + 740] = block.timestamp
                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                     gas gas_remaining wei
                                                                    args mem[mem[64] + 4 len _7698 + (2 * ceil32(return_data.size)) + (32 * mem[_7698 + ceil32(return_data.size) + 512]) + -mem[64] + 800]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _12043 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_12043] = 30
                                                                mem[_12043 + 32] = 'SafeMath: subtraction overflow'
                                                                if eth.balance(this.address) > eth.balance(this.address):
                                                                    _12079 = mem[64]
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 30
                                                                    idx = 0
                                                                    while idx < 30:
                                                                        mem[idx + _12079 + 68] = mem[_12043 + idx + 32]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    mem[_12079 + 98] = 0
                                                                    revert with memory
                                                                      from mem[64]
                                                                       len _12079 + -mem[64] + 100
                                                                if eth.balance(this.address) < eth.balance(this.address):
                                                                    revert with 0, 17
                                                                if not this.address:
                                                                    revert with 0, 'ERC20: approve from the zero address'
                                                                if not uniswapV2RouterAddress:
                                                                    revert with 0, 'ERC20: approve to the zero address'
                                                                mem[0] = uniswapV2RouterAddress
                                                                mem[32] = sha3(address(this.address), 1)
                                                                allowance[address(this.address)][stor9].field_0 = 0
                                                                emit Approval(0, this.address, uniswapV2RouterAddress);
                                                                mem[mem[64] + 68] = 0
                                                                mem[mem[64] + 100] = 0
                                                                mem[mem[64] + 132] = 0
                                                                mem[mem[64] + 164] = block.timestamp
                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                                     gas gas_remaining wei
                                                                    args this.address, 0, 0, 0, 0, block.timestamp
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 96
                                                                mem[mem[64] + 32] = 0
                                                                mem[mem[64] + 64] = 0
                                                                emit SwapAndLiquify(uint256 arg1, uint256 arg2, uint256 arg3):
                                                                                    0,
                                                                mem[0] = this.address
                                                                mem[32] = 0
                                                                _12598 = mem[64]
                                                                mem[mem[64]] = 2
                                                                mem[64] = mem[64] + 96
                                                                mem[_12598 + 32 len 64] = call.data[calldata.size len 64]
                                                                if 0 >= mem[_12598]:
                                                                    revert with 0, 50
                                                                mem[_12598 + 32] = this.address
                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                        gas gas_remaining wei
                                                                mem[_12598 + 96] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[64] = _12598 + ceil32(return_data.size) + 96
                                                                require return_data.size >= 32
                                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                if 1 >= mem[_12598]:
                                                                    revert with 0, 50
                                                                mem[_12598 + 64] = ext_call.return_data[12 len 20]
                                                                if not this.address:
                                                                    revert with 0, 'ERC20: approve from the zero address'
                                                                if not uniswapV2RouterAddress:
                                                                    revert with 0, 'ERC20: approve to the zero address'
                                                                mem[0] = uniswapV2RouterAddress
                                                                mem[32] = sha3(address(this.address), 1)
                                                                allowance[address(this.address)][stor9].field_0 = balanceOf[this.address]
                                                                emit Approval(balanceOf[this.address], this.address, uniswapV2RouterAddress);
                                                                mem[_12598 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                mem[_12598 + ceil32(return_data.size) + 100] = balanceOf[this.address]
                                                                mem[_12598 + ceil32(return_data.size) + 132] = 0
                                                                mem[_12598 + ceil32(return_data.size) + 164] = 160
                                                                mem[_12598 + ceil32(return_data.size) + 260] = mem[_12598]
                                                                idx = 0
                                                                s = _12598 + ceil32(return_data.size) + 292
                                                                t = _12598 + 32
                                                                while idx < mem[_12598]:
                                                                    mem[s] = mem[t + 12 len 20]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[_12598 + ceil32(return_data.size) + 196] = this.address
                                                                mem[_12598 + ceil32(return_data.size) + 228] = block.timestamp
                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                     gas gas_remaining wei
                                                                    args mem[mem[64] + 4 len _12598 + ceil32(return_data.size) + (32 * mem[_12598]) + -mem[64] + 288]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _13699 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_13699] = 30
                                                                mem[_13699 + 32] = 'SafeMath: subtraction overflow'
                                                                if eth.balance(this.address) > eth.balance(this.address):
                                                                    _13717 = mem[64]
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 30
                                                                    idx = 0
                                                                    while idx < 30:
                                                                        mem[idx + _13717 + 68] = mem[_13699 + idx + 32]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    mem[_13717 + 98] = 0
                                                                    revert with memory
                                                                      from mem[64]
                                                                       len _13717 + -mem[64] + 100
                                                                if eth.balance(this.address) < eth.balance(this.address):
                                                                    revert with 0, 17
                                                                call marketingWalletAddress with:
                                                                     gas 2300 wei
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                uint8(stor23.field_0) = 0
                                                                if not msg.sender:
                                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                                if not this.address:
                                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                                _13873 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_13873] = 38
                                                                mem[_13873 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                                mem[32] = 0
                                                                if _6955 > balanceOf[address(msg.sender)]:
                                                                    _13930 = mem[64]
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 38
                                                                    idx = 0
                                                                    while idx < 38:
                                                                        mem[idx + _13930 + 68] = mem[_13873 + idx + 32]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    mem[_13930 + 106] = 0
                                                                    revert with memory
                                                                      from mem[64]
                                                                       len _13930 + -mem[64] + 132
                                                            else:
                                                                if balanceOf[this.address] and liquidityPoolFee > -1 / balanceOf[this.address]:
                                                                    revert with 0, 17
                                                                if not balanceOf[this.address]:
                                                                    revert with 0, 18
                                                                if balanceOf[this.address] * liquidityPoolFee / balanceOf[this.address] != liquidityPoolFee:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                mem[_7698 + ceil32(return_data.size) + 320] = 26
                                                                mem[_7698 + ceil32(return_data.size) + 352] = 'SafeMath: division by zero'
                                                                mem[_7698 + ceil32(return_data.size) + 384] = 26
                                                                mem[_7698 + ceil32(return_data.size) + 416] = 'SafeMath: division by zero'
                                                                mem[_7698 + ceil32(return_data.size) + 448] = 30
                                                                mem[_7698 + ceil32(return_data.size) + 480] = 'SafeMath: subtraction overflow'
                                                                if balanceOf[this.address] * liquidityPoolFee / 100 / 2 > balanceOf[this.address] * liquidityPoolFee / 100:
                                                                    mem[_7698 + ceil32(return_data.size) + 512] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[_7698 + ceil32(return_data.size) + 516] = 32
                                                                    idx = 0
                                                                    while idx < 30:
                                                                        mem[idx + _7698 + ceil32(return_data.size) + 580] = mem[_7698 + ceil32(return_data.size) + idx + 480]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    revert with 0, 32, 30, mem[_7698 + ceil32(return_data.size) + 580 len 30], 0
                                                                if balanceOf[this.address] * liquidityPoolFee / 100 < balanceOf[this.address] * liquidityPoolFee / 100 / 2:
                                                                    revert with 0, 17
                                                                mem[_7698 + ceil32(return_data.size) + 512] = 2
                                                                mem[_7698 + ceil32(return_data.size) + 544] = this.address
                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                        gas gas_remaining wei
                                                                mem[_7698 + ceil32(return_data.size) + 608] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[64] = _7698 + (2 * ceil32(return_data.size)) + 608
                                                                require return_data.size >= 32
                                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                mem[_7698 + ceil32(return_data.size) + 576] = ext_call.return_data[12 len 20]
                                                                if not this.address:
                                                                    revert with 0, 'ERC20: approve from the zero address'
                                                                if not uniswapV2RouterAddress:
                                                                    revert with 0, 'ERC20: approve to the zero address'
                                                                mem[0] = uniswapV2RouterAddress
                                                                mem[32] = sha3(address(this.address), 1)
                                                                allowance[address(this.address)][stor9].field_0 = balanceOf[this.address] * liquidityPoolFee / 100 / 2
                                                                allowance[address(this.address)][stor9].field_255 = 0
                                                                emit Approval((balanceOf[this.address] * liquidityPoolFee / 100 / 2), this.address, uniswapV2RouterAddress);
                                                                mem[_7698 + (2 * ceil32(return_data.size)) + 608] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                mem[_7698 + (2 * ceil32(return_data.size)) + 612] = balanceOf[this.address] * liquidityPoolFee / 100 / 2
                                                                mem[_7698 + (2 * ceil32(return_data.size)) + 644] = 0
                                                                mem[_7698 + (2 * ceil32(return_data.size)) + 676] = 160
                                                                mem[_7698 + (2 * ceil32(return_data.size)) + 772] = 2
                                                                idx = 0
                                                                s = _7698 + (2 * ceil32(return_data.size)) + 804
                                                                t = _7698 + ceil32(return_data.size) + 544
                                                                while idx < mem[_7698 + ceil32(return_data.size) + 512]:
                                                                    mem[s] = mem[t + 12 len 20]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[_7698 + (2 * ceil32(return_data.size)) + 708] = this.address
                                                                mem[_7698 + (2 * ceil32(return_data.size)) + 740] = block.timestamp
                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                     gas gas_remaining wei
                                                                    args mem[mem[64] + 4 len _7698 + (2 * ceil32(return_data.size)) + (32 * mem[_7698 + ceil32(return_data.size) + 512]) + -mem[64] + 800]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _12042 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_12042] = 30
                                                                mem[_12042 + 32] = 'SafeMath: subtraction overflow'
                                                                if eth.balance(this.address) > eth.balance(this.address):
                                                                    _12078 = mem[64]
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 30
                                                                    idx = 0
                                                                    while idx < 30:
                                                                        mem[idx + _12078 + 68] = mem[_12042 + idx + 32]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    mem[_12078 + 98] = 0
                                                                    revert with memory
                                                                      from mem[64]
                                                                       len _12078 + -mem[64] + 100
                                                                if eth.balance(this.address) < eth.balance(this.address):
                                                                    revert with 0, 17
                                                                if not this.address:
                                                                    revert with 0, 'ERC20: approve from the zero address'
                                                                if not uniswapV2RouterAddress:
                                                                    revert with 0, 'ERC20: approve to the zero address'
                                                                mem[0] = uniswapV2RouterAddress
                                                                mem[32] = sha3(address(this.address), 1)
                                                                allowance[address(this.address)][stor9].field_0 = (balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2)
                                                                emit Approval(((balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2)), this.address, uniswapV2RouterAddress);
                                                                mem[mem[64] + 68] = 0
                                                                mem[mem[64] + 100] = 0
                                                                mem[mem[64] + 132] = 0
                                                                mem[mem[64] + 164] = block.timestamp
                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                                     gas gas_remaining wei
                                                                    args this.address, (balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2), 0, 0, 0, block.timestamp
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 96
                                                                mem[mem[64] + 32] = 0
                                                                mem[mem[64] + 64] = (balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2)
                                                                emit SwapAndLiquify(Mask(255, 1, balanceOf[this.address] * liquidityPoolFee / 100), 0, (balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2));
                                                                mem[0] = this.address
                                                                mem[32] = 0
                                                                _12596 = mem[64]
                                                                mem[mem[64]] = 2
                                                                mem[64] = mem[64] + 96
                                                                mem[_12596 + 32 len 64] = call.data[calldata.size len 64]
                                                                if 0 >= mem[_12596]:
                                                                    revert with 0, 50
                                                                mem[_12596 + 32] = this.address
                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                        gas gas_remaining wei
                                                                mem[_12596 + 96] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[64] = _12596 + ceil32(return_data.size) + 96
                                                                require return_data.size >= 32
                                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                if 1 >= mem[_12596]:
                                                                    revert with 0, 50
                                                                mem[_12596 + 64] = ext_call.return_data[12 len 20]
                                                                if not this.address:
                                                                    revert with 0, 'ERC20: approve from the zero address'
                                                                if not uniswapV2RouterAddress:
                                                                    revert with 0, 'ERC20: approve to the zero address'
                                                                mem[0] = uniswapV2RouterAddress
                                                                mem[32] = sha3(address(this.address), 1)
                                                                allowance[address(this.address)][stor9].field_0 = balanceOf[this.address]
                                                                emit Approval(balanceOf[this.address], this.address, uniswapV2RouterAddress);
                                                                mem[_12596 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                mem[_12596 + ceil32(return_data.size) + 100] = balanceOf[this.address]
                                                                mem[_12596 + ceil32(return_data.size) + 132] = 0
                                                                mem[_12596 + ceil32(return_data.size) + 164] = 160
                                                                mem[_12596 + ceil32(return_data.size) + 260] = mem[_12596]
                                                                idx = 0
                                                                s = _12596 + ceil32(return_data.size) + 292
                                                                t = _12596 + 32
                                                                while idx < mem[_12596]:
                                                                    mem[s] = mem[t + 12 len 20]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[_12596 + ceil32(return_data.size) + 196] = this.address
                                                                mem[_12596 + ceil32(return_data.size) + 228] = block.timestamp
                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                     gas gas_remaining wei
                                                                    args mem[mem[64] + 4 len _12596 + ceil32(return_data.size) + (32 * mem[_12596]) + -mem[64] + 288]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _13698 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_13698] = 30
                                                                mem[_13698 + 32] = 'SafeMath: subtraction overflow'
                                                                if eth.balance(this.address) > eth.balance(this.address):
                                                                    _13716 = mem[64]
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 30
                                                                    idx = 0
                                                                    while idx < 30:
                                                                        mem[idx + _13716 + 68] = mem[_13698 + idx + 32]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    mem[_13716 + 98] = 0
                                                                    revert with memory
                                                                      from mem[64]
                                                                       len _13716 + -mem[64] + 100
                                                                if eth.balance(this.address) < eth.balance(this.address):
                                                                    revert with 0, 17
                                                                call marketingWalletAddress with:
                                                                     gas 2300 wei
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                uint8(stor23.field_0) = 0
                                                                if not msg.sender:
                                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                                if not this.address:
                                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                                _13870 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_13870] = 38
                                                                mem[_13870 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                                mem[32] = 0
                                                                if _6955 > balanceOf[address(msg.sender)]:
                                                                    _13928 = mem[64]
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 38
                                                                    idx = 0
                                                                    while idx < 38:
                                                                        mem[idx + _13928 + 68] = mem[_13870 + idx + 32]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    mem[_13928 + 106] = 0
                                                                    revert with memory
                                                                      from mem[64]
                                                                       len _13928 + -mem[64] + 132
                                                        else:
                                                            if balanceOf[this.address] * rewardsFee / 100 and stor22 > -1 / balanceOf[this.address] * rewardsFee / 100:
                                                                revert with 0, 17
                                                            if not balanceOf[this.address] * rewardsFee / 100:
                                                                revert with 0, 18
                                                            if balanceOf[this.address] * rewardsFee / 100 * stor22 / balanceOf[this.address] * rewardsFee / 100 != stor22:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            _7659 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_7659] = 26
                                                            mem[_7659 + 32] = 'SafeMath: division by zero'
                                                            _7732 = mem[64]
                                                            mem[mem[64]] = 2
                                                            mem[64] = mem[64] + 96
                                                            mem[_7732 + 32 len 64] = call.data[calldata.size len 64]
                                                            if 0 >= mem[_7732]:
                                                                revert with 0, 50
                                                            mem[_7732 + 32] = this.address
                                                            require ext_code.size(uniswapV2RouterAddress)
                                                            staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                    gas gas_remaining wei
                                                            mem[_7732 + 96] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[64] = _7732 + ceil32(return_data.size) + 96
                                                            require return_data.size >= 32
                                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                            if 1 >= mem[_7732]:
                                                                revert with 0, 50
                                                            mem[_7732 + 64] = ext_call.return_data[12 len 20]
                                                            if not this.address:
                                                                revert with 0, 'ERC20: approve from the zero address'
                                                            if not uniswapV2RouterAddress:
                                                                revert with 0, 'ERC20: approve to the zero address'
                                                            mem[0] = uniswapV2RouterAddress
                                                            mem[32] = sha3(address(this.address), 1)
                                                            allowance[address(this.address)][stor9].field_0 = balanceOf[this.address] * rewardsFee / 100 * stor22 / 100
                                                            emit Approval((balanceOf[this.address] * rewardsFee / 100 * stor22 / 100), this.address, uniswapV2RouterAddress);
                                                            mem[_7732 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                            mem[_7732 + ceil32(return_data.size) + 100] = balanceOf[this.address] * rewardsFee / 100 * stor22 / 100
                                                            mem[_7732 + ceil32(return_data.size) + 132] = 0
                                                            mem[_7732 + ceil32(return_data.size) + 164] = 160
                                                            mem[_7732 + ceil32(return_data.size) + 260] = mem[_7732]
                                                            idx = 0
                                                            s = _7732 + ceil32(return_data.size) + 292
                                                            t = _7732 + 32
                                                            while idx < mem[_7732]:
                                                                mem[s] = mem[t + 12 len 20]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[_7732 + ceil32(return_data.size) + 228] = block.timestamp
                                                            require ext_code.size(uniswapV2RouterAddress)
                                                            call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args balanceOf[this.address] * rewardsFee / 100 * stor22 / 100, 0, 160, address(this.address), block.timestamp, mem[_7732 + ceil32(return_data.size) + 260 len (32 * mem[_7732]) + 32]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[_7732 + ceil32(return_data.size) + 96] = 30
                                                            mem[_7732 + ceil32(return_data.size) + 128] = 'SafeMath: subtraction overflow'
                                                            if eth.balance(this.address) > eth.balance(this.address):
                                                                mem[_7732 + ceil32(return_data.size) + 160] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_7732 + ceil32(return_data.size) + 164] = 32
                                                                idx = 0
                                                                while idx < 30:
                                                                    mem[idx + _7732 + ceil32(return_data.size) + 228] = mem[_7732 + ceil32(return_data.size) + idx + 128]
                                                                    idx = idx + 32
                                                                    continue 
                                                                revert with 0, 32, 30, mem[_7732 + ceil32(return_data.size) + 228 len 30], 0
                                                            if eth.balance(this.address) < eth.balance(this.address):
                                                                revert with 0, 17
                                                            call distributionPoolAddress with:
                                                                 gas 2300 wei
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[_7732 + ceil32(return_data.size) + 160] = 30
                                                            mem[_7732 + ceil32(return_data.size) + 192] = 'SafeMath: subtraction overflow'
                                                            if balanceOf[this.address] * rewardsFee / 100 * stor22 / 100 > balanceOf[this.address] * rewardsFee / 100:
                                                                mem[_7732 + ceil32(return_data.size) + 224] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_7732 + ceil32(return_data.size) + 228] = 32
                                                                idx = 0
                                                                while idx < 30:
                                                                    mem[idx + _7732 + ceil32(return_data.size) + 292] = mem[_7732 + ceil32(return_data.size) + idx + 192]
                                                                    idx = idx + 32
                                                                    continue 
                                                                revert with 0, 32, 30, mem[_7732 + ceil32(return_data.size) + 292 len 30], 0
                                                            if balanceOf[this.address] * rewardsFee / 100 < balanceOf[this.address] * rewardsFee / 100 * stor22 / 100:
                                                                revert with 0, 17
                                                            if not this.address:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not distributionPoolAddress:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            mem[_7732 + ceil32(return_data.size) + 224] = 38
                                                            mem[_7732 + ceil32(return_data.size) + 256 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                            if (balanceOf[this.address] * rewardsFee / 100) - (balanceOf[this.address] * rewardsFee / 100 * stor22 / 100) > balanceOf[address(this.address)]:
                                                                mem[_7732 + ceil32(return_data.size) + 320] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_7732 + ceil32(return_data.size) + 324] = 32
                                                                idx = 0
                                                                while idx < 38:
                                                                    mem[idx + _7732 + ceil32(return_data.size) + 388] = mem[_7732 + ceil32(return_data.size) + idx + 256]
                                                                    idx = idx + 32
                                                                    continue 
                                                                revert with 0, 32, 38, mem[_7732 + ceil32(return_data.size) + 388 len 38], 0
                                                            if balanceOf[address(this.address)] < (balanceOf[this.address] * rewardsFee / 100) - (balanceOf[this.address] * rewardsFee / 100 * stor22 / 100):
                                                                revert with 0, 17
                                                            balanceOf[address(this.address)] = balanceOf[address(this.address)] - (balanceOf[this.address] * rewardsFee / 100) + (balanceOf[this.address] * rewardsFee / 100 * stor22 / 100)
                                                            if balanceOf[stor12] > !((balanceOf[this.address] * rewardsFee / 100) - (balanceOf[this.address] * rewardsFee / 100 * stor22 / 100)):
                                                                revert with 0, 17
                                                            if balanceOf[stor12] + (balanceOf[this.address] * rewardsFee / 100) - (balanceOf[this.address] * rewardsFee / 100 * stor22 / 100) < balanceOf[stor12]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            balanceOf[stor12] = balanceOf[stor12] + (balanceOf[this.address] * rewardsFee / 100) - (balanceOf[this.address] * rewardsFee / 100 * stor22 / 100)
                                                            emit Transfer(((balanceOf[this.address] * rewardsFee / 100) - (balanceOf[this.address] * rewardsFee / 100 * stor22 / 100)), this.address, distributionPoolAddress);
                                                            if not balanceOf[this.address]:
                                                                mem[_7732 + ceil32(return_data.size) + 320] = 26
                                                                mem[_7732 + ceil32(return_data.size) + 352] = 'SafeMath: division by zero'
                                                                mem[_7732 + ceil32(return_data.size) + 384] = 26
                                                                mem[_7732 + ceil32(return_data.size) + 416] = 'SafeMath: division by zero'
                                                                mem[_7732 + ceil32(return_data.size) + 448] = 30
                                                                mem[_7732 + ceil32(return_data.size) + 480] = 'SafeMath: subtraction overflow'
                                                                mem[_7732 + ceil32(return_data.size) + 512] = 2
                                                                mem[_7732 + ceil32(return_data.size) + 544] = this.address
                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                        gas gas_remaining wei
                                                                mem[_7732 + ceil32(return_data.size) + 608] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[64] = _7732 + (2 * ceil32(return_data.size)) + 608
                                                                require return_data.size >= 32
                                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                mem[_7732 + ceil32(return_data.size) + 576] = ext_call.return_data[12 len 20]
                                                                if not this.address:
                                                                    revert with 0, 'ERC20: approve from the zero address'
                                                                if not uniswapV2RouterAddress:
                                                                    revert with 0, 'ERC20: approve to the zero address'
                                                                mem[0] = uniswapV2RouterAddress
                                                                mem[32] = sha3(address(this.address), 1)
                                                                allowance[address(this.address)][stor9].field_0 = 0
                                                                emit Approval(0, this.address, uniswapV2RouterAddress);
                                                                mem[_7732 + (2 * ceil32(return_data.size)) + 608] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                mem[_7732 + (2 * ceil32(return_data.size)) + 612] = 0
                                                                mem[_7732 + (2 * ceil32(return_data.size)) + 644] = 0
                                                                mem[_7732 + (2 * ceil32(return_data.size)) + 676] = 160
                                                                mem[_7732 + (2 * ceil32(return_data.size)) + 772] = 2
                                                                idx = 0
                                                                s = _7732 + (2 * ceil32(return_data.size)) + 804
                                                                t = _7732 + ceil32(return_data.size) + 544
                                                                while idx < mem[_7732 + ceil32(return_data.size) + 512]:
                                                                    mem[s] = mem[t + 12 len 20]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[_7732 + (2 * ceil32(return_data.size)) + 708] = this.address
                                                                mem[_7732 + (2 * ceil32(return_data.size)) + 740] = block.timestamp
                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                     gas gas_remaining wei
                                                                    args mem[mem[64] + 4 len _7732 + (2 * ceil32(return_data.size)) + (32 * mem[_7732 + ceil32(return_data.size) + 512]) + -mem[64] + 800]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _12041 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_12041] = 30
                                                                mem[_12041 + 32] = 'SafeMath: subtraction overflow'
                                                                if eth.balance(this.address) > eth.balance(this.address):
                                                                    _12077 = mem[64]
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 30
                                                                    idx = 0
                                                                    while idx < 30:
                                                                        mem[idx + _12077 + 68] = mem[_12041 + idx + 32]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    mem[_12077 + 98] = 0
                                                                    revert with memory
                                                                      from mem[64]
                                                                       len _12077 + -mem[64] + 100
                                                                if eth.balance(this.address) < eth.balance(this.address):
                                                                    revert with 0, 17
                                                                if not this.address:
                                                                    revert with 0, 'ERC20: approve from the zero address'
                                                                if not uniswapV2RouterAddress:
                                                                    revert with 0, 'ERC20: approve to the zero address'
                                                                mem[0] = uniswapV2RouterAddress
                                                                mem[32] = sha3(address(this.address), 1)
                                                                allowance[address(this.address)][stor9].field_0 = 0
                                                                emit Approval(0, this.address, uniswapV2RouterAddress);
                                                                mem[mem[64] + 68] = 0
                                                                mem[mem[64] + 100] = 0
                                                                mem[mem[64] + 132] = 0
                                                                mem[mem[64] + 164] = block.timestamp
                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                                     gas gas_remaining wei
                                                                    args this.address, 0, 0, 0, 0, block.timestamp
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 96
                                                                mem[mem[64] + 32] = 0
                                                                mem[mem[64] + 64] = 0
                                                                emit SwapAndLiquify(uint256 arg1, uint256 arg2, uint256 arg3):
                                                                                    0,
                                                                mem[0] = this.address
                                                                mem[32] = 0
                                                                _12594 = mem[64]
                                                                mem[mem[64]] = 2
                                                                mem[64] = mem[64] + 96
                                                                mem[_12594 + 32 len 64] = call.data[calldata.size len 64]
                                                                if 0 >= mem[_12594]:
                                                                    revert with 0, 50
                                                                mem[_12594 + 32] = this.address
                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                        gas gas_remaining wei
                                                                mem[_12594 + 96] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[64] = _12594 + ceil32(return_data.size) + 96
                                                                require return_data.size >= 32
                                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                if 1 >= mem[_12594]:
                                                                    revert with 0, 50
                                                                mem[_12594 + 64] = ext_call.return_data[12 len 20]
                                                                if not this.address:
                                                                    revert with 0, 'ERC20: approve from the zero address'
                                                                if not uniswapV2RouterAddress:
                                                                    revert with 0, 'ERC20: approve to the zero address'
                                                                mem[0] = uniswapV2RouterAddress
                                                                mem[32] = sha3(address(this.address), 1)
                                                                allowance[address(this.address)][stor9].field_0 = balanceOf[this.address]
                                                                emit Approval(balanceOf[this.address], this.address, uniswapV2RouterAddress);
                                                                mem[_12594 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                mem[_12594 + ceil32(return_data.size) + 100] = balanceOf[this.address]
                                                                mem[_12594 + ceil32(return_data.size) + 132] = 0
                                                                mem[_12594 + ceil32(return_data.size) + 164] = 160
                                                                mem[_12594 + ceil32(return_data.size) + 260] = mem[_12594]
                                                                idx = 0
                                                                s = _12594 + ceil32(return_data.size) + 292
                                                                t = _12594 + 32
                                                                while idx < mem[_12594]:
                                                                    mem[s] = mem[t + 12 len 20]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[_12594 + ceil32(return_data.size) + 196] = this.address
                                                                mem[_12594 + ceil32(return_data.size) + 228] = block.timestamp
                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                     gas gas_remaining wei
                                                                    args mem[mem[64] + 4 len _12594 + ceil32(return_data.size) + (32 * mem[_12594]) + -mem[64] + 288]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _13697 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_13697] = 30
                                                                mem[_13697 + 32] = 'SafeMath: subtraction overflow'
                                                                if eth.balance(this.address) > eth.balance(this.address):
                                                                    _13715 = mem[64]
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 30
                                                                    idx = 0
                                                                    while idx < 30:
                                                                        mem[idx + _13715 + 68] = mem[_13697 + idx + 32]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    mem[_13715 + 98] = 0
                                                                    revert with memory
                                                                      from mem[64]
                                                                       len _13715 + -mem[64] + 100
                                                                if eth.balance(this.address) < eth.balance(this.address):
                                                                    revert with 0, 17
                                                                call marketingWalletAddress with:
                                                                     gas 2300 wei
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                uint8(stor23.field_0) = 0
                                                                if not msg.sender:
                                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                                if not this.address:
                                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                                _13867 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_13867] = 38
                                                                mem[_13867 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                                mem[32] = 0
                                                                if _6955 > balanceOf[address(msg.sender)]:
                                                                    _13926 = mem[64]
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 38
                                                                    idx = 0
                                                                    while idx < 38:
                                                                        mem[idx + _13926 + 68] = mem[_13867 + idx + 32]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    mem[_13926 + 106] = 0
                                                                    revert with memory
                                                                      from mem[64]
                                                                       len _13926 + -mem[64] + 132
                                                            else:
                                                                if balanceOf[this.address] and liquidityPoolFee > -1 / balanceOf[this.address]:
                                                                    revert with 0, 17
                                                                if not balanceOf[this.address]:
                                                                    revert with 0, 18
                                                                if balanceOf[this.address] * liquidityPoolFee / balanceOf[this.address] != liquidityPoolFee:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                mem[_7732 + ceil32(return_data.size) + 320] = 26
                                                                mem[_7732 + ceil32(return_data.size) + 352] = 'SafeMath: division by zero'
                                                                mem[_7732 + ceil32(return_data.size) + 384] = 26
                                                                mem[_7732 + ceil32(return_data.size) + 416] = 'SafeMath: division by zero'
                                                                mem[_7732 + ceil32(return_data.size) + 448] = 30
                                                                mem[_7732 + ceil32(return_data.size) + 480] = 'SafeMath: subtraction overflow'
                                                                if balanceOf[this.address] * liquidityPoolFee / 100 / 2 > balanceOf[this.address] * liquidityPoolFee / 100:
                                                                    mem[_7732 + ceil32(return_data.size) + 512] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[_7732 + ceil32(return_data.size) + 516] = 32
                                                                    idx = 0
                                                                    while idx < 30:
                                                                        mem[idx + _7732 + ceil32(return_data.size) + 580] = mem[_7732 + ceil32(return_data.size) + idx + 480]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    revert with 0, 32, 30, mem[_7732 + ceil32(return_data.size) + 580 len 30], 0
                                                                if balanceOf[this.address] * liquidityPoolFee / 100 < balanceOf[this.address] * liquidityPoolFee / 100 / 2:
                                                                    revert with 0, 17
                                                                mem[_7732 + ceil32(return_data.size) + 512] = 2
                                                                mem[_7732 + ceil32(return_data.size) + 544] = this.address
                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                        gas gas_remaining wei
                                                                mem[_7732 + ceil32(return_data.size) + 608] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[64] = _7732 + (2 * ceil32(return_data.size)) + 608
                                                                require return_data.size >= 32
                                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                mem[_7732 + ceil32(return_data.size) + 576] = ext_call.return_data[12 len 20]
                                                                if not this.address:
                                                                    revert with 0, 'ERC20: approve from the zero address'
                                                                if not uniswapV2RouterAddress:
                                                                    revert with 0, 'ERC20: approve to the zero address'
                                                                mem[0] = uniswapV2RouterAddress
                                                                mem[32] = sha3(address(this.address), 1)
                                                                allowance[address(this.address)][stor9].field_0 = balanceOf[this.address] * liquidityPoolFee / 100 / 2
                                                                allowance[address(this.address)][stor9].field_255 = 0
                                                                emit Approval((balanceOf[this.address] * liquidityPoolFee / 100 / 2), this.address, uniswapV2RouterAddress);
                                                                mem[_7732 + (2 * ceil32(return_data.size)) + 608] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                mem[_7732 + (2 * ceil32(return_data.size)) + 612] = balanceOf[this.address] * liquidityPoolFee / 100 / 2
                                                                mem[_7732 + (2 * ceil32(return_data.size)) + 644] = 0
                                                                mem[_7732 + (2 * ceil32(return_data.size)) + 676] = 160
                                                                mem[_7732 + (2 * ceil32(return_data.size)) + 772] = 2
                                                                idx = 0
                                                                s = _7732 + (2 * ceil32(return_data.size)) + 804
                                                                t = _7732 + ceil32(return_data.size) + 544
                                                                while idx < mem[_7732 + ceil32(return_data.size) + 512]:
                                                                    mem[s] = mem[t + 12 len 20]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[_7732 + (2 * ceil32(return_data.size)) + 708] = this.address
                                                                mem[_7732 + (2 * ceil32(return_data.size)) + 740] = block.timestamp
                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                     gas gas_remaining wei
                                                                    args mem[mem[64] + 4 len _7732 + (2 * ceil32(return_data.size)) + (32 * mem[_7732 + ceil32(return_data.size) + 512]) + -mem[64] + 800]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _12040 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_12040] = 30
                                                                mem[_12040 + 32] = 'SafeMath: subtraction overflow'
                                                                if eth.balance(this.address) > eth.balance(this.address):
                                                                    _12076 = mem[64]
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 30
                                                                    idx = 0
                                                                    while idx < 30:
                                                                        mem[idx + _12076 + 68] = mem[_12040 + idx + 32]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    mem[_12076 + 98] = 0
                                                                    revert with memory
                                                                      from mem[64]
                                                                       len _12076 + -mem[64] + 100
                                                                if eth.balance(this.address) < eth.balance(this.address):
                                                                    revert with 0, 17
                                                                if not this.address:
                                                                    revert with 0, 'ERC20: approve from the zero address'
                                                                if not uniswapV2RouterAddress:
                                                                    revert with 0, 'ERC20: approve to the zero address'
                                                                mem[0] = uniswapV2RouterAddress
                                                                mem[32] = sha3(address(this.address), 1)
                                                                allowance[address(this.address)][stor9].field_0 = (balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2)
                                                                emit Approval(((balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2)), this.address, uniswapV2RouterAddress);
                                                                mem[mem[64] + 68] = 0
                                                                mem[mem[64] + 100] = 0
                                                                mem[mem[64] + 132] = 0
                                                                mem[mem[64] + 164] = block.timestamp
                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                                     gas gas_remaining wei
                                                                    args this.address, (balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2), 0, 0, 0, block.timestamp
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 96
                                                                mem[mem[64] + 32] = 0
                                                                mem[mem[64] + 64] = (balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2)
                                                                emit SwapAndLiquify(Mask(255, 1, balanceOf[this.address] * liquidityPoolFee / 100), 0, (balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2));
                                                                mem[0] = this.address
                                                                mem[32] = 0
                                                                _12592 = mem[64]
                                                                mem[mem[64]] = 2
                                                                mem[64] = mem[64] + 96
                                                                mem[_12592 + 32 len 64] = call.data[calldata.size len 64]
                                                                if 0 >= mem[_12592]:
                                                                    revert with 0, 50
                                                                mem[_12592 + 32] = this.address
                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                        gas gas_remaining wei
                                                                mem[_12592 + 96] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[64] = _12592 + ceil32(return_data.size) + 96
                                                                require return_data.size >= 32
                                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                if 1 >= mem[_12592]:
                                                                    revert with 0, 50
                                                                mem[_12592 + 64] = ext_call.return_data[12 len 20]
                                                                if not this.address:
                                                                    revert with 0, 'ERC20: approve from the zero address'
                                                                if not uniswapV2RouterAddress:
                                                                    revert with 0, 'ERC20: approve to the zero address'
                                                                mem[0] = uniswapV2RouterAddress
                                                                mem[32] = sha3(address(this.address), 1)
                                                                allowance[address(this.address)][stor9].field_0 = balanceOf[this.address]
                                                                emit Approval(balanceOf[this.address], this.address, uniswapV2RouterAddress);
                                                                mem[_12592 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                mem[_12592 + ceil32(return_data.size) + 100] = balanceOf[this.address]
                                                                mem[_12592 + ceil32(return_data.size) + 132] = 0
                                                                mem[_12592 + ceil32(return_data.size) + 164] = 160
                                                                mem[_12592 + ceil32(return_data.size) + 260] = mem[_12592]
                                                                idx = 0
                                                                s = _12592 + ceil32(return_data.size) + 292
                                                                t = _12592 + 32
                                                                while idx < mem[_12592]:
                                                                    mem[s] = mem[t + 12 len 20]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[_12592 + ceil32(return_data.size) + 196] = this.address
                                                                mem[_12592 + ceil32(return_data.size) + 228] = block.timestamp
                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                     gas gas_remaining wei
                                                                    args mem[mem[64] + 4 len _12592 + ceil32(return_data.size) + (32 * mem[_12592]) + -mem[64] + 288]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _13696 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_13696] = 30
                                                                mem[_13696 + 32] = 'SafeMath: subtraction overflow'
                                                                if eth.balance(this.address) > eth.balance(this.address):
                                                                    _13714 = mem[64]
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 30
                                                                    idx = 0
                                                                    while idx < 30:
                                                                        mem[idx + _13714 + 68] = mem[_13696 + idx + 32]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    mem[_13714 + 98] = 0
                                                                    revert with memory
                                                                      from mem[64]
                                                                       len _13714 + -mem[64] + 100
                                                                if eth.balance(this.address) < eth.balance(this.address):
                                                                    revert with 0, 17
                                                                call marketingWalletAddress with:
                                                                     gas 2300 wei
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                uint8(stor23.field_0) = 0
                                                                if not msg.sender:
                                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                                if not this.address:
                                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                                _13864 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_13864] = 38
                                                                mem[_13864 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                                mem[32] = 0
                                                                if _6955 > balanceOf[address(msg.sender)]:
                                                                    _13924 = mem[64]
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 38
                                                                    idx = 0
                                                                    while idx < 38:
                                                                        mem[idx + _13924 + 68] = mem[_13864 + idx + 32]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    mem[_13924 + 106] = 0
                                                                    revert with memory
                                                                      from mem[64]
                                                                       len _13924 + -mem[64] + 132
                                                        ('le', ('var', '_6955'), ('stor', ('map', ('mask_shl', 160, 0, 0, 'msg.sender'), ('name', 'balanceOf', 0))))
                                                        if balanceOf[address(msg.sender)] < _6955:
                                                            revert with 0, 17
                                                        balanceOf[address(msg.sender)] -= _6955
                                                        if balanceOf[this.address] > !_6955:
                                                            revert with 0, 17
                                                        if balanceOf[this.address] + _6955 < balanceOf[this.address]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        balanceOf[address(this.address)] = balanceOf[this.address] + _6955
                                                        emit Transfer(_6955, msg.sender, this.address);
                                                        if arg1 >= 3:
                                                            revert with 0, 50
                                                        mem[mem[64]] = 0x12b8603f00000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = msg.sender
                                                        mem[mem[64] + 36] = 64
                                                        mem[mem[64] + 68] = mem[128]
                                                        idx = 0
                                                        while idx < mem[128]:
                                                            mem[idx + mem[64] + 100] = mem[idx + 160]
                                                            idx = idx + 32
                                                            continue 
                                                        if ceil32(mem[128]) > mem[128]:
                                                            mem[mem[64] + mem[128] + 100] = 0
                                                        require ext_code.size(sub_20eea8b5[arg1])
                                                        call sub_20eea8b5[arg1].createNode(address arg1, string arg2) with:
                                                             gas gas_remaining wei
                                                            args msg.sender, Array(len=mem[128], data=mem[mem[64] + 100 len ceil32(mem[128])])
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if stor27[address(msg.sender)] > -2:
                                        revert with 0, 17
                                    if stor27[address(msg.sender)] + 1 < stor27[address(msg.sender)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor27[address(msg.sender)]++
                                if mem[128] <= 3:
                                    revert with 0, 'NODE CREATION: NAME SIZE INVALID'
                                if mem[128] >= 32:
                                    revert with 0, 'NODE CREATION: NAME SIZE INVALID'
                                if sub_6cdc78b3 <= stor27[msg.sender]:
                                    revert with 0, 'cannot create node more than 100'
                                if not msg.sender:
                                    revert with 0, 'NODE CREATION:  creation from the zero address'
                                mem[0] = msg.sender
                                mem[32] = 25
                                if stor25[address(msg.sender)]:
                                    revert with 0, 'NODE CREATION: Blacklisted address'
                                if futurUsePoolAddress == msg.sender:
                                    revert with 0, 'NODE CREATION: futur and rewardsPool cannot create node'
                                if distributionPoolAddress == msg.sender:
                                    revert with 0, 'NODE CREATION: futur and rewardsPool cannot create node'
                                if arg1 >= 3:
                                    revert with 0, 50
                                require ext_code.size(sub_20eea8b5[arg1])
                                staticcall sub_20eea8b5[arg1].nodePrice() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _5438 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _5500 = mem[_5438]
                                if balanceOf[address(msg.sender)] < mem[_5438]:
                                    revert with 0, 'NODE CREATION: Balance too low for creation.'
                                mem[0] = this.address
                                mem[32] = 0
                                if balanceOf[this.address] < swapTokensAmount:
                                    if not msg.sender:
                                        revert with 0, 'ERC20: transfer from the zero address'
                                    if not this.address:
                                        revert with 0, 'ERC20: transfer to the zero address'
                                    _5843 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_5843] = 38
                                    mem[_5843 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                    if _5500 > balanceOf[address(msg.sender)]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 38
                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_5843 + 70 len 26]
                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                    if balanceOf[address(msg.sender)] < _5500:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)] -= _5500
                                    if balanceOf[this.address] > !_5500:
                                        revert with 0, 17
                                    if balanceOf[this.address] + _5500 < balanceOf[this.address]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(this.address)] = balanceOf[this.address] + _5500
                                    emit Transfer(_5500, msg.sender, this.address);
                                    if arg1 >= 3:
                                        revert with 0, 50
                                    mem[mem[64]] = 0x12b8603f00000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = 64
                                    mem[mem[64] + 68] = mem[128]
                                    mem[mem[64] + 100 len ceil32(mem[128])] = mem[160 len ceil32(mem[128])]
                                    if ceil32(mem[128]) > mem[128]:
                                        mem[mem[64] + mem[128] + 100] = 0
                                    require ext_code.size(sub_20eea8b5[arg1])
                                    call sub_20eea8b5[arg1].createNode(address arg1, string arg2) with:
                                         gas gas_remaining wei
                                        args msg.sender, Array(len=mem[128], data=mem[mem[64] + 100 len ceil32(mem[128])])
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if stor27[address(msg.sender)] > -2:
                                        revert with 0, 17
                                    if stor27[address(msg.sender)] + 1 < stor27[address(msg.sender)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor27[address(msg.sender)]++
                                if not uint8(stor23.field_8):
                                    if not msg.sender:
                                        revert with 0, 'ERC20: transfer from the zero address'
                                    if not this.address:
                                        revert with 0, 'ERC20: transfer to the zero address'
                                    _5892 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_5892] = 38
                                    mem[_5892 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                    if _5500 > balanceOf[address(msg.sender)]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 38
                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_5892 + 70 len 26]
                                        var75001 = 64
                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                    if balanceOf[address(msg.sender)] < _5500:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)] -= _5500
                                    if balanceOf[this.address] > !_5500:
                                        revert with 0, 17
                                    if balanceOf[this.address] + _5500 < balanceOf[this.address]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(this.address)] = balanceOf[this.address] + _5500
                                    emit Transfer(_5500, msg.sender, this.address);
                                    if arg1 >= 3:
                                        revert with 0, 50
                                    mem[mem[64]] = 0x12b8603f00000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = 64
                                    mem[mem[64] + 68] = mem[128]
                                    mem[mem[64] + 100 len ceil32(mem[128])] = mem[160 len ceil32(mem[128])]
                                    if ceil32(mem[128]) > mem[128]:
                                        mem[mem[64] + mem[128] + 100] = 0
                                    require ext_code.size(sub_20eea8b5[arg1])
                                    call sub_20eea8b5[arg1].createNode(address arg1, string arg2) with:
                                         gas gas_remaining wei
                                        args msg.sender, Array(len=mem[128], data=mem[mem[64] + 100 len ceil32(mem[128])])
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if stor27[address(msg.sender)] > -2:
                                        revert with 0, 17
                                    if stor27[address(msg.sender)] + 1 < stor27[address(msg.sender)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor27[address(msg.sender)]++
                                if uint8(stor23.field_0):
                                    if not msg.sender:
                                        revert with 0, 'ERC20: transfer from the zero address'
                                    if not this.address:
                                        revert with 0, 'ERC20: transfer to the zero address'
                                    _5947 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_5947] = 38
                                    mem[_5947 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                    if _5500 > balanceOf[address(msg.sender)]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 38
                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_5947 + 70 len 26]
                                        idx = 64
                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                    if balanceOf[address(msg.sender)] < _5500:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)] -= _5500
                                    if balanceOf[this.address] > !_5500:
                                        revert with 0, 17
                                    if balanceOf[this.address] + _5500 < balanceOf[this.address]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(this.address)] = balanceOf[this.address] + _5500
                                    emit Transfer(_5500, msg.sender, this.address);
                                    if arg1 >= 3:
                                        revert with 0, 50
                                    mem[mem[64]] = 0x12b8603f00000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = 64
                                    mem[mem[64] + 68] = mem[128]
                                    mem[mem[64] + 100 len ceil32(mem[128])] = mem[160 len ceil32(mem[128])]
                                    if ceil32(mem[128]) > mem[128]:
                                        mem[mem[64] + mem[128] + 100] = 0
                                    require ext_code.size(sub_20eea8b5[arg1])
                                    call sub_20eea8b5[arg1].createNode(address arg1, string arg2) with:
                                         gas gas_remaining wei
                                        args msg.sender, Array(len=mem[128], data=mem[mem[64] + 100 len ceil32(mem[128])])
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if stor27[address(msg.sender)] > -2:
                                        revert with 0, 17
                                    if stor27[address(msg.sender)] + 1 < stor27[address(msg.sender)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor27[address(msg.sender)]++
                                if owner == msg.sender:
                                    if not msg.sender:
                                        revert with 0, 'ERC20: transfer from the zero address'
                                    if not this.address:
                                        revert with 0, 'ERC20: transfer to the zero address'
                                    _5964 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_5964] = 38
                                    mem[_5964 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                    if _5500 > balanceOf[address(msg.sender)]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 38
                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_5964 + 70 len 26]
                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                    if balanceOf[address(msg.sender)] < _5500:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)] -= _5500
                                    if balanceOf[this.address] > !_5500:
                                        revert with 0, 17
                                    if balanceOf[this.address] + _5500 < balanceOf[this.address]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(this.address)] = balanceOf[this.address] + _5500
                                    emit Transfer(_5500, msg.sender, this.address);
                                    if arg1 >= 3:
                                        revert with 0, 50
                                    mem[mem[64]] = 0x12b8603f00000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = 64
                                    mem[mem[64] + 68] = mem[128]
                                    mem[mem[64] + 100 len ceil32(mem[128])] = mem[160 len ceil32(mem[128])]
                                    if ceil32(mem[128]) > mem[128]:
                                        mem[mem[64] + mem[128] + 100] = 0
                                    require ext_code.size(sub_20eea8b5[arg1])
                                    call sub_20eea8b5[arg1].createNode(address arg1, string arg2) with:
                                         gas gas_remaining wei
                                        args msg.sender, Array(len=mem[128], data=mem[mem[64] + 100 len ceil32(mem[128])])
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if stor27[address(msg.sender)] > -2:
                                        revert with 0, 17
                                    if stor27[address(msg.sender)] + 1 < stor27[address(msg.sender)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor27[address(msg.sender)]++
                                mem[0] = msg.sender
                                mem[32] = 26
                                if stor26[address(msg.sender)]:
                                    if not msg.sender:
                                        revert with 0, 'ERC20: transfer from the zero address'
                                    if not this.address:
                                        revert with 0, 'ERC20: transfer to the zero address'
                                    _6001 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_6001] = 38
                                    mem[_6001 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                    if _5500 > balanceOf[address(msg.sender)]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 38
                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_6001 + 70 len 26]
                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                    if balanceOf[address(msg.sender)] < _5500:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)] -= _5500
                                    if balanceOf[this.address] > !_5500:
                                        revert with 0, 17
                                    if balanceOf[this.address] + _5500 < balanceOf[this.address]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(this.address)] = balanceOf[this.address] + _5500
                                    emit Transfer(_5500, msg.sender, this.address);
                                    if arg1 >= 3:
                                        revert with 0, 50
                                    mem[mem[64]] = 0x12b8603f00000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = 64
                                    mem[mem[64] + 68] = mem[128]
                                    mem[mem[64] + 100 len ceil32(mem[128])] = mem[160 len ceil32(mem[128])]
                                    var91001 = ceil32(mem[128])
                                    if ceil32(mem[128]) > mem[128]:
                                        mem[mem[64] + mem[128] + 100] = 0
                                    require ext_code.size(sub_20eea8b5[arg1])
                                    call sub_20eea8b5[arg1].createNode(address arg1, string arg2) with:
                                         gas gas_remaining wei
                                        args msg.sender, Array(len=mem[128], data=mem[mem[64] + 100 len ceil32(mem[128])])
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if stor27[address(msg.sender)] > -2:
                                        revert with 0, 17
                                    if stor27[address(msg.sender)] + 1 < stor27[address(msg.sender)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor27[address(msg.sender)]++
                                uint8(stor23.field_0) = 1
                                if not balanceOf[this.address]:
                                    _6048 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6048] = 26
                                    mem[_6048 + 32] = 'SafeMath: division by zero'
                                    _6378 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6378] = 26
                                    mem[_6378 + 32] = 'SafeMath: division by zero'
                                    _6515 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    mem[_6515 + 32 len 64] = call.data[calldata.size len 64]
                                    if 0 >= mem[_6515]:
                                        revert with 0, 50
                                    mem[_6515 + 32] = this.address
                                    require ext_code.size(uniswapV2RouterAddress)
                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                            gas gas_remaining wei
                                    mem[_6515 + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = _6515 + ceil32(return_data.size) + 96
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    if 1 >= mem[_6515]:
                                        revert with 0, 50
                                    mem[_6515 + 64] = ext_call.return_data[12 len 20]
                                    if not this.address:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not uniswapV2RouterAddress:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    mem[0] = uniswapV2RouterAddress
                                    mem[32] = sha3(address(this.address), 1)
                                    allowance[address(this.address)][stor9].field_0 = 0
                                    emit Approval(0, this.address, uniswapV2RouterAddress);
                                    mem[_6515 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                    mem[_6515 + ceil32(return_data.size) + 100] = 0
                                    mem[_6515 + ceil32(return_data.size) + 132] = 0
                                    mem[_6515 + ceil32(return_data.size) + 164] = 160
                                    mem[_6515 + ceil32(return_data.size) + 260] = mem[_6515]
                                    idx = 0
                                    s = _6515 + ceil32(return_data.size) + 292
                                    t = _6515 + 32
                                    while idx < mem[_6515]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(uniswapV2RouterAddress)
                                    call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args 0, 0, 160, address(this.address), block.timestamp, mem[_6515 + ceil32(return_data.size) + 260 len (32 * mem[_6515]) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_6515 + ceil32(return_data.size) + 96] = 30
                                    mem[_6515 + ceil32(return_data.size) + 128] = 'SafeMath: subtraction overflow'
                                    if eth.balance(this.address) > eth.balance(this.address):
                                        var125001 = 32
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if eth.balance(this.address) < eth.balance(this.address):
                                        revert with 0, 17
                                    call distributionPoolAddress with:
                                         gas 2300 wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_6515 + ceil32(return_data.size) + 160] = 30
                                    mem[_6515 + ceil32(return_data.size) + 192] = 'SafeMath: subtraction overflow'
                                    if not this.address:
                                        revert with 0, 'ERC20: transfer from the zero address'
                                    if not distributionPoolAddress:
                                        revert with 0, 'ERC20: transfer to the zero address'
                                    mem[_6515 + ceil32(return_data.size) + 224] = 38
                                    mem[_6515 + ceil32(return_data.size) + 256 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                    if 0 > balanceOf[address(this.address)]:
                                        var145001 = 64
                                        revert with 0, 
                                                    32,
                                                    38,
                                                    0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_6515 + ceil32(return_data.size) + 294 len 26] >> 48,
                                                    0
                                    if balanceOf[address(this.address)] < 0:
                                        revert with 0, 17
                                    if balanceOf[stor12] > -1:
                                        revert with 0, 17
                                    if balanceOf[stor12] < balanceOf[stor12]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[stor12] = balanceOf[stor12]
                                    emit Transfer(0, this.address, distributionPoolAddress);
                                    if not balanceOf[this.address]:
                                        mem[_6515 + ceil32(return_data.size) + 320] = 26
                                        mem[_6515 + ceil32(return_data.size) + 352] = 'SafeMath: division by zero'
                                        mem[_6515 + ceil32(return_data.size) + 384] = 26
                                        mem[_6515 + ceil32(return_data.size) + 416] = 'SafeMath: division by zero'
                                        mem[_6515 + ceil32(return_data.size) + 448] = 30
                                        mem[_6515 + ceil32(return_data.size) + 480] = 'SafeMath: subtraction overflow'
                                        mem[_6515 + ceil32(return_data.size) + 512] = 2
                                        mem[_6515 + ceil32(return_data.size) + 544] = this.address
                                        require ext_code.size(uniswapV2RouterAddress)
                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                gas gas_remaining wei
                                        mem[_6515 + ceil32(return_data.size) + 608] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[64] = _6515 + (2 * ceil32(return_data.size)) + 608
                                        require return_data.size >= 32
                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                        mem[_6515 + ceil32(return_data.size) + 576] = ext_call.return_data[12 len 20]
                                        if not this.address:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not uniswapV2RouterAddress:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        mem[0] = uniswapV2RouterAddress
                                        mem[32] = sha3(address(this.address), 1)
                                        allowance[address(this.address)][stor9].field_0 = 0
                                        emit Approval(0, this.address, uniswapV2RouterAddress);
                                        mem[_6515 + (2 * ceil32(return_data.size)) + 608] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                        mem[_6515 + (2 * ceil32(return_data.size)) + 612] = 0
                                        mem[_6515 + (2 * ceil32(return_data.size)) + 644] = 0
                                        mem[_6515 + (2 * ceil32(return_data.size)) + 676] = 160
                                        mem[_6515 + (2 * ceil32(return_data.size)) + 772] = 2
                                        idx = 0
                                        s = _6515 + (2 * ceil32(return_data.size)) + 804
                                        t = _6515 + ceil32(return_data.size) + 544
                                        while idx < mem[_6515 + ceil32(return_data.size) + 512]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_6515 + (2 * ceil32(return_data.size)) + 708] = this.address
                                        mem[_6515 + (2 * ceil32(return_data.size)) + 740] = block.timestamp
                                        require ext_code.size(uniswapV2RouterAddress)
                                        call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args 0, 0, 160, address(this.address), block.timestamp, mem[_6515 + (2 * ceil32(return_data.size)) + 772 len (32 * mem[_6515 + ceil32(return_data.size) + 512]) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[_6515 + (2 * ceil32(return_data.size)) + 608] = 30
                                        mem[_6515 + (2 * ceil32(return_data.size)) + 640] = 'SafeMath: subtraction overflow'
                                        if eth.balance(this.address) > eth.balance(this.address):
                                            mem[_6515 + (2 * ceil32(return_data.size)) + 672] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_6515 + (2 * ceil32(return_data.size)) + 676] = 32
                                            mem[_6515 + (2 * ceil32(return_data.size)) + 708] = 30
                                            mem[_6515 + (2 * ceil32(return_data.size)) + 740] = 'SafeMath: subtraction overflow'
                                            var213001 = 32
                                            mem[_6515 + (2 * ceil32(return_data.size)) + 770] = 0
                                            revert with memory
                                              from _6515 + (2 * ceil32(return_data.size)) + 672
                                               len ceil32(return_data.size) + 100
                                        if eth.balance(this.address) < eth.balance(this.address):
                                            revert with 0, 17
                                        if not this.address:
                                            mem[_6515 + (2 * ceil32(return_data.size)) + 672] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_6515 + (2 * ceil32(return_data.size)) + 676] = 32
                                            mem[_6515 + (2 * ceil32(return_data.size)) + 708] = 36
                                            mem[_6515 + (2 * ceil32(return_data.size)) + 740] = 'ERC20: approve from the zero add'
                                            mem[_6515 + (2 * ceil32(return_data.size)) + 772] = 0x7265737300000000000000000000000000000000000000000000000000000000
                                            revert with memory
                                              from _6515 + (2 * ceil32(return_data.size)) + 672
                                               len ceil32(return_data.size) + 132
                                        if not uniswapV2RouterAddress:
                                            mem[_6515 + (2 * ceil32(return_data.size)) + 672] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_6515 + (2 * ceil32(return_data.size)) + 676] = 32
                                            mem[_6515 + (2 * ceil32(return_data.size)) + 708] = 34
                                            mem[_6515 + (2 * ceil32(return_data.size)) + 740] = 'ERC20: approve to the zero addre'
                                            mem[_6515 + (2 * ceil32(return_data.size)) + 772] = 0x7373000000000000000000000000000000000000000000000000000000000000
                                            revert with memory
                                              from _6515 + (2 * ceil32(return_data.size)) + 672
                                               len ceil32(return_data.size) + 132
                                        allowance[address(this.address)][stor9].field_0 = 0
                                        emit Approval(0, this.address, uniswapV2RouterAddress);
                                        mem[_6515 + (2 * ceil32(return_data.size)) + 676] = this.address
                                        mem[_6515 + (2 * ceil32(return_data.size)) + 708] = 0
                                        mem[_6515 + (2 * ceil32(return_data.size)) + 740] = 0
                                        mem[_6515 + (2 * ceil32(return_data.size)) + 772] = 0
                                        mem[_6515 + (2 * ceil32(return_data.size)) + 804] = 0
                                        mem[_6515 + (2 * ceil32(return_data.size)) + 836] = block.timestamp
                                        require ext_code.size(uniswapV2RouterAddress)
                                        call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                             gas gas_remaining wei
                                            args mem[_6515 + (2 * ceil32(return_data.size)) + 676 len ceil32(return_data.size) + 192]
                                        mem[_6515 + (2 * ceil32(return_data.size)) + 672 len 96] = ext_call.return_data[0 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 96
                                        mem[_6515 + (4 * ceil32(return_data.size)) + 672] = 0
                                        mem[_6515 + (4 * ceil32(return_data.size)) + 704] = 0
                                        mem[_6515 + (4 * ceil32(return_data.size)) + 736] = 0
                                        emit SwapAndLiquify(uint256 arg1, uint256 arg2, uint256 arg3):
                                                            mem[_6515 + (4 * ceil32(return_data.size)) + 672 len (5 * ceil32(return_data.size)) + 96],
                                        mem[_6515 + (4 * ceil32(return_data.size)) + 672] = 2
                                        mem[_6515 + (4 * ceil32(return_data.size)) + 704] = this.address
                                        require ext_code.size(uniswapV2RouterAddress)
                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                gas gas_remaining wei
                                        mem[_6515 + (4 * ceil32(return_data.size)) + 768] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[64] = _6515 + (6 * ceil32(return_data.size)) + 768
                                        require return_data.size >= 32
                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                        mem[_6515 + (4 * ceil32(return_data.size)) + 736] = ext_call.return_data[12 len 20]
                                        if not this.address:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not uniswapV2RouterAddress:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        mem[0] = uniswapV2RouterAddress
                                        mem[32] = sha3(address(this.address), 1)
                                        allowance[address(this.address)][stor9].field_0 = balanceOf[this.address]
                                        emit Approval(balanceOf[this.address], this.address, uniswapV2RouterAddress);
                                        mem[_6515 + (6 * ceil32(return_data.size)) + 768] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                        mem[_6515 + (6 * ceil32(return_data.size)) + 772] = balanceOf[this.address]
                                        mem[_6515 + (6 * ceil32(return_data.size)) + 804] = 0
                                        mem[_6515 + (6 * ceil32(return_data.size)) + 836] = 160
                                        mem[_6515 + (6 * ceil32(return_data.size)) + 932] = 2
                                        idx = 0
                                        s = _6515 + (6 * ceil32(return_data.size)) + 964
                                        t = _6515 + (4 * ceil32(return_data.size)) + 704
                                        while idx < mem[_6515 + (4 * ceil32(return_data.size)) + 672]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_6515 + (6 * ceil32(return_data.size)) + 900] = block.timestamp
                                        require ext_code.size(uniswapV2RouterAddress)
                                        call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args balanceOf[this.address], 0, 160, address(this.address), block.timestamp, mem[_6515 + (6 * ceil32(return_data.size)) + 932 len (32 * mem[_6515 + (4 * ceil32(return_data.size)) + 672]) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[_6515 + (6 * ceil32(return_data.size)) + 768] = 30
                                        mem[_6515 + (6 * ceil32(return_data.size)) + 800] = 'SafeMath: subtraction overflow'
                                        if eth.balance(this.address) > eth.balance(this.address):
                                            var259001 = 32
                                            mem[_6515 + (6 * ceil32(return_data.size)) + 930] = 0
                                            revert with 0, 
                                                        'SafeMath: subtraction overflow',
                                                        mem[_6515 + (6 * ceil32(return_data.size)) + 930 len (9 * ceil32(return_data.size)) + 2]
                                        if eth.balance(this.address) < eth.balance(this.address):
                                            revert with 0, 17
                                        call marketingWalletAddress with:
                                             gas 2300 wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        uint8(stor23.field_0) = 0
                                        if not msg.sender:
                                            revert with 0, 
                                                        'ERC20: transfer from the zero address',
                                                        mem[_6515 + (6 * ceil32(return_data.size)) + 964 len 9 * ceil32(return_data.size)]
                                        if not this.address:
                                            revert with 0, 
                                                        'ERC20: transfer to the zero address',
                                                        mem[_6515 + (6 * ceil32(return_data.size)) + 964 len 9 * ceil32(return_data.size)]
                                        mem[_6515 + (6 * ceil32(return_data.size)) + 832] = 38
                                        mem[_6515 + (6 * ceil32(return_data.size)) + 864 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                        if _5500 > balanceOf[address(msg.sender)]:
                                            mem[_6515 + (6 * ceil32(return_data.size)) + 1034] = 0
                                            revert with 0, 
                                                        32,
                                                        38,
                                                        0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, Mask(208, 32, block.timestamp) >> 32 >> 48,
                                                        mem[_6515 + (6 * ceil32(return_data.size)) + 1034 len (9 * ceil32(return_data.size)) + 26]
                                        if balanceOf[address(msg.sender)] < _5500:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] -= _5500
                                        if balanceOf[this.address] > !_5500:
                                            revert with 0, 17
                                        if balanceOf[this.address] + _5500 < balanceOf[this.address]:
                                            revert with 0, 'SafeMath: addition overflow', mem[_6515 + (6 * ceil32(return_data.size)) + 1028 len 9 * ceil32(return_data.size)]
                                        balanceOf[address(this.address)] = balanceOf[this.address] + _5500
                                        emit Transfer(_5500, msg.sender, this.address);
                                        if arg1 >= 3:
                                            revert with 0, 50
                                        mem[_6515 + (6 * ceil32(return_data.size)) + 928] = 0x12b8603f00000000000000000000000000000000000000000000000000000000
                                        mem[_6515 + (6 * ceil32(return_data.size)) + 932] = msg.sender
                                        mem[_6515 + (6 * ceil32(return_data.size)) + 964] = 64
                                        mem[_6515 + (6 * ceil32(return_data.size)) + 996] = mem[128]
                                        mem[_6515 + (6 * ceil32(return_data.size)) + 1028 len ceil32(mem[128])] = mem[160 len ceil32(mem[128])]
                                        if ceil32(mem[128]) > mem[128]:
                                            mem[_6515 + (6 * ceil32(return_data.size)) + mem[128] + 1028] = 0
                                        require ext_code.size(sub_20eea8b5[arg1])
                                        call sub_20eea8b5[arg1].createNode(address arg1, string arg2) with:
                                             gas gas_remaining wei
                                            args msg.sender, Array(len=mem[128], data=mem[_6515 + (6 * ceil32(return_data.size)) + 1028 len (9 * ceil32(return_data.size)) + ceil32(mem[128])])
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if stor27[address(msg.sender)] > -2:
                                            revert with 0, 17
                                        if stor27[address(msg.sender)] + 1 < stor27[address(msg.sender)]:
                                            revert with 0, 'SafeMath: addition overflow', mem[_6515 + (6 * ceil32(return_data.size)) + 1028 len 9 * ceil32(return_data.size)]
                                    else:
                                        if balanceOf[this.address] and liquidityPoolFee > -1 / balanceOf[this.address]:
                                            revert with 0, 17
                                        if not balanceOf[this.address]:
                                            revert with 0, 18
                                        if balanceOf[this.address] * liquidityPoolFee / balanceOf[this.address] != liquidityPoolFee:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        mem[_6515 + ceil32(return_data.size) + 320] = 26
                                        mem[_6515 + ceil32(return_data.size) + 352] = 'SafeMath: division by zero'
                                        mem[_6515 + ceil32(return_data.size) + 384] = 26
                                        mem[_6515 + ceil32(return_data.size) + 416] = 'SafeMath: division by zero'
                                        mem[_6515 + ceil32(return_data.size) + 448] = 30
                                        mem[_6515 + ceil32(return_data.size) + 480] = 'SafeMath: subtraction overflow'
                                        if balanceOf[this.address] * liquidityPoolFee / 100 / 2 > balanceOf[this.address] * liquidityPoolFee / 100:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if balanceOf[this.address] * liquidityPoolFee / 100 < balanceOf[this.address] * liquidityPoolFee / 100 / 2:
                                            revert with 0, 17
                                        mem[_6515 + ceil32(return_data.size) + 512] = 2
                                        mem[_6515 + ceil32(return_data.size) + 544] = this.address
                                        require ext_code.size(uniswapV2RouterAddress)
                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                gas gas_remaining wei
                                        mem[_6515 + ceil32(return_data.size) + 608] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[64] = _6515 + (2 * ceil32(return_data.size)) + 608
                                        require return_data.size >= 32
                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                        mem[_6515 + ceil32(return_data.size) + 576] = ext_call.return_data[12 len 20]
                                        if not this.address:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not uniswapV2RouterAddress:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        mem[0] = uniswapV2RouterAddress
                                        mem[32] = sha3(address(this.address), 1)
                                        allowance[address(this.address)][stor9].field_0 = balanceOf[this.address] * liquidityPoolFee / 100 / 2
                                        allowance[address(this.address)][stor9].field_255 = 0
                                        emit Approval((balanceOf[this.address] * liquidityPoolFee / 100 / 2), this.address, uniswapV2RouterAddress);
                                        mem[_6515 + (2 * ceil32(return_data.size)) + 608] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                        mem[_6515 + (2 * ceil32(return_data.size)) + 612] = balanceOf[this.address] * liquidityPoolFee / 100 / 2
                                        mem[_6515 + (2 * ceil32(return_data.size)) + 644] = 0
                                        mem[_6515 + (2 * ceil32(return_data.size)) + 676] = 160
                                        mem[_6515 + (2 * ceil32(return_data.size)) + 772] = 2
                                        idx = 0
                                        s = _6515 + (2 * ceil32(return_data.size)) + 804
                                        t = _6515 + ceil32(return_data.size) + 544
                                        while idx < mem[_6515 + ceil32(return_data.size) + 512]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_6515 + (2 * ceil32(return_data.size)) + 708] = this.address
                                        mem[_6515 + (2 * ceil32(return_data.size)) + 740] = block.timestamp
                                        require ext_code.size(uniswapV2RouterAddress)
                                        call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _6515 + (2 * ceil32(return_data.size)) + (32 * mem[_6515 + ceil32(return_data.size) + 512]) + -mem[64] + 800]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _12038 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_12038] = 30
                                        mem[_12038 + 32] = 'SafeMath: subtraction overflow'
                                        if eth.balance(this.address) > eth.balance(this.address):
                                            var219001 = 32
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if eth.balance(this.address) < eth.balance(this.address):
                                            revert with 0, 17
                                        if not this.address:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not uniswapV2RouterAddress:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        mem[0] = uniswapV2RouterAddress
                                        mem[32] = sha3(address(this.address), 1)
                                        allowance[address(this.address)][stor9].field_0 = (balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2)
                                        emit Approval(((balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2)), this.address, uniswapV2RouterAddress);
                                        mem[mem[64] + 68] = 0
                                        mem[mem[64] + 100] = 0
                                        mem[mem[64] + 132] = 0
                                        mem[mem[64] + 164] = block.timestamp
                                        require ext_code.size(uniswapV2RouterAddress)
                                        call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                             gas gas_remaining wei
                                            args this.address, (balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2), 0, 0, 0, block.timestamp
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 96
                                        mem[mem[64] + 32] = 0
                                        mem[mem[64] + 64] = (balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2)
                                        emit SwapAndLiquify(Mask(255, 1, balanceOf[this.address] * liquidityPoolFee / 100), 0, (balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2));
                                        mem[0] = this.address
                                        mem[32] = 0
                                        _12588 = mem[64]
                                        mem[mem[64]] = 2
                                        mem[64] = mem[64] + 96
                                        mem[_12588 + 32 len 64] = call.data[calldata.size len 64]
                                        if 0 >= mem[_12588]:
                                            revert with 0, 50
                                        mem[_12588 + 32] = this.address
                                        require ext_code.size(uniswapV2RouterAddress)
                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                gas gas_remaining wei
                                        mem[_12588 + 96] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[64] = _12588 + ceil32(return_data.size) + 96
                                        require return_data.size >= 32
                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                        if 1 >= mem[_12588]:
                                            revert with 0, 50
                                        mem[_12588 + 64] = ext_call.return_data[12 len 20]
                                        if not this.address:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not uniswapV2RouterAddress:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        mem[0] = uniswapV2RouterAddress
                                        mem[32] = sha3(address(this.address), 1)
                                        allowance[address(this.address)][stor9].field_0 = balanceOf[this.address]
                                        emit Approval(balanceOf[this.address], this.address, uniswapV2RouterAddress);
                                        mem[_12588 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                        mem[_12588 + ceil32(return_data.size) + 100] = balanceOf[this.address]
                                        mem[_12588 + ceil32(return_data.size) + 132] = 0
                                        mem[_12588 + ceil32(return_data.size) + 164] = 160
                                        mem[_12588 + ceil32(return_data.size) + 260] = mem[_12588]
                                        idx = 0
                                        s = _12588 + ceil32(return_data.size) + 292
                                        t = _12588 + 32
                                        while idx < mem[_12588]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_12588 + ceil32(return_data.size) + 196] = this.address
                                        mem[_12588 + ceil32(return_data.size) + 228] = block.timestamp
                                        require ext_code.size(uniswapV2RouterAddress)
                                        call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _12588 + ceil32(return_data.size) + (32 * mem[_12588]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _13694 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13694] = 30
                                        mem[_13694 + 32] = 'SafeMath: subtraction overflow'
                                        if eth.balance(this.address) > eth.balance(this.address):
                                            var265001 = 32
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if eth.balance(this.address) < eth.balance(this.address):
                                            revert with 0, 17
                                        call marketingWalletAddress with:
                                             gas 2300 wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        uint8(stor23.field_0) = 0
                                        if not msg.sender:
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not this.address:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        _13858 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_13858] = 38
                                        mem[_13858 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                        if _5500 > balanceOf[address(msg.sender)]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 38
                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_13858 + 70 len 26]
                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                        if balanceOf[address(msg.sender)] < _5500:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] -= _5500
                                        if balanceOf[this.address] > !_5500:
                                            revert with 0, 17
                                        if balanceOf[this.address] + _5500 < balanceOf[this.address]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(this.address)] = balanceOf[this.address] + _5500
                                        emit Transfer(_5500, msg.sender, this.address);
                                        if arg1 >= 3:
                                            revert with 0, 50
                                        mem[mem[64]] = 0x12b8603f00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 64
                                        mem[mem[64] + 68] = mem[128]
                                        mem[mem[64] + 100 len ceil32(mem[128])] = mem[160 len ceil32(mem[128])]
                                        if ceil32(mem[128]) > mem[128]:
                                            mem[mem[64] + mem[128] + 100] = 0
                                        require ext_code.size(sub_20eea8b5[arg1])
                                        call sub_20eea8b5[arg1].createNode(address arg1, string arg2) with:
                                             gas gas_remaining wei
                                            args msg.sender, Array(len=mem[128], data=mem[mem[64] + 100 len ceil32(mem[128])])
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if stor27[address(msg.sender)] > -2:
                                            revert with 0, 17
                                        if stor27[address(msg.sender)] + 1 < stor27[address(msg.sender)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                    ('ge', ('add', 1, ('stor', ('map', ('mask_shl', 160, 0, 0, 'msg.sender'), ('name', 'stor27', 27)))), ('stor', ('map', ('mask_shl', 160, 0, 0, 'msg.sender'), ('name', 'stor27', 27))))
                                    stor27[address(msg.sender)]++
                                if balanceOf[this.address] and rewardsFee > -1 / balanceOf[this.address]:
                                    revert with 0, 17
                                if not balanceOf[this.address]:
                                    revert with 0, 18
                                if balanceOf[this.address] * rewardsFee / balanceOf[this.address] != rewardsFee:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _6132 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6132] = 26
                                mem[_6132 + 32] = 'SafeMath: division by zero'
                                if not balanceOf[this.address] * rewardsFee / 100:
                                    _6469 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6469] = 26
                                    mem[_6469 + 32] = 'SafeMath: division by zero'
                                    _6661 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    mem[_6661 + 32 len 64] = call.data[calldata.size len 64]
                                    if 0 >= mem[_6661]:
                                        revert with 0, 50
                                    mem[_6661 + 32] = this.address
                                    require ext_code.size(uniswapV2RouterAddress)
                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                            gas gas_remaining wei
                                    mem[_6661 + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = _6661 + ceil32(return_data.size) + 96
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    if 1 >= mem[_6661]:
                                        revert with 0, 50
                                    mem[_6661 + 64] = ext_call.return_data[12 len 20]
                                    if not this.address:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not uniswapV2RouterAddress:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    mem[0] = uniswapV2RouterAddress
                                    mem[32] = sha3(address(this.address), 1)
                                    allowance[address(this.address)][stor9].field_0 = 0
                                    emit Approval(0, this.address, uniswapV2RouterAddress);
                                    mem[_6661 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                    mem[_6661 + ceil32(return_data.size) + 100] = 0
                                    mem[_6661 + ceil32(return_data.size) + 132] = 0
                                    mem[_6661 + ceil32(return_data.size) + 164] = 160
                                    mem[_6661 + ceil32(return_data.size) + 260] = mem[_6661]
                                    idx = 0
                                    s = _6661 + ceil32(return_data.size) + 292
                                    t = _6661 + 32
                                    while idx < mem[_6661]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(uniswapV2RouterAddress)
                                    call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args 0, 0, 160, address(this.address), block.timestamp, mem[_6661 + ceil32(return_data.size) + 260 len (32 * mem[_6661]) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_6661 + ceil32(return_data.size) + 96] = 30
                                    mem[_6661 + ceil32(return_data.size) + 128] = 'SafeMath: subtraction overflow'
                                    if eth.balance(this.address) > eth.balance(this.address):
                                        var131001 = 32
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if eth.balance(this.address) < eth.balance(this.address):
                                        revert with 0, 17
                                    call distributionPoolAddress with:
                                         gas 2300 wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_6661 + ceil32(return_data.size) + 160] = 30
                                    mem[_6661 + ceil32(return_data.size) + 192] = 'SafeMath: subtraction overflow'
                                    if 0 > balanceOf[this.address] * rewardsFee / 100:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if balanceOf[this.address] * rewardsFee / 100 < 0:
                                        revert with 0, 17
                                    if not this.address:
                                        revert with 0, 'ERC20: transfer from the zero address'
                                    if not distributionPoolAddress:
                                        revert with 0, 'ERC20: transfer to the zero address'
                                    mem[_6661 + ceil32(return_data.size) + 224] = 38
                                    mem[_6661 + ceil32(return_data.size) + 256 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                    if balanceOf[this.address] * rewardsFee / 100 > balanceOf[address(this.address)]:
                                        revert with 0, 
                                                    32,
                                                    38,
                                                    0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_6661 + ceil32(return_data.size) + 294 len 26] >> 48,
                                                    0
                                    if balanceOf[address(this.address)] < balanceOf[this.address] * rewardsFee / 100:
                                        revert with 0, 17
                                    balanceOf[address(this.address)] -= balanceOf[this.address] * rewardsFee / 100
                                    if balanceOf[stor12] > !(balanceOf[this.address] * rewardsFee / 100):
                                        revert with 0, 17
                                    if balanceOf[stor12] + (balanceOf[this.address] * rewardsFee / 100) < balanceOf[stor12]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[stor12] += balanceOf[this.address] * rewardsFee / 100
                                    emit Transfer((balanceOf[this.address] * rewardsFee / 100), this.address, distributionPoolAddress);
                                    if not balanceOf[this.address]:
                                        mem[_6661 + ceil32(return_data.size) + 320] = 26
                                        mem[_6661 + ceil32(return_data.size) + 352] = 'SafeMath: division by zero'
                                        mem[_6661 + ceil32(return_data.size) + 384] = 26
                                        mem[_6661 + ceil32(return_data.size) + 416] = 'SafeMath: division by zero'
                                        mem[_6661 + ceil32(return_data.size) + 448] = 30
                                        mem[_6661 + ceil32(return_data.size) + 480] = 'SafeMath: subtraction overflow'
                                        mem[_6661 + ceil32(return_data.size) + 512] = 2
                                        mem[_6661 + ceil32(return_data.size) + 544] = this.address
                                        require ext_code.size(uniswapV2RouterAddress)
                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                gas gas_remaining wei
                                        mem[_6661 + ceil32(return_data.size) + 608] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[64] = _6661 + (2 * ceil32(return_data.size)) + 608
                                        require return_data.size >= 32
                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                        mem[_6661 + ceil32(return_data.size) + 576] = ext_call.return_data[12 len 20]
                                        if not this.address:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not uniswapV2RouterAddress:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        mem[0] = uniswapV2RouterAddress
                                        mem[32] = sha3(address(this.address), 1)
                                        allowance[address(this.address)][stor9].field_0 = 0
                                        emit Approval(0, this.address, uniswapV2RouterAddress);
                                        mem[_6661 + (2 * ceil32(return_data.size)) + 608] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                        mem[_6661 + (2 * ceil32(return_data.size)) + 612] = 0
                                        mem[_6661 + (2 * ceil32(return_data.size)) + 644] = 0
                                        mem[_6661 + (2 * ceil32(return_data.size)) + 676] = 160
                                        mem[_6661 + (2 * ceil32(return_data.size)) + 772] = 2
                                        idx = 0
                                        s = _6661 + (2 * ceil32(return_data.size)) + 804
                                        t = _6661 + ceil32(return_data.size) + 544
                                        while idx < mem[_6661 + ceil32(return_data.size) + 512]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_6661 + (2 * ceil32(return_data.size)) + 708] = this.address
                                        mem[_6661 + (2 * ceil32(return_data.size)) + 740] = block.timestamp
                                        require ext_code.size(uniswapV2RouterAddress)
                                        call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args 0, 0, 160, address(this.address), block.timestamp, mem[_6661 + (2 * ceil32(return_data.size)) + 772 len (32 * mem[_6661 + ceil32(return_data.size) + 512]) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[_6661 + (2 * ceil32(return_data.size)) + 608] = 30
                                        mem[_6661 + (2 * ceil32(return_data.size)) + 640] = 'SafeMath: subtraction overflow'
                                        if eth.balance(this.address) > eth.balance(this.address):
                                            mem[_6661 + (2 * ceil32(return_data.size)) + 672] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_6661 + (2 * ceil32(return_data.size)) + 676] = 32
                                            mem[_6661 + (2 * ceil32(return_data.size)) + 708] = 30
                                            mem[_6661 + (2 * ceil32(return_data.size)) + 740] = 'SafeMath: subtraction overflow'
                                            var219001 = 32
                                            mem[_6661 + (2 * ceil32(return_data.size)) + 770] = 0
                                            revert with memory
                                              from _6661 + (2 * ceil32(return_data.size)) + 672
                                               len ceil32(return_data.size) + 100
                                        if eth.balance(this.address) < eth.balance(this.address):
                                            revert with 0, 17
                                        if not this.address:
                                            mem[_6661 + (2 * ceil32(return_data.size)) + 672] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_6661 + (2 * ceil32(return_data.size)) + 676] = 32
                                            mem[_6661 + (2 * ceil32(return_data.size)) + 708] = 36
                                            mem[_6661 + (2 * ceil32(return_data.size)) + 740] = 'ERC20: approve from the zero add'
                                            mem[_6661 + (2 * ceil32(return_data.size)) + 772] = 0x7265737300000000000000000000000000000000000000000000000000000000
                                            revert with memory
                                              from _6661 + (2 * ceil32(return_data.size)) + 672
                                               len ceil32(return_data.size) + 132
                                        if not uniswapV2RouterAddress:
                                            mem[_6661 + (2 * ceil32(return_data.size)) + 672] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_6661 + (2 * ceil32(return_data.size)) + 676] = 32
                                            mem[_6661 + (2 * ceil32(return_data.size)) + 708] = 34
                                            mem[_6661 + (2 * ceil32(return_data.size)) + 740] = 'ERC20: approve to the zero addre'
                                            mem[_6661 + (2 * ceil32(return_data.size)) + 772] = 0x7373000000000000000000000000000000000000000000000000000000000000
                                            revert with memory
                                              from _6661 + (2 * ceil32(return_data.size)) + 672
                                               len ceil32(return_data.size) + 132
                                        allowance[address(this.address)][stor9].field_0 = 0
                                        emit Approval(0, this.address, uniswapV2RouterAddress);
                                        mem[_6661 + (2 * ceil32(return_data.size)) + 676] = this.address
                                        mem[_6661 + (2 * ceil32(return_data.size)) + 708] = 0
                                        mem[_6661 + (2 * ceil32(return_data.size)) + 740] = 0
                                        mem[_6661 + (2 * ceil32(return_data.size)) + 772] = 0
                                        mem[_6661 + (2 * ceil32(return_data.size)) + 804] = 0
                                        mem[_6661 + (2 * ceil32(return_data.size)) + 836] = block.timestamp
                                        require ext_code.size(uniswapV2RouterAddress)
                                        call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                             gas gas_remaining wei
                                            args mem[_6661 + (2 * ceil32(return_data.size)) + 676 len ceil32(return_data.size) + 192]
                                        mem[_6661 + (2 * ceil32(return_data.size)) + 672 len 96] = ext_call.return_data[0 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 96
                                        mem[_6661 + (4 * ceil32(return_data.size)) + 672] = 0
                                        mem[_6661 + (4 * ceil32(return_data.size)) + 704] = 0
                                        mem[_6661 + (4 * ceil32(return_data.size)) + 736] = 0
                                        emit SwapAndLiquify(uint256 arg1, uint256 arg2, uint256 arg3):
                                                            mem[_6661 + (4 * ceil32(return_data.size)) + 672 len (5 * ceil32(return_data.size)) + 96],
                                        mem[_6661 + (4 * ceil32(return_data.size)) + 672] = 2
                                        mem[_6661 + (4 * ceil32(return_data.size)) + 704] = this.address
                                        require ext_code.size(uniswapV2RouterAddress)
                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                gas gas_remaining wei
                                        mem[_6661 + (4 * ceil32(return_data.size)) + 768] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[64] = _6661 + (6 * ceil32(return_data.size)) + 768
                                        require return_data.size >= 32
                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                        mem[_6661 + (4 * ceil32(return_data.size)) + 736] = ext_call.return_data[12 len 20]
                                        if not this.address:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not uniswapV2RouterAddress:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        mem[0] = uniswapV2RouterAddress
                                        mem[32] = sha3(address(this.address), 1)
                                        allowance[address(this.address)][stor9].field_0 = balanceOf[this.address]
                                        emit Approval(balanceOf[this.address], this.address, uniswapV2RouterAddress);
                                        mem[_6661 + (6 * ceil32(return_data.size)) + 768] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                        mem[_6661 + (6 * ceil32(return_data.size)) + 772] = balanceOf[this.address]
                                        mem[_6661 + (6 * ceil32(return_data.size)) + 804] = 0
                                        mem[_6661 + (6 * ceil32(return_data.size)) + 836] = 160
                                        mem[_6661 + (6 * ceil32(return_data.size)) + 932] = 2
                                        idx = 0
                                        s = _6661 + (6 * ceil32(return_data.size)) + 964
                                        t = _6661 + (4 * ceil32(return_data.size)) + 704
                                        while idx < mem[_6661 + (4 * ceil32(return_data.size)) + 672]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_6661 + (6 * ceil32(return_data.size)) + 868] = this.address
                                        mem[_6661 + (6 * ceil32(return_data.size)) + 900] = block.timestamp
                                        require ext_code.size(uniswapV2RouterAddress)
                                        call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _6661 + (6 * ceil32(return_data.size)) + (32 * mem[_6661 + (4 * ceil32(return_data.size)) + 672]) + -mem[64] + 960]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _13693 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13693] = 30
                                        mem[_13693 + 32] = 'SafeMath: subtraction overflow'
                                        if eth.balance(this.address) > eth.balance(this.address):
                                            var265001 = 32
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if eth.balance(this.address) < eth.balance(this.address):
                                            revert with 0, 17
                                        call marketingWalletAddress with:
                                             gas 2300 wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        uint8(stor23.field_0) = 0
                                        if not msg.sender:
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not this.address:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        _13855 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_13855] = 38
                                        mem[_13855 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                        if _5500 > balanceOf[address(msg.sender)]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 38
                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_13855 + 70 len 26]
                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                        if balanceOf[address(msg.sender)] < _5500:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] -= _5500
                                        if balanceOf[this.address] > !_5500:
                                            revert with 0, 17
                                        if balanceOf[this.address] + _5500 < balanceOf[this.address]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(this.address)] = balanceOf[this.address] + _5500
                                        emit Transfer(_5500, msg.sender, this.address);
                                        if arg1 >= 3:
                                            revert with 0, 50
                                        mem[mem[64]] = 0x12b8603f00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 64
                                        mem[mem[64] + 68] = mem[128]
                                        mem[mem[64] + 100 len ceil32(mem[128])] = mem[160 len ceil32(mem[128])]
                                        if ceil32(mem[128]) > mem[128]:
                                            mem[mem[64] + mem[128] + 100] = 0
                                        require ext_code.size(sub_20eea8b5[arg1])
                                        call sub_20eea8b5[arg1].createNode(address arg1, string arg2) with:
                                             gas gas_remaining wei
                                            args msg.sender, Array(len=mem[128], data=mem[mem[64] + 100 len ceil32(mem[128])])
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if stor27[address(msg.sender)] > -2:
                                            revert with 0, 17
                                        if stor27[address(msg.sender)] + 1 < stor27[address(msg.sender)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                    else:
                                        if balanceOf[this.address] and liquidityPoolFee > -1 / balanceOf[this.address]:
                                            revert with 0, 17
                                        if not balanceOf[this.address]:
                                            revert with 0, 18
                                        if balanceOf[this.address] * liquidityPoolFee / balanceOf[this.address] != liquidityPoolFee:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        mem[_6661 + ceil32(return_data.size) + 320] = 26
                                        mem[_6661 + ceil32(return_data.size) + 352] = 'SafeMath: division by zero'
                                        mem[_6661 + ceil32(return_data.size) + 384] = 26
                                        mem[_6661 + ceil32(return_data.size) + 416] = 'SafeMath: division by zero'
                                        mem[_6661 + ceil32(return_data.size) + 448] = 30
                                        mem[_6661 + ceil32(return_data.size) + 480] = 'SafeMath: subtraction overflow'
                                        if balanceOf[this.address] * liquidityPoolFee / 100 / 2 > balanceOf[this.address] * liquidityPoolFee / 100:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if balanceOf[this.address] * liquidityPoolFee / 100 < balanceOf[this.address] * liquidityPoolFee / 100 / 2:
                                            revert with 0, 17
                                        mem[_6661 + ceil32(return_data.size) + 512] = 2
                                        mem[_6661 + ceil32(return_data.size) + 544] = this.address
                                        require ext_code.size(uniswapV2RouterAddress)
                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                gas gas_remaining wei
                                        mem[_6661 + ceil32(return_data.size) + 608] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[64] = _6661 + (2 * ceil32(return_data.size)) + 608
                                        require return_data.size >= 32
                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                        mem[_6661 + ceil32(return_data.size) + 576] = ext_call.return_data[12 len 20]
                                        if not this.address:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not uniswapV2RouterAddress:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        mem[0] = uniswapV2RouterAddress
                                        mem[32] = sha3(address(this.address), 1)
                                        allowance[address(this.address)][stor9].field_0 = balanceOf[this.address] * liquidityPoolFee / 100 / 2
                                        allowance[address(this.address)][stor9].field_255 = 0
                                        emit Approval((balanceOf[this.address] * liquidityPoolFee / 100 / 2), this.address, uniswapV2RouterAddress);
                                        mem[_6661 + (2 * ceil32(return_data.size)) + 608] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                        mem[_6661 + (2 * ceil32(return_data.size)) + 612] = balanceOf[this.address] * liquidityPoolFee / 100 / 2
                                        mem[_6661 + (2 * ceil32(return_data.size)) + 644] = 0
                                        mem[_6661 + (2 * ceil32(return_data.size)) + 676] = 160
                                        mem[_6661 + (2 * ceil32(return_data.size)) + 772] = 2
                                        idx = 0
                                        s = _6661 + (2 * ceil32(return_data.size)) + 804
                                        t = _6661 + ceil32(return_data.size) + 544
                                        while idx < mem[_6661 + ceil32(return_data.size) + 512]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_6661 + (2 * ceil32(return_data.size)) + 708] = this.address
                                        mem[_6661 + (2 * ceil32(return_data.size)) + 740] = block.timestamp
                                        require ext_code.size(uniswapV2RouterAddress)
                                        call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args Mask(255, 1, balanceOf[this.address] * liquidityPoolFee / 100), 0, 160, address(this.address), block.timestamp, mem[_6661 + (2 * ceil32(return_data.size)) + 772 len (32 * mem[_6661 + ceil32(return_data.size) + 512]) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[_6661 + (2 * ceil32(return_data.size)) + 608] = 30
                                        mem[_6661 + (2 * ceil32(return_data.size)) + 640] = 'SafeMath: subtraction overflow'
                                        if eth.balance(this.address) > eth.balance(this.address):
                                            mem[_6661 + (2 * ceil32(return_data.size)) + 672] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_6661 + (2 * ceil32(return_data.size)) + 676] = 32
                                            mem[_6661 + (2 * ceil32(return_data.size)) + 708] = 30
                                            mem[_6661 + (2 * ceil32(return_data.size)) + 740] = 'SafeMath: subtraction overflow'
                                            mem[_6661 + (2 * ceil32(return_data.size)) + 770] = 0
                                            revert with memory
                                              from _6661 + (2 * ceil32(return_data.size)) + 672
                                               len ceil32(return_data.size) + 100
                                        if eth.balance(this.address) < eth.balance(this.address):
                                            revert with 0, 17
                                        if not this.address:
                                            mem[_6661 + (2 * ceil32(return_data.size)) + 672] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_6661 + (2 * ceil32(return_data.size)) + 676] = 32
                                            mem[_6661 + (2 * ceil32(return_data.size)) + 708] = 36
                                            mem[_6661 + (2 * ceil32(return_data.size)) + 740] = 'ERC20: approve from the zero add'
                                            mem[_6661 + (2 * ceil32(return_data.size)) + 772] = 0x7265737300000000000000000000000000000000000000000000000000000000
                                            revert with memory
                                              from _6661 + (2 * ceil32(return_data.size)) + 672
                                               len ceil32(return_data.size) + 132
                                        if not uniswapV2RouterAddress:
                                            mem[_6661 + (2 * ceil32(return_data.size)) + 672] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_6661 + (2 * ceil32(return_data.size)) + 676] = 32
                                            mem[_6661 + (2 * ceil32(return_data.size)) + 708] = 34
                                            mem[_6661 + (2 * ceil32(return_data.size)) + 740] = 'ERC20: approve to the zero addre'
                                            mem[_6661 + (2 * ceil32(return_data.size)) + 772] = 0x7373000000000000000000000000000000000000000000000000000000000000
                                            revert with memory
                                              from _6661 + (2 * ceil32(return_data.size)) + 672
                                               len ceil32(return_data.size) + 132
                                        allowance[address(this.address)][stor9].field_0 = (balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2)
                                        emit Approval(((balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2)), this.address, uniswapV2RouterAddress);
                                        mem[_6661 + (2 * ceil32(return_data.size)) + 676] = this.address
                                        mem[_6661 + (2 * ceil32(return_data.size)) + 708] = (balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2)
                                        mem[_6661 + (2 * ceil32(return_data.size)) + 740] = 0
                                        mem[_6661 + (2 * ceil32(return_data.size)) + 772] = 0
                                        mem[_6661 + (2 * ceil32(return_data.size)) + 804] = 0
                                        mem[_6661 + (2 * ceil32(return_data.size)) + 836] = block.timestamp
                                        require ext_code.size(uniswapV2RouterAddress)
                                        call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                             gas gas_remaining wei
                                            args mem[_6661 + (2 * ceil32(return_data.size)) + 676 len ceil32(return_data.size) + 192]
                                        mem[_6661 + (2 * ceil32(return_data.size)) + 672 len 96] = ext_call.return_data[0 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 96
                                        mem[_6661 + (4 * ceil32(return_data.size)) + 672] = balanceOf[this.address] * liquidityPoolFee / 100 / 2
                                        mem[_6661 + (4 * ceil32(return_data.size)) + 704] = 0
                                        mem[_6661 + (4 * ceil32(return_data.size)) + 736] = (balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2)
                                        emit SwapAndLiquify(uint256 arg1, uint256 arg2, uint256 arg3):
                                                            mem[_6661 + (4 * ceil32(return_data.size)) + 672 len (5 * ceil32(return_data.size)) + 96],
                                        mem[_6661 + (4 * ceil32(return_data.size)) + 672] = 2
                                        mem[_6661 + (4 * ceil32(return_data.size)) + 704] = this.address
                                        require ext_code.size(uniswapV2RouterAddress)
                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                gas gas_remaining wei
                                        mem[_6661 + (4 * ceil32(return_data.size)) + 768] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[64] = _6661 + (6 * ceil32(return_data.size)) + 768
                                        require return_data.size >= 32
                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                        mem[_6661 + (4 * ceil32(return_data.size)) + 736] = ext_call.return_data[12 len 20]
                                        if not this.address:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not uniswapV2RouterAddress:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        mem[0] = uniswapV2RouterAddress
                                        mem[32] = sha3(address(this.address), 1)
                                        allowance[address(this.address)][stor9].field_0 = balanceOf[this.address]
                                        emit Approval(balanceOf[this.address], this.address, uniswapV2RouterAddress);
                                        mem[_6661 + (6 * ceil32(return_data.size)) + 768] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                        mem[_6661 + (6 * ceil32(return_data.size)) + 772] = balanceOf[this.address]
                                        mem[_6661 + (6 * ceil32(return_data.size)) + 804] = 0
                                        mem[_6661 + (6 * ceil32(return_data.size)) + 836] = 160
                                        mem[_6661 + (6 * ceil32(return_data.size)) + 932] = 2
                                        idx = 0
                                        s = _6661 + (6 * ceil32(return_data.size)) + 964
                                        t = _6661 + (4 * ceil32(return_data.size)) + 704
                                        while idx < mem[_6661 + (4 * ceil32(return_data.size)) + 672]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_6661 + (6 * ceil32(return_data.size)) + 900] = block.timestamp
                                        require ext_code.size(uniswapV2RouterAddress)
                                        call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args balanceOf[this.address], 0, 160, address(this.address), block.timestamp, mem[_6661 + (6 * ceil32(return_data.size)) + 932 len (32 * mem[_6661 + (4 * ceil32(return_data.size)) + 672]) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[_6661 + (6 * ceil32(return_data.size)) + 768] = 30
                                        mem[_6661 + (6 * ceil32(return_data.size)) + 800] = 'SafeMath: subtraction overflow'
                                        if eth.balance(this.address) > eth.balance(this.address):
                                            mem[_6661 + (6 * ceil32(return_data.size)) + 930] = 0
                                            revert with 0, 
                                                        'SafeMath: subtraction overflow',
                                                        mem[_6661 + (6 * ceil32(return_data.size)) + 930 len (9 * ceil32(return_data.size)) + 2]
                                        if eth.balance(this.address) < eth.balance(this.address):
                                            revert with 0, 17
                                        call marketingWalletAddress with:
                                             gas 2300 wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        uint8(stor23.field_0) = 0
                                        if not msg.sender:
                                            revert with 0, 
                                                        'ERC20: transfer from the zero address',
                                                        mem[_6661 + (6 * ceil32(return_data.size)) + 964 len 9 * ceil32(return_data.size)]
                                        if not this.address:
                                            revert with 0, 
                                                        'ERC20: transfer to the zero address',
                                                        mem[_6661 + (6 * ceil32(return_data.size)) + 964 len 9 * ceil32(return_data.size)]
                                        mem[_6661 + (6 * ceil32(return_data.size)) + 832] = 38
                                        mem[_6661 + (6 * ceil32(return_data.size)) + 864 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                        if _5500 > balanceOf[address(msg.sender)]:
                                            mem[_6661 + (6 * ceil32(return_data.size)) + 1034] = 0
                                            revert with 0, 
                                                        32,
                                                        38,
                                                        0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, Mask(208, 32, block.timestamp) >> 32 >> 48,
                                                        mem[_6661 + (6 * ceil32(return_data.size)) + 1034 len (9 * ceil32(return_data.size)) + 26]
                                        if balanceOf[address(msg.sender)] < _5500:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] -= _5500
                                        if balanceOf[this.address] > !_5500:
                                            revert with 0, 17
                                        if balanceOf[this.address] + _5500 < balanceOf[this.address]:
                                            revert with 0, 'SafeMath: addition overflow', mem[_6661 + (6 * ceil32(return_data.size)) + 1028 len 9 * ceil32(return_data.size)]
                                        balanceOf[address(this.address)] = balanceOf[this.address] + _5500
                                        emit Transfer(_5500, msg.sender, this.address);
                                        if arg1 >= 3:
                                            revert with 0, 50
                                        mem[_6661 + (6 * ceil32(return_data.size)) + 928] = 0x12b8603f00000000000000000000000000000000000000000000000000000000
                                        mem[_6661 + (6 * ceil32(return_data.size)) + 932] = msg.sender
                                        mem[_6661 + (6 * ceil32(return_data.size)) + 964] = 64
                                        mem[_6661 + (6 * ceil32(return_data.size)) + 996] = mem[128]
                                        mem[_6661 + (6 * ceil32(return_data.size)) + 1028 len ceil32(mem[128])] = mem[160 len ceil32(mem[128])]
                                        if ceil32(mem[128]) > mem[128]:
                                            mem[_6661 + (6 * ceil32(return_data.size)) + mem[128] + 1028] = 0
                                        require ext_code.size(sub_20eea8b5[arg1])
                                        call sub_20eea8b5[arg1].createNode(address arg1, string arg2) with:
                                             gas gas_remaining wei
                                            args msg.sender, Array(len=mem[128], data=mem[_6661 + (6 * ceil32(return_data.size)) + 1028 len (9 * ceil32(return_data.size)) + ceil32(mem[128])])
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if stor27[address(msg.sender)] > -2:
                                            revert with 0, 17
                                        if stor27[address(msg.sender)] + 1 < stor27[address(msg.sender)]:
                                            revert with 0, 'SafeMath: addition overflow', mem[_6661 + (6 * ceil32(return_data.size)) + 1028 len 9 * ceil32(return_data.size)]
                                    ('ge', ('add', 1, ('stor', ('map', ('mask_shl', 160, 0, 0, 'msg.sender'), ('name', 'stor27', 27)))), ('stor', ('map', ('mask_shl', 160, 0, 0, 'msg.sender'), ('name', 'stor27', 27))))
                                    stor27[address(msg.sender)]++
                                if balanceOf[this.address] * rewardsFee / 100 and stor22 > -1 / balanceOf[this.address] * rewardsFee / 100:
                                    revert with 0, 17
                                if not balanceOf[this.address] * rewardsFee / 100:
                                    revert with 0, 18
                                if balanceOf[this.address] * rewardsFee / 100 * stor22 / balanceOf[this.address] * rewardsFee / 100 != stor22:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _6580 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6580] = 26
                                mem[_6580 + 32] = 'SafeMath: division by zero'
                                _6846 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                mem[_6846 + 32 len 64] = call.data[calldata.size len 64]
                                if 0 >= mem[_6846]:
                                    revert with 0, 50
                                mem[_6846 + 32] = this.address
                                require ext_code.size(uniswapV2RouterAddress)
                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                        gas gas_remaining wei
                                mem[_6846 + 96] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = _6846 + ceil32(return_data.size) + 96
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                if 1 >= mem[_6846]:
                                    revert with 0, 50
                                mem[_6846 + 64] = ext_call.return_data[12 len 20]
                                if not this.address:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not uniswapV2RouterAddress:
                                    revert with 0, 'ERC20: approve to the zero address'
                                mem[0] = uniswapV2RouterAddress
                                mem[32] = sha3(address(this.address), 1)
                                allowance[address(this.address)][stor9].field_0 = balanceOf[this.address] * rewardsFee / 100 * stor22 / 100
                                emit Approval((balanceOf[this.address] * rewardsFee / 100 * stor22 / 100), this.address, uniswapV2RouterAddress);
                                mem[_6846 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                mem[_6846 + ceil32(return_data.size) + 100] = balanceOf[this.address] * rewardsFee / 100 * stor22 / 100
                                mem[_6846 + ceil32(return_data.size) + 132] = 0
                                mem[_6846 + ceil32(return_data.size) + 164] = 160
                                mem[_6846 + ceil32(return_data.size) + 260] = mem[_6846]
                                idx = 0
                                s = _6846 + ceil32(return_data.size) + 292
                                t = _6846 + 32
                                while idx < mem[_6846]:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[_6846 + ceil32(return_data.size) + 196] = this.address
                                mem[_6846 + ceil32(return_data.size) + 228] = block.timestamp
                                require ext_code.size(uniswapV2RouterAddress)
                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len _6846 + ceil32(return_data.size) + (32 * mem[_6846]) + -mem[64] + 288]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _8777 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_8777] = 30
                                mem[_8777 + 32] = 'SafeMath: subtraction overflow'
                                if eth.balance(this.address) > eth.balance(this.address):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if eth.balance(this.address) < eth.balance(this.address):
                                    revert with 0, 17
                                call distributionPoolAddress with:
                                     gas 2300 wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _9052 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_9052] = 30
                                mem[_9052 + 32] = 'SafeMath: subtraction overflow'
                                if balanceOf[this.address] * rewardsFee / 100 * stor22 / 100 > balanceOf[this.address] * rewardsFee / 100:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if balanceOf[this.address] * rewardsFee / 100 < balanceOf[this.address] * rewardsFee / 100 * stor22 / 100:
                                    revert with 0, 17
                                if not this.address:
                                    revert with 0, 'ERC20: transfer from the zero address'
                                if not distributionPoolAddress:
                                    revert with 0, 'ERC20: transfer to the zero address'
                                _9306 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_9306] = 38
                                mem[_9306 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                if (balanceOf[this.address] * rewardsFee / 100) - (balanceOf[this.address] * rewardsFee / 100 * stor22 / 100) > balanceOf[address(this.address)]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 38
                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_9306 + 70 len 26]
                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                if balanceOf[address(this.address)] < (balanceOf[this.address] * rewardsFee / 100) - (balanceOf[this.address] * rewardsFee / 100 * stor22 / 100):
                                    revert with 0, 17
                                balanceOf[address(this.address)] = balanceOf[address(this.address)] - (balanceOf[this.address] * rewardsFee / 100) + (balanceOf[this.address] * rewardsFee / 100 * stor22 / 100)
                                if balanceOf[stor12] > !((balanceOf[this.address] * rewardsFee / 100) - (balanceOf[this.address] * rewardsFee / 100 * stor22 / 100)):
                                    revert with 0, 17
                                if balanceOf[stor12] + (balanceOf[this.address] * rewardsFee / 100) - (balanceOf[this.address] * rewardsFee / 100 * stor22 / 100) < balanceOf[stor12]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = distributionPoolAddress
                                mem[32] = 0
                                balanceOf[stor12] = balanceOf[stor12] + (balanceOf[this.address] * rewardsFee / 100) - (balanceOf[this.address] * rewardsFee / 100 * stor22 / 100)
                                emit Transfer(((balanceOf[this.address] * rewardsFee / 100) - (balanceOf[this.address] * rewardsFee / 100 * stor22 / 100)), this.address, distributionPoolAddress);
                                if not balanceOf[this.address]:
                                    _9709 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_9709] = 26
                                    mem[_9709 + 32] = 'SafeMath: division by zero'
                                    _9853 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_9853] = 26
                                    mem[_9853 + 32] = 'SafeMath: division by zero'
                                    _9871 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_9871] = 30
                                    mem[_9871 + 32] = 'SafeMath: subtraction overflow'
                                    _9896 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    mem[_9896 + 32 len 64] = call.data[calldata.size len 64]
                                    if 0 >= mem[_9896]:
                                        revert with 0, 50
                                    mem[_9896 + 32] = this.address
                                    require ext_code.size(uniswapV2RouterAddress)
                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                            gas gas_remaining wei
                                    mem[_9896 + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = _9896 + ceil32(return_data.size) + 96
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    if 1 >= mem[_9896]:
                                        revert with 0, 50
                                    mem[_9896 + 64] = ext_call.return_data[12 len 20]
                                    if not this.address:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not uniswapV2RouterAddress:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    mem[0] = uniswapV2RouterAddress
                                    mem[32] = sha3(address(this.address), 1)
                                    allowance[address(this.address)][stor9].field_0 = 0
                                    emit Approval(0, this.address, uniswapV2RouterAddress);
                                    mem[_9896 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                    mem[_9896 + ceil32(return_data.size) + 100] = 0
                                    mem[_9896 + ceil32(return_data.size) + 132] = 0
                                    mem[_9896 + ceil32(return_data.size) + 164] = 160
                                    mem[_9896 + ceil32(return_data.size) + 260] = mem[_9896]
                                    idx = 0
                                    s = _9896 + ceil32(return_data.size) + 292
                                    t = _9896 + 32
                                    while idx < mem[_9896]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(uniswapV2RouterAddress)
                                    call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args 0, 0, 160, address(this.address), block.timestamp, mem[_9896 + ceil32(return_data.size) + 260 len (32 * mem[_9896]) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_9896 + ceil32(return_data.size) + 96] = 30
                                    mem[_9896 + ceil32(return_data.size) + 128] = 'SafeMath: subtraction overflow'
                                    if eth.balance(this.address) > eth.balance(this.address):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if eth.balance(this.address) < eth.balance(this.address):
                                        revert with 0, 17
                                    if not this.address:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not uniswapV2RouterAddress:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    allowance[address(this.address)][stor9].field_0 = 0
                                    emit Approval(0, this.address, uniswapV2RouterAddress);
                                    mem[_9896 + ceil32(return_data.size) + 228] = 0
                                    mem[_9896 + ceil32(return_data.size) + 260] = 0
                                    mem[_9896 + ceil32(return_data.size) + 292] = 0
                                    mem[_9896 + ceil32(return_data.size) + 324] = block.timestamp
                                    require ext_code.size(uniswapV2RouterAddress)
                                    call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                         gas gas_remaining wei
                                        args this.address, 0, 0, 0, 0, block.timestamp
                                    mem[_9896 + ceil32(return_data.size) + 160 len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 96
                                    emit SwapAndLiquify(uint256 arg1, uint256 arg2, uint256 arg3):
                                                        0,
                                    mem[_9896 + (2 * ceil32(return_data.size)) + 160] = 2
                                    mem[_9896 + (2 * ceil32(return_data.size)) + 192] = this.address
                                    require ext_code.size(uniswapV2RouterAddress)
                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                            gas gas_remaining wei
                                    mem[_9896 + (2 * ceil32(return_data.size)) + 256] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    mem[_9896 + (2 * ceil32(return_data.size)) + 224] = ext_call.return_data[12 len 20]
                                    if not this.address:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not uniswapV2RouterAddress:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    allowance[address(this.address)][stor9].field_0 = balanceOf[this.address]
                                    emit Approval(balanceOf[this.address], this.address, uniswapV2RouterAddress);
                                    mem[_9896 + (4 * ceil32(return_data.size)) + 256] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                    mem[_9896 + (4 * ceil32(return_data.size)) + 260] = balanceOf[this.address]
                                    mem[_9896 + (4 * ceil32(return_data.size)) + 292] = 0
                                    mem[_9896 + (4 * ceil32(return_data.size)) + 324] = 160
                                    mem[_9896 + (4 * ceil32(return_data.size)) + 420] = 2
                                    idx = 0
                                    s = _9896 + (4 * ceil32(return_data.size)) + 452
                                    t = _9896 + (2 * ceil32(return_data.size)) + 192
                                    while idx < mem[_9896 + (2 * ceil32(return_data.size)) + 160]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_9896 + (4 * ceil32(return_data.size)) + 356] = this.address
                                    mem[_9896 + (4 * ceil32(return_data.size)) + 388] = block.timestamp
                                    require ext_code.size(uniswapV2RouterAddress)
                                    call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args balanceOf[this.address], 0, 160, address(this.address), block.timestamp, mem[_9896 + (4 * ceil32(return_data.size)) + 420 len (32 * mem[_9896 + (2 * ceil32(return_data.size)) + 160]) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_9896 + (4 * ceil32(return_data.size)) + 256] = 30
                                    mem[_9896 + (4 * ceil32(return_data.size)) + 288] = 'SafeMath: subtraction overflow'
                                    if eth.balance(this.address) > eth.balance(this.address):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if eth.balance(this.address) < eth.balance(this.address):
                                        revert with 0, 17
                                    call marketingWalletAddress with:
                                         gas 2300 wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    uint8(stor23.field_0) = 0
                                    if not msg.sender:
                                        revert with 0, 'ERC20: transfer from the zero address'
                                    if not this.address:
                                        revert with 0, 'ERC20: transfer to the zero address'
                                    mem[_9896 + (4 * ceil32(return_data.size)) + 320] = 38
                                    mem[_9896 + (4 * ceil32(return_data.size)) + 352 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                    if _5500 > balanceOf[address(msg.sender)]:
                                        revert with 0, 
                                                    32,
                                                    38,
                                                    0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, Mask(208, 32, block.timestamp) >> 32 >> 48,
                                                    0
                                    if balanceOf[address(msg.sender)] < _5500:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)] -= _5500
                                    if balanceOf[this.address] > !_5500:
                                        revert with 0, 17
                                    if balanceOf[this.address] + _5500 < balanceOf[this.address]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(this.address)] = balanceOf[this.address] + _5500
                                    emit Transfer(_5500, msg.sender, this.address);
                                    if arg1 >= 3:
                                        revert with 0, 50
                                    mem[_9896 + (4 * ceil32(return_data.size)) + 416] = 0x12b8603f00000000000000000000000000000000000000000000000000000000
                                    mem[_9896 + (4 * ceil32(return_data.size)) + 420] = msg.sender
                                    mem[_9896 + (4 * ceil32(return_data.size)) + 452] = 64
                                    mem[_9896 + (4 * ceil32(return_data.size)) + 484] = mem[128]
                                    mem[_9896 + (4 * ceil32(return_data.size)) + 516 len ceil32(mem[128])] = mem[160 len ceil32(mem[128])]
                                    if ceil32(mem[128]) > mem[128]:
                                        mem[_9896 + (4 * ceil32(return_data.size)) + mem[128] + 516] = 0
                                    require ext_code.size(sub_20eea8b5[arg1])
                                    call sub_20eea8b5[arg1].createNode(address arg1, string arg2) with:
                                         gas gas_remaining wei
                                        args msg.sender, Array(len=mem[128], data=mem[_9896 + (4 * ceil32(return_data.size)) + 516 len ceil32(mem[128])])
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if stor27[address(msg.sender)] > -2:
                                        revert with 0, 17
                                    if stor27[address(msg.sender)] + 1 < stor27[address(msg.sender)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor27[address(msg.sender)]++
                                if balanceOf[this.address] and liquidityPoolFee > -1 / balanceOf[this.address]:
                                    revert with 0, 17
                                if not balanceOf[this.address]:
                                    revert with 0, 18
                                if balanceOf[this.address] * liquidityPoolFee / balanceOf[this.address] != liquidityPoolFee:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _9844 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_9844] = 26
                                mem[_9844 + 32] = 'SafeMath: division by zero'
                                _9862 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_9862] = 26
                                mem[_9862 + 32] = 'SafeMath: division by zero'
                                _9880 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_9880] = 30
                                mem[_9880 + 32] = 'SafeMath: subtraction overflow'
                                if balanceOf[this.address] * liquidityPoolFee / 100 / 2 > balanceOf[this.address] * liquidityPoolFee / 100:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if balanceOf[this.address] * liquidityPoolFee / 100 < balanceOf[this.address] * liquidityPoolFee / 100 / 2:
                                    revert with 0, 17
                                _9973 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                mem[_9973 + 32 len 64] = call.data[calldata.size len 64]
                                if 0 >= mem[_9973]:
                                    revert with 0, 50
                                mem[_9973 + 32] = this.address
                                require ext_code.size(uniswapV2RouterAddress)
                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                        gas gas_remaining wei
                                mem[_9973 + 96] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = _9973 + ceil32(return_data.size) + 96
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                if 1 >= mem[_9973]:
                                    revert with 0, 50
                                mem[_9973 + 64] = ext_call.return_data[12 len 20]
                                if not this.address:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not uniswapV2RouterAddress:
                                    revert with 0, 'ERC20: approve to the zero address'
                                mem[0] = uniswapV2RouterAddress
                                mem[32] = sha3(address(this.address), 1)
                                allowance[address(this.address)][stor9].field_0 = balanceOf[this.address] * liquidityPoolFee / 100 / 2
                                allowance[address(this.address)][stor9].field_255 = 0
                                emit Approval((balanceOf[this.address] * liquidityPoolFee / 100 / 2), this.address, uniswapV2RouterAddress);
                                mem[_9973 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                mem[_9973 + ceil32(return_data.size) + 100] = balanceOf[this.address] * liquidityPoolFee / 100 / 2
                                mem[_9973 + ceil32(return_data.size) + 132] = 0
                                mem[_9973 + ceil32(return_data.size) + 164] = 160
                                mem[_9973 + ceil32(return_data.size) + 260] = mem[_9973]
                                idx = 0
                                s = _9973 + ceil32(return_data.size) + 292
                                t = _9973 + 32
                                while idx < mem[_9973]:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(uniswapV2RouterAddress)
                                call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                     gas gas_remaining wei
                                    args Mask(255, 1, balanceOf[this.address] * liquidityPoolFee / 100), 0, 160, address(this.address), block.timestamp, mem[_9973 + ceil32(return_data.size) + 260 len (32 * mem[_9973]) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[_9973 + ceil32(return_data.size) + 96] = 30
                                mem[_9973 + ceil32(return_data.size) + 128] = 'SafeMath: subtraction overflow'
                                if eth.balance(this.address) > eth.balance(this.address):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if eth.balance(this.address) < eth.balance(this.address):
                                    revert with 0, 17
                                if not this.address:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not uniswapV2RouterAddress:
                                    revert with 0, 'ERC20: approve to the zero address'
                                allowance[address(this.address)][stor9].field_0 = (balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2)
                                emit Approval(((balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2)), this.address, uniswapV2RouterAddress);
                                mem[_9973 + ceil32(return_data.size) + 228] = 0
                                mem[_9973 + ceil32(return_data.size) + 260] = 0
                                mem[_9973 + ceil32(return_data.size) + 292] = 0
                                mem[_9973 + ceil32(return_data.size) + 324] = block.timestamp
                                require ext_code.size(uniswapV2RouterAddress)
                                call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                     gas gas_remaining wei
                                    args this.address, (balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2), 0, 0, 0, block.timestamp
                                mem[_9973 + ceil32(return_data.size) + 160 len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 96
                                emit SwapAndLiquify(Mask(255, 1, balanceOf[this.address] * liquidityPoolFee / 100), 0, (balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2));
                                mem[_9973 + (2 * ceil32(return_data.size)) + 160] = 2
                                mem[_9973 + (2 * ceil32(return_data.size)) + 192] = this.address
                                require ext_code.size(uniswapV2RouterAddress)
                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                        gas gas_remaining wei
                                mem[_9973 + (2 * ceil32(return_data.size)) + 256] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                mem[_9973 + (2 * ceil32(return_data.size)) + 224] = ext_call.return_data[12 len 20]
                                if not this.address:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not uniswapV2RouterAddress:
                                    revert with 0, 'ERC20: approve to the zero address'
                                allowance[address(this.address)][stor9].field_0 = balanceOf[this.address]
                                emit Approval(balanceOf[this.address], this.address, uniswapV2RouterAddress);
                                mem[_9973 + (4 * ceil32(return_data.size)) + 256] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                mem[_9973 + (4 * ceil32(return_data.size)) + 260] = balanceOf[this.address]
                                mem[_9973 + (4 * ceil32(return_data.size)) + 292] = 0
                                mem[_9973 + (4 * ceil32(return_data.size)) + 324] = 160
                                mem[_9973 + (4 * ceil32(return_data.size)) + 420] = 2
                                idx = 0
                                s = _9973 + (4 * ceil32(return_data.size)) + 452
                                t = _9973 + (2 * ceil32(return_data.size)) + 192
                                while idx < mem[_9973 + (2 * ceil32(return_data.size)) + 160]:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[_9973 + (4 * ceil32(return_data.size)) + 356] = this.address
                                mem[_9973 + (4 * ceil32(return_data.size)) + 388] = block.timestamp
                                require ext_code.size(uniswapV2RouterAddress)
                                call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                     gas gas_remaining wei
                                    args balanceOf[this.address], 0, 160, address(this.address), block.timestamp, mem[_9973 + (4 * ceil32(return_data.size)) + 420 len (32 * mem[_9973 + (2 * ceil32(return_data.size)) + 160]) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[_9973 + (4 * ceil32(return_data.size)) + 256] = 30
                                mem[_9973 + (4 * ceil32(return_data.size)) + 288] = 'SafeMath: subtraction overflow'
                                if eth.balance(this.address) > eth.balance(this.address):
                                    mem[_9973 + (4 * ceil32(return_data.size)) + 320] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[_9973 + (4 * ceil32(return_data.size)) + 324] = 32
                                    mem[_9973 + (4 * ceil32(return_data.size)) + 356] = 30
                                    mem[_9973 + (4 * ceil32(return_data.size)) + 388] = 'SafeMath: subtraction overflow'
                                    mem[_9973 + (4 * ceil32(return_data.size)) + 418] = 0
                                    revert with memory
                                      from _9973 + (4 * ceil32(return_data.size)) + 320
                                       len (5 * ceil32(return_data.size)) + 100
                                if eth.balance(this.address) < eth.balance(this.address):
                                    revert with 0, 17
                                call marketingWalletAddress with:
                                     gas 2300 wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                uint8(stor23.field_0) = 0
                                if not msg.sender:
                                    mem[_9973 + (4 * ceil32(return_data.size)) + 320] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[_9973 + (4 * ceil32(return_data.size)) + 324] = 32
                                    mem[_9973 + (4 * ceil32(return_data.size)) + 356] = 37
                                    mem[_9973 + (4 * ceil32(return_data.size)) + 388] = 'ERC20: transfer from the zero ad'
                                    mem[_9973 + (4 * ceil32(return_data.size)) + 420] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                    revert with memory
                                      from _9973 + (4 * ceil32(return_data.size)) + 320
                                       len (5 * ceil32(return_data.size)) + 132
                                if not this.address:
                                    mem[_9973 + (4 * ceil32(return_data.size)) + 320] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[_9973 + (4 * ceil32(return_data.size)) + 324] = 32
                                    mem[_9973 + (4 * ceil32(return_data.size)) + 356] = 35
                                    mem[_9973 + (4 * ceil32(return_data.size)) + 388] = 'ERC20: transfer to the zero addr'
                                    mem[_9973 + (4 * ceil32(return_data.size)) + 420] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                    revert with memory
                                      from _9973 + (4 * ceil32(return_data.size)) + 320
                                       len (5 * ceil32(return_data.size)) + 132
                                mem[_9973 + (4 * ceil32(return_data.size)) + 320] = 38
                                mem[_9973 + (4 * ceil32(return_data.size)) + 352 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                if _5500 > balanceOf[address(msg.sender)]:
                                    mem[_9973 + (4 * ceil32(return_data.size)) + 416] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[_9973 + (4 * ceil32(return_data.size)) + 420] = 32
                                    mem[_9973 + (4 * ceil32(return_data.size)) + 452] = 38
                                    mem[_9973 + (4 * ceil32(return_data.size)) + 484 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, Mask(208, 32, block.timestamp) >> 32
                                    mem[_9973 + (4 * ceil32(return_data.size)) + 522] = 0
                                    revert with memory
                                      from _9973 + (4 * ceil32(return_data.size)) + 416
                                       len (5 * ceil32(return_data.size)) + 132
                                if balanceOf[address(msg.sender)] < _5500:
                                    revert with 0, 17
                                balanceOf[address(msg.sender)] -= _5500
                                if balanceOf[this.address] > !_5500:
                                    revert with 0, 17
                                if balanceOf[this.address] + _5500 >= balanceOf[this.address]:
                                    balanceOf[address(this.address)] = balanceOf[this.address] + _5500
                                    emit Transfer(_5500, msg.sender, this.address);
                                    if arg1 >= 3:
                                        revert with 0, 50
                                    mem[_9973 + (4 * ceil32(return_data.size)) + 416] = 0x12b8603f00000000000000000000000000000000000000000000000000000000
                                    mem[_9973 + (4 * ceil32(return_data.size)) + 420] = msg.sender
                                    mem[_9973 + (4 * ceil32(return_data.size)) + 452] = 64
                                    mem[_9973 + (4 * ceil32(return_data.size)) + 484] = mem[128]
                                    mem[_9973 + (4 * ceil32(return_data.size)) + 516 len ceil32(mem[128])] = mem[160 len ceil32(mem[128])]
                                    if ceil32(mem[128]) > mem[128]:
                                        mem[_9973 + (4 * ceil32(return_data.size)) + mem[128] + 516] = 0
                                    require ext_code.size(sub_20eea8b5[arg1])
                                    call sub_20eea8b5[arg1].createNode(address arg1, string arg2) with:
                                         gas gas_remaining wei
                                        args mem[_9973 + (4 * ceil32(return_data.size)) + 420 len ceil32(mem[128]) + (5 * ceil32(return_data.size)) + 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if stor27[address(msg.sender)] > -2:
                                        revert with 0, 17
                                    if stor27[address(msg.sender)] + 1 >= stor27[address(msg.sender)]:
                                        stor27[address(msg.sender)]++
                                mem[_9973 + (4 * ceil32(return_data.size)) + 416] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[_9973 + (4 * ceil32(return_data.size)) + 420] = 32
                                mem[_9973 + (4 * ceil32(return_data.size)) + 452] = 27
                                mem[_9973 + (4 * ceil32(return_data.size)) + 484] = 'SafeMath: addition overflow'
                                revert with memory
                                  from _9973 + (4 * ceil32(return_data.size)) + 416
                                   len (5 * ceil32(return_data.size)) + 100
                            idx = 0
                            while idx < 3:
                                mem[mem[64] + 4] = msg.sender
                                mem[mem[64] + 36] = 0
                                require ext_code.size(sub_20eea8b5[idx])
                                staticcall sub_20eea8b5[idx].0x80e9be34 with:
                                        gas gas_remaining wei
                                       args msg.sender, 0
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _5344 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _5374 = mem[_5344]
                                if not distributionPoolAddress:
                                    revert with 0, 'ERC20: transfer from the zero address'
                                if not msg.sender:
                                    revert with 0, 'ERC20: transfer to the zero address'
                                _5430 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_5430] = 38
                                mem[_5430 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                mem[32] = 0
                                if _5374 > balanceOf[stor12]:
                                    _5458 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 38
                                    idx = 0
                                    while idx < 38:
                                        mem[idx + _5458 + 68] = mem[_5430 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_5458 + 106] = 0
                                    revert with memory
                                      from mem[64]
                                       len _5458 + -mem[64] + 132
                                if balanceOf[stor12] < _5374:
                                    revert with 0, 17
                                balanceOf[stor12] -= _5374
                                if balanceOf[msg.sender] > !_5374:
                                    revert with 0, 17
                                if balanceOf[msg.sender] + _5374 < balanceOf[msg.sender]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = msg.sender
                                mem[32] = 0
                                balanceOf[address(msg.sender)] = balanceOf[msg.sender] + _5374
                                emit Transfer(_5374, distributionPoolAddress, msg.sender);
                                if idx >= 3:
                                    revert with 0, 50
                                mem[mem[64]] = 0xd74037e500000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = msg.sender
                                mem[mem[64] + 36] = 0
                                mem[mem[64] + 68] = 0
                                require ext_code.size(sub_20eea8b5[idx])
                                call sub_20eea8b5[idx].0xd74037e5 with:
                                     gas gas_remaining wei
                                    args msg.sender, 0, 0
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                            if mem[128] <= 3:
                                revert with 0, 'NODE CREATION: NAME SIZE INVALID'
                            if mem[128] >= 32:
                                revert with 0, 'NODE CREATION: NAME SIZE INVALID'
                            if sub_6cdc78b3 <= stor27[msg.sender]:
                                revert with 0, 'cannot create node more than 100'
                            if not msg.sender:
                                revert with 0, 'NODE CREATION:  creation from the zero address'
                            mem[0] = msg.sender
                            mem[32] = 25
                            if stor25[address(msg.sender)]:
                                revert with 0, 'NODE CREATION: Blacklisted address'
                            if futurUsePoolAddress == msg.sender:
                                revert with 0, 'NODE CREATION: futur and rewardsPool cannot create node'
                            if distributionPoolAddress == msg.sender:
                                revert with 0, 'NODE CREATION: futur and rewardsPool cannot create node'
                            if arg1 >= 3:
                                revert with 0, 50
                            require ext_code.size(sub_20eea8b5[arg1])
                            staticcall sub_20eea8b5[arg1].nodePrice() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _5436 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _5499 = mem[_5436]
                            if balanceOf[address(msg.sender)] < mem[_5436]:
                                revert with 0, 'NODE CREATION: Balance too low for creation.'
                            mem[0] = this.address
                            mem[32] = 0
                            if balanceOf[this.address] < swapTokensAmount:
                                if not msg.sender:
                                    revert with 0, 'ERC20: transfer from the zero address'
                                if not this.address:
                                    revert with 0, 'ERC20: transfer to the zero address'
                                _5839 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_5839] = 38
                                mem[_5839 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                if _5499 > balanceOf[address(msg.sender)]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 38
                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_5839 + 70 len 26]
                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                if balanceOf[address(msg.sender)] < _5499:
                                    revert with 0, 17
                                balanceOf[address(msg.sender)] -= _5499
                                if balanceOf[this.address] > !_5499:
                                    revert with 0, 17
                                if balanceOf[this.address] + _5499 < balanceOf[this.address]:
                                    revert with 0, 'SafeMath: addition overflow'
                                balanceOf[address(this.address)] = balanceOf[this.address] + _5499
                                emit Transfer(_5499, msg.sender, this.address);
                                if arg1 >= 3:
                                    revert with 0, 50
                                mem[mem[64]] = 0x12b8603f00000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = msg.sender
                                mem[mem[64] + 36] = 64
                                mem[mem[64] + 68] = mem[128]
                                mem[mem[64] + 100 len ceil32(mem[128])] = mem[160 len ceil32(mem[128])]
                                if ceil32(mem[128]) > mem[128]:
                                    mem[mem[64] + mem[128] + 100] = 0
                                require ext_code.size(sub_20eea8b5[arg1])
                                call sub_20eea8b5[arg1].createNode(address arg1, string arg2) with:
                                     gas gas_remaining wei
                                    args msg.sender, Array(len=mem[128], data=mem[mem[64] + 100 len ceil32(mem[128])])
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if stor27[address(msg.sender)] > -2:
                                    revert with 0, 17
                                if stor27[address(msg.sender)] + 1 < stor27[address(msg.sender)]:
                                    revert with 0, 'SafeMath: addition overflow'
                            else:
                                if not uint8(stor23.field_8):
                                    if not msg.sender:
                                        revert with 0, 'ERC20: transfer from the zero address'
                                    if not this.address:
                                        revert with 0, 'ERC20: transfer to the zero address'
                                    _5886 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_5886] = 38
                                    mem[_5886 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                    if _5499 > balanceOf[address(msg.sender)]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 38
                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_5886 + 70 len 26]
                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                    if balanceOf[address(msg.sender)] < _5499:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)] -= _5499
                                    if balanceOf[this.address] > !_5499:
                                        revert with 0, 17
                                    if balanceOf[this.address] + _5499 < balanceOf[this.address]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(this.address)] = balanceOf[this.address] + _5499
                                    emit Transfer(_5499, msg.sender, this.address);
                                    if arg1 >= 3:
                                        revert with 0, 50
                                    mem[mem[64]] = 0x12b8603f00000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = 64
                                    mem[mem[64] + 68] = mem[128]
                                    mem[mem[64] + 100 len ceil32(mem[128])] = mem[160 len ceil32(mem[128])]
                                    if ceil32(mem[128]) > mem[128]:
                                        mem[mem[64] + mem[128] + 100] = 0
                                    require ext_code.size(sub_20eea8b5[arg1])
                                    call sub_20eea8b5[arg1].createNode(address arg1, string arg2) with:
                                         gas gas_remaining wei
                                        args msg.sender, Array(len=mem[128], data=mem[mem[64] + 100 len ceil32(mem[128])])
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if stor27[address(msg.sender)] > -2:
                                        revert with 0, 17
                                    if stor27[address(msg.sender)] + 1 < stor27[address(msg.sender)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                else:
                                    if uint8(stor23.field_0):
                                        if not msg.sender:
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not this.address:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        _5940 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_5940] = 38
                                        mem[_5940 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                        if _5499 > balanceOf[address(msg.sender)]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 38
                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_5940 + 70 len 26]
                                            idx = 64
                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                        if balanceOf[address(msg.sender)] < _5499:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] -= _5499
                                        if balanceOf[this.address] > !_5499:
                                            revert with 0, 17
                                        if balanceOf[this.address] + _5499 < balanceOf[this.address]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(this.address)] = balanceOf[this.address] + _5499
                                        emit Transfer(_5499, msg.sender, this.address);
                                        if arg1 >= 3:
                                            revert with 0, 50
                                        mem[mem[64]] = 0x12b8603f00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 64
                                        mem[mem[64] + 68] = mem[128]
                                        mem[mem[64] + 100 len ceil32(mem[128])] = mem[160 len ceil32(mem[128])]
                                        if ceil32(mem[128]) > mem[128]:
                                            mem[mem[64] + mem[128] + 100] = 0
                                        require ext_code.size(sub_20eea8b5[arg1])
                                        call sub_20eea8b5[arg1].createNode(address arg1, string arg2) with:
                                             gas gas_remaining wei
                                            args msg.sender, Array(len=mem[128], data=mem[mem[64] + 100 len ceil32(mem[128])])
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if stor27[address(msg.sender)] > -2:
                                            revert with 0, 17
                                        if stor27[address(msg.sender)] + 1 < stor27[address(msg.sender)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                    else:
                                        if owner == msg.sender:
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not this.address:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            _5956 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_5956] = 38
                                            mem[_5956 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                            if _5499 > balanceOf[address(msg.sender)]:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 38
                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_5956 + 70 len 26]
                                                var76001 = 64
                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                            if balanceOf[address(msg.sender)] < _5499:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] -= _5499
                                            if balanceOf[this.address] > !_5499:
                                                revert with 0, 17
                                            if balanceOf[this.address] + _5499 < balanceOf[this.address]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(this.address)] = balanceOf[this.address] + _5499
                                            emit Transfer(_5499, msg.sender, this.address);
                                            if arg1 >= 3:
                                                revert with 0, 50
                                            mem[mem[64]] = 0x12b8603f00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 64
                                            mem[mem[64] + 68] = mem[128]
                                            mem[mem[64] + 100 len ceil32(mem[128])] = mem[160 len ceil32(mem[128])]
                                            if ceil32(mem[128]) > mem[128]:
                                                mem[mem[64] + mem[128] + 100] = 0
                                            require ext_code.size(sub_20eea8b5[arg1])
                                            call sub_20eea8b5[arg1].createNode(address arg1, string arg2) with:
                                                 gas gas_remaining wei
                                                args msg.sender, Array(len=mem[128], data=mem[mem[64] + 100 len ceil32(mem[128])])
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if stor27[address(msg.sender)] > -2:
                                                revert with 0, 17
                                            if stor27[address(msg.sender)] + 1 < stor27[address(msg.sender)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                        else:
                                            mem[0] = msg.sender
                                            mem[32] = 26
                                            if stor26[address(msg.sender)]:
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not this.address:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                _5994 = mem[64]
                                                mem[64] = mem[64] + 96
                                                mem[_5994] = 38
                                                mem[_5994 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                if _5499 > balanceOf[address(msg.sender)]:
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 38
                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_5994 + 70 len 26]
                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                if balanceOf[address(msg.sender)] < _5499:
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] -= _5499
                                                if balanceOf[this.address] > !_5499:
                                                    revert with 0, 17
                                                if balanceOf[this.address] + _5499 < balanceOf[this.address]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(this.address)] = balanceOf[this.address] + _5499
                                                emit Transfer(_5499, msg.sender, this.address);
                                                if arg1 >= 3:
                                                    revert with 0, 50
                                                mem[mem[64]] = 0x12b8603f00000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 64
                                                mem[mem[64] + 68] = mem[128]
                                                mem[mem[64] + 100 len ceil32(mem[128])] = mem[160 len ceil32(mem[128])]
                                                if ceil32(mem[128]) > mem[128]:
                                                    mem[mem[64] + mem[128] + 100] = 0
                                                require ext_code.size(sub_20eea8b5[arg1])
                                                call sub_20eea8b5[arg1].createNode(address arg1, string arg2) with:
                                                     gas gas_remaining wei
                                                    args msg.sender, Array(len=mem[128], data=mem[mem[64] + 100 len ceil32(mem[128])])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if stor27[address(msg.sender)] > -2:
                                                    revert with 0, 17
                                                if stor27[address(msg.sender)] + 1 < stor27[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                            else:
                                                uint8(stor23.field_0) = 1
                                                if not balanceOf[this.address]:
                                                    _6041 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_6041] = 26
                                                    mem[_6041 + 32] = 'SafeMath: division by zero'
                                                    _6375 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_6375] = 26
                                                    mem[_6375 + 32] = 'SafeMath: division by zero'
                                                    _6510 = mem[64]
                                                    mem[mem[64]] = 2
                                                    mem[64] = mem[64] + 96
                                                    mem[_6510 + 32 len 64] = call.data[calldata.size len 64]
                                                    if 0 >= mem[_6510]:
                                                        revert with 0, 50
                                                    mem[_6510 + 32] = this.address
                                                    require ext_code.size(uniswapV2RouterAddress)
                                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                                            gas gas_remaining wei
                                                    mem[_6510 + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[64] = _6510 + ceil32(return_data.size) + 96
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                    if 1 >= mem[_6510]:
                                                        revert with 0, 50
                                                    mem[_6510 + 64] = ext_call.return_data[12 len 20]
                                                    if not this.address:
                                                        revert with 0, 'ERC20: approve from the zero address'
                                                    if not uniswapV2RouterAddress:
                                                        revert with 0, 'ERC20: approve to the zero address'
                                                    mem[0] = uniswapV2RouterAddress
                                                    mem[32] = sha3(address(this.address), 1)
                                                    allowance[address(this.address)][stor9].field_0 = 0
                                                    emit Approval(0, this.address, uniswapV2RouterAddress);
                                                    mem[_6510 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                    mem[_6510 + ceil32(return_data.size) + 100] = 0
                                                    mem[_6510 + ceil32(return_data.size) + 132] = 0
                                                    mem[_6510 + ceil32(return_data.size) + 164] = 160
                                                    mem[_6510 + ceil32(return_data.size) + 260] = mem[_6510]
                                                    idx = 0
                                                    s = _6510 + ceil32(return_data.size) + 292
                                                    t = _6510 + 32
                                                    while idx < mem[_6510]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_6510 + ceil32(return_data.size) + 196] = this.address
                                                    mem[_6510 + ceil32(return_data.size) + 228] = block.timestamp
                                                    require ext_code.size(uniswapV2RouterAddress)
                                                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _6510 + ceil32(return_data.size) + (32 * mem[_6510]) + -mem[64] + 288]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _8771 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_8771] = 30
                                                    mem[_8771 + 32] = 'SafeMath: subtraction overflow'
                                                    if eth.balance(this.address) > eth.balance(this.address):
                                                        var124001 = 32
                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                    if eth.balance(this.address) < eth.balance(this.address):
                                                        revert with 0, 17
                                                    call distributionPoolAddress with:
                                                         gas 2300 wei
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _9050 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_9050] = 30
                                                    mem[_9050 + 32] = 'SafeMath: subtraction overflow'
                                                    if not this.address:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not distributionPoolAddress:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    _9303 = mem[64]
                                                    mem[64] = mem[64] + 96
                                                    mem[_9303] = 38
                                                    mem[_9303 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                    if 0 > balanceOf[address(this.address)]:
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 38
                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_9303 + 70 len 26]
                                                        var144001 = 64
                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                    if balanceOf[address(this.address)] < 0:
                                                        revert with 0, 17
                                                    if balanceOf[stor12] > -1:
                                                        revert with 0, 17
                                                    if balanceOf[stor12] < balanceOf[stor12]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = distributionPoolAddress
                                                    mem[32] = 0
                                                    balanceOf[stor12] = balanceOf[stor12]
                                                    emit Transfer(0, this.address, distributionPoolAddress);
                                                    if balanceOf[this.address]:
                                                        if balanceOf[this.address] and liquidityPoolFee > -1 / balanceOf[this.address]:
                                                            revert with 0, 17
                                                        if not balanceOf[this.address]:
                                                            revert with 0, 18
                                                        if balanceOf[this.address] * liquidityPoolFee / balanceOf[this.address] != liquidityPoolFee:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _9843 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_9843] = 26
                                                        mem[_9843 + 32] = 'SafeMath: division by zero'
                                                        _9861 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_9861] = 26
                                                        mem[_9861 + 32] = 'SafeMath: division by zero'
                                                        _9879 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_9879] = 30
                                                        mem[_9879 + 32] = 'SafeMath: subtraction overflow'
                                                        if balanceOf[this.address] * liquidityPoolFee / 100 / 2 > balanceOf[this.address] * liquidityPoolFee / 100:
                                                            var186001 = 32
                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                        if balanceOf[this.address] * liquidityPoolFee / 100 < balanceOf[this.address] * liquidityPoolFee / 100 / 2:
                                                            revert with 0, 17
                                                        _9971 = mem[64]
                                                        mem[mem[64]] = 2
                                                        mem[64] = mem[64] + 96
                                                        mem[_9971 + 32 len 64] = call.data[calldata.size len 64]
                                                        if 0 >= mem[_9971]:
                                                            revert with 0, 50
                                                        mem[_9971 + 32] = this.address
                                                        require ext_code.size(uniswapV2RouterAddress)
                                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                gas gas_remaining wei
                                                        mem[_9971 + 96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[64] = _9971 + ceil32(return_data.size) + 96
                                                        require return_data.size >= 32
                                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                        if 1 >= mem[_9971]:
                                                            revert with 0, 50
                                                        mem[_9971 + 64] = ext_call.return_data[12 len 20]
                                                        if not this.address:
                                                            revert with 0, 'ERC20: approve from the zero address'
                                                        if not uniswapV2RouterAddress:
                                                            revert with 0, 'ERC20: approve to the zero address'
                                                        mem[0] = uniswapV2RouterAddress
                                                        mem[32] = sha3(address(this.address), 1)
                                                        allowance[address(this.address)][stor9].field_0 = balanceOf[this.address] * liquidityPoolFee / 100 / 2
                                                        allowance[address(this.address)][stor9].field_255 = 0
                                                        emit Approval((balanceOf[this.address] * liquidityPoolFee / 100 / 2), this.address, uniswapV2RouterAddress);
                                                        mem[_9971 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                        mem[_9971 + ceil32(return_data.size) + 100] = balanceOf[this.address] * liquidityPoolFee / 100 / 2
                                                        mem[_9971 + ceil32(return_data.size) + 132] = 0
                                                        mem[_9971 + ceil32(return_data.size) + 164] = 160
                                                        mem[_9971 + ceil32(return_data.size) + 260] = mem[_9971]
                                                        idx = 0
                                                        s = _9971 + ceil32(return_data.size) + 292
                                                        t = _9971 + 32
                                                        while idx < mem[_9971]:
                                                            mem[s] = mem[t + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        require ext_code.size(uniswapV2RouterAddress)
                                                        call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                             gas gas_remaining wei
                                                            args Mask(255, 1, balanceOf[this.address] * liquidityPoolFee / 100), 0, 160, address(this.address), block.timestamp, mem[_9971 + ceil32(return_data.size) + 260 len (32 * mem[_9971]) + 32]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[_9971 + ceil32(return_data.size) + 96] = 30
                                                        mem[_9971 + ceil32(return_data.size) + 128] = 'SafeMath: subtraction overflow'
                                                        if eth.balance(this.address) > eth.balance(this.address):
                                                            var218001 = 32
                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                        if eth.balance(this.address) < eth.balance(this.address):
                                                            revert with 0, 17
                                                        if not this.address:
                                                            revert with 0, 'ERC20: approve from the zero address'
                                                        if not uniswapV2RouterAddress:
                                                            revert with 0, 'ERC20: approve to the zero address'
                                                        allowance[address(this.address)][stor9].field_0 = (balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2)
                                                        emit Approval(((balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2)), this.address, uniswapV2RouterAddress);
                                                        mem[_9971 + ceil32(return_data.size) + 228] = 0
                                                        mem[_9971 + ceil32(return_data.size) + 260] = 0
                                                        mem[_9971 + ceil32(return_data.size) + 292] = 0
                                                        mem[_9971 + ceil32(return_data.size) + 324] = block.timestamp
                                                        require ext_code.size(uniswapV2RouterAddress)
                                                        call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                             gas gas_remaining wei
                                                            args this.address, (balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2), 0, 0, 0, block.timestamp
                                                        mem[_9971 + ceil32(return_data.size) + 160 len 96] = ext_call.return_data[0 len 96]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 96
                                                        emit SwapAndLiquify(Mask(255, 1, balanceOf[this.address] * liquidityPoolFee / 100), 0, (balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2));
                                                        mem[_9971 + (2 * ceil32(return_data.size)) + 160] = 2
                                                        mem[_9971 + (2 * ceil32(return_data.size)) + 192] = this.address
                                                        require ext_code.size(uniswapV2RouterAddress)
                                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                gas gas_remaining wei
                                                        mem[_9971 + (2 * ceil32(return_data.size)) + 256] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                        mem[_9971 + (2 * ceil32(return_data.size)) + 224] = ext_call.return_data[12 len 20]
                                                        if not this.address:
                                                            revert with 0, 'ERC20: approve from the zero address'
                                                        if not uniswapV2RouterAddress:
                                                            revert with 0, 'ERC20: approve to the zero address'
                                                        allowance[address(this.address)][stor9].field_0 = balanceOf[this.address]
                                                        emit Approval(balanceOf[this.address], this.address, uniswapV2RouterAddress);
                                                        mem[_9971 + (4 * ceil32(return_data.size)) + 256] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                        mem[_9971 + (4 * ceil32(return_data.size)) + 260] = balanceOf[this.address]
                                                        mem[_9971 + (4 * ceil32(return_data.size)) + 292] = 0
                                                        mem[_9971 + (4 * ceil32(return_data.size)) + 324] = 160
                                                        mem[_9971 + (4 * ceil32(return_data.size)) + 420] = 2
                                                        idx = 0
                                                        s = _9971 + (4 * ceil32(return_data.size)) + 452
                                                        t = _9971 + (2 * ceil32(return_data.size)) + 192
                                                        while idx < mem[_9971 + (2 * ceil32(return_data.size)) + 160]:
                                                            mem[s] = mem[t + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[_9971 + (4 * ceil32(return_data.size)) + 356] = this.address
                                                        mem[_9971 + (4 * ceil32(return_data.size)) + 388] = block.timestamp
                                                        require ext_code.size(uniswapV2RouterAddress)
                                                        call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                             gas gas_remaining wei
                                                            args balanceOf[this.address], 0, 160, address(this.address), block.timestamp, mem[_9971 + (4 * ceil32(return_data.size)) + 420 len (32 * mem[_9971 + (2 * ceil32(return_data.size)) + 160]) + 32]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[_9971 + (4 * ceil32(return_data.size)) + 256] = 30
                                                        mem[_9971 + (4 * ceil32(return_data.size)) + 288] = 'SafeMath: subtraction overflow'
                                                        if eth.balance(this.address) > eth.balance(this.address):
                                                            var264001 = 32
                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                        if eth.balance(this.address) < eth.balance(this.address):
                                                            revert with 0, 17
                                                        call marketingWalletAddress with:
                                                             gas 2300 wei
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        uint8(stor23.field_0) = 0
                                                        if not msg.sender:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not this.address:
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        mem[_9971 + (4 * ceil32(return_data.size)) + 320] = 38
                                                        mem[_9971 + (4 * ceil32(return_data.size)) + 352 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                        if _5499 > balanceOf[address(msg.sender)]:
                                                            revert with 0, 
                                                                        32,
                                                                        38,
                                                                        0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, Mask(208, 32, block.timestamp) >> 32 >> 48,
                                                                        0
                                                        if balanceOf[address(msg.sender)] < _5499:
                                                            revert with 0, 17
                                                        balanceOf[address(msg.sender)] -= _5499
                                                        if balanceOf[this.address] > !_5499:
                                                            revert with 0, 17
                                                        if balanceOf[this.address] + _5499 < balanceOf[this.address]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        balanceOf[address(this.address)] = balanceOf[this.address] + _5499
                                                        emit Transfer(_5499, msg.sender, this.address);
                                                        if arg1 >= 3:
                                                            revert with 0, 50
                                                        mem[_9971 + (4 * ceil32(return_data.size)) + 416] = 0x12b8603f00000000000000000000000000000000000000000000000000000000
                                                        mem[_9971 + (4 * ceil32(return_data.size)) + 420] = msg.sender
                                                        mem[_9971 + (4 * ceil32(return_data.size)) + 452] = 64
                                                        mem[_9971 + (4 * ceil32(return_data.size)) + 484] = mem[128]
                                                        mem[_9971 + (4 * ceil32(return_data.size)) + 516 len ceil32(mem[128])] = mem[160 len ceil32(mem[128])]
                                                        if ceil32(mem[128]) > mem[128]:
                                                            mem[_9971 + (4 * ceil32(return_data.size)) + mem[128] + 516] = 0
                                                        require ext_code.size(sub_20eea8b5[arg1])
                                                        call sub_20eea8b5[arg1].createNode(address arg1, string arg2) with:
                                                             gas gas_remaining wei
                                                            args msg.sender, Array(len=mem[128], data=mem[_9971 + (4 * ceil32(return_data.size)) + 516 len ceil32(mem[128])])
                                                    else:
                                                        _9708 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_9708] = 26
                                                        mem[_9708 + 32] = 'SafeMath: division by zero'
                                                        _9852 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_9852] = 26
                                                        mem[_9852 + 32] = 'SafeMath: division by zero'
                                                        _9870 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_9870] = 30
                                                        mem[_9870 + 32] = 'SafeMath: subtraction overflow'
                                                        _9893 = mem[64]
                                                        mem[mem[64]] = 2
                                                        mem[64] = mem[64] + 96
                                                        mem[_9893 + 32 len 64] = call.data[calldata.size len 64]
                                                        if 0 >= mem[_9893]:
                                                            revert with 0, 50
                                                        mem[_9893 + 32] = this.address
                                                        require ext_code.size(uniswapV2RouterAddress)
                                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                gas gas_remaining wei
                                                        mem[_9893 + 96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[64] = _9893 + ceil32(return_data.size) + 96
                                                        require return_data.size >= 32
                                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                        if 1 >= mem[_9893]:
                                                            revert with 0, 50
                                                        mem[_9893 + 64] = ext_call.return_data[12 len 20]
                                                        if not this.address:
                                                            revert with 0, 'ERC20: approve from the zero address'
                                                        if not uniswapV2RouterAddress:
                                                            revert with 0, 'ERC20: approve to the zero address'
                                                        mem[0] = uniswapV2RouterAddress
                                                        mem[32] = sha3(address(this.address), 1)
                                                        allowance[address(this.address)][stor9].field_0 = 0
                                                        emit Approval(0, this.address, uniswapV2RouterAddress);
                                                        mem[_9893 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                        mem[_9893 + ceil32(return_data.size) + 100] = 0
                                                        mem[_9893 + ceil32(return_data.size) + 132] = 0
                                                        mem[_9893 + ceil32(return_data.size) + 164] = 160
                                                        mem[_9893 + ceil32(return_data.size) + 260] = mem[_9893]
                                                        idx = 0
                                                        s = _9893 + ceil32(return_data.size) + 292
                                                        t = _9893 + 32
                                                        while idx < mem[_9893]:
                                                            mem[s] = mem[t + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[_9893 + ceil32(return_data.size) + 196] = this.address
                                                        mem[_9893 + ceil32(return_data.size) + 228] = block.timestamp
                                                        require ext_code.size(uniswapV2RouterAddress)
                                                        call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                             gas gas_remaining wei
                                                            args mem[mem[64] + 4 len _9893 + ceil32(return_data.size) + (32 * mem[_9893]) + -mem[64] + 288]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _12033 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_12033] = 30
                                                        mem[_12033 + 32] = 'SafeMath: subtraction overflow'
                                                        if eth.balance(this.address) > eth.balance(this.address):
                                                            var212001 = 32
                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                        if eth.balance(this.address) < eth.balance(this.address):
                                                            revert with 0, 17
                                                        if not this.address:
                                                            revert with 0, 'ERC20: approve from the zero address'
                                                        if not uniswapV2RouterAddress:
                                                            revert with 0, 'ERC20: approve to the zero address'
                                                        mem[0] = uniswapV2RouterAddress
                                                        mem[32] = sha3(address(this.address), 1)
                                                        allowance[address(this.address)][stor9].field_0 = 0
                                                        emit Approval(0, this.address, uniswapV2RouterAddress);
                                                        mem[mem[64] + 68] = 0
                                                        mem[mem[64] + 100] = 0
                                                        mem[mem[64] + 132] = 0
                                                        mem[mem[64] + 164] = block.timestamp
                                                        require ext_code.size(uniswapV2RouterAddress)
                                                        call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                             gas gas_remaining wei
                                                            args this.address, 0, 0, 0, 0, block.timestamp
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 96
                                                        mem[mem[64] + 32] = 0
                                                        mem[mem[64] + 64] = 0
                                                        emit SwapAndLiquify(uint256 arg1, uint256 arg2, uint256 arg3):
                                                                            0,
                                                        mem[0] = this.address
                                                        mem[32] = 0
                                                        _12578 = mem[64]
                                                        mem[mem[64]] = 2
                                                        mem[64] = mem[64] + 96
                                                        mem[_12578 + 32 len 64] = call.data[calldata.size len 64]
                                                        if 0 >= mem[_12578]:
                                                            revert with 0, 50
                                                        mem[_12578 + 32] = this.address
                                                        require ext_code.size(uniswapV2RouterAddress)
                                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                gas gas_remaining wei
                                                        mem[_12578 + 96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[64] = _12578 + ceil32(return_data.size) + 96
                                                        require return_data.size >= 32
                                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                        if 1 >= mem[_12578]:
                                                            revert with 0, 50
                                                        mem[_12578 + 64] = ext_call.return_data[12 len 20]
                                                        if not this.address:
                                                            revert with 0, 'ERC20: approve from the zero address'
                                                        if not uniswapV2RouterAddress:
                                                            revert with 0, 'ERC20: approve to the zero address'
                                                        mem[0] = uniswapV2RouterAddress
                                                        mem[32] = sha3(address(this.address), 1)
                                                        allowance[address(this.address)][stor9].field_0 = balanceOf[this.address]
                                                        emit Approval(balanceOf[this.address], this.address, uniswapV2RouterAddress);
                                                        mem[_12578 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                        mem[_12578 + ceil32(return_data.size) + 100] = balanceOf[this.address]
                                                        mem[_12578 + ceil32(return_data.size) + 132] = 0
                                                        mem[_12578 + ceil32(return_data.size) + 164] = 160
                                                        mem[_12578 + ceil32(return_data.size) + 260] = mem[_12578]
                                                        idx = 0
                                                        s = _12578 + ceil32(return_data.size) + 292
                                                        t = _12578 + 32
                                                        while idx < mem[_12578]:
                                                            mem[s] = mem[t + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[_12578 + ceil32(return_data.size) + 196] = this.address
                                                        mem[_12578 + ceil32(return_data.size) + 228] = block.timestamp
                                                        require ext_code.size(uniswapV2RouterAddress)
                                                        call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                             gas gas_remaining wei
                                                            args mem[mem[64] + 4 len _12578 + ceil32(return_data.size) + (32 * mem[_12578]) + -mem[64] + 288]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _13689 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_13689] = 30
                                                        mem[_13689 + 32] = 'SafeMath: subtraction overflow'
                                                        if eth.balance(this.address) > eth.balance(this.address):
                                                            var258001 = 32
                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                        if eth.balance(this.address) < eth.balance(this.address):
                                                            revert with 0, 17
                                                        call marketingWalletAddress with:
                                                             gas 2300 wei
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        uint8(stor23.field_0) = 0
                                                        if not msg.sender:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not this.address:
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        _13843 = mem[64]
                                                        mem[64] = mem[64] + 96
                                                        mem[_13843] = 38
                                                        mem[_13843 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                        if _5499 > balanceOf[address(msg.sender)]:
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 38
                                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_13843 + 70 len 26]
                                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                        if balanceOf[address(msg.sender)] < _5499:
                                                            revert with 0, 17
                                                        balanceOf[address(msg.sender)] -= _5499
                                                        if balanceOf[this.address] > !_5499:
                                                            revert with 0, 17
                                                        if balanceOf[this.address] + _5499 < balanceOf[this.address]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        balanceOf[address(this.address)] = balanceOf[this.address] + _5499
                                                        emit Transfer(_5499, msg.sender, this.address);
                                                        if arg1 >= 3:
                                                            revert with 0, 50
                                                        mem[mem[64]] = 0x12b8603f00000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = msg.sender
                                                        mem[mem[64] + 36] = 64
                                                        mem[mem[64] + 68] = mem[128]
                                                        mem[mem[64] + 100 len ceil32(mem[128])] = mem[160 len ceil32(mem[128])]
                                                        if ceil32(mem[128]) > mem[128]:
                                                            mem[mem[64] + mem[128] + 100] = 0
                                                        require ext_code.size(sub_20eea8b5[arg1])
                                                        call sub_20eea8b5[arg1].createNode(address arg1, string arg2) with:
                                                             gas gas_remaining wei
                                                            args msg.sender, Array(len=mem[128], data=mem[mem[64] + 100 len ceil32(mem[128])])
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    if stor27[address(msg.sender)] > -2:
                                                        revert with 0, 17
                                                    if stor27[address(msg.sender)] + 1 < stor27[address(msg.sender)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                else:
                                                    if balanceOf[this.address] and rewardsFee > -1 / balanceOf[this.address]:
                                                        revert with 0, 17
                                                    if not balanceOf[this.address]:
                                                        revert with 0, 18
                                                    if balanceOf[this.address] * rewardsFee / balanceOf[this.address] != rewardsFee:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    _6125 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_6125] = 26
                                                    mem[_6125 + 32] = 'SafeMath: division by zero'
                                                    if not balanceOf[this.address] * rewardsFee / 100:
                                                        _6465 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_6465] = 26
                                                        mem[_6465 + 32] = 'SafeMath: division by zero'
                                                        _6653 = mem[64]
                                                        mem[mem[64]] = 2
                                                        mem[64] = mem[64] + 96
                                                        mem[_6653 + 32 len 64] = call.data[calldata.size len 64]
                                                        if 0 >= mem[_6653]:
                                                            revert with 0, 50
                                                        mem[_6653 + 32] = this.address
                                                        require ext_code.size(uniswapV2RouterAddress)
                                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                gas gas_remaining wei
                                                        mem[_6653 + 96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[64] = _6653 + ceil32(return_data.size) + 96
                                                        require return_data.size >= 32
                                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                        if 1 >= mem[_6653]:
                                                            revert with 0, 50
                                                        mem[_6653 + 64] = ext_call.return_data[12 len 20]
                                                        if not this.address:
                                                            revert with 0, 'ERC20: approve from the zero address'
                                                        if not uniswapV2RouterAddress:
                                                            revert with 0, 'ERC20: approve to the zero address'
                                                        mem[0] = uniswapV2RouterAddress
                                                        mem[32] = sha3(address(this.address), 1)
                                                        allowance[address(this.address)][stor9].field_0 = 0
                                                        emit Approval(0, this.address, uniswapV2RouterAddress);
                                                        mem[_6653 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                        mem[_6653 + ceil32(return_data.size) + 100] = 0
                                                        mem[_6653 + ceil32(return_data.size) + 132] = 0
                                                        mem[_6653 + ceil32(return_data.size) + 164] = 160
                                                        mem[_6653 + ceil32(return_data.size) + 260] = mem[_6653]
                                                        idx = 0
                                                        s = _6653 + ceil32(return_data.size) + 292
                                                        t = _6653 + 32
                                                        while idx < mem[_6653]:
                                                            mem[s] = mem[t + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        require ext_code.size(uniswapV2RouterAddress)
                                                        call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                             gas gas_remaining wei
                                                            args 0, 0, 160, address(this.address), block.timestamp, mem[_6653 + ceil32(return_data.size) + 260 len (32 * mem[_6653]) + 32]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[_6653 + ceil32(return_data.size) + 96] = 30
                                                        mem[_6653 + ceil32(return_data.size) + 128] = 'SafeMath: subtraction overflow'
                                                        if eth.balance(this.address) > eth.balance(this.address):
                                                            var130001 = 32
                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                        if eth.balance(this.address) < eth.balance(this.address):
                                                            revert with 0, 17
                                                        call distributionPoolAddress with:
                                                             gas 2300 wei
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[_6653 + ceil32(return_data.size) + 160] = 30
                                                        mem[_6653 + ceil32(return_data.size) + 192] = 'SafeMath: subtraction overflow'
                                                        if 0 > balanceOf[this.address] * rewardsFee / 100:
                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                        if balanceOf[this.address] * rewardsFee / 100 < 0:
                                                            revert with 0, 17
                                                        if not this.address:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not distributionPoolAddress:
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        mem[_6653 + ceil32(return_data.size) + 224] = 38
                                                        mem[_6653 + ceil32(return_data.size) + 256 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                        if balanceOf[this.address] * rewardsFee / 100 > balanceOf[address(this.address)]:
                                                            revert with 0, 
                                                                        32,
                                                                        38,
                                                                        0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_6653 + ceil32(return_data.size) + 294 len 26] >> 48,
                                                                        0
                                                        if balanceOf[address(this.address)] < balanceOf[this.address] * rewardsFee / 100:
                                                            revert with 0, 17
                                                        balanceOf[address(this.address)] -= balanceOf[this.address] * rewardsFee / 100
                                                        if balanceOf[stor12] > !(balanceOf[this.address] * rewardsFee / 100):
                                                            revert with 0, 17
                                                        if balanceOf[stor12] + (balanceOf[this.address] * rewardsFee / 100) < balanceOf[stor12]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        balanceOf[stor12] += balanceOf[this.address] * rewardsFee / 100
                                                        emit Transfer((balanceOf[this.address] * rewardsFee / 100), this.address, distributionPoolAddress);
                                                        if balanceOf[this.address]:
                                                            if balanceOf[this.address] and liquidityPoolFee > -1 / balanceOf[this.address]:
                                                                revert with 0, 17
                                                            if not balanceOf[this.address]:
                                                                revert with 0, 18
                                                            if balanceOf[this.address] * liquidityPoolFee / balanceOf[this.address] != liquidityPoolFee:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            mem[_6653 + ceil32(return_data.size) + 320] = 26
                                                            mem[_6653 + ceil32(return_data.size) + 352] = 'SafeMath: division by zero'
                                                            mem[_6653 + ceil32(return_data.size) + 384] = 26
                                                            mem[_6653 + ceil32(return_data.size) + 416] = 'SafeMath: division by zero'
                                                            mem[_6653 + ceil32(return_data.size) + 448] = 30
                                                            mem[_6653 + ceil32(return_data.size) + 480] = 'SafeMath: subtraction overflow'
                                                            if balanceOf[this.address] * liquidityPoolFee / 100 / 2 > balanceOf[this.address] * liquidityPoolFee / 100:
                                                                var192001 = 32
                                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                                            if balanceOf[this.address] * liquidityPoolFee / 100 < balanceOf[this.address] * liquidityPoolFee / 100 / 2:
                                                                revert with 0, 17
                                                            mem[_6653 + ceil32(return_data.size) + 512] = 2
                                                            mem[_6653 + ceil32(return_data.size) + 544] = this.address
                                                            require ext_code.size(uniswapV2RouterAddress)
                                                            staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                    gas gas_remaining wei
                                                            mem[_6653 + ceil32(return_data.size) + 608] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[64] = _6653 + (2 * ceil32(return_data.size)) + 608
                                                            require return_data.size >= 32
                                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                            mem[_6653 + ceil32(return_data.size) + 576] = ext_call.return_data[12 len 20]
                                                            if not this.address:
                                                                revert with 0, 'ERC20: approve from the zero address'
                                                            if not uniswapV2RouterAddress:
                                                                revert with 0, 'ERC20: approve to the zero address'
                                                            mem[0] = uniswapV2RouterAddress
                                                            mem[32] = sha3(address(this.address), 1)
                                                            allowance[address(this.address)][stor9].field_0 = balanceOf[this.address] * liquidityPoolFee / 100 / 2
                                                            allowance[address(this.address)][stor9].field_255 = 0
                                                            emit Approval((balanceOf[this.address] * liquidityPoolFee / 100 / 2), this.address, uniswapV2RouterAddress);
                                                            mem[_6653 + (2 * ceil32(return_data.size)) + 608] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                            mem[_6653 + (2 * ceil32(return_data.size)) + 612] = balanceOf[this.address] * liquidityPoolFee / 100 / 2
                                                            mem[_6653 + (2 * ceil32(return_data.size)) + 644] = 0
                                                            mem[_6653 + (2 * ceil32(return_data.size)) + 676] = 160
                                                            mem[_6653 + (2 * ceil32(return_data.size)) + 772] = 2
                                                            idx = 0
                                                            s = _6653 + (2 * ceil32(return_data.size)) + 804
                                                            t = _6653 + ceil32(return_data.size) + 544
                                                            while idx < mem[_6653 + ceil32(return_data.size) + 512]:
                                                                mem[s] = mem[t + 12 len 20]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[_6653 + (2 * ceil32(return_data.size)) + 708] = this.address
                                                            mem[_6653 + (2 * ceil32(return_data.size)) + 740] = block.timestamp
                                                            require ext_code.size(uniswapV2RouterAddress)
                                                            call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args Mask(255, 1, balanceOf[this.address] * liquidityPoolFee / 100), 0, 160, address(this.address), block.timestamp, mem[_6653 + (2 * ceil32(return_data.size)) + 772 len (32 * mem[_6653 + ceil32(return_data.size) + 512]) + 32]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[_6653 + (2 * ceil32(return_data.size)) + 608] = 30
                                                            mem[_6653 + (2 * ceil32(return_data.size)) + 640] = 'SafeMath: subtraction overflow'
                                                            if eth.balance(this.address) > eth.balance(this.address):
                                                                mem[_6653 + (2 * ceil32(return_data.size)) + 672] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_6653 + (2 * ceil32(return_data.size)) + 676] = 32
                                                                mem[_6653 + (2 * ceil32(return_data.size)) + 708] = 30
                                                                mem[_6653 + (2 * ceil32(return_data.size)) + 740] = 'SafeMath: subtraction overflow'
                                                                mem[_6653 + (2 * ceil32(return_data.size)) + 770] = 0
                                                                revert with memory
                                                                  from _6653 + (2 * ceil32(return_data.size)) + 672
                                                                   len ceil32(return_data.size) + 100
                                                            if eth.balance(this.address) < eth.balance(this.address):
                                                                revert with 0, 17
                                                            if not this.address:
                                                                mem[_6653 + (2 * ceil32(return_data.size)) + 672] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_6653 + (2 * ceil32(return_data.size)) + 676] = 32
                                                                mem[_6653 + (2 * ceil32(return_data.size)) + 708] = 36
                                                                mem[_6653 + (2 * ceil32(return_data.size)) + 740] = 'ERC20: approve from the zero add'
                                                                mem[_6653 + (2 * ceil32(return_data.size)) + 772] = 0x7265737300000000000000000000000000000000000000000000000000000000
                                                                revert with memory
                                                                  from _6653 + (2 * ceil32(return_data.size)) + 672
                                                                   len ceil32(return_data.size) + 132
                                                            if not uniswapV2RouterAddress:
                                                                mem[_6653 + (2 * ceil32(return_data.size)) + 672] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_6653 + (2 * ceil32(return_data.size)) + 676] = 32
                                                                mem[_6653 + (2 * ceil32(return_data.size)) + 708] = 34
                                                                mem[_6653 + (2 * ceil32(return_data.size)) + 740] = 'ERC20: approve to the zero addre'
                                                                mem[_6653 + (2 * ceil32(return_data.size)) + 772] = 0x7373000000000000000000000000000000000000000000000000000000000000
                                                                revert with memory
                                                                  from _6653 + (2 * ceil32(return_data.size)) + 672
                                                                   len ceil32(return_data.size) + 132
                                                            allowance[address(this.address)][stor9].field_0 = (balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2)
                                                            emit Approval(((balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2)), this.address, uniswapV2RouterAddress);
                                                            mem[_6653 + (2 * ceil32(return_data.size)) + 676] = this.address
                                                            mem[_6653 + (2 * ceil32(return_data.size)) + 708] = (balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2)
                                                            mem[_6653 + (2 * ceil32(return_data.size)) + 740] = 0
                                                            mem[_6653 + (2 * ceil32(return_data.size)) + 772] = 0
                                                            mem[_6653 + (2 * ceil32(return_data.size)) + 804] = 0
                                                            mem[_6653 + (2 * ceil32(return_data.size)) + 836] = block.timestamp
                                                            require ext_code.size(uniswapV2RouterAddress)
                                                            call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                                 gas gas_remaining wei
                                                                args mem[_6653 + (2 * ceil32(return_data.size)) + 676 len ceil32(return_data.size) + 192]
                                                            mem[_6653 + (2 * ceil32(return_data.size)) + 672 len 96] = ext_call.return_data[0 len 96]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 96
                                                            mem[_6653 + (4 * ceil32(return_data.size)) + 672] = balanceOf[this.address] * liquidityPoolFee / 100 / 2
                                                            mem[_6653 + (4 * ceil32(return_data.size)) + 704] = 0
                                                            mem[_6653 + (4 * ceil32(return_data.size)) + 736] = (balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2)
                                                            emit SwapAndLiquify(uint256 arg1, uint256 arg2, uint256 arg3):
                                                                                mem[_6653 + (4 * ceil32(return_data.size)) + 672 len (5 * ceil32(return_data.size)) + 96],
                                                            mem[_6653 + (4 * ceil32(return_data.size)) + 672] = 2
                                                            mem[_6653 + (4 * ceil32(return_data.size)) + 704] = this.address
                                                            require ext_code.size(uniswapV2RouterAddress)
                                                            staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                    gas gas_remaining wei
                                                            mem[_6653 + (4 * ceil32(return_data.size)) + 768] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[64] = _6653 + (6 * ceil32(return_data.size)) + 768
                                                            require return_data.size >= 32
                                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                            mem[_6653 + (4 * ceil32(return_data.size)) + 736] = ext_call.return_data[12 len 20]
                                                            if not this.address:
                                                                revert with 0, 'ERC20: approve from the zero address'
                                                            if not uniswapV2RouterAddress:
                                                                revert with 0, 'ERC20: approve to the zero address'
                                                            mem[0] = uniswapV2RouterAddress
                                                            mem[32] = sha3(address(this.address), 1)
                                                            allowance[address(this.address)][stor9].field_0 = balanceOf[this.address]
                                                            emit Approval(balanceOf[this.address], this.address, uniswapV2RouterAddress);
                                                            mem[_6653 + (6 * ceil32(return_data.size)) + 768] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                            mem[_6653 + (6 * ceil32(return_data.size)) + 772] = balanceOf[this.address]
                                                            mem[_6653 + (6 * ceil32(return_data.size)) + 804] = 0
                                                            mem[_6653 + (6 * ceil32(return_data.size)) + 836] = 160
                                                            mem[_6653 + (6 * ceil32(return_data.size)) + 932] = 2
                                                            idx = 0
                                                            s = _6653 + (6 * ceil32(return_data.size)) + 964
                                                            t = _6653 + (4 * ceil32(return_data.size)) + 704
                                                            while idx < mem[_6653 + (4 * ceil32(return_data.size)) + 672]:
                                                                mem[s] = mem[t + 12 len 20]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[_6653 + (6 * ceil32(return_data.size)) + 900] = block.timestamp
                                                            require ext_code.size(uniswapV2RouterAddress)
                                                            call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args balanceOf[this.address], 0, 160, address(this.address), block.timestamp, mem[_6653 + (6 * ceil32(return_data.size)) + 932 len (32 * mem[_6653 + (4 * ceil32(return_data.size)) + 672]) + 32]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[_6653 + (6 * ceil32(return_data.size)) + 768] = 30
                                                            mem[_6653 + (6 * ceil32(return_data.size)) + 800] = 'SafeMath: subtraction overflow'
                                                            if eth.balance(this.address) > eth.balance(this.address):
                                                                mem[_6653 + (6 * ceil32(return_data.size)) + 930] = 0
                                                                revert with 0, 
                                                                            'SafeMath: subtraction overflow',
                                                                            mem[_6653 + (6 * ceil32(return_data.size)) + 930 len (9 * ceil32(return_data.size)) + 2]
                                                            if eth.balance(this.address) < eth.balance(this.address):
                                                                revert with 0, 17
                                                            call marketingWalletAddress with:
                                                                 gas 2300 wei
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            uint8(stor23.field_0) = 0
                                                            if not msg.sender:
                                                                revert with 0, 
                                                                            'ERC20: transfer from the zero address',
                                                                            mem[_6653 + (6 * ceil32(return_data.size)) + 964 len 9 * ceil32(return_data.size)]
                                                            if not this.address:
                                                                revert with 0, 
                                                                            'ERC20: transfer to the zero address',
                                                                            mem[_6653 + (6 * ceil32(return_data.size)) + 964 len 9 * ceil32(return_data.size)]
                                                            mem[_6653 + (6 * ceil32(return_data.size)) + 832] = 38
                                                            mem[_6653 + (6 * ceil32(return_data.size)) + 864 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                            if _5499 > balanceOf[address(msg.sender)]:
                                                                mem[_6653 + (6 * ceil32(return_data.size)) + 1034] = 0
                                                                revert with 0, 
                                                                            32,
                                                                            38,
                                                                            0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, Mask(208, 32, block.timestamp) >> 32 >> 48,
                                                                            mem[_6653 + (6 * ceil32(return_data.size)) + 1034 len (9 * ceil32(return_data.size)) + 26]
                                                            if balanceOf[address(msg.sender)] < _5499:
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] -= _5499
                                                            if balanceOf[this.address] > !_5499:
                                                                revert with 0, 17
                                                            if balanceOf[this.address] + _5499 < balanceOf[this.address]:
                                                                revert with 0, 'SafeMath: addition overflow', mem[_6653 + (6 * ceil32(return_data.size)) + 1028 len 9 * ceil32(return_data.size)]
                                                            balanceOf[address(this.address)] = balanceOf[this.address] + _5499
                                                            emit Transfer(_5499, msg.sender, this.address);
                                                            if arg1 >= 3:
                                                                revert with 0, 50
                                                            mem[_6653 + (6 * ceil32(return_data.size)) + 928] = 0x12b8603f00000000000000000000000000000000000000000000000000000000
                                                            mem[_6653 + (6 * ceil32(return_data.size)) + 932] = msg.sender
                                                            mem[_6653 + (6 * ceil32(return_data.size)) + 964] = 64
                                                            mem[_6653 + (6 * ceil32(return_data.size)) + 996] = mem[128]
                                                            mem[_6653 + (6 * ceil32(return_data.size)) + 1028 len ceil32(mem[128])] = mem[160 len ceil32(mem[128])]
                                                            if ceil32(mem[128]) > mem[128]:
                                                                mem[_6653 + (6 * ceil32(return_data.size)) + mem[128] + 1028] = 0
                                                            require ext_code.size(sub_20eea8b5[arg1])
                                                            call sub_20eea8b5[arg1].createNode(address arg1, string arg2) with:
                                                                 gas gas_remaining wei
                                                                args msg.sender, Array(len=mem[128], data=mem[_6653 + (6 * ceil32(return_data.size)) + 1028 len (9 * ceil32(return_data.size)) + ceil32(mem[128])])
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            if stor27[address(msg.sender)] > -2:
                                                                revert with 0, 17
                                                            if stor27[address(msg.sender)] + 1 < stor27[address(msg.sender)]:
                                                                revert with 0, 'SafeMath: addition overflow', mem[_6653 + (6 * ceil32(return_data.size)) + 1028 len 9 * ceil32(return_data.size)]
                                                        else:
                                                            mem[_6653 + ceil32(return_data.size) + 320] = 26
                                                            mem[_6653 + ceil32(return_data.size) + 352] = 'SafeMath: division by zero'
                                                            mem[_6653 + ceil32(return_data.size) + 384] = 26
                                                            mem[_6653 + ceil32(return_data.size) + 416] = 'SafeMath: division by zero'
                                                            mem[_6653 + ceil32(return_data.size) + 448] = 30
                                                            mem[_6653 + ceil32(return_data.size) + 480] = 'SafeMath: subtraction overflow'
                                                            mem[_6653 + ceil32(return_data.size) + 512] = 2
                                                            mem[_6653 + ceil32(return_data.size) + 544] = this.address
                                                            require ext_code.size(uniswapV2RouterAddress)
                                                            staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                    gas gas_remaining wei
                                                            mem[_6653 + ceil32(return_data.size) + 608] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[64] = _6653 + (2 * ceil32(return_data.size)) + 608
                                                            require return_data.size >= 32
                                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                            mem[_6653 + ceil32(return_data.size) + 576] = ext_call.return_data[12 len 20]
                                                            if not this.address:
                                                                revert with 0, 'ERC20: approve from the zero address'
                                                            if not uniswapV2RouterAddress:
                                                                revert with 0, 'ERC20: approve to the zero address'
                                                            mem[0] = uniswapV2RouterAddress
                                                            mem[32] = sha3(address(this.address), 1)
                                                            allowance[address(this.address)][stor9].field_0 = 0
                                                            emit Approval(0, this.address, uniswapV2RouterAddress);
                                                            mem[_6653 + (2 * ceil32(return_data.size)) + 608] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                            mem[_6653 + (2 * ceil32(return_data.size)) + 612] = 0
                                                            mem[_6653 + (2 * ceil32(return_data.size)) + 644] = 0
                                                            mem[_6653 + (2 * ceil32(return_data.size)) + 676] = 160
                                                            mem[_6653 + (2 * ceil32(return_data.size)) + 772] = 2
                                                            idx = 0
                                                            s = _6653 + (2 * ceil32(return_data.size)) + 804
                                                            t = _6653 + ceil32(return_data.size) + 544
                                                            while idx < mem[_6653 + ceil32(return_data.size) + 512]:
                                                                mem[s] = mem[t + 12 len 20]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[_6653 + (2 * ceil32(return_data.size)) + 708] = this.address
                                                            mem[_6653 + (2 * ceil32(return_data.size)) + 740] = block.timestamp
                                                            require ext_code.size(uniswapV2RouterAddress)
                                                            call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                 gas gas_remaining wei
                                                                args mem[mem[64] + 4 len _6653 + (2 * ceil32(return_data.size)) + (32 * mem[_6653 + ceil32(return_data.size) + 512]) + -mem[64] + 800]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _12031 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_12031] = 30
                                                            mem[_12031 + 32] = 'SafeMath: subtraction overflow'
                                                            if eth.balance(this.address) > eth.balance(this.address):
                                                                var218001 = 32
                                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                                            if eth.balance(this.address) < eth.balance(this.address):
                                                                revert with 0, 17
                                                            if not this.address:
                                                                revert with 0, 'ERC20: approve from the zero address'
                                                            if not uniswapV2RouterAddress:
                                                                revert with 0, 'ERC20: approve to the zero address'
                                                            mem[0] = uniswapV2RouterAddress
                                                            mem[32] = sha3(address(this.address), 1)
                                                            allowance[address(this.address)][stor9].field_0 = 0
                                                            emit Approval(0, this.address, uniswapV2RouterAddress);
                                                            mem[mem[64] + 68] = 0
                                                            mem[mem[64] + 100] = 0
                                                            mem[mem[64] + 132] = 0
                                                            mem[mem[64] + 164] = block.timestamp
                                                            require ext_code.size(uniswapV2RouterAddress)
                                                            call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                                 gas gas_remaining wei
                                                                args this.address, 0, 0, 0, 0, block.timestamp
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 96
                                                            mem[mem[64] + 32] = 0
                                                            mem[mem[64] + 64] = 0
                                                            emit SwapAndLiquify(uint256 arg1, uint256 arg2, uint256 arg3):
                                                                                0,
                                                            mem[0] = this.address
                                                            mem[32] = 0
                                                            _12574 = mem[64]
                                                            mem[mem[64]] = 2
                                                            mem[64] = mem[64] + 96
                                                            mem[_12574 + 32 len 64] = call.data[calldata.size len 64]
                                                            if 0 >= mem[_12574]:
                                                                revert with 0, 50
                                                            mem[_12574 + 32] = this.address
                                                            require ext_code.size(uniswapV2RouterAddress)
                                                            staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                    gas gas_remaining wei
                                                            mem[_12574 + 96] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[64] = _12574 + ceil32(return_data.size) + 96
                                                            require return_data.size >= 32
                                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                            if 1 >= mem[_12574]:
                                                                revert with 0, 50
                                                            mem[_12574 + 64] = ext_call.return_data[12 len 20]
                                                            if not this.address:
                                                                revert with 0, 'ERC20: approve from the zero address'
                                                            if not uniswapV2RouterAddress:
                                                                revert with 0, 'ERC20: approve to the zero address'
                                                            mem[0] = uniswapV2RouterAddress
                                                            mem[32] = sha3(address(this.address), 1)
                                                            allowance[address(this.address)][stor9].field_0 = balanceOf[this.address]
                                                            emit Approval(balanceOf[this.address], this.address, uniswapV2RouterAddress);
                                                            mem[_12574 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                            mem[_12574 + ceil32(return_data.size) + 100] = balanceOf[this.address]
                                                            mem[_12574 + ceil32(return_data.size) + 132] = 0
                                                            mem[_12574 + ceil32(return_data.size) + 164] = 160
                                                            mem[_12574 + ceil32(return_data.size) + 260] = mem[_12574]
                                                            idx = 0
                                                            s = _12574 + ceil32(return_data.size) + 292
                                                            t = _12574 + 32
                                                            while idx < mem[_12574]:
                                                                mem[s] = mem[t + 12 len 20]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[_12574 + ceil32(return_data.size) + 196] = this.address
                                                            mem[_12574 + ceil32(return_data.size) + 228] = block.timestamp
                                                            require ext_code.size(uniswapV2RouterAddress)
                                                            call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                 gas gas_remaining wei
                                                                args mem[mem[64] + 4 len _12574 + ceil32(return_data.size) + (32 * mem[_12574]) + -mem[64] + 288]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _13687 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_13687] = 30
                                                            mem[_13687 + 32] = 'SafeMath: subtraction overflow'
                                                            if eth.balance(this.address) > eth.balance(this.address):
                                                                var264001 = 32
                                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                                            if eth.balance(this.address) < eth.balance(this.address):
                                                                revert with 0, 17
                                                            call marketingWalletAddress with:
                                                                 gas 2300 wei
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            uint8(stor23.field_0) = 0
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not this.address:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            _13837 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_13837] = 38
                                                            mem[_13837 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                            if _5499 > balanceOf[address(msg.sender)]:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 38
                                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_13837 + 70 len 26]
                                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                            if balanceOf[address(msg.sender)] < _5499:
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] -= _5499
                                                            if balanceOf[this.address] > !_5499:
                                                                revert with 0, 17
                                                            if balanceOf[this.address] + _5499 < balanceOf[this.address]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            balanceOf[address(this.address)] = balanceOf[this.address] + _5499
                                                            emit Transfer(_5499, msg.sender, this.address);
                                                            if arg1 >= 3:
                                                                revert with 0, 50
                                                            mem[mem[64]] = 0x12b8603f00000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = msg.sender
                                                            mem[mem[64] + 36] = 64
                                                            mem[mem[64] + 68] = mem[128]
                                                            mem[mem[64] + 100 len ceil32(mem[128])] = mem[160 len ceil32(mem[128])]
                                                            if ceil32(mem[128]) > mem[128]:
                                                                mem[mem[64] + mem[128] + 100] = 0
                                                            require ext_code.size(sub_20eea8b5[arg1])
                                                            call sub_20eea8b5[arg1].createNode(address arg1, string arg2) with:
                                                                 gas gas_remaining wei
                                                                args msg.sender, Array(len=mem[128], data=mem[mem[64] + 100 len ceil32(mem[128])])
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            if stor27[address(msg.sender)] > -2:
                                                                revert with 0, 17
                                                            if stor27[address(msg.sender)] + 1 < stor27[address(msg.sender)]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                    else:
                                                        if balanceOf[this.address] * rewardsFee / 100 and stor22 > -1 / balanceOf[this.address] * rewardsFee / 100:
                                                            revert with 0, 17
                                                        if not balanceOf[this.address] * rewardsFee / 100:
                                                            revert with 0, 18
                                                        if balanceOf[this.address] * rewardsFee / 100 * stor22 / balanceOf[this.address] * rewardsFee / 100 != stor22:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _6574 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_6574] = 26
                                                        mem[_6574 + 32] = 'SafeMath: division by zero'
                                                        _6843 = mem[64]
                                                        mem[mem[64]] = 2
                                                        mem[64] = mem[64] + 96
                                                        mem[_6843 + 32 len 64] = call.data[calldata.size len 64]
                                                        if 0 >= mem[_6843]:
                                                            revert with 0, 50
                                                        mem[_6843 + 32] = this.address
                                                        require ext_code.size(uniswapV2RouterAddress)
                                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                gas gas_remaining wei
                                                        mem[_6843 + 96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[64] = _6843 + ceil32(return_data.size) + 96
                                                        require return_data.size >= 32
                                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                        if 1 >= mem[_6843]:
                                                            revert with 0, 50
                                                        mem[_6843 + 64] = ext_call.return_data[12 len 20]
                                                        if not this.address:
                                                            revert with 0, 'ERC20: approve from the zero address'
                                                        if not uniswapV2RouterAddress:
                                                            revert with 0, 'ERC20: approve to the zero address'
                                                        mem[0] = uniswapV2RouterAddress
                                                        mem[32] = sha3(address(this.address), 1)
                                                        allowance[address(this.address)][stor9].field_0 = balanceOf[this.address] * rewardsFee / 100 * stor22 / 100
                                                        emit Approval((balanceOf[this.address] * rewardsFee / 100 * stor22 / 100), this.address, uniswapV2RouterAddress);
                                                        mem[_6843 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                        mem[_6843 + ceil32(return_data.size) + 100] = balanceOf[this.address] * rewardsFee / 100 * stor22 / 100
                                                        mem[_6843 + ceil32(return_data.size) + 132] = 0
                                                        mem[_6843 + ceil32(return_data.size) + 164] = 160
                                                        mem[_6843 + ceil32(return_data.size) + 260] = mem[_6843]
                                                        idx = 0
                                                        s = _6843 + ceil32(return_data.size) + 292
                                                        t = _6843 + 32
                                                        while idx < mem[_6843]:
                                                            mem[s] = mem[t + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[_6843 + ceil32(return_data.size) + 196] = this.address
                                                        mem[_6843 + ceil32(return_data.size) + 228] = block.timestamp
                                                        require ext_code.size(uniswapV2RouterAddress)
                                                        call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                             gas gas_remaining wei
                                                            args mem[mem[64] + 4 len _6843 + ceil32(return_data.size) + (32 * mem[_6843]) + -mem[64] + 288]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _8769 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_8769] = 30
                                                        mem[_8769 + 32] = 'SafeMath: subtraction overflow'
                                                        if eth.balance(this.address) > eth.balance(this.address):
                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                        if eth.balance(this.address) < eth.balance(this.address):
                                                            revert with 0, 17
                                                        call distributionPoolAddress with:
                                                             gas 2300 wei
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _9046 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_9046] = 30
                                                        mem[_9046 + 32] = 'SafeMath: subtraction overflow'
                                                        if balanceOf[this.address] * rewardsFee / 100 * stor22 / 100 > balanceOf[this.address] * rewardsFee / 100:
                                                            var146001 = 32
                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                        if balanceOf[this.address] * rewardsFee / 100 < balanceOf[this.address] * rewardsFee / 100 * stor22 / 100:
                                                            revert with 0, 17
                                                        if not this.address:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not distributionPoolAddress:
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        _9295 = mem[64]
                                                        mem[64] = mem[64] + 96
                                                        mem[_9295] = 38
                                                        mem[_9295 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                        if (balanceOf[this.address] * rewardsFee / 100) - (balanceOf[this.address] * rewardsFee / 100 * stor22 / 100) > balanceOf[address(this.address)]:
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 38
                                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_9295 + 70 len 26]
                                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                        if balanceOf[address(this.address)] < (balanceOf[this.address] * rewardsFee / 100) - (balanceOf[this.address] * rewardsFee / 100 * stor22 / 100):
                                                            revert with 0, 17
                                                        balanceOf[address(this.address)] = balanceOf[address(this.address)] - (balanceOf[this.address] * rewardsFee / 100) + (balanceOf[this.address] * rewardsFee / 100 * stor22 / 100)
                                                        if balanceOf[stor12] > !((balanceOf[this.address] * rewardsFee / 100) - (balanceOf[this.address] * rewardsFee / 100 * stor22 / 100)):
                                                            revert with 0, 17
                                                        if balanceOf[stor12] + (balanceOf[this.address] * rewardsFee / 100) - (balanceOf[this.address] * rewardsFee / 100 * stor22 / 100) < balanceOf[stor12]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        mem[0] = distributionPoolAddress
                                                        mem[32] = 0
                                                        balanceOf[stor12] = balanceOf[stor12] + (balanceOf[this.address] * rewardsFee / 100) - (balanceOf[this.address] * rewardsFee / 100 * stor22 / 100)
                                                        emit Transfer(((balanceOf[this.address] * rewardsFee / 100) - (balanceOf[this.address] * rewardsFee / 100 * stor22 / 100)), this.address, distributionPoolAddress);
                                                        if not balanceOf[this.address]:
                                                            _9706 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_9706] = 26
                                                            mem[_9706 + 32] = 'SafeMath: division by zero'
                                                            _9850 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_9850] = 26
                                                            mem[_9850 + 32] = 'SafeMath: division by zero'
                                                            _9868 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_9868] = 30
                                                            mem[_9868 + 32] = 'SafeMath: subtraction overflow'
                                                            _9887 = mem[64]
                                                            mem[mem[64]] = 2
                                                            mem[64] = mem[64] + 96
                                                            mem[_9887 + 32 len 64] = call.data[calldata.size len 64]
                                                            if 0 >= mem[_9887]:
                                                                revert with 0, 50
                                                            mem[_9887 + 32] = this.address
                                                            require ext_code.size(uniswapV2RouterAddress)
                                                            staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                    gas gas_remaining wei
                                                            mem[_9887 + 96] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[64] = _9887 + ceil32(return_data.size) + 96
                                                            require return_data.size >= 32
                                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                            if 1 >= mem[_9887]:
                                                                revert with 0, 50
                                                            mem[_9887 + 64] = ext_call.return_data[12 len 20]
                                                            if not this.address:
                                                                revert with 0, 'ERC20: approve from the zero address'
                                                            if not uniswapV2RouterAddress:
                                                                revert with 0, 'ERC20: approve to the zero address'
                                                            mem[0] = uniswapV2RouterAddress
                                                            mem[32] = sha3(address(this.address), 1)
                                                            allowance[address(this.address)][stor9].field_0 = 0
                                                            emit Approval(0, this.address, uniswapV2RouterAddress);
                                                            mem[_9887 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                            mem[_9887 + ceil32(return_data.size) + 100] = 0
                                                            mem[_9887 + ceil32(return_data.size) + 132] = 0
                                                            mem[_9887 + ceil32(return_data.size) + 164] = 160
                                                            mem[_9887 + ceil32(return_data.size) + 260] = mem[_9887]
                                                            idx = 0
                                                            s = _9887 + ceil32(return_data.size) + 292
                                                            t = _9887 + 32
                                                            while idx < mem[_9887]:
                                                                mem[s] = mem[t + 12 len 20]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            require ext_code.size(uniswapV2RouterAddress)
                                                            call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args 0, 0, 160, address(this.address), block.timestamp, mem[_9887 + ceil32(return_data.size) + 260 len (32 * mem[_9887]) + 32]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[_9887 + ceil32(return_data.size) + 96] = 30
                                                            mem[_9887 + ceil32(return_data.size) + 128] = 'SafeMath: subtraction overflow'
                                                            if eth.balance(this.address) > eth.balance(this.address):
                                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                                            if eth.balance(this.address) < eth.balance(this.address):
                                                                revert with 0, 17
                                                            if not this.address:
                                                                revert with 0, 'ERC20: approve from the zero address'
                                                            if not uniswapV2RouterAddress:
                                                                revert with 0, 'ERC20: approve to the zero address'
                                                            allowance[address(this.address)][stor9].field_0 = 0
                                                            emit Approval(0, this.address, uniswapV2RouterAddress);
                                                            mem[_9887 + ceil32(return_data.size) + 228] = 0
                                                            mem[_9887 + ceil32(return_data.size) + 260] = 0
                                                            mem[_9887 + ceil32(return_data.size) + 292] = 0
                                                            mem[_9887 + ceil32(return_data.size) + 324] = block.timestamp
                                                            require ext_code.size(uniswapV2RouterAddress)
                                                            call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                                 gas gas_remaining wei
                                                                args this.address, 0, 0, 0, 0, block.timestamp
                                                            mem[_9887 + ceil32(return_data.size) + 160 len 96] = ext_call.return_data[0 len 96]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 96
                                                            emit SwapAndLiquify(uint256 arg1, uint256 arg2, uint256 arg3):
                                                                                0,
                                                            mem[_9887 + (2 * ceil32(return_data.size)) + 160] = 2
                                                            mem[_9887 + (2 * ceil32(return_data.size)) + 192] = this.address
                                                            require ext_code.size(uniswapV2RouterAddress)
                                                            staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                    gas gas_remaining wei
                                                            mem[_9887 + (2 * ceil32(return_data.size)) + 256] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[64] = _9887 + (4 * ceil32(return_data.size)) + 256
                                                            require return_data.size >= 32
                                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                            mem[_9887 + (2 * ceil32(return_data.size)) + 224] = ext_call.return_data[12 len 20]
                                                            if not this.address:
                                                                revert with 0, 'ERC20: approve from the zero address'
                                                            if not uniswapV2RouterAddress:
                                                                revert with 0, 'ERC20: approve to the zero address'
                                                            mem[0] = uniswapV2RouterAddress
                                                            mem[32] = sha3(address(this.address), 1)
                                                            allowance[address(this.address)][stor9].field_0 = balanceOf[this.address]
                                                            emit Approval(balanceOf[this.address], this.address, uniswapV2RouterAddress);
                                                            mem[_9887 + (4 * ceil32(return_data.size)) + 256] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                            mem[_9887 + (4 * ceil32(return_data.size)) + 260] = balanceOf[this.address]
                                                            mem[_9887 + (4 * ceil32(return_data.size)) + 292] = 0
                                                            mem[_9887 + (4 * ceil32(return_data.size)) + 324] = 160
                                                            mem[_9887 + (4 * ceil32(return_data.size)) + 420] = 2
                                                            idx = 0
                                                            s = _9887 + (4 * ceil32(return_data.size)) + 452
                                                            t = _9887 + (2 * ceil32(return_data.size)) + 192
                                                            while idx < mem[_9887 + (2 * ceil32(return_data.size)) + 160]:
                                                                mem[s] = mem[t + 12 len 20]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[_9887 + (4 * ceil32(return_data.size)) + 356] = this.address
                                                            mem[_9887 + (4 * ceil32(return_data.size)) + 388] = block.timestamp
                                                            require ext_code.size(uniswapV2RouterAddress)
                                                            call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                 gas gas_remaining wei
                                                                args balanceOf[this.address], 0, 160, address(this.address), block.timestamp, mem[_9887 + (4 * ceil32(return_data.size)) + 420 len (32 * mem[_9887 + (2 * ceil32(return_data.size)) + 160]) + 32]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[_9887 + (4 * ceil32(return_data.size)) + 256] = 30
                                                            mem[_9887 + (4 * ceil32(return_data.size)) + 288] = 'SafeMath: subtraction overflow'
                                                            if eth.balance(this.address) > eth.balance(this.address):
                                                                mem[_9887 + (4 * ceil32(return_data.size)) + 320] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_9887 + (4 * ceil32(return_data.size)) + 324] = 32
                                                                mem[_9887 + (4 * ceil32(return_data.size)) + 356] = 30
                                                                mem[_9887 + (4 * ceil32(return_data.size)) + 388] = 'SafeMath: subtraction overflow'
                                                                mem[_9887 + (4 * ceil32(return_data.size)) + 418] = 0
                                                                revert with memory
                                                                  from _9887 + (4 * ceil32(return_data.size)) + 320
                                                                   len (5 * ceil32(return_data.size)) + 100
                                                            if eth.balance(this.address) < eth.balance(this.address):
                                                                revert with 0, 17
                                                            call marketingWalletAddress with:
                                                                 gas 2300 wei
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            uint8(stor23.field_0) = 0
                                                            if not msg.sender:
                                                                mem[_9887 + (4 * ceil32(return_data.size)) + 320] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_9887 + (4 * ceil32(return_data.size)) + 324] = 32
                                                                mem[_9887 + (4 * ceil32(return_data.size)) + 356] = 37
                                                                mem[_9887 + (4 * ceil32(return_data.size)) + 388] = 'ERC20: transfer from the zero ad'
                                                                mem[_9887 + (4 * ceil32(return_data.size)) + 420] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                                revert with memory
                                                                  from _9887 + (4 * ceil32(return_data.size)) + 320
                                                                   len (5 * ceil32(return_data.size)) + 132
                                                            if not this.address:
                                                                mem[_9887 + (4 * ceil32(return_data.size)) + 320] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_9887 + (4 * ceil32(return_data.size)) + 324] = 32
                                                                mem[_9887 + (4 * ceil32(return_data.size)) + 356] = 35
                                                                mem[_9887 + (4 * ceil32(return_data.size)) + 388] = 'ERC20: transfer to the zero addr'
                                                                mem[_9887 + (4 * ceil32(return_data.size)) + 420] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                                revert with memory
                                                                  from _9887 + (4 * ceil32(return_data.size)) + 320
                                                                   len (5 * ceil32(return_data.size)) + 132
                                                            mem[_9887 + (4 * ceil32(return_data.size)) + 320] = 38
                                                            mem[_9887 + (4 * ceil32(return_data.size)) + 352 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                            if _5499 > balanceOf[address(msg.sender)]:
                                                                mem[_9887 + (4 * ceil32(return_data.size)) + 416] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_9887 + (4 * ceil32(return_data.size)) + 420] = 32
                                                                mem[_9887 + (4 * ceil32(return_data.size)) + 452] = 38
                                                                mem[_9887 + (4 * ceil32(return_data.size)) + 484 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, Mask(208, 32, block.timestamp) >> 32
                                                                mem[_9887 + (4 * ceil32(return_data.size)) + 522] = 0
                                                                revert with memory
                                                                  from _9887 + (4 * ceil32(return_data.size)) + 416
                                                                   len (5 * ceil32(return_data.size)) + 132
                                                            if balanceOf[address(msg.sender)] < _5499:
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] -= _5499
                                                            if balanceOf[this.address] > !_5499:
                                                                revert with 0, 17
                                                            if balanceOf[this.address] + _5499 >= balanceOf[this.address]:
                                                                balanceOf[address(this.address)] = balanceOf[this.address] + _5499
                                                                emit Transfer(_5499, msg.sender, this.address);
                                                                if arg1 >= 3:
                                                                    revert with 0, 50
                                                                mem[_9887 + (4 * ceil32(return_data.size)) + 416] = 0x12b8603f00000000000000000000000000000000000000000000000000000000
                                                                mem[_9887 + (4 * ceil32(return_data.size)) + 420] = msg.sender
                                                                mem[_9887 + (4 * ceil32(return_data.size)) + 452] = 64
                                                                mem[_9887 + (4 * ceil32(return_data.size)) + 484] = mem[128]
                                                                mem[_9887 + (4 * ceil32(return_data.size)) + 516 len ceil32(mem[128])] = mem[160 len ceil32(mem[128])]
                                                                if ceil32(mem[128]) > mem[128]:
                                                                    mem[_9887 + (4 * ceil32(return_data.size)) + mem[128] + 516] = 0
                                                                require ext_code.size(sub_20eea8b5[arg1])
                                                                call sub_20eea8b5[arg1].createNode(address arg1, string arg2) with:
                                                                     gas gas_remaining wei
                                                                    args mem[_9887 + (4 * ceil32(return_data.size)) + 420 len ceil32(mem[128]) + (5 * ceil32(return_data.size)) + 96]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                if stor27[address(msg.sender)] > -2:
                                                                    revert with 0, 17
                                                                if stor27[address(msg.sender)] + 1 >= stor27[address(msg.sender)]:
                                                                    stor27[address(msg.sender)]++
                                                            mem[_9887 + (4 * ceil32(return_data.size)) + 416] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_9887 + (4 * ceil32(return_data.size)) + 420] = 32
                                                            mem[_9887 + (4 * ceil32(return_data.size)) + 452] = 27
                                                            mem[_9887 + (4 * ceil32(return_data.size)) + 484] = 'SafeMath: addition overflow'
                                                            revert with memory
                                                              from _9887 + (4 * ceil32(return_data.size)) + 416
                                                               len (5 * ceil32(return_data.size)) + 100
                                                        if balanceOf[this.address] and liquidityPoolFee > -1 / balanceOf[this.address]:
                                                            revert with 0, 17
                                                        if not balanceOf[this.address]:
                                                            revert with 0, 18
                                                        if balanceOf[this.address] * liquidityPoolFee / balanceOf[this.address] != liquidityPoolFee:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _9841 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_9841] = 26
                                                        mem[_9841 + 32] = 'SafeMath: division by zero'
                                                        _9859 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_9859] = 26
                                                        mem[_9859 + 32] = 'SafeMath: division by zero'
                                                        _9877 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_9877] = 30
                                                        mem[_9877 + 32] = 'SafeMath: subtraction overflow'
                                                        if balanceOf[this.address] * liquidityPoolFee / 100 / 2 > balanceOf[this.address] * liquidityPoolFee / 100:
                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                        if balanceOf[this.address] * liquidityPoolFee / 100 < balanceOf[this.address] * liquidityPoolFee / 100 / 2:
                                                            revert with 0, 17
                                                        _9967 = mem[64]
                                                        mem[mem[64]] = 2
                                                        mem[64] = mem[64] + 96
                                                        mem[_9967 + 32 len 64] = call.data[calldata.size len 64]
                                                        if 0 >= mem[_9967]:
                                                            revert with 0, 50
                                                        mem[_9967 + 32] = this.address
                                                        require ext_code.size(uniswapV2RouterAddress)
                                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                gas gas_remaining wei
                                                        mem[_9967 + 96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[64] = _9967 + ceil32(return_data.size) + 96
                                                        require return_data.size >= 32
                                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                        if 1 >= mem[_9967]:
                                                            revert with 0, 50
                                                        mem[_9967 + 64] = ext_call.return_data[12 len 20]
                                                        if not this.address:
                                                            revert with 0, 'ERC20: approve from the zero address'
                                                        if not uniswapV2RouterAddress:
                                                            revert with 0, 'ERC20: approve to the zero address'
                                                        mem[0] = uniswapV2RouterAddress
                                                        mem[32] = sha3(address(this.address), 1)
                                                        allowance[address(this.address)][stor9].field_0 = balanceOf[this.address] * liquidityPoolFee / 100 / 2
                                                        allowance[address(this.address)][stor9].field_255 = 0
                                                        emit Approval((balanceOf[this.address] * liquidityPoolFee / 100 / 2), this.address, uniswapV2RouterAddress);
                                                        mem[_9967 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                        mem[_9967 + ceil32(return_data.size) + 100] = balanceOf[this.address] * liquidityPoolFee / 100 / 2
                                                        mem[_9967 + ceil32(return_data.size) + 132] = 0
                                                        mem[_9967 + ceil32(return_data.size) + 164] = 160
                                                        mem[_9967 + ceil32(return_data.size) + 260] = mem[_9967]
                                                        idx = 0
                                                        s = _9967 + ceil32(return_data.size) + 292
                                                        t = _9967 + 32
                                                        while idx < mem[_9967]:
                                                            mem[s] = mem[t + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[_9967 + ceil32(return_data.size) + 196] = this.address
                                                        mem[_9967 + ceil32(return_data.size) + 228] = block.timestamp
                                                        require ext_code.size(uniswapV2RouterAddress)
                                                        call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                             gas gas_remaining wei
                                                            args mem[mem[64] + 4 len _9967 + ceil32(return_data.size) + (32 * mem[_9967]) + -mem[64] + 288]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _12028 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_12028] = 30
                                                        mem[_12028 + 32] = 'SafeMath: subtraction overflow'
                                                        if eth.balance(this.address) > eth.balance(this.address):
                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                        if eth.balance(this.address) < eth.balance(this.address):
                                                            revert with 0, 17
                                                        if not this.address:
                                                            revert with 0, 'ERC20: approve from the zero address'
                                                        if not uniswapV2RouterAddress:
                                                            revert with 0, 'ERC20: approve to the zero address'
                                                        mem[0] = uniswapV2RouterAddress
                                                        mem[32] = sha3(address(this.address), 1)
                                                        allowance[address(this.address)][stor9].field_0 = (balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2)
                                                        emit Approval(((balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2)), this.address, uniswapV2RouterAddress);
                                                        mem[mem[64] + 68] = 0
                                                        mem[mem[64] + 100] = 0
                                                        mem[mem[64] + 132] = 0
                                                        mem[mem[64] + 164] = block.timestamp
                                                        require ext_code.size(uniswapV2RouterAddress)
                                                        call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                             gas gas_remaining wei
                                                            args this.address, (balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2), 0, 0, 0, block.timestamp
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 96
                                                        mem[mem[64] + 32] = 0
                                                        mem[mem[64] + 64] = (balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2)
                                                        emit SwapAndLiquify(Mask(255, 1, balanceOf[this.address] * liquidityPoolFee / 100), 0, (balanceOf[this.address] * liquidityPoolFee / 100) - (balanceOf[this.address] * liquidityPoolFee / 100 / 2));
                                                        mem[0] = this.address
                                                        mem[32] = 0
                                                        _12568 = mem[64]
                                                        mem[mem[64]] = 2
                                                        mem[64] = mem[64] + 96
                                                        mem[_12568 + 32 len 64] = call.data[calldata.size len 64]
                                                        if 0 >= mem[_12568]:
                                                            revert with 0, 50
                                                        mem[_12568 + 32] = this.address
                                                        require ext_code.size(uniswapV2RouterAddress)
                                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                gas gas_remaining wei
                                                        mem[_12568 + 96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[64] = _12568 + ceil32(return_data.size) + 96
                                                        require return_data.size >= 32
                                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                        if 1 >= mem[_12568]:
                                                            revert with 0, 50
                                                        mem[_12568 + 64] = ext_call.return_data[12 len 20]
                                                        if not this.address:
                                                            revert with 0, 'ERC20: approve from the zero address'
                                                        if not uniswapV2RouterAddress:
                                                            revert with 0, 'ERC20: approve to the zero address'
                                                        mem[0] = uniswapV2RouterAddress
                                                        mem[32] = sha3(address(this.address), 1)
                                                        allowance[address(this.address)][stor9].field_0 = balanceOf[this.address]
                                                        emit Approval(balanceOf[this.address], this.address, uniswapV2RouterAddress);
                                                        mem[_12568 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                        mem[_12568 + ceil32(return_data.size) + 100] = balanceOf[this.address]
                                                        mem[_12568 + ceil32(return_data.size) + 132] = 0
                                                        mem[_12568 + ceil32(return_data.size) + 164] = 160
                                                        mem[_12568 + ceil32(return_data.size) + 260] = mem[_12568]
                                                        idx = 0
                                                        s = _12568 + ceil32(return_data.size) + 292
                                                        t = _12568 + 32
                                                        while idx < mem[_12568]:
                                                            mem[s] = mem[t + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[_12568 + ceil32(return_data.size) + 228] = block.timestamp
                                                        require ext_code.size(uniswapV2RouterAddress)
                                                        call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                             gas gas_remaining wei
                                                            args balanceOf[this.address], 0, 160, address(this.address), block.timestamp, mem[_12568 + ceil32(return_data.size) + 260 len (32 * mem[_12568]) + 32]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[_12568 + ceil32(return_data.size) + 96] = 30
                                                        mem[_12568 + ceil32(return_data.size) + 128] = 'SafeMath: subtraction overflow'
                                                        if eth.balance(this.address) > eth.balance(this.address):
                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                        if eth.balance(this.address) < eth.balance(this.address):
                                                            revert with 0, 17
                                                        call marketingWalletAddress with:
                                                             gas 2300 wei
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        uint8(stor23.field_0) = 0
                                                        if not msg.sender:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not this.address:
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        mem[_12568 + ceil32(return_data.size) + 160] = 38
                                                        mem[_12568 + ceil32(return_data.size) + 192 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                        if _5499 > balanceOf[address(msg.sender)]:
                                                            revert with 0, 
                                                                        32,
                                                                        38,
                                                                        0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, Mask(208, 32, block.timestamp) >> 32 >> 48,
                                                                        0
                                                        if balanceOf[address(msg.sender)] < _5499:
                                                            revert with 0, 17
                                                        balanceOf[address(msg.sender)] -= _5499
                                                        if balanceOf[this.address] > !_5499:
                                                            revert with 0, 17
                                                        if balanceOf[this.address] + _5499 < balanceOf[this.address]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        balanceOf[address(this.address)] = balanceOf[this.address] + _5499
                                                        emit Transfer(_5499, msg.sender, this.address);
                                                        if arg1 >= 3:
                                                            revert with 0, 50
                                                        mem[_12568 + ceil32(return_data.size) + 256] = 0x12b8603f00000000000000000000000000000000000000000000000000000000
                                                        mem[_12568 + ceil32(return_data.size) + 260] = msg.sender
                                                        mem[_12568 + ceil32(return_data.size) + 292] = 64
                                                        mem[_12568 + ceil32(return_data.size) + 324] = mem[128]
                                                        mem[_12568 + ceil32(return_data.size) + 356 len ceil32(mem[128])] = mem[160 len ceil32(mem[128])]
                                                        var302001 = ceil32(mem[128])
                                                        if ceil32(mem[128]) > mem[128]:
                                                            mem[_12568 + ceil32(return_data.size) + mem[128] + 356] = 0
                                                        require ext_code.size(sub_20eea8b5[arg1])
                                                        call sub_20eea8b5[arg1].createNode(address arg1, string arg2) with:
                                                             gas gas_remaining wei
                                                            args msg.sender, Array(len=mem[128], data=mem[_12568 + ceil32(return_data.size) + 356 len ceil32(mem[128])])
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        if stor27[address(msg.sender)] > -2:
                                                            revert with 0, 17
                                                        if stor27[address(msg.sender)] + 1 < stor27[address(msg.sender)]:
                                                            revert with 0, 'SafeMath: addition overflow'
                            ('ge', ('add', 1, ('stor', ('map', ('mask_shl', 160, 0, 0, 'msg.sender'), ('name', 'stor27', 27)))), ('stor', ('map', ('mask_shl', 160, 0, 0, 'msg.sender'), ('name', 'stor27', 27))))
                            stor27[address(msg.sender)]++
}



}

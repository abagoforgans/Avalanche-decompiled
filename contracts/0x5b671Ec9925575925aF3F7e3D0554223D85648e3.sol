contract main {




// =====================  Runtime code  =====================


#
#  - sub_0886d0df(?)
#  - sub_10fec347(?)
#  - sub_500f1313(?)
#  - sub_9ead80fd(?)
#
mapping of uint8 sub_f119462d;
mapping of uint8 stor1;
mapping of uint256 sub_c40571ec;
address stor3;

function sub_c40571ec(?) {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    return sub_c40571ec[arg1]
}

function sub_f119462d(?) {
    require calldata.size - 4 >= 64
    require arg1 == address(arg1)
    require arg2 == address(arg2)
    return uint256(sub_f119462d[arg1][arg2])
}

function sub_fa847836(?) {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    return bool(stor1[arg1])
}

function _fallback() payable {
  stop
}

function isAllowed() {
    if 0x85a92368ab710a85f57b9872c0fe4361a405e5d != msg.sender:
        require msg.sender == 0xebdef90adcd0cef650afd081375570b391a6880a
    return 1
}

function sub_4e27b7d5(?) {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    if address(arg1) != 0xd8aa70f7990dab4a383a0d8a57df7a372916575d:
        if address(arg1) != 0xb9a9bb6cc39387548baa7185fbff51d47eef8771:
            return 0
    return 1
}

function sub_0050648d(?) {
    require calldata.size - 4 >= 224
    require arg1 == arg1
    require calldata.size - 36 >= 192
    require arg2 == address(arg2)
    require arg3 == address(arg3)
    require arg4 == address(arg4)
    require arg5 == address(arg5)
    require arg6 == arg6
    require arg7 == arg7
}

function sub_90c3d203(?) {
    require calldata.size - 4 >= 96
    require arg1 == address(arg1)
    require arg2 == address(arg2)
    require arg3 == address(arg3)
    if uint256(sub_f119462d[address(arg1)][address(arg2)]) == uint256(sub_f119462d[address(arg1)][address(arg3)]):
        revert with 0, 'BAD CURVE'
    return uint256(sub_f119462d[address(arg1)][address(arg2)]), uint256(sub_f119462d[address(arg1)][address(arg3)])
}

function sub_02be4f86(?) {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    mem[132] = 0, mem[132 len 28]
    mem[136] = 0
    staticcall address(arg1).mem[132 len 4] with:
            gas gas_remaining wei
    if not return_data.size:
        mem[132] = 0, mem[132 len 4], 0
        return mem[132], 0, mem[168 len 24]
    mem[164 len return_data.size] = ext_call.return_data[0 len return_data.size]
    _41 = mem[196]
    mem[ceil32(return_data.size) + 133] = mem[164]
    return mem[ceil32(return_data.size) + 133], _41
}

function sub_a22da4b2(?) {
    require calldata.size - 4 >= 224
    require arg1 == arg1
    require calldata.size - 36 >= 192
    require arg2 == address(arg2)
    require arg3 == address(arg3)
    require arg4 == address(arg4)
    require arg5 == address(arg5)
    require arg6 == arg6
    require arg7 == arg7
    if uint256(sub_f119462d[address(arg5)][address(arg2)]) == uint256(sub_f119462d[address(arg5)][address(arg3)]):
        revert with 0, 'BAD CURVE'
    require ext_code.size(address(arg5))
    staticcall address(arg5).calculateSwap(uint8 arg1, uint8 arg2, uint256 arg3) with:
            gas gas_remaining wei
           args uint8(sub_f119462d[address(arg5)][address(arg2)]), uint8(sub_f119462d[address(arg5)][address(arg3)]), arg1
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[0]
    if ext_call.return_data[0] < 1:
        revert with 'NH{q', 17
    return (ext_call.return_data[0] - 1)
}

function withdraw(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    require ext_code.size(arg1)
    staticcall arg1.0x70a08231 with:
            gas gas_remaining wei
           args this.address
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[0]
    if ext_call.return_data[0] <= 0:
        revert with 0, 'not found'
    require ext_code.size(arg1)
    call arg1.0xa9059cbb with:
         gas gas_remaining wei
        args 0x85a92368ab710a85f57b9872c0fe4361a405e5d, ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if eth.balance(this.address) > 0:
        call 0x085a92368ab710a85f57b9872c0fe4361a405e5d with:
           value eth.balance(this.address) wei
             gas 2300 * is_zero(value) wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
}

function sub_399d71fd(?) {
    require calldata.size - 4 >= 224
    require arg1 == address(arg1)
    require arg2 == address(arg2)
    require arg3 == address(arg3)
    require arg4 == arg4
    require arg5 == arg5
    require arg6 == bool(arg6)
    require arg7 == address(arg7)
    if 0x85a92368ab710a85f57b9872c0fe4361a405e5d != msg.sender:
        require msg.sender == 0xebdef90adcd0cef650afd081375570b391a6880a
    if arg6:
        require ext_code.size(address(arg2))
        call address(arg2).0xa9059cbb with:
             gas gas_remaining wei
            args address(arg1), arg4
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == bool(ext_call.return_data[0])
    require ext_code.size(address(arg1))
    if address(arg2) < address(arg3):
        if address(arg2) == address(arg2):
            call address(arg1).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, arg5, address(arg7), 128, 0
            if not ext_call.success:
                require ext_code.size(address(arg1))
                call address(arg1).swap(uint256 arg1, uint256 arg2, address arg3) with:
                     gas gas_remaining wei
                    args 0, arg5, address(arg7)
                require ext_call.success
        else:
            call address(arg1).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args arg5, 0, address(arg7), 128, 0
            if not ext_call.success:
                require ext_code.size(address(arg1))
                call address(arg1).swap(uint256 arg1, uint256 arg2, address arg3) with:
                     gas gas_remaining wei
                    args arg5, 0, address(arg7)
                require ext_call.success
    else:
        if address(arg2) == address(arg3):
            call address(arg1).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, arg5, address(arg7), 128, 0
            if not ext_call.success:
                require ext_code.size(address(arg1))
                call address(arg1).swap(uint256 arg1, uint256 arg2, address arg3) with:
                     gas gas_remaining wei
                    args 0, arg5, address(arg7)
                require ext_call.success
        else:
            call address(arg1).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args arg5, 0, address(arg7), 128, 0
            if not ext_call.success:
                require ext_code.size(address(arg1))
                call address(arg1).swap(uint256 arg1, uint256 arg2, address arg3) with:
                     gas gas_remaining wei
                    args arg5, 0, address(arg7)
                require ext_call.success
}

function sub_d80c6821(?) {
    require calldata.size - 4 >= 224
    require arg1 == arg1
    require calldata.size - 36 >= 192
    require arg2 == address(arg2)
    require arg3 == address(arg3)
    require arg4 == address(arg4)
    require arg5 == address(arg5)
    require arg6 == arg6
    require arg7 == arg7
    if uint256(sub_f119462d[address(arg5)][address(arg2)]) == uint256(sub_f119462d[address(arg5)][address(arg3)]):
        revert with 0, 'BAD CURVE'
    if address(arg5) == 0x58e57ca18b7a47112b877e31929798cd3d703b0f:
        require ext_code.size(address(arg5))
        call address(arg5).exchange_underlying(uint256 arg1, uint256 arg2, uint256 arg3, uint256 arg4) with:
             gas gas_remaining wei
            args uint256(sub_f119462d[address(arg5)][address(arg2)]), uint256(sub_f119462d[address(arg5)][address(arg3)]), arg1, 0
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
    if address(arg5) == 0x7f90122bf0700f9e7e1f688fe926940e8839f353:
        require ext_code.size(address(arg5))
        call address(arg5).exchange_underlying(int128 arg1, int128 arg2, uint256 arg3, uint256 arg4) with:
             gas gas_remaining wei
            args ('signextend', 15, ('type', 256, ('stor', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg5')), ('name', 'sub_f119462d', 0)))))), ('signextend', 15, ('type', 256, ('stor', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg3')), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg5')), ('name', 'sub_f119462d', 0)))))), arg1, 0
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
    if address(arg5) == 0xaea2e71b631fa93683bcf256a8689dfa0e094fcd:
        require ext_code.size(address(arg5))
        call address(arg5).exchange(int128 arg1, int128 arg2, uint256 arg3, uint256 arg4) with:
             gas gas_remaining wei
            args ('signextend', 15, ('type', 256, ('stor', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg5')), ('name', 'sub_f119462d', 0)))))), ('signextend', 15, ('type', 256, ('stor', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg3')), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg5')), ('name', 'sub_f119462d', 0)))))), arg1, 0
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
    else:
        if address(arg5) == 0x3a43a5851a3e3e0e25a3c1089670269786be1577:
            require ext_code.size(address(arg5))
            call address(arg5).exchange(int128 arg1, int128 arg2, uint256 arg3, uint256 arg4) with:
                 gas gas_remaining wei
                args ('signextend', 15, ('type', 256, ('stor', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg5')), ('name', 'sub_f119462d', 0)))))), ('signextend', 15, ('type', 256, ('stor', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg3')), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg5')), ('name', 'sub_f119462d', 0)))))), arg1, 0
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
        else:
            if address(arg5) == 0x93004d8477f117ea359b71ec02f2706c8175c55c:
                require ext_code.size(address(arg5))
                call address(arg5).exchange(int128 arg1, int128 arg2, uint256 arg3, uint256 arg4) with:
                     gas gas_remaining wei
                    args ('signextend', 15, ('type', 256, ('stor', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg5')), ('name', 'sub_f119462d', 0)))))), ('signextend', 15, ('type', 256, ('stor', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg3')), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg5')), ('name', 'sub_f119462d', 0)))))), arg1, 0
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
            else:
                if address(arg5) == 0xd79138c49c49200a1afc935171d1bdad084fdc95:
                    require ext_code.size(address(arg5))
                    call address(arg5).exchange(int128 arg1, int128 arg2, uint256 arg3, uint256 arg4) with:
                         gas gas_remaining wei
                        args ('signextend', 15, ('type', 256, ('stor', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg5')), ('name', 'sub_f119462d', 0)))))), ('signextend', 15, ('type', 256, ('stor', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg3')), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg5')), ('name', 'sub_f119462d', 0)))))), arg1, 0
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
}

function sub_36888411(?) {
    require calldata.size - 4 >= 96
    require arg1 == arg1
    require arg2 == address(arg2)
    require arg3 == address(arg3)
    require ext_code.size(address(arg2))
    staticcall address(arg2).0x313ce567 with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[0]
    require ext_code.size(address(arg3))
    staticcall address(arg3).0x313ce567 with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[0]
    if ext_call.return_data[0] == ext_call.return_data[0]:
        return arg1
    if not ext_call.return_data[0]:
        if not ext_call.return_data[0]:
            if arg1 and 1 > -1 / arg1:
                revert with 'NH{q', 17
            return arg1
        if bool(bool(ext_call.return_data[0] < 78)) or bool(bool(ext_call.return_data[0] < 32)):
            if 10^ext_call.return_data[0] > -1:
                revert with 'NH{q', 17
            if arg1 and 10^ext_call.return_data[0] > -1 / arg1:
                revert with 'NH{q', 17
            return (arg1 * 10^ext_call.return_data[0])
        s = 10
        t = 1
        idx = ext_call.return_data[0]
        while idx > 1:
            if s > -1 / s:
                revert with 'NH{q', 17
            if not bool(idx):
                s = s * s
                t = t
                idx = uint255(idx) * 0.5
                continue 
            s = s * s
            t = t * s
            idx = uint255(idx) * 0.5
            continue 
        if t > -1 / s:
            revert with 'NH{q', 17
        if arg1 and t * s > -1 / arg1:
            revert with 'NH{q', 17
        return (arg1 * t * s)
    if bool(bool(ext_call.return_data[0] < 78)) or bool(bool(ext_call.return_data[0] < 32)):
        if 10^ext_call.return_data[0] > -1:
            revert with 'NH{q', 17
        if not ext_call.return_data[0]:
            if arg1 and 1 > -1 / arg1:
                revert with 'NH{q', 17
            if not 10^ext_call.return_data[0]:
                revert with 'NH{q', 18
            return (arg1 / 10^ext_call.return_data[0])
        if bool(bool(ext_call.return_data[0] < 78)) or bool(bool(ext_call.return_data[0] < 32)):
            if 10^ext_call.return_data[0] > -1:
                revert with 'NH{q', 17
            if arg1 and 10^ext_call.return_data[0] > -1 / arg1:
                revert with 'NH{q', 17
            if not 10^ext_call.return_data[0]:
                revert with 'NH{q', 18
            return (arg1 * 10^ext_call.return_data[0] / 10^ext_call.return_data[0])
        s = 10
        t = 1
        idx = ext_call.return_data[0]
        while idx > 1:
            if s > -1 / s:
                revert with 'NH{q', 17
            if not bool(idx):
                s = s * s
                t = t
                idx = uint255(idx) * 0.5
                continue 
            s = s * s
            t = t * s
            idx = uint255(idx) * 0.5
            continue 
        if t > -1 / s:
            revert with 'NH{q', 17
        if arg1 and t * s > -1 / arg1:
            revert with 'NH{q', 17
        if not 10^ext_call.return_data[0]:
            revert with 'NH{q', 18
        return (arg1 * t * s / 10^ext_call.return_data[0])
    s = 10
    t = 1
    idx = ext_call.return_data[0]
    while idx > 1:
        if s > -1 / s:
            revert with 'NH{q', 17
        if not bool(idx):
            s = s * s
            t = t
            idx = uint255(idx) * 0.5
            continue 
        s = s * s
        t = t * s
        idx = uint255(idx) * 0.5
        continue 
    if t > -1 / s:
        revert with 'NH{q', 17
    if not ext_call.return_data[0]:
        if arg1 and 1 > -1 / arg1:
            revert with 'NH{q', 17
        if not t * s:
            revert with 'NH{q', 18
        return (arg1 / t * s)
    if bool(bool(ext_call.return_data[0] < 78)) or bool(bool(ext_call.return_data[0] < 32)):
        if 10^ext_call.return_data[0] > -1:
            revert with 'NH{q', 17
        if arg1 and 10^ext_call.return_data[0] > -1 / arg1:
            revert with 'NH{q', 17
        if not t * s:
            revert with 'NH{q', 18
        return (arg1 * 10^ext_call.return_data[0] / t * s)
    u = 10
    v = 1
    idx = ext_call.return_data[0]
    while idx > 1:
        if u > -1 / u:
            revert with 'NH{q', 17
        if not bool(idx):
            u = u * u
            v = v
            idx = uint255(idx) * 0.5
            continue 
        u = u * u
        v = v * u
        idx = uint255(idx) * 0.5
        continue 
    if v > -1 / u:
        revert with 'NH{q', 17
    if arg1 and v * u > -1 / arg1:
        revert with 'NH{q', 17
    if not t * s:
        revert with 'NH{q', 18
    return (arg1 * v * u / t * s)
}

function sub_2e6595c0(?) {
    require calldata.size - 4 >= 64
    require cd[4] == cd[4]
    require cd[36] <= test266151307()
    require cd[36] + 35 < calldata.size
    if ('cd', 36).length > test266151307():
        revert with 'NH{q', 65
    if floor32(('cd', 36).length) + 97 > test266151307() or floor32(('cd', 36).length) + 97 < 96:
        revert with 'NH{q', 65
    mem[64] = floor32(('cd', 36).length) + 97
    mem[96] = ('cd', 36).length
    require cd[36] + (192 * ('cd', 36).length) + 36 <= calldata.size
    idx = 0
    s = cd[36] + 36
    t = 128
    while idx < ('cd', 36).length:
        require calldata.size - s >= 192
        _286 = mem[64]
        if mem[64] + 192 > test266151307() or mem[64] + 192 < mem[64]:
            revert with 'NH{q', 65
        mem[64] = mem[64] + 192
        require cd[s] == address(cd[s])
        mem[_286] = cd[s]
        require cd[(s + 32)] == address(cd[(s + 32)])
        mem[_286 + 32] = cd[(s + 32)]
        require cd[(s + 64)] == address(cd[(s + 64)])
        mem[_286 + 64] = cd[(s + 64)]
        require cd[(s + 96)] == address(cd[(s + 96)])
        mem[_286 + 96] = cd[(s + 96)]
        require cd[(s + 128)] == cd[(s + 128)]
        mem[_286 + 128] = cd[(s + 128)]
        require cd[(s + 160)] == cd[(s + 160)]
        mem[_286 + 160] = cd[(s + 160)]
        mem[t] = _286
        idx = idx + 1
        s = s + 192
        t = t + 32
        continue 
    if 0 >= mem[96]:
        revert with 'NH{q', 50
    if mem[96] < 1:
        revert with 'NH{q', 17
    if mem[96] - 1 >= mem[96]:
        revert with 'NH{q', 50
    if stor3:
        if mem[mem[128] + 12 len 20] == mem[mem[(32 * mem[96] - 1) + 128] + 44 len 20]:
            if mem[mem[128] + 160] == 1:
                if mem[mem[(32 * mem[96] - 1) + 128] + 160] == 1:
                    if mem[96] == 2:
                        return 1
                    if mem[96] != 3:
                        return 1
                    mem[0] = mem[mem[128] + 44 len 20]
                    mem[32] = 1
                    if stor1[mem[0]]:
                        mem[0] = mem[mem[(32 * mem[96] - 1) + 128] + 12 len 20]
                        if stor1[mem[0]]:
                            return 1
                else:
                    if mem[mem[(32 * mem[96] - 1) + 128] + 160] == 7:
                        if mem[96] == 2:
                            return 1
                        if mem[96] != 3:
                            return 1
                        mem[0] = mem[mem[128] + 44 len 20]
                        mem[32] = 1
                        if stor1[mem[0]]:
                            mem[0] = mem[mem[(32 * mem[96] - 1) + 128] + 12 len 20]
                            if stor1[mem[0]]:
                                return 1
                    else:
                        if mem[mem[(32 * mem[96] - 1) + 128] + 160] == 13:
                            if mem[96] == 2:
                                return 1
                            if mem[96] != 3:
                                return 1
                            mem[0] = mem[mem[128] + 44 len 20]
                            mem[32] = 1
                            if stor1[mem[0]]:
                                mem[0] = mem[mem[(32 * mem[96] - 1) + 128] + 12 len 20]
                                if stor1[mem[0]]:
                                    return 1
                        else:
                            if mem[mem[(32 * mem[96] - 1) + 128] + 160] == 14:
                                if mem[96] == 2:
                                    return 1
                                if mem[96] != 3:
                                    return 1
                                mem[0] = mem[mem[128] + 44 len 20]
                                mem[32] = 1
                                if stor1[mem[0]]:
                                    mem[0] = mem[mem[(32 * mem[96] - 1) + 128] + 12 len 20]
                                    if stor1[mem[0]]:
                                        return 1
            else:
                if mem[mem[128] + 160] == 7:
                    if mem[mem[(32 * mem[96] - 1) + 128] + 160] == 1:
                        if mem[96] == 2:
                            return 1
                        if mem[96] != 3:
                            return 1
                        mem[0] = mem[mem[128] + 44 len 20]
                        mem[32] = 1
                        if stor1[mem[0]]:
                            mem[0] = mem[mem[(32 * mem[96] - 1) + 128] + 12 len 20]
                            if stor1[mem[0]]:
                                return 1
                    else:
                        if mem[mem[(32 * mem[96] - 1) + 128] + 160] == 7:
                            if mem[96] == 2:
                                return 1
                            if mem[96] != 3:
                                return 1
                            mem[0] = mem[mem[128] + 44 len 20]
                            mem[32] = 1
                            if stor1[mem[0]]:
                                mem[0] = mem[mem[(32 * mem[96] - 1) + 128] + 12 len 20]
                                if stor1[mem[0]]:
                                    return 1
                        else:
                            if mem[mem[(32 * mem[96] - 1) + 128] + 160] == 13:
                                if mem[96] == 2:
                                    return 1
                                if mem[96] != 3:
                                    return 1
                                mem[0] = mem[mem[128] + 44 len 20]
                                mem[32] = 1
                                if stor1[mem[0]]:
                                    mem[0] = mem[mem[(32 * mem[96] - 1) + 128] + 12 len 20]
                                    if stor1[mem[0]]:
                                        return 1
                            else:
                                if mem[mem[(32 * mem[96] - 1) + 128] + 160] == 14:
                                    if mem[96] == 2:
                                        return 1
                                    if mem[96] != 3:
                                        return 1
                                    mem[0] = mem[mem[128] + 44 len 20]
                                    mem[32] = 1
                                    if stor1[mem[0]]:
                                        mem[0] = mem[mem[(32 * mem[96] - 1) + 128] + 12 len 20]
                                        if stor1[mem[0]]:
                                            return 1
                else:
                    if mem[mem[128] + 160] == 13:
                        if mem[mem[(32 * mem[96] - 1) + 128] + 160] == 1:
                            if mem[96] == 2:
                                return 1
                            if mem[96] != 3:
                                return 1
                            mem[0] = mem[mem[128] + 44 len 20]
                            mem[32] = 1
                            if stor1[mem[0]]:
                                mem[0] = mem[mem[(32 * mem[96] - 1) + 128] + 12 len 20]
                                if stor1[mem[0]]:
                                    return 1
                        else:
                            if mem[mem[(32 * mem[96] - 1) + 128] + 160] == 7:
                                if mem[96] == 2:
                                    return 1
                                if mem[96] != 3:
                                    return 1
                                mem[0] = mem[mem[128] + 44 len 20]
                                mem[32] = 1
                                if stor1[mem[0]]:
                                    mem[0] = mem[mem[(32 * mem[96] - 1) + 128] + 12 len 20]
                                    if stor1[mem[0]]:
                                        return 1
                            else:
                                if mem[mem[(32 * mem[96] - 1) + 128] + 160] == 13:
                                    if mem[96] == 2:
                                        return 1
                                    if mem[96] != 3:
                                        return 1
                                    mem[0] = mem[mem[128] + 44 len 20]
                                    mem[32] = 1
                                    if stor1[mem[0]]:
                                        mem[0] = mem[mem[(32 * mem[96] - 1) + 128] + 12 len 20]
                                        if stor1[mem[0]]:
                                            return 1
                                else:
                                    if mem[mem[(32 * mem[96] - 1) + 128] + 160] == 14:
                                        if mem[96] == 2:
                                            return 1
                                        if mem[96] != 3:
                                            return 1
                                        mem[0] = mem[mem[128] + 44 len 20]
                                        mem[32] = 1
                                        if stor1[mem[0]]:
                                            mem[0] = mem[mem[(32 * mem[96] - 1) + 128] + 12 len 20]
                                            if stor1[mem[0]]:
                                                return 1
                    else:
                        if mem[mem[128] + 160] == 14:
                            if mem[mem[(32 * mem[96] - 1) + 128] + 160] == 1:
                                if mem[96] == 2:
                                    return 1
                                if mem[96] != 3:
                                    return 1
                                mem[0] = mem[mem[128] + 44 len 20]
                                mem[32] = 1
                                if stor1[mem[0]]:
                                    mem[0] = mem[mem[(32 * mem[96] - 1) + 128] + 12 len 20]
                                    if stor1[mem[0]]:
                                        return 1
                            else:
                                if mem[mem[(32 * mem[96] - 1) + 128] + 160] == 7:
                                    if mem[96] == 2:
                                        return 1
                                    if mem[96] != 3:
                                        return 1
                                    mem[0] = mem[mem[128] + 44 len 20]
                                    mem[32] = 1
                                    if stor1[mem[0]]:
                                        mem[0] = mem[mem[(32 * mem[96] - 1) + 128] + 12 len 20]
                                        if stor1[mem[0]]:
                                            return 1
                                else:
                                    if mem[mem[(32 * mem[96] - 1) + 128] + 160] == 13:
                                        if mem[96] == 2:
                                            return 1
                                        if mem[96] != 3:
                                            return 1
                                        mem[0] = mem[mem[128] + 44 len 20]
                                        mem[32] = 1
                                        if stor1[mem[0]]:
                                            mem[0] = mem[mem[(32 * mem[96] - 1) + 128] + 12 len 20]
                                            if stor1[mem[0]]:
                                                return 1
                                    else:
                                        if mem[mem[(32 * mem[96] - 1) + 128] + 160] == 14:
                                            if mem[96] == 2:
                                                return 1
                                            if mem[96] != 3:
                                                return 1
                                            mem[0] = mem[mem[128] + 44 len 20]
                                            mem[32] = 1
                                            if stor1[mem[0]]:
                                                mem[0] = mem[mem[(32 * mem[96] - 1) + 128] + 12 len 20]
                                                if stor1[mem[0]]:
                                                    return 1
    return 0
}

function sub_5bf03be3(?) {
    require calldata.size - 4 >= 224
    require arg1 == arg1
    require calldata.size - 36 >= 192
    require arg2 == address(arg2)
    require arg3 == address(arg3)
    require arg4 == address(arg4)
    require arg5 == address(arg5)
    require arg6 == arg6
    require arg7 == arg7
    if uint256(sub_f119462d[address(arg5)][address(arg2)]) == uint256(sub_f119462d[address(arg5)][address(arg3)]):
        revert with 0, 'BAD CURVE'
    if address(arg5) != 0x58e57ca18b7a47112b877e31929798cd3d703b0f:
        if address(arg5) != 0x7f90122bf0700f9e7e1f688fe926940e8839f353:
            if address(arg5) != 0xaea2e71b631fa93683bcf256a8689dfa0e094fcd:
                if address(arg5) != 0x3a43a5851a3e3e0e25a3c1089670269786be1577:
                    if address(arg5) != 0x93004d8477f117ea359b71ec02f2706c8175c55c:
                        require address(arg5) == 0xd79138c49c49200a1afc935171d1bdad084fdc95
            require ext_code.size(address(arg5))
            staticcall address(arg5).get_dy(int128 arg1, int128 arg2, uint256 arg3) with:
                    gas gas_remaining wei
                   args ('signextend', 15, ('type', 256, ('stor', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg5')), ('name', 'sub_f119462d', 0)))))), ('signextend', 15, ('type', 256, ('stor', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg3')), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg5')), ('name', 'sub_f119462d', 0)))))), arg1
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[0]
        else:
            require ext_code.size(address(arg5))
            staticcall address(arg5).get_dy_underlying(int128 arg1, int128 arg2, uint256 arg3) with:
                    gas gas_remaining wei
                   args ('signextend', 15, ('type', 256, ('stor', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg5')), ('name', 'sub_f119462d', 0)))))), ('signextend', 15, ('type', 256, ('stor', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg3')), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg5')), ('name', 'sub_f119462d', 0)))))), arg1
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[0]
            if address(arg5) == 0xaea2e71b631fa93683bcf256a8689dfa0e094fcd:
                require ext_code.size(address(arg5))
                staticcall address(arg5).get_dy(int128 arg1, int128 arg2, uint256 arg3) with:
                        gas gas_remaining wei
                       args ('signextend', 15, ('type', 256, ('stor', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg5')), ('name', 'sub_f119462d', 0)))))), ('signextend', 15, ('type', 256, ('stor', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg3')), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg5')), ('name', 'sub_f119462d', 0)))))), arg1
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[0]
            else:
                if address(arg5) == 0x3a43a5851a3e3e0e25a3c1089670269786be1577:
                    require ext_code.size(address(arg5))
                    staticcall address(arg5).get_dy(int128 arg1, int128 arg2, uint256 arg3) with:
                            gas gas_remaining wei
                           args ('signextend', 15, ('type', 256, ('stor', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg5')), ('name', 'sub_f119462d', 0)))))), ('signextend', 15, ('type', 256, ('stor', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg3')), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg5')), ('name', 'sub_f119462d', 0)))))), arg1
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                else:
                    if address(arg5) == 0x93004d8477f117ea359b71ec02f2706c8175c55c:
                        require ext_code.size(address(arg5))
                        staticcall address(arg5).get_dy(int128 arg1, int128 arg2, uint256 arg3) with:
                                gas gas_remaining wei
                               args ('signextend', 15, ('type', 256, ('stor', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg5')), ('name', 'sub_f119462d', 0)))))), ('signextend', 15, ('type', 256, ('stor', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg3')), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg5')), ('name', 'sub_f119462d', 0)))))), arg1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[0]
                    else:
                        if address(arg5) == 0xd79138c49c49200a1afc935171d1bdad084fdc95:
                            require ext_code.size(address(arg5))
                            staticcall address(arg5).get_dy(int128 arg1, int128 arg2, uint256 arg3) with:
                                    gas gas_remaining wei
                                   args ('signextend', 15, ('type', 256, ('stor', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg5')), ('name', 'sub_f119462d', 0)))))), ('signextend', 15, ('type', 256, ('stor', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg3')), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg5')), ('name', 'sub_f119462d', 0)))))), arg1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[0]
    else:
        require ext_code.size(address(arg5))
        staticcall address(arg5).get_dy_underlying(uint256 arg1, uint256 arg2, uint256 arg3) with:
                gas gas_remaining wei
               args uint256(sub_f119462d[address(arg5)][address(arg2)]), uint256(sub_f119462d[address(arg5)][address(arg3)]), arg1
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[0]
        if ext_call.return_data[0] and 9996 > -1 / ext_call.return_data[0]:
            revert with 'NH{q', 17
        if address(arg5) != 0x7f90122bf0700f9e7e1f688fe926940e8839f353:
            if address(arg5) != 0xaea2e71b631fa93683bcf256a8689dfa0e094fcd:
                if address(arg5) != 0x3a43a5851a3e3e0e25a3c1089670269786be1577:
                    if address(arg5) != 0x93004d8477f117ea359b71ec02f2706c8175c55c:
                        if address(arg5) != 0xd79138c49c49200a1afc935171d1bdad084fdc95:
                            require 9996 * ext_call.return_data[0] / 10000 > 0
                            if 9996 * ext_call.return_data[0] / 10000 < 1:
                                revert with 'NH{q', 17
                            return ((9996 * ext_call.return_data[0] / 10000) - 1)
            require ext_code.size(address(arg5))
            staticcall address(arg5).get_dy(int128 arg1, int128 arg2, uint256 arg3) with:
                    gas gas_remaining wei
                   args ('signextend', 15, ('type', 256, ('stor', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg5')), ('name', 'sub_f119462d', 0)))))), ('signextend', 15, ('type', 256, ('stor', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg3')), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg5')), ('name', 'sub_f119462d', 0)))))), arg1
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[0]
        else:
            require ext_code.size(address(arg5))
            staticcall address(arg5).get_dy_underlying(int128 arg1, int128 arg2, uint256 arg3) with:
                    gas gas_remaining wei
                   args ('signextend', 15, ('type', 256, ('stor', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg5')), ('name', 'sub_f119462d', 0)))))), ('signextend', 15, ('type', 256, ('stor', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg3')), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg5')), ('name', 'sub_f119462d', 0)))))), arg1
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[0]
            if address(arg5) == 0xaea2e71b631fa93683bcf256a8689dfa0e094fcd:
                require ext_code.size(address(arg5))
                staticcall address(arg5).get_dy(int128 arg1, int128 arg2, uint256 arg3) with:
                        gas gas_remaining wei
                       args ('signextend', 15, ('type', 256, ('stor', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg5')), ('name', 'sub_f119462d', 0)))))), ('signextend', 15, ('type', 256, ('stor', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg3')), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg5')), ('name', 'sub_f119462d', 0)))))), arg1
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[0]
            else:
                if address(arg5) == 0x3a43a5851a3e3e0e25a3c1089670269786be1577:
                    require ext_code.size(address(arg5))
                    staticcall address(arg5).get_dy(int128 arg1, int128 arg2, uint256 arg3) with:
                            gas gas_remaining wei
                           args ('signextend', 15, ('type', 256, ('stor', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg5')), ('name', 'sub_f119462d', 0)))))), ('signextend', 15, ('type', 256, ('stor', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg3')), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg5')), ('name', 'sub_f119462d', 0)))))), arg1
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                else:
                    if address(arg5) == 0x93004d8477f117ea359b71ec02f2706c8175c55c:
                        require ext_code.size(address(arg5))
                        staticcall address(arg5).get_dy(int128 arg1, int128 arg2, uint256 arg3) with:
                                gas gas_remaining wei
                               args ('signextend', 15, ('type', 256, ('stor', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg5')), ('name', 'sub_f119462d', 0)))))), ('signextend', 15, ('type', 256, ('stor', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg3')), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg5')), ('name', 'sub_f119462d', 0)))))), arg1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[0]
                    else:
                        if address(arg5) == 0xd79138c49c49200a1afc935171d1bdad084fdc95:
                            require ext_code.size(address(arg5))
                            staticcall address(arg5).get_dy(int128 arg1, int128 arg2, uint256 arg3) with:
                                    gas gas_remaining wei
                                   args ('signextend', 15, ('type', 256, ('stor', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg5')), ('name', 'sub_f119462d', 0)))))), ('signextend', 15, ('type', 256, ('stor', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg3')), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg5')), ('name', 'sub_f119462d', 0)))))), arg1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[0]
    require ext_call.return_data[0] > 0
    if ext_call.return_data[0] < 1:
        revert with 'NH{q', 17
    return (ext_call.return_data[0] - 1)
}

function sub_c54820e8(?) {
    require calldata.size - 4 >= 64
    require cd[4] == cd[4]
    require cd[36] <= test266151307()
    require cd[36] + 35 < calldata.size
    if ('cd', 36).length > test266151307():
        revert with 'NH{q', 65
    if floor32(('cd', 36).length) + 97 > test266151307() or floor32(('cd', 36).length) + 97 < 96:
        revert with 'NH{q', 65
    mem[64] = floor32(('cd', 36).length) + 97
    mem[96] = ('cd', 36).length
    require cd[36] + (192 * ('cd', 36).length) + 36 <= calldata.size
    idx = 0
    s = cd[36] + 36
    t = 128
    while idx < ('cd', 36).length:
        require calldata.size - s >= 192
        _1941 = mem[64]
        if mem[64] + 192 > test266151307() or mem[64] + 192 < mem[64]:
            revert with 'NH{q', 65
        mem[64] = mem[64] + 192
        require cd[s] == address(cd[s])
        mem[_1941] = cd[s]
        require cd[(s + 32)] == address(cd[(s + 32)])
        mem[_1941 + 32] = cd[(s + 32)]
        require cd[(s + 64)] == address(cd[(s + 64)])
        mem[_1941 + 64] = cd[(s + 64)]
        require cd[(s + 96)] == address(cd[(s + 96)])
        mem[_1941 + 96] = cd[(s + 96)]
        require cd[(s + 128)] == cd[(s + 128)]
        mem[_1941 + 128] = cd[(s + 128)]
        require cd[(s + 160)] == cd[(s + 160)]
        mem[_1941 + 160] = cd[(s + 160)]
        mem[t] = _1941
        idx = idx + 1
        s = s + 192
        t = t + 32
        continue 
    if 0 >= mem[96]:
        revert with 'NH{q', 50
    if mem[96] < 1:
        revert with 'NH{q', 17
    if mem[96] - 1 >= mem[96]:
        revert with 'NH{q', 50
    if not stor3:
        return cd[4]
    if mem[mem[128] + 12 len 20] != mem[mem[(32 * mem[96] - 1) + 128] + 44 len 20]:
        return cd[4]
    if mem[mem[128] + 160] == 1:
        if mem[mem[(32 * mem[96] - 1) + 128] + 160] == 1:
            if mem[96] == 2:
                if 0 >= mem[96]:
                    revert with 'NH{q', 50
                _2022 = mem[128]
                if mem[96] < 1:
                    revert with 'NH{q', 17
                if mem[96] - 1 >= mem[96]:
                    revert with 'NH{q', 50
                _2208 = mem[(32 * mem[96] - 1) + 128]
                mem[mem[64]] = 0x6fbc980700000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = mem[_2022 + 12 len 20]
                mem[mem[64] + 36] = mem[_2022 + 44 len 20]
                mem[mem[64] + 68] = mem[_2022 + 76 len 20]
                mem[mem[64] + 100] = mem[_2022 + 108 len 20]
                mem[mem[64] + 132] = mem[_2022 + 128]
                mem[mem[64] + 164] = mem[_2022 + 160]
                mem[mem[64] + 196] = mem[_2208 + 12 len 20]
                mem[mem[64] + 228] = mem[_2208 + 44 len 20]
                mem[mem[64] + 260] = mem[_2208 + 76 len 20]
                mem[mem[64] + 292] = mem[_2208 + 108 len 20]
                mem[mem[64] + 324] = mem[_2208 + 128]
                mem[mem[64] + 356] = mem[_2208 + 160]
                require ext_code.size(stor3)
                staticcall stor3.0x6fbc9807 with:
                        gas gas_remaining wei
                       args mem[mem[64] + 4 len 384]
                mem[mem[64] len 64] = ext_call.return_data[0 len 64]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _2993 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 64
                require mem[_2993] == bool(mem[_2993])
                _3124 = mem[_2993 + 32]
                require mem[_2993 + 32] == mem[_2993 + 32]
                if not mem[_2993]:
                    revert with 0, 'B'
                if 0 >= mem[96]:
                    revert with 'NH{q', 50
                _3188 = mem[mem[128]]
                mem[mem[64] + 4] = 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                require ext_code.size(address(_3188))
                staticcall address(_3188).0x70a08231 with:
                        gas gas_remaining wei
                       args 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3441 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_3441] == mem[_3441]
                if _3124 < mem[_3441]:
                    if _3124:
                        return _3124
                    return cd[4]
                if not mem[_3441]:
                    return cd[4]
                mem[mem[64]] = mem[_3441]
            else:
                if mem[96] != 3:
                    if 0 >= mem[96]:
                        revert with 'NH{q', 50
                    _2072 = mem[128]
                    if mem[96] < 1:
                        revert with 'NH{q', 17
                    if mem[96] - 1 >= mem[96]:
                        revert with 'NH{q', 50
                    _2257 = mem[(32 * mem[96] - 1) + 128]
                    mem[mem[64]] = 0x6fbc980700000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = mem[_2072 + 12 len 20]
                    mem[mem[64] + 36] = mem[_2072 + 44 len 20]
                    mem[mem[64] + 68] = mem[_2072 + 76 len 20]
                    mem[mem[64] + 100] = mem[_2072 + 108 len 20]
                    mem[mem[64] + 132] = mem[_2072 + 128]
                    mem[mem[64] + 164] = mem[_2072 + 160]
                    mem[mem[64] + 196] = mem[_2257 + 12 len 20]
                    mem[mem[64] + 228] = mem[_2257 + 44 len 20]
                    mem[mem[64] + 260] = mem[_2257 + 76 len 20]
                    mem[mem[64] + 292] = mem[_2257 + 108 len 20]
                    mem[mem[64] + 324] = mem[_2257 + 128]
                    mem[mem[64] + 356] = mem[_2257 + 160]
                    require ext_code.size(stor3)
                    staticcall stor3.0x6fbc9807 with:
                            gas gas_remaining wei
                           args mem[mem[64] + 4 len 384]
                    mem[mem[64] len 64] = ext_call.return_data[0 len 64]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3016 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 64
                    require mem[_3016] == bool(mem[_3016])
                    _3139 = mem[_3016 + 32]
                    require mem[_3016 + 32] == mem[_3016 + 32]
                    if not mem[_3016]:
                        revert with 0, 'B'
                    if 0 >= mem[96]:
                        revert with 'NH{q', 50
                    _3229 = mem[mem[128]]
                    mem[mem[64] + 4] = 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                    require ext_code.size(address(_3229))
                    staticcall address(_3229).0x70a08231 with:
                            gas gas_remaining wei
                           args 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3474 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_3474] == mem[_3474]
                    if _3139 < mem[_3474]:
                        if _3139:
                            return _3139
                        return cd[4]
                    if not mem[_3474]:
                        return cd[4]
                    mem[mem[64]] = mem[_3474]
                else:
                    mem[0] = mem[mem[128] + 44 len 20]
                    mem[32] = 1
                    if not stor1[mem[0]]:
                        return cd[4]
                    mem[0] = mem[mem[(32 * mem[96] - 1) + 128] + 12 len 20]
                    mem[32] = 1
                    if not stor1[mem[0]]:
                        return cd[4]
                    if 0 >= mem[96]:
                        revert with 'NH{q', 50
                    _2142 = mem[128]
                    if mem[96] < 1:
                        revert with 'NH{q', 17
                    if mem[96] - 1 >= mem[96]:
                        revert with 'NH{q', 50
                    _2344 = mem[(32 * mem[96] - 1) + 128]
                    mem[mem[64]] = 0x6fbc980700000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = mem[_2142 + 12 len 20]
                    mem[mem[64] + 36] = mem[_2142 + 44 len 20]
                    mem[mem[64] + 68] = mem[_2142 + 76 len 20]
                    mem[mem[64] + 100] = mem[_2142 + 108 len 20]
                    mem[mem[64] + 132] = mem[_2142 + 128]
                    mem[mem[64] + 164] = mem[_2142 + 160]
                    mem[mem[64] + 196] = mem[_2344 + 12 len 20]
                    mem[mem[64] + 228] = mem[_2344 + 44 len 20]
                    mem[mem[64] + 260] = mem[_2344 + 76 len 20]
                    mem[mem[64] + 292] = mem[_2344 + 108 len 20]
                    mem[mem[64] + 324] = mem[_2344 + 128]
                    mem[mem[64] + 356] = mem[_2344 + 160]
                    require ext_code.size(stor3)
                    staticcall stor3.0x6fbc9807 with:
                            gas gas_remaining wei
                           args mem[mem[64] + 4 len 384]
                    mem[mem[64] len 64] = ext_call.return_data[0 len 64]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3061 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 64
                    require mem[_3061] == bool(mem[_3061])
                    _3161 = mem[_3061 + 32]
                    require mem[_3061 + 32] == mem[_3061 + 32]
                    if not mem[_3061]:
                        revert with 0, 'B'
                    if 0 >= mem[96]:
                        revert with 'NH{q', 50
                    _3324 = mem[mem[128]]
                    mem[mem[64] + 4] = 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                    require ext_code.size(address(_3324))
                    staticcall address(_3324).0x70a08231 with:
                            gas gas_remaining wei
                           args 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3535 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_3535] == mem[_3535]
                    if _3161 < mem[_3535]:
                        if _3161:
                            return _3161
                        return cd[4]
                    if not mem[_3535]:
                        return cd[4]
                    mem[mem[64]] = mem[_3535]
        else:
            if mem[mem[(32 * mem[96] - 1) + 128] + 160] == 7:
                if mem[96] == 2:
                    if 0 >= mem[96]:
                        revert with 'NH{q', 50
                    _2046 = mem[128]
                    if mem[96] < 1:
                        revert with 'NH{q', 17
                    if mem[96] - 1 >= mem[96]:
                        revert with 'NH{q', 50
                    _2231 = mem[(32 * mem[96] - 1) + 128]
                    mem[mem[64]] = 0x6fbc980700000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = mem[_2046 + 12 len 20]
                    mem[mem[64] + 36] = mem[_2046 + 44 len 20]
                    mem[mem[64] + 68] = mem[_2046 + 76 len 20]
                    mem[mem[64] + 100] = mem[_2046 + 108 len 20]
                    mem[mem[64] + 132] = mem[_2046 + 128]
                    mem[mem[64] + 164] = mem[_2046 + 160]
                    mem[mem[64] + 196] = mem[_2231 + 12 len 20]
                    mem[mem[64] + 228] = mem[_2231 + 44 len 20]
                    mem[mem[64] + 260] = mem[_2231 + 76 len 20]
                    mem[mem[64] + 292] = mem[_2231 + 108 len 20]
                    mem[mem[64] + 324] = mem[_2231 + 128]
                    mem[mem[64] + 356] = mem[_2231 + 160]
                    require ext_code.size(stor3)
                    staticcall stor3.0x6fbc9807 with:
                            gas gas_remaining wei
                           args mem[mem[64] + 4 len 384]
                    mem[mem[64] len 64] = ext_call.return_data[0 len 64]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3004 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 64
                    require mem[_3004] == bool(mem[_3004])
                    _3132 = mem[_3004 + 32]
                    require mem[_3004 + 32] == mem[_3004 + 32]
                    if not mem[_3004]:
                        revert with 0, 'B'
                    if 0 >= mem[96]:
                        revert with 'NH{q', 50
                    _3202 = mem[mem[128]]
                    mem[mem[64] + 4] = 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                    require ext_code.size(address(_3202))
                    staticcall address(_3202).0x70a08231 with:
                            gas gas_remaining wei
                           args 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3458 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_3458] == mem[_3458]
                    if _3132 < mem[_3458]:
                        if _3132:
                            return _3132
                        return cd[4]
                    if not mem[_3458]:
                        return cd[4]
                    mem[mem[64]] = mem[_3458]
                else:
                    if mem[96] != 3:
                        if 0 >= mem[96]:
                            revert with 'NH{q', 50
                        _2097 = mem[128]
                        if mem[96] < 1:
                            revert with 'NH{q', 17
                        if mem[96] - 1 >= mem[96]:
                            revert with 'NH{q', 50
                        _2283 = mem[(32 * mem[96] - 1) + 128]
                        mem[mem[64]] = 0x6fbc980700000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = mem[_2097 + 12 len 20]
                        mem[mem[64] + 36] = mem[_2097 + 44 len 20]
                        mem[mem[64] + 68] = mem[_2097 + 76 len 20]
                        mem[mem[64] + 100] = mem[_2097 + 108 len 20]
                        mem[mem[64] + 132] = mem[_2097 + 128]
                        mem[mem[64] + 164] = mem[_2097 + 160]
                        mem[mem[64] + 196] = mem[_2283 + 12 len 20]
                        mem[mem[64] + 228] = mem[_2283 + 44 len 20]
                        mem[mem[64] + 260] = mem[_2283 + 76 len 20]
                        mem[mem[64] + 292] = mem[_2283 + 108 len 20]
                        mem[mem[64] + 324] = mem[_2283 + 128]
                        mem[mem[64] + 356] = mem[_2283 + 160]
                        require ext_code.size(stor3)
                        staticcall stor3.0x6fbc9807 with:
                                gas gas_remaining wei
                               args mem[mem[64] + 4 len 384]
                        mem[mem[64] len 64] = ext_call.return_data[0 len 64]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3029 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 64
                        require mem[_3029] == bool(mem[_3029])
                        _3147 = mem[_3029 + 32]
                        require mem[_3029 + 32] == mem[_3029 + 32]
                        if not mem[_3029]:
                            revert with 0, 'B'
                        if 0 >= mem[96]:
                            revert with 'NH{q', 50
                        _3259 = mem[mem[128]]
                        mem[mem[64] + 4] = 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                        require ext_code.size(address(_3259))
                        staticcall address(_3259).0x70a08231 with:
                                gas gas_remaining wei
                               args 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3492 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_3492] == mem[_3492]
                        if _3147 < mem[_3492]:
                            if _3147:
                                return _3147
                            return cd[4]
                        if not mem[_3492]:
                            return cd[4]
                        mem[mem[64]] = mem[_3492]
                    else:
                        mem[0] = mem[mem[128] + 44 len 20]
                        mem[32] = 1
                        if not stor1[mem[0]]:
                            return cd[4]
                        mem[0] = mem[mem[(32 * mem[96] - 1) + 128] + 12 len 20]
                        mem[32] = 1
                        if not stor1[mem[0]]:
                            return cd[4]
                        if 0 >= mem[96]:
                            revert with 'NH{q', 50
                        _2162 = mem[128]
                        if mem[96] < 1:
                            revert with 'NH{q', 17
                        if mem[96] - 1 >= mem[96]:
                            revert with 'NH{q', 50
                        _2374 = mem[(32 * mem[96] - 1) + 128]
                        mem[mem[64]] = 0x6fbc980700000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = mem[_2162 + 12 len 20]
                        mem[mem[64] + 36] = mem[_2162 + 44 len 20]
                        mem[mem[64] + 68] = mem[_2162 + 76 len 20]
                        mem[mem[64] + 100] = mem[_2162 + 108 len 20]
                        mem[mem[64] + 132] = mem[_2162 + 128]
                        mem[mem[64] + 164] = mem[_2162 + 160]
                        mem[mem[64] + 196] = mem[_2374 + 12 len 20]
                        mem[mem[64] + 228] = mem[_2374 + 44 len 20]
                        mem[mem[64] + 260] = mem[_2374 + 76 len 20]
                        mem[mem[64] + 292] = mem[_2374 + 108 len 20]
                        mem[mem[64] + 324] = mem[_2374 + 128]
                        mem[mem[64] + 356] = mem[_2374 + 160]
                        require ext_code.size(stor3)
                        staticcall stor3.0x6fbc9807 with:
                                gas gas_remaining wei
                               args mem[mem[64] + 4 len 384]
                        mem[mem[64] len 64] = ext_call.return_data[0 len 64]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3078 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 64
                        require mem[_3078] == bool(mem[_3078])
                        _3167 = mem[_3078 + 32]
                        require mem[_3078 + 32] == mem[_3078 + 32]
                        if not mem[_3078]:
                            revert with 0, 'B'
                        if 0 >= mem[96]:
                            revert with 'NH{q', 50
                        _3352 = mem[mem[128]]
                        mem[mem[64] + 4] = 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                        require ext_code.size(address(_3352))
                        staticcall address(_3352).0x70a08231 with:
                                gas gas_remaining wei
                               args 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3555 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_3555] == mem[_3555]
                        if _3167 < mem[_3555]:
                            if _3167:
                                return _3167
                            return cd[4]
                        if not mem[_3555]:
                            return cd[4]
                        mem[mem[64]] = mem[_3555]
            else:
                if mem[mem[(32 * mem[96] - 1) + 128] + 160] == 13:
                    if mem[96] == 2:
                        if 0 >= mem[96]:
                            revert with 'NH{q', 50
                        _2069 = mem[128]
                        if mem[96] < 1:
                            revert with 'NH{q', 17
                        if mem[96] - 1 >= mem[96]:
                            revert with 'NH{q', 50
                        _2254 = mem[(32 * mem[96] - 1) + 128]
                        mem[mem[64]] = 0x6fbc980700000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = mem[_2069 + 12 len 20]
                        mem[mem[64] + 36] = mem[_2069 + 44 len 20]
                        mem[mem[64] + 68] = mem[_2069 + 76 len 20]
                        mem[mem[64] + 100] = mem[_2069 + 108 len 20]
                        mem[mem[64] + 132] = mem[_2069 + 128]
                        mem[mem[64] + 164] = mem[_2069 + 160]
                        mem[mem[64] + 196] = mem[_2254 + 12 len 20]
                        mem[mem[64] + 228] = mem[_2254 + 44 len 20]
                        mem[mem[64] + 260] = mem[_2254 + 76 len 20]
                        mem[mem[64] + 292] = mem[_2254 + 108 len 20]
                        mem[mem[64] + 324] = mem[_2254 + 128]
                        mem[mem[64] + 356] = mem[_2254 + 160]
                        require ext_code.size(stor3)
                        staticcall stor3.0x6fbc9807 with:
                                gas gas_remaining wei
                               args mem[mem[64] + 4 len 384]
                        mem[mem[64] len 64] = ext_call.return_data[0 len 64]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3015 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 64
                        require mem[_3015] == bool(mem[_3015])
                        _3138 = mem[_3015 + 32]
                        require mem[_3015 + 32] == mem[_3015 + 32]
                        if not mem[_3015]:
                            revert with 0, 'B'
                        if 0 >= mem[96]:
                            revert with 'NH{q', 50
                        _3224 = mem[mem[128]]
                        mem[mem[64] + 4] = 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                        require ext_code.size(address(_3224))
                        staticcall address(_3224).0x70a08231 with:
                                gas gas_remaining wei
                               args 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3473 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_3473] == mem[_3473]
                        if _3138 < mem[_3473]:
                            if _3138:
                                return _3138
                            return cd[4]
                        if not mem[_3473]:
                            return cd[4]
                        mem[mem[64]] = mem[_3473]
                    else:
                        if mem[96] != 3:
                            if 0 >= mem[96]:
                                revert with 'NH{q', 50
                            _2119 = mem[128]
                            if mem[96] < 1:
                                revert with 'NH{q', 17
                            if mem[96] - 1 >= mem[96]:
                                revert with 'NH{q', 50
                            _2308 = mem[(32 * mem[96] - 1) + 128]
                            mem[mem[64]] = 0x6fbc980700000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = mem[_2119 + 12 len 20]
                            mem[mem[64] + 36] = mem[_2119 + 44 len 20]
                            mem[mem[64] + 68] = mem[_2119 + 76 len 20]
                            mem[mem[64] + 100] = mem[_2119 + 108 len 20]
                            mem[mem[64] + 132] = mem[_2119 + 128]
                            mem[mem[64] + 164] = mem[_2119 + 160]
                            mem[mem[64] + 196] = mem[_2308 + 12 len 20]
                            mem[mem[64] + 228] = mem[_2308 + 44 len 20]
                            mem[mem[64] + 260] = mem[_2308 + 76 len 20]
                            mem[mem[64] + 292] = mem[_2308 + 108 len 20]
                            mem[mem[64] + 324] = mem[_2308 + 128]
                            mem[mem[64] + 356] = mem[_2308 + 160]
                            require ext_code.size(stor3)
                            staticcall stor3.0x6fbc9807 with:
                                    gas gas_remaining wei
                                   args mem[mem[64] + 4 len 384]
                            mem[mem[64] len 64] = ext_call.return_data[0 len 64]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3043 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 64
                            require mem[_3043] == bool(mem[_3043])
                            _3154 = mem[_3043 + 32]
                            require mem[_3043 + 32] == mem[_3043 + 32]
                            if not mem[_3043]:
                                revert with 0, 'B'
                            if 0 >= mem[96]:
                                revert with 'NH{q', 50
                            _3289 = mem[mem[128]]
                            mem[mem[64] + 4] = 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                            require ext_code.size(address(_3289))
                            staticcall address(_3289).0x70a08231 with:
                                    gas gas_remaining wei
                                   args 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3511 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_3511] == mem[_3511]
                            if _3154 < mem[_3511]:
                                if _3154:
                                    return _3154
                                return cd[4]
                            if not mem[_3511]:
                                return cd[4]
                            mem[mem[64]] = mem[_3511]
                        else:
                            mem[0] = mem[mem[128] + 44 len 20]
                            mem[32] = 1
                            if not stor1[mem[0]]:
                                return cd[4]
                            mem[0] = mem[mem[(32 * mem[96] - 1) + 128] + 12 len 20]
                            mem[32] = 1
                            if not stor1[mem[0]]:
                                return cd[4]
                            if 0 >= mem[96]:
                                revert with 'NH{q', 50
                            _2182 = mem[128]
                            if mem[96] < 1:
                                revert with 'NH{q', 17
                            if mem[96] - 1 >= mem[96]:
                                revert with 'NH{q', 50
                            _2402 = mem[(32 * mem[96] - 1) + 128]
                            mem[mem[64]] = 0x6fbc980700000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = mem[_2182 + 12 len 20]
                            mem[mem[64] + 36] = mem[_2182 + 44 len 20]
                            mem[mem[64] + 68] = mem[_2182 + 76 len 20]
                            mem[mem[64] + 100] = mem[_2182 + 108 len 20]
                            mem[mem[64] + 132] = mem[_2182 + 128]
                            mem[mem[64] + 164] = mem[_2182 + 160]
                            mem[mem[64] + 196] = mem[_2402 + 12 len 20]
                            mem[mem[64] + 228] = mem[_2402 + 44 len 20]
                            mem[mem[64] + 260] = mem[_2402 + 76 len 20]
                            mem[mem[64] + 292] = mem[_2402 + 108 len 20]
                            mem[mem[64] + 324] = mem[_2402 + 128]
                            mem[mem[64] + 356] = mem[_2402 + 160]
                            require ext_code.size(stor3)
                            staticcall stor3.0x6fbc9807 with:
                                    gas gas_remaining wei
                                   args mem[mem[64] + 4 len 384]
                            mem[mem[64] len 64] = ext_call.return_data[0 len 64]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3092 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 64
                            require mem[_3092] == bool(mem[_3092])
                            _3172 = mem[_3092 + 32]
                            require mem[_3092 + 32] == mem[_3092 + 32]
                            if not mem[_3092]:
                                revert with 0, 'B'
                            if 0 >= mem[96]:
                                revert with 'NH{q', 50
                            _3377 = mem[mem[128]]
                            mem[mem[64] + 4] = 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                            require ext_code.size(address(_3377))
                            staticcall address(_3377).0x70a08231 with:
                                    gas gas_remaining wei
                                   args 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3571 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_3571] == mem[_3571]
                            if _3172 < mem[_3571]:
                                if _3172:
                                    return _3172
                                return cd[4]
                            if not mem[_3571]:
                                return cd[4]
                            mem[mem[64]] = mem[_3571]
                else:
                    if mem[mem[(32 * mem[96] - 1) + 128] + 160] != 14:
                        return cd[4]
                    if mem[96] == 2:
                        if 0 >= mem[96]:
                            revert with 'NH{q', 50
                        _2094 = mem[128]
                        if mem[96] < 1:
                            revert with 'NH{q', 17
                        if mem[96] - 1 >= mem[96]:
                            revert with 'NH{q', 50
                        _2280 = mem[(32 * mem[96] - 1) + 128]
                        mem[mem[64]] = 0x6fbc980700000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = mem[_2094 + 12 len 20]
                        mem[mem[64] + 36] = mem[_2094 + 44 len 20]
                        mem[mem[64] + 68] = mem[_2094 + 76 len 20]
                        mem[mem[64] + 100] = mem[_2094 + 108 len 20]
                        mem[mem[64] + 132] = mem[_2094 + 128]
                        mem[mem[64] + 164] = mem[_2094 + 160]
                        mem[mem[64] + 196] = mem[_2280 + 12 len 20]
                        mem[mem[64] + 228] = mem[_2280 + 44 len 20]
                        mem[mem[64] + 260] = mem[_2280 + 76 len 20]
                        mem[mem[64] + 292] = mem[_2280 + 108 len 20]
                        mem[mem[64] + 324] = mem[_2280 + 128]
                        mem[mem[64] + 356] = mem[_2280 + 160]
                        require ext_code.size(stor3)
                        staticcall stor3.0x6fbc9807 with:
                                gas gas_remaining wei
                               args mem[mem[64] + 4 len 384]
                        mem[mem[64] len 64] = ext_call.return_data[0 len 64]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3028 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 64
                        require mem[_3028] == bool(mem[_3028])
                        _3146 = mem[_3028 + 32]
                        require mem[_3028 + 32] == mem[_3028 + 32]
                        if not mem[_3028]:
                            revert with 0, 'B'
                        if 0 >= mem[96]:
                            revert with 'NH{q', 50
                        _3254 = mem[mem[128]]
                        mem[mem[64] + 4] = 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                        require ext_code.size(address(_3254))
                        staticcall address(_3254).0x70a08231 with:
                                gas gas_remaining wei
                               args 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3491 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_3491] == mem[_3491]
                        if _3146 < mem[_3491]:
                            if _3146:
                                return _3146
                            return cd[4]
                        if not mem[_3491]:
                            return cd[4]
                        mem[mem[64]] = mem[_3491]
                    else:
                        if mem[96] != 3:
                            if 0 >= mem[96]:
                                revert with 'NH{q', 50
                            _2138 = mem[128]
                            if mem[96] < 1:
                                revert with 'NH{q', 17
                            if mem[96] - 1 >= mem[96]:
                                revert with 'NH{q', 50
                            _2337 = mem[(32 * mem[96] - 1) + 128]
                            mem[mem[64]] = 0x6fbc980700000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = mem[_2138 + 12 len 20]
                            mem[mem[64] + 36] = mem[_2138 + 44 len 20]
                            mem[mem[64] + 68] = mem[_2138 + 76 len 20]
                            mem[mem[64] + 100] = mem[_2138 + 108 len 20]
                            mem[mem[64] + 132] = mem[_2138 + 128]
                            mem[mem[64] + 164] = mem[_2138 + 160]
                            mem[mem[64] + 196] = mem[_2337 + 12 len 20]
                            mem[mem[64] + 228] = mem[_2337 + 44 len 20]
                            mem[mem[64] + 260] = mem[_2337 + 76 len 20]
                            mem[mem[64] + 292] = mem[_2337 + 108 len 20]
                            mem[mem[64] + 324] = mem[_2337 + 128]
                            mem[mem[64] + 356] = mem[_2337 + 160]
                            require ext_code.size(stor3)
                            staticcall stor3.0x6fbc9807 with:
                                    gas gas_remaining wei
                                   args mem[mem[64] + 4 len 384]
                            mem[mem[64] len 64] = ext_call.return_data[0 len 64]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3057 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 64
                            require mem[_3057] == bool(mem[_3057])
                            _3160 = mem[_3057 + 32]
                            require mem[_3057 + 32] == mem[_3057 + 32]
                            if not mem[_3057]:
                                revert with 0, 'B'
                            if 0 >= mem[96]:
                                revert with 'NH{q', 50
                            _3319 = mem[mem[128]]
                            mem[mem[64] + 4] = 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                            require ext_code.size(address(_3319))
                            staticcall address(_3319).0x70a08231 with:
                                    gas gas_remaining wei
                                   args 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3530 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_3530] == mem[_3530]
                            if _3160 < mem[_3530]:
                                if _3160:
                                    return _3160
                                return cd[4]
                            if not mem[_3530]:
                                return cd[4]
                            mem[mem[64]] = mem[_3530]
                        else:
                            mem[0] = mem[mem[128] + 44 len 20]
                            mem[32] = 1
                            if not stor1[mem[0]]:
                                return cd[4]
                            mem[0] = mem[mem[(32 * mem[96] - 1) + 128] + 12 len 20]
                            mem[32] = 1
                            if not stor1[mem[0]]:
                                return cd[4]
                            if 0 >= mem[96]:
                                revert with 'NH{q', 50
                            _2204 = mem[128]
                            if mem[96] < 1:
                                revert with 'NH{q', 17
                            if mem[96] - 1 >= mem[96]:
                                revert with 'NH{q', 50
                            _2426 = mem[(32 * mem[96] - 1) + 128]
                            mem[mem[64]] = 0x6fbc980700000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = mem[_2204 + 12 len 20]
                            mem[mem[64] + 36] = mem[_2204 + 44 len 20]
                            mem[mem[64] + 68] = mem[_2204 + 76 len 20]
                            mem[mem[64] + 100] = mem[_2204 + 108 len 20]
                            mem[mem[64] + 132] = mem[_2204 + 128]
                            mem[mem[64] + 164] = mem[_2204 + 160]
                            mem[mem[64] + 196] = mem[_2426 + 12 len 20]
                            mem[mem[64] + 228] = mem[_2426 + 44 len 20]
                            mem[mem[64] + 260] = mem[_2426 + 76 len 20]
                            mem[mem[64] + 292] = mem[_2426 + 108 len 20]
                            mem[mem[64] + 324] = mem[_2426 + 128]
                            mem[mem[64] + 356] = mem[_2426 + 160]
                            require ext_code.size(stor3)
                            staticcall stor3.0x6fbc9807 with:
                                    gas gas_remaining wei
                                   args mem[mem[64] + 4 len 384]
                            mem[mem[64] len 64] = ext_call.return_data[0 len 64]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3105 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 64
                            require mem[_3105] == bool(mem[_3105])
                            _3177 = mem[_3105 + 32]
                            require mem[_3105 + 32] == mem[_3105 + 32]
                            if not mem[_3105]:
                                revert with 0, 'B'
                            if 0 >= mem[96]:
                                revert with 'NH{q', 50
                            _3400 = mem[mem[128]]
                            mem[mem[64] + 4] = 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                            require ext_code.size(address(_3400))
                            staticcall address(_3400).0x70a08231 with:
                                    gas gas_remaining wei
                                   args 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3585 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_3585] == mem[_3585]
                            if _3177 < mem[_3585]:
                                if _3177:
                                    return _3177
                                return cd[4]
                            if not mem[_3585]:
                                return cd[4]
                            mem[mem[64]] = mem[_3585]
    else:
        if mem[mem[128] + 160] == 7:
            if mem[mem[(32 * mem[96] - 1) + 128] + 160] == 1:
                if mem[96] == 2:
                    if 0 >= mem[96]:
                        revert with 'NH{q', 50
                    _2041 = mem[128]
                    if mem[96] < 1:
                        revert with 'NH{q', 17
                    if mem[96] - 1 >= mem[96]:
                        revert with 'NH{q', 50
                    _2226 = mem[(32 * mem[96] - 1) + 128]
                    mem[mem[64]] = 0x6fbc980700000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = mem[_2041 + 12 len 20]
                    mem[mem[64] + 36] = mem[_2041 + 44 len 20]
                    mem[mem[64] + 68] = mem[_2041 + 76 len 20]
                    mem[mem[64] + 100] = mem[_2041 + 108 len 20]
                    mem[mem[64] + 132] = mem[_2041 + 128]
                    mem[mem[64] + 164] = mem[_2041 + 160]
                    mem[mem[64] + 196] = mem[_2226 + 12 len 20]
                    mem[mem[64] + 228] = mem[_2226 + 44 len 20]
                    mem[mem[64] + 260] = mem[_2226 + 76 len 20]
                    mem[mem[64] + 292] = mem[_2226 + 108 len 20]
                    mem[mem[64] + 324] = mem[_2226 + 128]
                    mem[mem[64] + 356] = mem[_2226 + 160]
                    require ext_code.size(stor3)
                    staticcall stor3.0x6fbc9807 with:
                            gas gas_remaining wei
                           args mem[mem[64] + 4 len 384]
                    mem[mem[64] len 64] = ext_call.return_data[0 len 64]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3001 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 64
                    require mem[_3001] == bool(mem[_3001])
                    _3130 = mem[_3001 + 32]
                    require mem[_3001 + 32] == mem[_3001 + 32]
                    if not mem[_3001]:
                        revert with 0, 'B'
                    if 0 >= mem[96]:
                        revert with 'NH{q', 50
                    _3197 = mem[mem[128]]
                    mem[mem[64] + 4] = 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                    require ext_code.size(address(_3197))
                    staticcall address(_3197).0x70a08231 with:
                            gas gas_remaining wei
                           args 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3454 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_3454] == mem[_3454]
                    if _3130 < mem[_3454]:
                        if _3130:
                            return _3130
                        return cd[4]
                    if not mem[_3454]:
                        return cd[4]
                    mem[mem[64]] = mem[_3454]
                else:
                    if mem[96] != 3:
                        if 0 >= mem[96]:
                            revert with 'NH{q', 50
                        _2091 = mem[128]
                        if mem[96] < 1:
                            revert with 'NH{q', 17
                        if mem[96] - 1 >= mem[96]:
                            revert with 'NH{q', 50
                        _2277 = mem[(32 * mem[96] - 1) + 128]
                        mem[mem[64]] = 0x6fbc980700000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = mem[_2091 + 12 len 20]
                        mem[mem[64] + 36] = mem[_2091 + 44 len 20]
                        mem[mem[64] + 68] = mem[_2091 + 76 len 20]
                        mem[mem[64] + 100] = mem[_2091 + 108 len 20]
                        mem[mem[64] + 132] = mem[_2091 + 128]
                        mem[mem[64] + 164] = mem[_2091 + 160]
                        mem[mem[64] + 196] = mem[_2277 + 12 len 20]
                        mem[mem[64] + 228] = mem[_2277 + 44 len 20]
                        mem[mem[64] + 260] = mem[_2277 + 76 len 20]
                        mem[mem[64] + 292] = mem[_2277 + 108 len 20]
                        mem[mem[64] + 324] = mem[_2277 + 128]
                        mem[mem[64] + 356] = mem[_2277 + 160]
                        require ext_code.size(stor3)
                        staticcall stor3.0x6fbc9807 with:
                                gas gas_remaining wei
                               args mem[mem[64] + 4 len 384]
                        mem[mem[64] len 64] = ext_call.return_data[0 len 64]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3026 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 64
                        require mem[_3026] == bool(mem[_3026])
                        _3145 = mem[_3026 + 32]
                        require mem[_3026 + 32] == mem[_3026 + 32]
                        if not mem[_3026]:
                            revert with 0, 'B'
                        if 0 >= mem[96]:
                            revert with 'NH{q', 50
                        _3251 = mem[mem[128]]
                        mem[mem[64] + 4] = 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                        require ext_code.size(address(_3251))
                        staticcall address(_3251).0x70a08231 with:
                                gas gas_remaining wei
                               args 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3488 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_3488] == mem[_3488]
                        if _3145 < mem[_3488]:
                            if _3145:
                                return _3145
                            return cd[4]
                        if not mem[_3488]:
                            return cd[4]
                        mem[mem[64]] = mem[_3488]
                    else:
                        mem[0] = mem[mem[128] + 44 len 20]
                        mem[32] = 1
                        if not stor1[mem[0]]:
                            return cd[4]
                        mem[0] = mem[mem[(32 * mem[96] - 1) + 128] + 12 len 20]
                        mem[32] = 1
                        if not stor1[mem[0]]:
                            return cd[4]
                        if 0 >= mem[96]:
                            revert with 'NH{q', 50
                        _2158 = mem[128]
                        if mem[96] < 1:
                            revert with 'NH{q', 17
                        if mem[96] - 1 >= mem[96]:
                            revert with 'NH{q', 50
                        _2368 = mem[(32 * mem[96] - 1) + 128]
                        mem[mem[64]] = 0x6fbc980700000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = mem[_2158 + 12 len 20]
                        mem[mem[64] + 36] = mem[_2158 + 44 len 20]
                        mem[mem[64] + 68] = mem[_2158 + 76 len 20]
                        mem[mem[64] + 100] = mem[_2158 + 108 len 20]
                        mem[mem[64] + 132] = mem[_2158 + 128]
                        mem[mem[64] + 164] = mem[_2158 + 160]
                        mem[mem[64] + 196] = mem[_2368 + 12 len 20]
                        mem[mem[64] + 228] = mem[_2368 + 44 len 20]
                        mem[mem[64] + 260] = mem[_2368 + 76 len 20]
                        mem[mem[64] + 292] = mem[_2368 + 108 len 20]
                        mem[mem[64] + 324] = mem[_2368 + 128]
                        mem[mem[64] + 356] = mem[_2368 + 160]
                        require ext_code.size(stor3)
                        staticcall stor3.0x6fbc9807 with:
                                gas gas_remaining wei
                               args mem[mem[64] + 4 len 384]
                        mem[mem[64] len 64] = ext_call.return_data[0 len 64]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3074 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 64
                        require mem[_3074] == bool(mem[_3074])
                        _3166 = mem[_3074 + 32]
                        require mem[_3074 + 32] == mem[_3074 + 32]
                        if not mem[_3074]:
                            revert with 0, 'B'
                        if 0 >= mem[96]:
                            revert with 'NH{q', 50
                        _3347 = mem[mem[128]]
                        mem[mem[64] + 4] = 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                        require ext_code.size(address(_3347))
                        staticcall address(_3347).0x70a08231 with:
                                gas gas_remaining wei
                               args 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3551 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_3551] == mem[_3551]
                        if _3166 < mem[_3551]:
                            if _3166:
                                return _3166
                            return cd[4]
                        if not mem[_3551]:
                            return cd[4]
                        mem[mem[64]] = mem[_3551]
            else:
                if mem[mem[(32 * mem[96] - 1) + 128] + 160] == 7:
                    if mem[96] == 2:
                        if 0 >= mem[96]:
                            revert with 'NH{q', 50
                        _2065 = mem[128]
                        if mem[96] < 1:
                            revert with 'NH{q', 17
                        if mem[96] - 1 >= mem[96]:
                            revert with 'NH{q', 50
                        _2250 = mem[(32 * mem[96] - 1) + 128]
                        mem[mem[64]] = 0x6fbc980700000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = mem[_2065 + 12 len 20]
                        mem[mem[64] + 36] = mem[_2065 + 44 len 20]
                        mem[mem[64] + 68] = mem[_2065 + 76 len 20]
                        mem[mem[64] + 100] = mem[_2065 + 108 len 20]
                        mem[mem[64] + 132] = mem[_2065 + 128]
                        mem[mem[64] + 164] = mem[_2065 + 160]
                        mem[mem[64] + 196] = mem[_2250 + 12 len 20]
                        mem[mem[64] + 228] = mem[_2250 + 44 len 20]
                        mem[mem[64] + 260] = mem[_2250 + 76 len 20]
                        mem[mem[64] + 292] = mem[_2250 + 108 len 20]
                        mem[mem[64] + 324] = mem[_2250 + 128]
                        mem[mem[64] + 356] = mem[_2250 + 160]
                        require ext_code.size(stor3)
                        staticcall stor3.0x6fbc9807 with:
                                gas gas_remaining wei
                               args mem[mem[64] + 4 len 384]
                        mem[mem[64] len 64] = ext_call.return_data[0 len 64]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3013 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 64
                        require mem[_3013] == bool(mem[_3013])
                        _3137 = mem[_3013 + 32]
                        require mem[_3013 + 32] == mem[_3013 + 32]
                        if not mem[_3013]:
                            revert with 0, 'B'
                        if 0 >= mem[96]:
                            revert with 'NH{q', 50
                        _3217 = mem[mem[128]]
                        mem[mem[64] + 4] = 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                        require ext_code.size(address(_3217))
                        staticcall address(_3217).0x70a08231 with:
                                gas gas_remaining wei
                               args 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3470 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_3470] == mem[_3470]
                        if _3137 < mem[_3470]:
                            if _3137:
                                return _3137
                            return cd[4]
                        if not mem[_3470]:
                            return cd[4]
                        mem[mem[64]] = mem[_3470]
                    else:
                        if mem[96] != 3:
                            if 0 >= mem[96]:
                                revert with 'NH{q', 50
                            _2116 = mem[128]
                            if mem[96] < 1:
                                revert with 'NH{q', 17
                            if mem[96] - 1 >= mem[96]:
                                revert with 'NH{q', 50
                            _2303 = mem[(32 * mem[96] - 1) + 128]
                            mem[mem[64]] = 0x6fbc980700000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = mem[_2116 + 12 len 20]
                            mem[mem[64] + 36] = mem[_2116 + 44 len 20]
                            mem[mem[64] + 68] = mem[_2116 + 76 len 20]
                            mem[mem[64] + 100] = mem[_2116 + 108 len 20]
                            mem[mem[64] + 132] = mem[_2116 + 128]
                            mem[mem[64] + 164] = mem[_2116 + 160]
                            mem[mem[64] + 196] = mem[_2303 + 12 len 20]
                            mem[mem[64] + 228] = mem[_2303 + 44 len 20]
                            mem[mem[64] + 260] = mem[_2303 + 76 len 20]
                            mem[mem[64] + 292] = mem[_2303 + 108 len 20]
                            mem[mem[64] + 324] = mem[_2303 + 128]
                            mem[mem[64] + 356] = mem[_2303 + 160]
                            require ext_code.size(stor3)
                            staticcall stor3.0x6fbc9807 with:
                                    gas gas_remaining wei
                                   args mem[mem[64] + 4 len 384]
                            mem[mem[64] len 64] = ext_call.return_data[0 len 64]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3040 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 64
                            require mem[_3040] == bool(mem[_3040])
                            _3153 = mem[_3040 + 32]
                            require mem[_3040 + 32] == mem[_3040 + 32]
                            if not mem[_3040]:
                                revert with 0, 'B'
                            if 0 >= mem[96]:
                                revert with 'NH{q', 50
                            _3284 = mem[mem[128]]
                            mem[mem[64] + 4] = 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                            require ext_code.size(address(_3284))
                            staticcall address(_3284).0x70a08231 with:
                                    gas gas_remaining wei
                                   args 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3507 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_3507] == mem[_3507]
                            if _3153 < mem[_3507]:
                                if _3153:
                                    return _3153
                                return cd[4]
                            if not mem[_3507]:
                                return cd[4]
                            mem[mem[64]] = mem[_3507]
                        else:
                            mem[0] = mem[mem[128] + 44 len 20]
                            mem[32] = 1
                            if not stor1[mem[0]]:
                                return cd[4]
                            mem[0] = mem[mem[(32 * mem[96] - 1) + 128] + 12 len 20]
                            mem[32] = 1
                            if not stor1[mem[0]]:
                                return cd[4]
                            if 0 >= mem[96]:
                                revert with 'NH{q', 50
                            _2177 = mem[128]
                            if mem[96] < 1:
                                revert with 'NH{q', 17
                            if mem[96] - 1 >= mem[96]:
                                revert with 'NH{q', 50
                            _2397 = mem[(32 * mem[96] - 1) + 128]
                            mem[mem[64]] = 0x6fbc980700000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = mem[_2177 + 12 len 20]
                            mem[mem[64] + 36] = mem[_2177 + 44 len 20]
                            mem[mem[64] + 68] = mem[_2177 + 76 len 20]
                            mem[mem[64] + 100] = mem[_2177 + 108 len 20]
                            mem[mem[64] + 132] = mem[_2177 + 128]
                            mem[mem[64] + 164] = mem[_2177 + 160]
                            mem[mem[64] + 196] = mem[_2397 + 12 len 20]
                            mem[mem[64] + 228] = mem[_2397 + 44 len 20]
                            mem[mem[64] + 260] = mem[_2397 + 76 len 20]
                            mem[mem[64] + 292] = mem[_2397 + 108 len 20]
                            mem[mem[64] + 324] = mem[_2397 + 128]
                            mem[mem[64] + 356] = mem[_2397 + 160]
                            require ext_code.size(stor3)
                            staticcall stor3.0x6fbc9807 with:
                                    gas gas_remaining wei
                                   args mem[mem[64] + 4 len 384]
                            mem[mem[64] len 64] = ext_call.return_data[0 len 64]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3090 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 64
                            require mem[_3090] == bool(mem[_3090])
                            _3171 = mem[_3090 + 32]
                            require mem[_3090 + 32] == mem[_3090 + 32]
                            if not mem[_3090]:
                                revert with 0, 'B'
                            if 0 >= mem[96]:
                                revert with 'NH{q', 50
                            _3372 = mem[mem[128]]
                            mem[mem[64] + 4] = 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                            require ext_code.size(address(_3372))
                            staticcall address(_3372).0x70a08231 with:
                                    gas gas_remaining wei
                                   args 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3569 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_3569] == mem[_3569]
                            if _3171 < mem[_3569]:
                                if _3171:
                                    return _3171
                                return cd[4]
                            if not mem[_3569]:
                                return cd[4]
                            mem[mem[64]] = mem[_3569]
                else:
                    if mem[mem[(32 * mem[96] - 1) + 128] + 160] == 13:
                        if mem[96] == 2:
                            if 0 >= mem[96]:
                                revert with 'NH{q', 50
                            _2088 = mem[128]
                            if mem[96] < 1:
                                revert with 'NH{q', 17
                            if mem[96] - 1 >= mem[96]:
                                revert with 'NH{q', 50
                            _2274 = mem[(32 * mem[96] - 1) + 128]
                            mem[mem[64]] = 0x6fbc980700000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = mem[_2088 + 12 len 20]
                            mem[mem[64] + 36] = mem[_2088 + 44 len 20]
                            mem[mem[64] + 68] = mem[_2088 + 76 len 20]
                            mem[mem[64] + 100] = mem[_2088 + 108 len 20]
                            mem[mem[64] + 132] = mem[_2088 + 128]
                            mem[mem[64] + 164] = mem[_2088 + 160]
                            mem[mem[64] + 196] = mem[_2274 + 12 len 20]
                            mem[mem[64] + 228] = mem[_2274 + 44 len 20]
                            mem[mem[64] + 260] = mem[_2274 + 76 len 20]
                            mem[mem[64] + 292] = mem[_2274 + 108 len 20]
                            mem[mem[64] + 324] = mem[_2274 + 128]
                            mem[mem[64] + 356] = mem[_2274 + 160]
                            require ext_code.size(stor3)
                            staticcall stor3.0x6fbc9807 with:
                                    gas gas_remaining wei
                                   args mem[mem[64] + 4 len 384]
                            mem[mem[64] len 64] = ext_call.return_data[0 len 64]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3025 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 64
                            require mem[_3025] == bool(mem[_3025])
                            _3144 = mem[_3025 + 32]
                            require mem[_3025 + 32] == mem[_3025 + 32]
                            if not mem[_3025]:
                                revert with 0, 'B'
                            if 0 >= mem[96]:
                                revert with 'NH{q', 50
                            _3246 = mem[mem[128]]
                            mem[mem[64] + 4] = 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                            require ext_code.size(address(_3246))
                            staticcall address(_3246).0x70a08231 with:
                                    gas gas_remaining wei
                                   args 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3487 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_3487] == mem[_3487]
                            if _3144 < mem[_3487]:
                                if _3144:
                                    return _3144
                                return cd[4]
                            if not mem[_3487]:
                                return cd[4]
                            mem[mem[64]] = mem[_3487]
                        else:
                            if mem[96] != 3:
                                if 0 >= mem[96]:
                                    revert with 'NH{q', 50
                                _2135 = mem[128]
                                if mem[96] < 1:
                                    revert with 'NH{q', 17
                                if mem[96] - 1 >= mem[96]:
                                    revert with 'NH{q', 50
                                _2330 = mem[(32 * mem[96] - 1) + 128]
                                mem[mem[64]] = 0x6fbc980700000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = mem[_2135 + 12 len 20]
                                mem[mem[64] + 36] = mem[_2135 + 44 len 20]
                                mem[mem[64] + 68] = mem[_2135 + 76 len 20]
                                mem[mem[64] + 100] = mem[_2135 + 108 len 20]
                                mem[mem[64] + 132] = mem[_2135 + 128]
                                mem[mem[64] + 164] = mem[_2135 + 160]
                                mem[mem[64] + 196] = mem[_2330 + 12 len 20]
                                mem[mem[64] + 228] = mem[_2330 + 44 len 20]
                                mem[mem[64] + 260] = mem[_2330 + 76 len 20]
                                mem[mem[64] + 292] = mem[_2330 + 108 len 20]
                                mem[mem[64] + 324] = mem[_2330 + 128]
                                mem[mem[64] + 356] = mem[_2330 + 160]
                                require ext_code.size(stor3)
                                staticcall stor3.0x6fbc9807 with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len 384]
                                mem[mem[64] len 64] = ext_call.return_data[0 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3054 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 64
                                require mem[_3054] == bool(mem[_3054])
                                _3159 = mem[_3054 + 32]
                                require mem[_3054 + 32] == mem[_3054 + 32]
                                if not mem[_3054]:
                                    revert with 0, 'B'
                                if 0 >= mem[96]:
                                    revert with 'NH{q', 50
                                _3314 = mem[mem[128]]
                                mem[mem[64] + 4] = 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                                require ext_code.size(address(_3314))
                                staticcall address(_3314).0x70a08231 with:
                                        gas gas_remaining wei
                                       args 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3526 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_3526] == mem[_3526]
                                if _3159 < mem[_3526]:
                                    if _3159:
                                        return _3159
                                    return cd[4]
                                if not mem[_3526]:
                                    return cd[4]
                                mem[mem[64]] = mem[_3526]
                            else:
                                mem[0] = mem[mem[128] + 44 len 20]
                                mem[32] = 1
                                if not stor1[mem[0]]:
                                    return cd[4]
                                mem[0] = mem[mem[(32 * mem[96] - 1) + 128] + 12 len 20]
                                mem[32] = 1
                                if not stor1[mem[0]]:
                                    return cd[4]
                                if 0 >= mem[96]:
                                    revert with 'NH{q', 50
                                _2199 = mem[128]
                                if mem[96] < 1:
                                    revert with 'NH{q', 17
                                if mem[96] - 1 >= mem[96]:
                                    revert with 'NH{q', 50
                                _2423 = mem[(32 * mem[96] - 1) + 128]
                                mem[mem[64]] = 0x6fbc980700000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = mem[_2199 + 12 len 20]
                                mem[mem[64] + 36] = mem[_2199 + 44 len 20]
                                mem[mem[64] + 68] = mem[_2199 + 76 len 20]
                                mem[mem[64] + 100] = mem[_2199 + 108 len 20]
                                mem[mem[64] + 132] = mem[_2199 + 128]
                                mem[mem[64] + 164] = mem[_2199 + 160]
                                mem[mem[64] + 196] = mem[_2423 + 12 len 20]
                                mem[mem[64] + 228] = mem[_2423 + 44 len 20]
                                mem[mem[64] + 260] = mem[_2423 + 76 len 20]
                                mem[mem[64] + 292] = mem[_2423 + 108 len 20]
                                mem[mem[64] + 324] = mem[_2423 + 128]
                                mem[mem[64] + 356] = mem[_2423 + 160]
                                require ext_code.size(stor3)
                                staticcall stor3.0x6fbc9807 with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len 384]
                                mem[mem[64] len 64] = ext_call.return_data[0 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3103 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 64
                                require mem[_3103] == bool(mem[_3103])
                                _3176 = mem[_3103 + 32]
                                require mem[_3103 + 32] == mem[_3103 + 32]
                                if not mem[_3103]:
                                    revert with 0, 'B'
                                if 0 >= mem[96]:
                                    revert with 'NH{q', 50
                                _3396 = mem[mem[128]]
                                mem[mem[64] + 4] = 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                                require ext_code.size(address(_3396))
                                staticcall address(_3396).0x70a08231 with:
                                        gas gas_remaining wei
                                       args 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3583 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_3583] == mem[_3583]
                                if _3176 < mem[_3583]:
                                    if _3176:
                                        return _3176
                                    return cd[4]
                                if not mem[_3583]:
                                    return cd[4]
                                mem[mem[64]] = mem[_3583]
                    else:
                        if mem[mem[(32 * mem[96] - 1) + 128] + 160] != 14:
                            return cd[4]
                        if mem[96] == 2:
                            if 0 >= mem[96]:
                                revert with 'NH{q', 50
                            _2113 = mem[128]
                            if mem[96] < 1:
                                revert with 'NH{q', 17
                            if mem[96] - 1 >= mem[96]:
                                revert with 'NH{q', 50
                            _2300 = mem[(32 * mem[96] - 1) + 128]
                            mem[mem[64]] = 0x6fbc980700000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = mem[_2113 + 12 len 20]
                            mem[mem[64] + 36] = mem[_2113 + 44 len 20]
                            mem[mem[64] + 68] = mem[_2113 + 76 len 20]
                            mem[mem[64] + 100] = mem[_2113 + 108 len 20]
                            mem[mem[64] + 132] = mem[_2113 + 128]
                            mem[mem[64] + 164] = mem[_2113 + 160]
                            mem[mem[64] + 196] = mem[_2300 + 12 len 20]
                            mem[mem[64] + 228] = mem[_2300 + 44 len 20]
                            mem[mem[64] + 260] = mem[_2300 + 76 len 20]
                            mem[mem[64] + 292] = mem[_2300 + 108 len 20]
                            mem[mem[64] + 324] = mem[_2300 + 128]
                            mem[mem[64] + 356] = mem[_2300 + 160]
                            require ext_code.size(stor3)
                            staticcall stor3.0x6fbc9807 with:
                                    gas gas_remaining wei
                                   args mem[mem[64] + 4 len 384]
                            mem[mem[64] len 64] = ext_call.return_data[0 len 64]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3039 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 64
                            require mem[_3039] == bool(mem[_3039])
                            _3152 = mem[_3039 + 32]
                            require mem[_3039 + 32] == mem[_3039 + 32]
                            if not mem[_3039]:
                                revert with 0, 'B'
                            if 0 >= mem[96]:
                                revert with 'NH{q', 50
                            _3279 = mem[mem[128]]
                            mem[mem[64] + 4] = 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                            require ext_code.size(address(_3279))
                            staticcall address(_3279).0x70a08231 with:
                                    gas gas_remaining wei
                                   args 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3506 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_3506] == mem[_3506]
                            if _3152 < mem[_3506]:
                                if _3152:
                                    return _3152
                                return cd[4]
                            if not mem[_3506]:
                                return cd[4]
                            mem[mem[64]] = mem[_3506]
                        else:
                            if mem[96] != 3:
                                if 0 >= mem[96]:
                                    revert with 'NH{q', 50
                                _2154 = mem[128]
                                if mem[96] < 1:
                                    revert with 'NH{q', 17
                                if mem[96] - 1 >= mem[96]:
                                    revert with 'NH{q', 50
                                _2361 = mem[(32 * mem[96] - 1) + 128]
                                mem[mem[64]] = 0x6fbc980700000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = mem[_2154 + 12 len 20]
                                mem[mem[64] + 36] = mem[_2154 + 44 len 20]
                                mem[mem[64] + 68] = mem[_2154 + 76 len 20]
                                mem[mem[64] + 100] = mem[_2154 + 108 len 20]
                                mem[mem[64] + 132] = mem[_2154 + 128]
                                mem[mem[64] + 164] = mem[_2154 + 160]
                                mem[mem[64] + 196] = mem[_2361 + 12 len 20]
                                mem[mem[64] + 228] = mem[_2361 + 44 len 20]
                                mem[mem[64] + 260] = mem[_2361 + 76 len 20]
                                mem[mem[64] + 292] = mem[_2361 + 108 len 20]
                                mem[mem[64] + 324] = mem[_2361 + 128]
                                mem[mem[64] + 356] = mem[_2361 + 160]
                                require ext_code.size(stor3)
                                staticcall stor3.0x6fbc9807 with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len 384]
                                mem[mem[64] len 64] = ext_call.return_data[0 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3070 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 64
                                require mem[_3070] == bool(mem[_3070])
                                _3165 = mem[_3070 + 32]
                                require mem[_3070 + 32] == mem[_3070 + 32]
                                if not mem[_3070]:
                                    revert with 0, 'B'
                                if 0 >= mem[96]:
                                    revert with 'NH{q', 50
                                _3342 = mem[mem[128]]
                                mem[mem[64] + 4] = 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                                require ext_code.size(address(_3342))
                                staticcall address(_3342).0x70a08231 with:
                                        gas gas_remaining wei
                                       args 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3546 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_3546] == mem[_3546]
                                if _3165 < mem[_3546]:
                                    if _3165:
                                        return _3165
                                    return cd[4]
                                if not mem[_3546]:
                                    return cd[4]
                                mem[mem[64]] = mem[_3546]
                            else:
                                mem[0] = mem[mem[128] + 44 len 20]
                                mem[32] = 1
                                if not stor1[mem[0]]:
                                    return cd[4]
                                mem[0] = mem[mem[(32 * mem[96] - 1) + 128] + 12 len 20]
                                mem[32] = 1
                                if not stor1[mem[0]]:
                                    return cd[4]
                                if 0 >= mem[96]:
                                    revert with 'NH{q', 50
                                _2222 = mem[128]
                                if mem[96] < 1:
                                    revert with 'NH{q', 17
                                if mem[96] - 1 >= mem[96]:
                                    revert with 'NH{q', 50
                                _2442 = mem[(32 * mem[96] - 1) + 128]
                                mem[mem[64]] = 0x6fbc980700000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = mem[_2222 + 12 len 20]
                                mem[mem[64] + 36] = mem[_2222 + 44 len 20]
                                mem[mem[64] + 68] = mem[_2222 + 76 len 20]
                                mem[mem[64] + 100] = mem[_2222 + 108 len 20]
                                mem[mem[64] + 132] = mem[_2222 + 128]
                                mem[mem[64] + 164] = mem[_2222 + 160]
                                mem[mem[64] + 196] = mem[_2442 + 12 len 20]
                                mem[mem[64] + 228] = mem[_2442 + 44 len 20]
                                mem[mem[64] + 260] = mem[_2442 + 76 len 20]
                                mem[mem[64] + 292] = mem[_2442 + 108 len 20]
                                mem[mem[64] + 324] = mem[_2442 + 128]
                                mem[mem[64] + 356] = mem[_2442 + 160]
                                require ext_code.size(stor3)
                                staticcall stor3.0x6fbc9807 with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len 384]
                                mem[mem[64] len 64] = ext_call.return_data[0 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3114 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 64
                                require mem[_3114] == bool(mem[_3114])
                                _3182 = mem[_3114 + 32]
                                require mem[_3114 + 32] == mem[_3114 + 32]
                                if not mem[_3114]:
                                    revert with 0, 'B'
                                if 0 >= mem[96]:
                                    revert with 'NH{q', 50
                                _3416 = mem[mem[128]]
                                mem[mem[64] + 4] = 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                                require ext_code.size(address(_3416))
                                staticcall address(_3416).0x70a08231 with:
                                        gas gas_remaining wei
                                       args 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3594 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_3594] == mem[_3594]
                                if _3182 < mem[_3594]:
                                    if _3182:
                                        return _3182
                                    return cd[4]
                                if not mem[_3594]:
                                    return cd[4]
                                mem[mem[64]] = mem[_3594]
        else:
            if mem[mem[128] + 160] == 13:
                if mem[mem[(32 * mem[96] - 1) + 128] + 160] == 1:
                    if mem[96] == 2:
                        if 0 >= mem[96]:
                            revert with 'NH{q', 50
                        _2060 = mem[128]
                        if mem[96] < 1:
                            revert with 'NH{q', 17
                        if mem[96] - 1 >= mem[96]:
                            revert with 'NH{q', 50
                        _2245 = mem[(32 * mem[96] - 1) + 128]
                        mem[mem[64]] = 0x6fbc980700000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = mem[_2060 + 12 len 20]
                        mem[mem[64] + 36] = mem[_2060 + 44 len 20]
                        mem[mem[64] + 68] = mem[_2060 + 76 len 20]
                        mem[mem[64] + 100] = mem[_2060 + 108 len 20]
                        mem[mem[64] + 132] = mem[_2060 + 128]
                        mem[mem[64] + 164] = mem[_2060 + 160]
                        mem[mem[64] + 196] = mem[_2245 + 12 len 20]
                        mem[mem[64] + 228] = mem[_2245 + 44 len 20]
                        mem[mem[64] + 260] = mem[_2245 + 76 len 20]
                        mem[mem[64] + 292] = mem[_2245 + 108 len 20]
                        mem[mem[64] + 324] = mem[_2245 + 128]
                        mem[mem[64] + 356] = mem[_2245 + 160]
                        require ext_code.size(stor3)
                        staticcall stor3.0x6fbc9807 with:
                                gas gas_remaining wei
                               args mem[mem[64] + 4 len 384]
                        mem[mem[64] len 64] = ext_call.return_data[0 len 64]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3010 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 64
                        require mem[_3010] == bool(mem[_3010])
                        _3135 = mem[_3010 + 32]
                        require mem[_3010 + 32] == mem[_3010 + 32]
                        if not mem[_3010]:
                            revert with 0, 'B'
                        if 0 >= mem[96]:
                            revert with 'NH{q', 50
                        _3212 = mem[mem[128]]
                        mem[mem[64] + 4] = 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                        require ext_code.size(address(_3212))
                        staticcall address(_3212).0x70a08231 with:
                                gas gas_remaining wei
                               args 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3466 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_3466] == mem[_3466]
                        if _3135 < mem[_3466]:
                            if _3135:
                                return _3135
                            return cd[4]
                        if not mem[_3466]:
                            return cd[4]
                        mem[mem[64]] = mem[_3466]
                    else:
                        if mem[96] != 3:
                            if 0 >= mem[96]:
                                revert with 'NH{q', 50
                            _2110 = mem[128]
                            if mem[96] < 1:
                                revert with 'NH{q', 17
                            if mem[96] - 1 >= mem[96]:
                                revert with 'NH{q', 50
                            _2297 = mem[(32 * mem[96] - 1) + 128]
                            mem[mem[64]] = 0x6fbc980700000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = mem[_2110 + 12 len 20]
                            mem[mem[64] + 36] = mem[_2110 + 44 len 20]
                            mem[mem[64] + 68] = mem[_2110 + 76 len 20]
                            mem[mem[64] + 100] = mem[_2110 + 108 len 20]
                            mem[mem[64] + 132] = mem[_2110 + 128]
                            mem[mem[64] + 164] = mem[_2110 + 160]
                            mem[mem[64] + 196] = mem[_2297 + 12 len 20]
                            mem[mem[64] + 228] = mem[_2297 + 44 len 20]
                            mem[mem[64] + 260] = mem[_2297 + 76 len 20]
                            mem[mem[64] + 292] = mem[_2297 + 108 len 20]
                            mem[mem[64] + 324] = mem[_2297 + 128]
                            mem[mem[64] + 356] = mem[_2297 + 160]
                            require ext_code.size(stor3)
                            staticcall stor3.0x6fbc9807 with:
                                    gas gas_remaining wei
                                   args mem[mem[64] + 4 len 384]
                            mem[mem[64] len 64] = ext_call.return_data[0 len 64]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3037 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 64
                            require mem[_3037] == bool(mem[_3037])
                            _3151 = mem[_3037 + 32]
                            require mem[_3037 + 32] == mem[_3037 + 32]
                            if not mem[_3037]:
                                revert with 0, 'B'
                            if 0 >= mem[96]:
                                revert with 'NH{q', 50
                            _3276 = mem[mem[128]]
                            mem[mem[64] + 4] = 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                            require ext_code.size(address(_3276))
                            staticcall address(_3276).0x70a08231 with:
                                    gas gas_remaining wei
                                   args 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3503 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_3503] == mem[_3503]
                            if _3151 < mem[_3503]:
                                if _3151:
                                    return _3151
                                return cd[4]
                            if not mem[_3503]:
                                return cd[4]
                            mem[mem[64]] = mem[_3503]
                        else:
                            mem[0] = mem[mem[128] + 44 len 20]
                            mem[32] = 1
                            if not stor1[mem[0]]:
                                return cd[4]
                            mem[0] = mem[mem[(32 * mem[96] - 1) + 128] + 12 len 20]
                            mem[32] = 1
                            if not stor1[mem[0]]:
                                return cd[4]
                            if 0 >= mem[96]:
                                revert with 'NH{q', 50
                            _2173 = mem[128]
                            if mem[96] < 1:
                                revert with 'NH{q', 17
                            if mem[96] - 1 >= mem[96]:
                                revert with 'NH{q', 50
                            _2391 = mem[(32 * mem[96] - 1) + 128]
                            mem[mem[64]] = 0x6fbc980700000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = mem[_2173 + 12 len 20]
                            mem[mem[64] + 36] = mem[_2173 + 44 len 20]
                            mem[mem[64] + 68] = mem[_2173 + 76 len 20]
                            mem[mem[64] + 100] = mem[_2173 + 108 len 20]
                            mem[mem[64] + 132] = mem[_2173 + 128]
                            mem[mem[64] + 164] = mem[_2173 + 160]
                            mem[mem[64] + 196] = mem[_2391 + 12 len 20]
                            mem[mem[64] + 228] = mem[_2391 + 44 len 20]
                            mem[mem[64] + 260] = mem[_2391 + 76 len 20]
                            mem[mem[64] + 292] = mem[_2391 + 108 len 20]
                            mem[mem[64] + 324] = mem[_2391 + 128]
                            mem[mem[64] + 356] = mem[_2391 + 160]
                            require ext_code.size(stor3)
                            staticcall stor3.0x6fbc9807 with:
                                    gas gas_remaining wei
                                   args mem[mem[64] + 4 len 384]
                            mem[mem[64] len 64] = ext_call.return_data[0 len 64]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3086 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 64
                            require mem[_3086] == bool(mem[_3086])
                            _3170 = mem[_3086 + 32]
                            require mem[_3086 + 32] == mem[_3086 + 32]
                            if not mem[_3086]:
                                revert with 0, 'B'
                            if 0 >= mem[96]:
                                revert with 'NH{q', 50
                            _3367 = mem[mem[128]]
                            mem[mem[64] + 4] = 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                            require ext_code.size(address(_3367))
                            staticcall address(_3367).0x70a08231 with:
                                    gas gas_remaining wei
                                   args 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3565 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_3565] == mem[_3565]
                            if _3170 < mem[_3565]:
                                if _3170:
                                    return _3170
                                return cd[4]
                            if not mem[_3565]:
                                return cd[4]
                            mem[mem[64]] = mem[_3565]
                else:
                    if mem[mem[(32 * mem[96] - 1) + 128] + 160] == 7:
                        if mem[96] == 2:
                            if 0 >= mem[96]:
                                revert with 'NH{q', 50
                            _2084 = mem[128]
                            if mem[96] < 1:
                                revert with 'NH{q', 17
                            if mem[96] - 1 >= mem[96]:
                                revert with 'NH{q', 50
                            _2270 = mem[(32 * mem[96] - 1) + 128]
                            mem[mem[64]] = 0x6fbc980700000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = mem[_2084 + 12 len 20]
                            mem[mem[64] + 36] = mem[_2084 + 44 len 20]
                            mem[mem[64] + 68] = mem[_2084 + 76 len 20]
                            mem[mem[64] + 100] = mem[_2084 + 108 len 20]
                            mem[mem[64] + 132] = mem[_2084 + 128]
                            mem[mem[64] + 164] = mem[_2084 + 160]
                            mem[mem[64] + 196] = mem[_2270 + 12 len 20]
                            mem[mem[64] + 228] = mem[_2270 + 44 len 20]
                            mem[mem[64] + 260] = mem[_2270 + 76 len 20]
                            mem[mem[64] + 292] = mem[_2270 + 108 len 20]
                            mem[mem[64] + 324] = mem[_2270 + 128]
                            mem[mem[64] + 356] = mem[_2270 + 160]
                            require ext_code.size(stor3)
                            staticcall stor3.0x6fbc9807 with:
                                    gas gas_remaining wei
                                   args mem[mem[64] + 4 len 384]
                            mem[mem[64] len 64] = ext_call.return_data[0 len 64]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3023 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 64
                            require mem[_3023] == bool(mem[_3023])
                            _3143 = mem[_3023 + 32]
                            require mem[_3023 + 32] == mem[_3023 + 32]
                            if not mem[_3023]:
                                revert with 0, 'B'
                            if 0 >= mem[96]:
                                revert with 'NH{q', 50
                            _3239 = mem[mem[128]]
                            mem[mem[64] + 4] = 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                            require ext_code.size(address(_3239))
                            staticcall address(_3239).0x70a08231 with:
                                    gas gas_remaining wei
                                   args 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3484 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_3484] == mem[_3484]
                            if _3143 < mem[_3484]:
                                if _3143:
                                    return _3143
                                return cd[4]
                            if not mem[_3484]:
                                return cd[4]
                            mem[mem[64]] = mem[_3484]
                        else:
                            if mem[96] != 3:
                                if 0 >= mem[96]:
                                    revert with 'NH{q', 50
                                _2132 = mem[128]
                                if mem[96] < 1:
                                    revert with 'NH{q', 17
                                if mem[96] - 1 >= mem[96]:
                                    revert with 'NH{q', 50
                                _2325 = mem[(32 * mem[96] - 1) + 128]
                                mem[mem[64]] = 0x6fbc980700000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = mem[_2132 + 12 len 20]
                                mem[mem[64] + 36] = mem[_2132 + 44 len 20]
                                mem[mem[64] + 68] = mem[_2132 + 76 len 20]
                                mem[mem[64] + 100] = mem[_2132 + 108 len 20]
                                mem[mem[64] + 132] = mem[_2132 + 128]
                                mem[mem[64] + 164] = mem[_2132 + 160]
                                mem[mem[64] + 196] = mem[_2325 + 12 len 20]
                                mem[mem[64] + 228] = mem[_2325 + 44 len 20]
                                mem[mem[64] + 260] = mem[_2325 + 76 len 20]
                                mem[mem[64] + 292] = mem[_2325 + 108 len 20]
                                mem[mem[64] + 324] = mem[_2325 + 128]
                                mem[mem[64] + 356] = mem[_2325 + 160]
                                require ext_code.size(stor3)
                                staticcall stor3.0x6fbc9807 with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len 384]
                                mem[mem[64] len 64] = ext_call.return_data[0 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3051 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 64
                                require mem[_3051] == bool(mem[_3051])
                                _3158 = mem[_3051 + 32]
                                require mem[_3051 + 32] == mem[_3051 + 32]
                                if not mem[_3051]:
                                    revert with 0, 'B'
                                if 0 >= mem[96]:
                                    revert with 'NH{q', 50
                                _3309 = mem[mem[128]]
                                mem[mem[64] + 4] = 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                                require ext_code.size(address(_3309))
                                staticcall address(_3309).0x70a08231 with:
                                        gas gas_remaining wei
                                       args 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3522 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_3522] == mem[_3522]
                                if _3158 < mem[_3522]:
                                    if _3158:
                                        return _3158
                                    return cd[4]
                                if not mem[_3522]:
                                    return cd[4]
                                mem[mem[64]] = mem[_3522]
                            else:
                                mem[0] = mem[mem[128] + 44 len 20]
                                mem[32] = 1
                                if not stor1[mem[0]]:
                                    return cd[4]
                                mem[0] = mem[mem[(32 * mem[96] - 1) + 128] + 12 len 20]
                                mem[32] = 1
                                if not stor1[mem[0]]:
                                    return cd[4]
                                if 0 >= mem[96]:
                                    revert with 'NH{q', 50
                                _2194 = mem[128]
                                if mem[96] < 1:
                                    revert with 'NH{q', 17
                                if mem[96] - 1 >= mem[96]:
                                    revert with 'NH{q', 50
                                _2418 = mem[(32 * mem[96] - 1) + 128]
                                mem[mem[64]] = 0x6fbc980700000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = mem[_2194 + 12 len 20]
                                mem[mem[64] + 36] = mem[_2194 + 44 len 20]
                                mem[mem[64] + 68] = mem[_2194 + 76 len 20]
                                mem[mem[64] + 100] = mem[_2194 + 108 len 20]
                                mem[mem[64] + 132] = mem[_2194 + 128]
                                mem[mem[64] + 164] = mem[_2194 + 160]
                                mem[mem[64] + 196] = mem[_2418 + 12 len 20]
                                mem[mem[64] + 228] = mem[_2418 + 44 len 20]
                                mem[mem[64] + 260] = mem[_2418 + 76 len 20]
                                mem[mem[64] + 292] = mem[_2418 + 108 len 20]
                                mem[mem[64] + 324] = mem[_2418 + 128]
                                mem[mem[64] + 356] = mem[_2418 + 160]
                                require ext_code.size(stor3)
                                staticcall stor3.0x6fbc9807 with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len 384]
                                mem[mem[64] len 64] = ext_call.return_data[0 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3101 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 64
                                require mem[_3101] == bool(mem[_3101])
                                _3175 = mem[_3101 + 32]
                                require mem[_3101 + 32] == mem[_3101 + 32]
                                if not mem[_3101]:
                                    revert with 0, 'B'
                                if 0 >= mem[96]:
                                    revert with 'NH{q', 50
                                _3391 = mem[mem[128]]
                                mem[mem[64] + 4] = 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                                require ext_code.size(address(_3391))
                                staticcall address(_3391).0x70a08231 with:
                                        gas gas_remaining wei
                                       args 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3581 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_3581] == mem[_3581]
                                if _3175 < mem[_3581]:
                                    if _3175:
                                        return _3175
                                    return cd[4]
                                if not mem[_3581]:
                                    return cd[4]
                                mem[mem[64]] = mem[_3581]
                    else:
                        if mem[mem[(32 * mem[96] - 1) + 128] + 160] == 13:
                            if mem[96] == 2:
                                if 0 >= mem[96]:
                                    revert with 'NH{q', 50
                                _2107 = mem[128]
                                if mem[96] < 1:
                                    revert with 'NH{q', 17
                                if mem[96] - 1 >= mem[96]:
                                    revert with 'NH{q', 50
                                _2294 = mem[(32 * mem[96] - 1) + 128]
                                mem[mem[64]] = 0x6fbc980700000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = mem[_2107 + 12 len 20]
                                mem[mem[64] + 36] = mem[_2107 + 44 len 20]
                                mem[mem[64] + 68] = mem[_2107 + 76 len 20]
                                mem[mem[64] + 100] = mem[_2107 + 108 len 20]
                                mem[mem[64] + 132] = mem[_2107 + 128]
                                mem[mem[64] + 164] = mem[_2107 + 160]
                                mem[mem[64] + 196] = mem[_2294 + 12 len 20]
                                mem[mem[64] + 228] = mem[_2294 + 44 len 20]
                                mem[mem[64] + 260] = mem[_2294 + 76 len 20]
                                mem[mem[64] + 292] = mem[_2294 + 108 len 20]
                                mem[mem[64] + 324] = mem[_2294 + 128]
                                mem[mem[64] + 356] = mem[_2294 + 160]
                                require ext_code.size(stor3)
                                staticcall stor3.0x6fbc9807 with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len 384]
                                mem[mem[64] len 64] = ext_call.return_data[0 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3036 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 64
                                require mem[_3036] == bool(mem[_3036])
                                _3150 = mem[_3036 + 32]
                                require mem[_3036 + 32] == mem[_3036 + 32]
                                if not mem[_3036]:
                                    revert with 0, 'B'
                                if 0 >= mem[96]:
                                    revert with 'NH{q', 50
                                _3271 = mem[mem[128]]
                                mem[mem[64] + 4] = 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                                require ext_code.size(address(_3271))
                                staticcall address(_3271).0x70a08231 with:
                                        gas gas_remaining wei
                                       args 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3502 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_3502] == mem[_3502]
                                if _3150 < mem[_3502]:
                                    if _3150:
                                        return _3150
                                    return cd[4]
                                if not mem[_3502]:
                                    return cd[4]
                                mem[mem[64]] = mem[_3502]
                            else:
                                if mem[96] != 3:
                                    if 0 >= mem[96]:
                                        revert with 'NH{q', 50
                                    _2151 = mem[128]
                                    if mem[96] < 1:
                                        revert with 'NH{q', 17
                                    if mem[96] - 1 >= mem[96]:
                                        revert with 'NH{q', 50
                                    _2354 = mem[(32 * mem[96] - 1) + 128]
                                    mem[mem[64]] = 0x6fbc980700000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = mem[_2151 + 12 len 20]
                                    mem[mem[64] + 36] = mem[_2151 + 44 len 20]
                                    mem[mem[64] + 68] = mem[_2151 + 76 len 20]
                                    mem[mem[64] + 100] = mem[_2151 + 108 len 20]
                                    mem[mem[64] + 132] = mem[_2151 + 128]
                                    mem[mem[64] + 164] = mem[_2151 + 160]
                                    mem[mem[64] + 196] = mem[_2354 + 12 len 20]
                                    mem[mem[64] + 228] = mem[_2354 + 44 len 20]
                                    mem[mem[64] + 260] = mem[_2354 + 76 len 20]
                                    mem[mem[64] + 292] = mem[_2354 + 108 len 20]
                                    mem[mem[64] + 324] = mem[_2354 + 128]
                                    mem[mem[64] + 356] = mem[_2354 + 160]
                                    require ext_code.size(stor3)
                                    staticcall stor3.0x6fbc9807 with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4 len 384]
                                    mem[mem[64] len 64] = ext_call.return_data[0 len 64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _3067 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 64
                                    require mem[_3067] == bool(mem[_3067])
                                    _3164 = mem[_3067 + 32]
                                    require mem[_3067 + 32] == mem[_3067 + 32]
                                    if not mem[_3067]:
                                        revert with 0, 'B'
                                    if 0 >= mem[96]:
                                        revert with 'NH{q', 50
                                    _3337 = mem[mem[128]]
                                    mem[mem[64] + 4] = 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                                    require ext_code.size(address(_3337))
                                    staticcall address(_3337).0x70a08231 with:
                                            gas gas_remaining wei
                                           args 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _3542 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_3542] == mem[_3542]
                                    if _3164 < mem[_3542]:
                                        if _3164:
                                            return _3164
                                        return cd[4]
                                    if not mem[_3542]:
                                        return cd[4]
                                    mem[mem[64]] = mem[_3542]
                                else:
                                    mem[0] = mem[mem[128] + 44 len 20]
                                    mem[32] = 1
                                    if not stor1[mem[0]]:
                                        return cd[4]
                                    mem[0] = mem[mem[(32 * mem[96] - 1) + 128] + 12 len 20]
                                    mem[32] = 1
                                    if not stor1[mem[0]]:
                                        return cd[4]
                                    if 0 >= mem[96]:
                                        revert with 'NH{q', 50
                                    _2217 = mem[128]
                                    if mem[96] < 1:
                                        revert with 'NH{q', 17
                                    if mem[96] - 1 >= mem[96]:
                                        revert with 'NH{q', 50
                                    _2439 = mem[(32 * mem[96] - 1) + 128]
                                    mem[mem[64]] = 0x6fbc980700000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = mem[_2217 + 12 len 20]
                                    mem[mem[64] + 36] = mem[_2217 + 44 len 20]
                                    mem[mem[64] + 68] = mem[_2217 + 76 len 20]
                                    mem[mem[64] + 100] = mem[_2217 + 108 len 20]
                                    mem[mem[64] + 132] = mem[_2217 + 128]
                                    mem[mem[64] + 164] = mem[_2217 + 160]
                                    mem[mem[64] + 196] = mem[_2439 + 12 len 20]
                                    mem[mem[64] + 228] = mem[_2439 + 44 len 20]
                                    mem[mem[64] + 260] = mem[_2439 + 76 len 20]
                                    mem[mem[64] + 292] = mem[_2439 + 108 len 20]
                                    mem[mem[64] + 324] = mem[_2439 + 128]
                                    mem[mem[64] + 356] = mem[_2439 + 160]
                                    require ext_code.size(stor3)
                                    staticcall stor3.0x6fbc9807 with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4 len 384]
                                    mem[mem[64] len 64] = ext_call.return_data[0 len 64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _3112 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 64
                                    require mem[_3112] == bool(mem[_3112])
                                    _3181 = mem[_3112 + 32]
                                    require mem[_3112 + 32] == mem[_3112 + 32]
                                    if not mem[_3112]:
                                        revert with 0, 'B'
                                    if 0 >= mem[96]:
                                        revert with 'NH{q', 50
                                    _3412 = mem[mem[128]]
                                    mem[mem[64] + 4] = 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                                    require ext_code.size(address(_3412))
                                    staticcall address(_3412).0x70a08231 with:
                                            gas gas_remaining wei
                                           args 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _3592 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_3592] == mem[_3592]
                                    if _3181 < mem[_3592]:
                                        if _3181:
                                            return _3181
                                        return cd[4]
                                    if not mem[_3592]:
                                        return cd[4]
                                    mem[mem[64]] = mem[_3592]
                        else:
                            if mem[mem[(32 * mem[96] - 1) + 128] + 160] != 14:
                                return cd[4]
                            if mem[96] == 2:
                                if 0 >= mem[96]:
                                    revert with 'NH{q', 50
                                _2129 = mem[128]
                                if mem[96] < 1:
                                    revert with 'NH{q', 17
                                if mem[96] - 1 >= mem[96]:
                                    revert with 'NH{q', 50
                                _2322 = mem[(32 * mem[96] - 1) + 128]
                                mem[mem[64]] = 0x6fbc980700000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = mem[_2129 + 12 len 20]
                                mem[mem[64] + 36] = mem[_2129 + 44 len 20]
                                mem[mem[64] + 68] = mem[_2129 + 76 len 20]
                                mem[mem[64] + 100] = mem[_2129 + 108 len 20]
                                mem[mem[64] + 132] = mem[_2129 + 128]
                                mem[mem[64] + 164] = mem[_2129 + 160]
                                mem[mem[64] + 196] = mem[_2322 + 12 len 20]
                                mem[mem[64] + 228] = mem[_2322 + 44 len 20]
                                mem[mem[64] + 260] = mem[_2322 + 76 len 20]
                                mem[mem[64] + 292] = mem[_2322 + 108 len 20]
                                mem[mem[64] + 324] = mem[_2322 + 128]
                                mem[mem[64] + 356] = mem[_2322 + 160]
                                require ext_code.size(stor3)
                                staticcall stor3.0x6fbc9807 with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len 384]
                                mem[mem[64] len 64] = ext_call.return_data[0 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3050 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 64
                                require mem[_3050] == bool(mem[_3050])
                                _3157 = mem[_3050 + 32]
                                require mem[_3050 + 32] == mem[_3050 + 32]
                                if not mem[_3050]:
                                    revert with 0, 'B'
                                if 0 >= mem[96]:
                                    revert with 'NH{q', 50
                                _3304 = mem[mem[128]]
                                mem[mem[64] + 4] = 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                                require ext_code.size(address(_3304))
                                staticcall address(_3304).0x70a08231 with:
                                        gas gas_remaining wei
                                       args 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3521 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_3521] == mem[_3521]
                                if _3157 < mem[_3521]:
                                    if _3157:
                                        return _3157
                                    return cd[4]
                                if not mem[_3521]:
                                    return cd[4]
                                mem[mem[64]] = mem[_3521]
                            else:
                                if mem[96] != 3:
                                    if 0 >= mem[96]:
                                        revert with 'NH{q', 50
                                    _2169 = mem[128]
                                    if mem[96] < 1:
                                        revert with 'NH{q', 17
                                    if mem[96] - 1 >= mem[96]:
                                        revert with 'NH{q', 50
                                    _2384 = mem[(32 * mem[96] - 1) + 128]
                                    mem[mem[64]] = 0x6fbc980700000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = mem[_2169 + 12 len 20]
                                    mem[mem[64] + 36] = mem[_2169 + 44 len 20]
                                    mem[mem[64] + 68] = mem[_2169 + 76 len 20]
                                    mem[mem[64] + 100] = mem[_2169 + 108 len 20]
                                    mem[mem[64] + 132] = mem[_2169 + 128]
                                    mem[mem[64] + 164] = mem[_2169 + 160]
                                    mem[mem[64] + 196] = mem[_2384 + 12 len 20]
                                    mem[mem[64] + 228] = mem[_2384 + 44 len 20]
                                    mem[mem[64] + 260] = mem[_2384 + 76 len 20]
                                    mem[mem[64] + 292] = mem[_2384 + 108 len 20]
                                    mem[mem[64] + 324] = mem[_2384 + 128]
                                    mem[mem[64] + 356] = mem[_2384 + 160]
                                    require ext_code.size(stor3)
                                    staticcall stor3.0x6fbc9807 with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4 len 384]
                                    mem[mem[64] len 64] = ext_call.return_data[0 len 64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _3082 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 64
                                    require mem[_3082] == bool(mem[_3082])
                                    _3169 = mem[_3082 + 32]
                                    require mem[_3082 + 32] == mem[_3082 + 32]
                                    if not mem[_3082]:
                                        revert with 0, 'B'
                                    if 0 >= mem[96]:
                                        revert with 'NH{q', 50
                                    _3362 = mem[mem[128]]
                                    mem[mem[64] + 4] = 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                                    require ext_code.size(address(_3362))
                                    staticcall address(_3362).0x70a08231 with:
                                            gas gas_remaining wei
                                           args 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _3560 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_3560] == mem[_3560]
                                    if _3169 < mem[_3560]:
                                        if _3169:
                                            return _3169
                                        return cd[4]
                                    if not mem[_3560]:
                                        return cd[4]
                                    mem[mem[64]] = mem[_3560]
                                else:
                                    mem[0] = mem[mem[128] + 44 len 20]
                                    mem[32] = 1
                                    if not stor1[mem[0]]:
                                        return cd[4]
                                    mem[0] = mem[mem[(32 * mem[96] - 1) + 128] + 12 len 20]
                                    mem[32] = 1
                                    if not stor1[mem[0]]:
                                        return cd[4]
                                    if 0 >= mem[96]:
                                        revert with 'NH{q', 50
                                    _2241 = mem[128]
                                    if mem[96] < 1:
                                        revert with 'NH{q', 17
                                    if mem[96] - 1 >= mem[96]:
                                        revert with 'NH{q', 50
                                    _2454 = mem[(32 * mem[96] - 1) + 128]
                                    mem[mem[64]] = 0x6fbc980700000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = mem[_2241 + 12 len 20]
                                    mem[mem[64] + 36] = mem[_2241 + 44 len 20]
                                    mem[mem[64] + 68] = mem[_2241 + 76 len 20]
                                    mem[mem[64] + 100] = mem[_2241 + 108 len 20]
                                    mem[mem[64] + 132] = mem[_2241 + 128]
                                    mem[mem[64] + 164] = mem[_2241 + 160]
                                    mem[mem[64] + 196] = mem[_2454 + 12 len 20]
                                    mem[mem[64] + 228] = mem[_2454 + 44 len 20]
                                    mem[mem[64] + 260] = mem[_2454 + 76 len 20]
                                    mem[mem[64] + 292] = mem[_2454 + 108 len 20]
                                    mem[mem[64] + 324] = mem[_2454 + 128]
                                    mem[mem[64] + 356] = mem[_2454 + 160]
                                    require ext_code.size(stor3)
                                    staticcall stor3.0x6fbc9807 with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4 len 384]
                                    mem[mem[64] len 64] = ext_call.return_data[0 len 64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _3120 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 64
                                    require mem[_3120] == bool(mem[_3120])
                                    _3191 = mem[_3120 + 32]
                                    require mem[_3120 + 32] == mem[_3120 + 32]
                                    if not mem[_3120]:
                                        revert with 0, 'B'
                                    if 0 >= mem[96]:
                                        revert with 'NH{q', 50
                                    _3430 = mem[mem[128]]
                                    mem[mem[64] + 4] = 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                                    require ext_code.size(address(_3430))
                                    staticcall address(_3430).0x70a08231 with:
                                            gas gas_remaining wei
                                           args 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _3600 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_3600] == mem[_3600]
                                    if _3191 < mem[_3600]:
                                        if _3191:
                                            return _3191
                                        return cd[4]
                                    if not mem[_3600]:
                                        return cd[4]
                                    mem[mem[64]] = mem[_3600]
            else:
                if mem[mem[128] + 160] != 14:
                    return cd[4]
                if mem[mem[(32 * mem[96] - 1) + 128] + 160] == 1:
                    if mem[96] == 2:
                        if 0 >= mem[96]:
                            revert with 'NH{q', 50
                        _2079 = mem[128]
                        if mem[96] < 1:
                            revert with 'NH{q', 17
                        if mem[96] - 1 >= mem[96]:
                            revert with 'NH{q', 50
                        _2265 = mem[(32 * mem[96] - 1) + 128]
                        mem[mem[64]] = 0x6fbc980700000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = mem[_2079 + 12 len 20]
                        mem[mem[64] + 36] = mem[_2079 + 44 len 20]
                        mem[mem[64] + 68] = mem[_2079 + 76 len 20]
                        mem[mem[64] + 100] = mem[_2079 + 108 len 20]
                        mem[mem[64] + 132] = mem[_2079 + 128]
                        mem[mem[64] + 164] = mem[_2079 + 160]
                        mem[mem[64] + 196] = mem[_2265 + 12 len 20]
                        mem[mem[64] + 228] = mem[_2265 + 44 len 20]
                        mem[mem[64] + 260] = mem[_2265 + 76 len 20]
                        mem[mem[64] + 292] = mem[_2265 + 108 len 20]
                        mem[mem[64] + 324] = mem[_2265 + 128]
                        mem[mem[64] + 356] = mem[_2265 + 160]
                        require ext_code.size(stor3)
                        staticcall stor3.0x6fbc9807 with:
                                gas gas_remaining wei
                               args mem[mem[64] + 4 len 384]
                        mem[mem[64] len 64] = ext_call.return_data[0 len 64]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3020 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 64
                        require mem[_3020] == bool(mem[_3020])
                        _3141 = mem[_3020 + 32]
                        require mem[_3020 + 32] == mem[_3020 + 32]
                        if not mem[_3020]:
                            revert with 0, 'B'
                        if 0 >= mem[96]:
                            revert with 'NH{q', 50
                        _3234 = mem[mem[128]]
                        mem[mem[64] + 4] = 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                        require ext_code.size(address(_3234))
                        staticcall address(_3234).0x70a08231 with:
                                gas gas_remaining wei
                               args 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3480 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_3480] == mem[_3480]
                        if _3141 < mem[_3480]:
                            if _3141:
                                return _3141
                            return cd[4]
                        if not mem[_3480]:
                            return cd[4]
                        mem[mem[64]] = mem[_3480]
                    else:
                        if mem[96] != 3:
                            if 0 >= mem[96]:
                                revert with 'NH{q', 50
                            _2126 = mem[128]
                            if mem[96] < 1:
                                revert with 'NH{q', 17
                            if mem[96] - 1 >= mem[96]:
                                revert with 'NH{q', 50
                            _2319 = mem[(32 * mem[96] - 1) + 128]
                            mem[mem[64]] = 0x6fbc980700000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = mem[_2126 + 12 len 20]
                            mem[mem[64] + 36] = mem[_2126 + 44 len 20]
                            mem[mem[64] + 68] = mem[_2126 + 76 len 20]
                            mem[mem[64] + 100] = mem[_2126 + 108 len 20]
                            mem[mem[64] + 132] = mem[_2126 + 128]
                            mem[mem[64] + 164] = mem[_2126 + 160]
                            mem[mem[64] + 196] = mem[_2319 + 12 len 20]
                            mem[mem[64] + 228] = mem[_2319 + 44 len 20]
                            mem[mem[64] + 260] = mem[_2319 + 76 len 20]
                            mem[mem[64] + 292] = mem[_2319 + 108 len 20]
                            mem[mem[64] + 324] = mem[_2319 + 128]
                            mem[mem[64] + 356] = mem[_2319 + 160]
                            require ext_code.size(stor3)
                            staticcall stor3.0x6fbc9807 with:
                                    gas gas_remaining wei
                                   args mem[mem[64] + 4 len 384]
                            mem[mem[64] len 64] = ext_call.return_data[0 len 64]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3048 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 64
                            require mem[_3048] == bool(mem[_3048])
                            _3156 = mem[_3048 + 32]
                            require mem[_3048 + 32] == mem[_3048 + 32]
                            if not mem[_3048]:
                                revert with 0, 'B'
                            if 0 >= mem[96]:
                                revert with 'NH{q', 50
                            _3301 = mem[mem[128]]
                            mem[mem[64] + 4] = 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                            require ext_code.size(address(_3301))
                            staticcall address(_3301).0x70a08231 with:
                                    gas gas_remaining wei
                                   args 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3518 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_3518] == mem[_3518]
                            if _3156 < mem[_3518]:
                                if _3156:
                                    return _3156
                                return cd[4]
                            if not mem[_3518]:
                                return cd[4]
                            mem[mem[64]] = mem[_3518]
                        else:
                            mem[0] = mem[mem[128] + 44 len 20]
                            mem[32] = 1
                            if not stor1[mem[0]]:
                                return cd[4]
                            mem[0] = mem[mem[(32 * mem[96] - 1) + 128] + 12 len 20]
                            mem[32] = 1
                            if not stor1[mem[0]]:
                                return cd[4]
                            if 0 >= mem[96]:
                                revert with 'NH{q', 50
                            _2190 = mem[128]
                            if mem[96] < 1:
                                revert with 'NH{q', 17
                            if mem[96] - 1 >= mem[96]:
                                revert with 'NH{q', 50
                            _2412 = mem[(32 * mem[96] - 1) + 128]
                            mem[mem[64]] = 0x6fbc980700000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = mem[_2190 + 12 len 20]
                            mem[mem[64] + 36] = mem[_2190 + 44 len 20]
                            mem[mem[64] + 68] = mem[_2190 + 76 len 20]
                            mem[mem[64] + 100] = mem[_2190 + 108 len 20]
                            mem[mem[64] + 132] = mem[_2190 + 128]
                            mem[mem[64] + 164] = mem[_2190 + 160]
                            mem[mem[64] + 196] = mem[_2412 + 12 len 20]
                            mem[mem[64] + 228] = mem[_2412 + 44 len 20]
                            mem[mem[64] + 260] = mem[_2412 + 76 len 20]
                            mem[mem[64] + 292] = mem[_2412 + 108 len 20]
                            mem[mem[64] + 324] = mem[_2412 + 128]
                            mem[mem[64] + 356] = mem[_2412 + 160]
                            require ext_code.size(stor3)
                            staticcall stor3.0x6fbc9807 with:
                                    gas gas_remaining wei
                                   args mem[mem[64] + 4 len 384]
                            mem[mem[64] len 64] = ext_call.return_data[0 len 64]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3097 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 64
                            require mem[_3097] == bool(mem[_3097])
                            _3174 = mem[_3097 + 32]
                            require mem[_3097 + 32] == mem[_3097 + 32]
                            if not mem[_3097]:
                                revert with 0, 'B'
                            if 0 >= mem[96]:
                                revert with 'NH{q', 50
                            _3386 = mem[mem[128]]
                            mem[mem[64] + 4] = 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                            require ext_code.size(address(_3386))
                            staticcall address(_3386).0x70a08231 with:
                                    gas gas_remaining wei
                                   args 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3577 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_3577] == mem[_3577]
                            if _3174 < mem[_3577]:
                                if _3174:
                                    return _3174
                                return cd[4]
                            if not mem[_3577]:
                                return cd[4]
                            mem[mem[64]] = mem[_3577]
                else:
                    if mem[mem[(32 * mem[96] - 1) + 128] + 160] == 7:
                        if mem[96] == 2:
                            if 0 >= mem[96]:
                                revert with 'NH{q', 50
                            _2103 = mem[128]
                            if mem[96] < 1:
                                revert with 'NH{q', 17
                            if mem[96] - 1 >= mem[96]:
                                revert with 'NH{q', 50
                            _2290 = mem[(32 * mem[96] - 1) + 128]
                            mem[mem[64]] = 0x6fbc980700000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = mem[_2103 + 12 len 20]
                            mem[mem[64] + 36] = mem[_2103 + 44 len 20]
                            mem[mem[64] + 68] = mem[_2103 + 76 len 20]
                            mem[mem[64] + 100] = mem[_2103 + 108 len 20]
                            mem[mem[64] + 132] = mem[_2103 + 128]
                            mem[mem[64] + 164] = mem[_2103 + 160]
                            mem[mem[64] + 196] = mem[_2290 + 12 len 20]
                            mem[mem[64] + 228] = mem[_2290 + 44 len 20]
                            mem[mem[64] + 260] = mem[_2290 + 76 len 20]
                            mem[mem[64] + 292] = mem[_2290 + 108 len 20]
                            mem[mem[64] + 324] = mem[_2290 + 128]
                            mem[mem[64] + 356] = mem[_2290 + 160]
                            require ext_code.size(stor3)
                            staticcall stor3.0x6fbc9807 with:
                                    gas gas_remaining wei
                                   args mem[mem[64] + 4 len 384]
                            mem[mem[64] len 64] = ext_call.return_data[0 len 64]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3034 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 64
                            require mem[_3034] == bool(mem[_3034])
                            _3149 = mem[_3034 + 32]
                            require mem[_3034 + 32] == mem[_3034 + 32]
                            if not mem[_3034]:
                                revert with 0, 'B'
                            if 0 >= mem[96]:
                                revert with 'NH{q', 50
                            _3264 = mem[mem[128]]
                            mem[mem[64] + 4] = 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                            require ext_code.size(address(_3264))
                            staticcall address(_3264).0x70a08231 with:
                                    gas gas_remaining wei
                                   args 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3499 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_3499] == mem[_3499]
                            if _3149 < mem[_3499]:
                                if _3149:
                                    return _3149
                                return cd[4]
                            if not mem[_3499]:
                                return cd[4]
                            mem[mem[64]] = mem[_3499]
                        else:
                            if mem[96] != 3:
                                if 0 >= mem[96]:
                                    revert with 'NH{q', 50
                                _2148 = mem[128]
                                if mem[96] < 1:
                                    revert with 'NH{q', 17
                                if mem[96] - 1 >= mem[96]:
                                    revert with 'NH{q', 50
                                _2349 = mem[(32 * mem[96] - 1) + 128]
                                mem[mem[64]] = 0x6fbc980700000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = mem[_2148 + 12 len 20]
                                mem[mem[64] + 36] = mem[_2148 + 44 len 20]
                                mem[mem[64] + 68] = mem[_2148 + 76 len 20]
                                mem[mem[64] + 100] = mem[_2148 + 108 len 20]
                                mem[mem[64] + 132] = mem[_2148 + 128]
                                mem[mem[64] + 164] = mem[_2148 + 160]
                                mem[mem[64] + 196] = mem[_2349 + 12 len 20]
                                mem[mem[64] + 228] = mem[_2349 + 44 len 20]
                                mem[mem[64] + 260] = mem[_2349 + 76 len 20]
                                mem[mem[64] + 292] = mem[_2349 + 108 len 20]
                                mem[mem[64] + 324] = mem[_2349 + 128]
                                mem[mem[64] + 356] = mem[_2349 + 160]
                                require ext_code.size(stor3)
                                staticcall stor3.0x6fbc9807 with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len 384]
                                mem[mem[64] len 64] = ext_call.return_data[0 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3064 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 64
                                require mem[_3064] == bool(mem[_3064])
                                _3163 = mem[_3064 + 32]
                                require mem[_3064 + 32] == mem[_3064 + 32]
                                if not mem[_3064]:
                                    revert with 0, 'B'
                                if 0 >= mem[96]:
                                    revert with 'NH{q', 50
                                _3332 = mem[mem[128]]
                                mem[mem[64] + 4] = 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                                require ext_code.size(address(_3332))
                                staticcall address(_3332).0x70a08231 with:
                                        gas gas_remaining wei
                                       args 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3538 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_3538] == mem[_3538]
                                if _3163 < mem[_3538]:
                                    if _3163:
                                        return _3163
                                    return cd[4]
                                if not mem[_3538]:
                                    return cd[4]
                                mem[mem[64]] = mem[_3538]
                            else:
                                mem[0] = mem[mem[128] + 44 len 20]
                                mem[32] = 1
                                if not stor1[mem[0]]:
                                    return cd[4]
                                mem[0] = mem[mem[(32 * mem[96] - 1) + 128] + 12 len 20]
                                mem[32] = 1
                                if not stor1[mem[0]]:
                                    return cd[4]
                                if 0 >= mem[96]:
                                    revert with 'NH{q', 50
                                _2212 = mem[128]
                                if mem[96] < 1:
                                    revert with 'NH{q', 17
                                if mem[96] - 1 >= mem[96]:
                                    revert with 'NH{q', 50
                                _2434 = mem[(32 * mem[96] - 1) + 128]
                                mem[mem[64]] = 0x6fbc980700000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = mem[_2212 + 12 len 20]
                                mem[mem[64] + 36] = mem[_2212 + 44 len 20]
                                mem[mem[64] + 68] = mem[_2212 + 76 len 20]
                                mem[mem[64] + 100] = mem[_2212 + 108 len 20]
                                mem[mem[64] + 132] = mem[_2212 + 128]
                                mem[mem[64] + 164] = mem[_2212 + 160]
                                mem[mem[64] + 196] = mem[_2434 + 12 len 20]
                                mem[mem[64] + 228] = mem[_2434 + 44 len 20]
                                mem[mem[64] + 260] = mem[_2434 + 76 len 20]
                                mem[mem[64] + 292] = mem[_2434 + 108 len 20]
                                mem[mem[64] + 324] = mem[_2434 + 128]
                                mem[mem[64] + 356] = mem[_2434 + 160]
                                require ext_code.size(stor3)
                                staticcall stor3.0x6fbc9807 with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len 384]
                                mem[mem[64] len 64] = ext_call.return_data[0 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3110 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 64
                                require mem[_3110] == bool(mem[_3110])
                                _3180 = mem[_3110 + 32]
                                require mem[_3110 + 32] == mem[_3110 + 32]
                                if not mem[_3110]:
                                    revert with 0, 'B'
                                if 0 >= mem[96]:
                                    revert with 'NH{q', 50
                                _3407 = mem[mem[128]]
                                mem[mem[64] + 4] = 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                                require ext_code.size(address(_3407))
                                staticcall address(_3407).0x70a08231 with:
                                        gas gas_remaining wei
                                       args 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3590 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_3590] == mem[_3590]
                                if _3180 < mem[_3590]:
                                    if _3180:
                                        return _3180
                                    return cd[4]
                                if not mem[_3590]:
                                    return cd[4]
                                mem[mem[64]] = mem[_3590]
                    else:
                        if mem[mem[(32 * mem[96] - 1) + 128] + 160] == 13:
                            if mem[96] == 2:
                                if 0 >= mem[96]:
                                    revert with 'NH{q', 50
                                _2123 = mem[128]
                                if mem[96] < 1:
                                    revert with 'NH{q', 17
                                if mem[96] - 1 >= mem[96]:
                                    revert with 'NH{q', 50
                                _2316 = mem[(32 * mem[96] - 1) + 128]
                                mem[mem[64]] = 0x6fbc980700000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = mem[_2123 + 12 len 20]
                                mem[mem[64] + 36] = mem[_2123 + 44 len 20]
                                mem[mem[64] + 68] = mem[_2123 + 76 len 20]
                                mem[mem[64] + 100] = mem[_2123 + 108 len 20]
                                mem[mem[64] + 132] = mem[_2123 + 128]
                                mem[mem[64] + 164] = mem[_2123 + 160]
                                mem[mem[64] + 196] = mem[_2316 + 12 len 20]
                                mem[mem[64] + 228] = mem[_2316 + 44 len 20]
                                mem[mem[64] + 260] = mem[_2316 + 76 len 20]
                                mem[mem[64] + 292] = mem[_2316 + 108 len 20]
                                mem[mem[64] + 324] = mem[_2316 + 128]
                                mem[mem[64] + 356] = mem[_2316 + 160]
                                require ext_code.size(stor3)
                                staticcall stor3.0x6fbc9807 with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len 384]
                                mem[mem[64] len 64] = ext_call.return_data[0 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3047 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 64
                                require mem[_3047] == bool(mem[_3047])
                                _3155 = mem[_3047 + 32]
                                require mem[_3047 + 32] == mem[_3047 + 32]
                                if not mem[_3047]:
                                    revert with 0, 'B'
                                if 0 >= mem[96]:
                                    revert with 'NH{q', 50
                                _3296 = mem[mem[128]]
                                mem[mem[64] + 4] = 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                                require ext_code.size(address(_3296))
                                staticcall address(_3296).0x70a08231 with:
                                        gas gas_remaining wei
                                       args 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3517 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_3517] == mem[_3517]
                                if _3155 < mem[_3517]:
                                    if _3155:
                                        return _3155
                                    return cd[4]
                                if not mem[_3517]:
                                    return cd[4]
                                mem[mem[64]] = mem[_3517]
                            else:
                                if mem[96] != 3:
                                    if 0 >= mem[96]:
                                        revert with 'NH{q', 50
                                    _2166 = mem[128]
                                    if mem[96] < 1:
                                        revert with 'NH{q', 17
                                    if mem[96] - 1 >= mem[96]:
                                        revert with 'NH{q', 50
                                    _2377 = mem[(32 * mem[96] - 1) + 128]
                                    mem[mem[64]] = 0x6fbc980700000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = mem[_2166 + 12 len 20]
                                    mem[mem[64] + 36] = mem[_2166 + 44 len 20]
                                    mem[mem[64] + 68] = mem[_2166 + 76 len 20]
                                    mem[mem[64] + 100] = mem[_2166 + 108 len 20]
                                    mem[mem[64] + 132] = mem[_2166 + 128]
                                    mem[mem[64] + 164] = mem[_2166 + 160]
                                    mem[mem[64] + 196] = mem[_2377 + 12 len 20]
                                    mem[mem[64] + 228] = mem[_2377 + 44 len 20]
                                    mem[mem[64] + 260] = mem[_2377 + 76 len 20]
                                    mem[mem[64] + 292] = mem[_2377 + 108 len 20]
                                    mem[mem[64] + 324] = mem[_2377 + 128]
                                    mem[mem[64] + 356] = mem[_2377 + 160]
                                    require ext_code.size(stor3)
                                    staticcall stor3.0x6fbc9807 with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4 len 384]
                                    mem[mem[64] len 64] = ext_call.return_data[0 len 64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _3079 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 64
                                    require mem[_3079] == bool(mem[_3079])
                                    _3168 = mem[_3079 + 32]
                                    require mem[_3079 + 32] == mem[_3079 + 32]
                                    if not mem[_3079]:
                                        revert with 0, 'B'
                                    if 0 >= mem[96]:
                                        revert with 'NH{q', 50
                                    _3357 = mem[mem[128]]
                                    mem[mem[64] + 4] = 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                                    require ext_code.size(address(_3357))
                                    staticcall address(_3357).0x70a08231 with:
                                            gas gas_remaining wei
                                           args 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _3556 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_3556] == mem[_3556]
                                    if _3168 < mem[_3556]:
                                        if _3168:
                                            return _3168
                                        return cd[4]
                                    if not mem[_3556]:
                                        return cd[4]
                                    mem[mem[64]] = mem[_3556]
                                else:
                                    mem[0] = mem[mem[128] + 44 len 20]
                                    mem[32] = 1
                                    if not stor1[mem[0]]:
                                        return cd[4]
                                    mem[0] = mem[mem[(32 * mem[96] - 1) + 128] + 12 len 20]
                                    mem[32] = 1
                                    if not stor1[mem[0]]:
                                        return cd[4]
                                    if 0 >= mem[96]:
                                        revert with 'NH{q', 50
                                    _2236 = mem[128]
                                    if mem[96] < 1:
                                        revert with 'NH{q', 17
                                    if mem[96] - 1 >= mem[96]:
                                        revert with 'NH{q', 50
                                    _2451 = mem[(32 * mem[96] - 1) + 128]
                                    mem[mem[64]] = 0x6fbc980700000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = mem[_2236 + 12 len 20]
                                    mem[mem[64] + 36] = mem[_2236 + 44 len 20]
                                    mem[mem[64] + 68] = mem[_2236 + 76 len 20]
                                    mem[mem[64] + 100] = mem[_2236 + 108 len 20]
                                    mem[mem[64] + 132] = mem[_2236 + 128]
                                    mem[mem[64] + 164] = mem[_2236 + 160]
                                    mem[mem[64] + 196] = mem[_2451 + 12 len 20]
                                    mem[mem[64] + 228] = mem[_2451 + 44 len 20]
                                    mem[mem[64] + 260] = mem[_2451 + 76 len 20]
                                    mem[mem[64] + 292] = mem[_2451 + 108 len 20]
                                    mem[mem[64] + 324] = mem[_2451 + 128]
                                    mem[mem[64] + 356] = mem[_2451 + 160]
                                    require ext_code.size(stor3)
                                    staticcall stor3.0x6fbc9807 with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4 len 384]
                                    mem[mem[64] len 64] = ext_call.return_data[0 len 64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _3118 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 64
                                    require mem[_3118] == bool(mem[_3118])
                                    _3190 = mem[_3118 + 32]
                                    require mem[_3118 + 32] == mem[_3118 + 32]
                                    if not mem[_3118]:
                                        revert with 0, 'B'
                                    if 0 >= mem[96]:
                                        revert with 'NH{q', 50
                                    _3426 = mem[mem[128]]
                                    mem[mem[64] + 4] = 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                                    require ext_code.size(address(_3426))
                                    staticcall address(_3426).0x70a08231 with:
                                            gas gas_remaining wei
                                           args 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _3598 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_3598] == mem[_3598]
                                    if _3190 < mem[_3598]:
                                        if _3190:
                                            return _3190
                                        return cd[4]
                                    if not mem[_3598]:
                                        return cd[4]
                                    mem[mem[64]] = mem[_3598]
                        else:
                            if mem[mem[(32 * mem[96] - 1) + 128] + 160] != 14:
                                return cd[4]
                            if mem[96] == 2:
                                if 0 >= mem[96]:
                                    revert with 'NH{q', 50
                                _2145 = mem[128]
                                if mem[96] < 1:
                                    revert with 'NH{q', 17
                                if mem[96] - 1 >= mem[96]:
                                    revert with 'NH{q', 50
                                _2346 = mem[(32 * mem[96] - 1) + 128]
                                mem[mem[64]] = 0x6fbc980700000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = mem[_2145 + 12 len 20]
                                mem[mem[64] + 36] = mem[_2145 + 44 len 20]
                                mem[mem[64] + 68] = mem[_2145 + 76 len 20]
                                mem[mem[64] + 100] = mem[_2145 + 108 len 20]
                                mem[mem[64] + 132] = mem[_2145 + 128]
                                mem[mem[64] + 164] = mem[_2145 + 160]
                                mem[mem[64] + 196] = mem[_2346 + 12 len 20]
                                mem[mem[64] + 228] = mem[_2346 + 44 len 20]
                                mem[mem[64] + 260] = mem[_2346 + 76 len 20]
                                mem[mem[64] + 292] = mem[_2346 + 108 len 20]
                                mem[mem[64] + 324] = mem[_2346 + 128]
                                mem[mem[64] + 356] = mem[_2346 + 160]
                                require ext_code.size(stor3)
                                staticcall stor3.0x6fbc9807 with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len 384]
                                mem[mem[64] len 64] = ext_call.return_data[0 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3063 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 64
                                require mem[_3063] == bool(mem[_3063])
                                _3162 = mem[_3063 + 32]
                                require mem[_3063 + 32] == mem[_3063 + 32]
                                if not mem[_3063]:
                                    revert with 0, 'B'
                                if 0 >= mem[96]:
                                    revert with 'NH{q', 50
                                _3327 = mem[mem[128]]
                                mem[mem[64] + 4] = 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                                require ext_code.size(address(_3327))
                                staticcall address(_3327).0x70a08231 with:
                                        gas gas_remaining wei
                                       args 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3537 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_3537] == mem[_3537]
                                if _3162 < mem[_3537]:
                                    if _3162:
                                        return _3162
                                    return cd[4]
                                if not mem[_3537]:
                                    return cd[4]
                                mem[mem[64]] = mem[_3537]
                            else:
                                if mem[96] != 3:
                                    if 0 >= mem[96]:
                                        revert with 'NH{q', 50
                                    _2186 = mem[128]
                                    if mem[96] < 1:
                                        revert with 'NH{q', 17
                                    if mem[96] - 1 >= mem[96]:
                                        revert with 'NH{q', 50
                                    _2405 = mem[(32 * mem[96] - 1) + 128]
                                    mem[mem[64]] = 0x6fbc980700000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = mem[_2186 + 12 len 20]
                                    mem[mem[64] + 36] = mem[_2186 + 44 len 20]
                                    mem[mem[64] + 68] = mem[_2186 + 76 len 20]
                                    mem[mem[64] + 100] = mem[_2186 + 108 len 20]
                                    mem[mem[64] + 132] = mem[_2186 + 128]
                                    mem[mem[64] + 164] = mem[_2186 + 160]
                                    mem[mem[64] + 196] = mem[_2405 + 12 len 20]
                                    mem[mem[64] + 228] = mem[_2405 + 44 len 20]
                                    mem[mem[64] + 260] = mem[_2405 + 76 len 20]
                                    mem[mem[64] + 292] = mem[_2405 + 108 len 20]
                                    mem[mem[64] + 324] = mem[_2405 + 128]
                                    mem[mem[64] + 356] = mem[_2405 + 160]
                                    require ext_code.size(stor3)
                                    staticcall stor3.0x6fbc9807 with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4 len 384]
                                    mem[mem[64] len 64] = ext_call.return_data[0 len 64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _3093 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 64
                                    require mem[_3093] == bool(mem[_3093])
                                    _3173 = mem[_3093 + 32]
                                    require mem[_3093 + 32] == mem[_3093 + 32]
                                    if not mem[_3093]:
                                        revert with 0, 'B'
                                    if 0 >= mem[96]:
                                        revert with 'NH{q', 50
                                    _3381 = mem[mem[128]]
                                    mem[mem[64] + 4] = 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                                    require ext_code.size(address(_3381))
                                    staticcall address(_3381).0x70a08231 with:
                                            gas gas_remaining wei
                                           args 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _3572 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_3572] == mem[_3572]
                                    if _3173 < mem[_3572]:
                                        if _3173:
                                            return _3173
                                        return cd[4]
                                    if not mem[_3572]:
                                        return cd[4]
                                    mem[mem[64]] = mem[_3572]
                                else:
                                    mem[0] = mem[mem[128] + 44 len 20]
                                    mem[32] = 1
                                    if not stor1[mem[0]]:
                                        return cd[4]
                                    mem[0] = mem[mem[(32 * mem[96] - 1) + 128] + 12 len 20]
                                    mem[32] = 1
                                    if not stor1[mem[0]]:
                                        return cd[4]
                                    if 0 >= mem[96]:
                                        revert with 'NH{q', 50
                                    _2261 = mem[128]
                                    if mem[96] < 1:
                                        revert with 'NH{q', 17
                                    if mem[96] - 1 >= mem[96]:
                                        revert with 'NH{q', 50
                                    _2463 = mem[(32 * mem[96] - 1) + 128]
                                    mem[mem[64]] = 0x6fbc980700000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = mem[_2261 + 12 len 20]
                                    mem[mem[64] + 36] = mem[_2261 + 44 len 20]
                                    mem[mem[64] + 68] = mem[_2261 + 76 len 20]
                                    mem[mem[64] + 100] = mem[_2261 + 108 len 20]
                                    mem[mem[64] + 132] = mem[_2261 + 128]
                                    mem[mem[64] + 164] = mem[_2261 + 160]
                                    mem[mem[64] + 196] = mem[_2463 + 12 len 20]
                                    mem[mem[64] + 228] = mem[_2463 + 44 len 20]
                                    mem[mem[64] + 260] = mem[_2463 + 76 len 20]
                                    mem[mem[64] + 292] = mem[_2463 + 108 len 20]
                                    mem[mem[64] + 324] = mem[_2463 + 128]
                                    mem[mem[64] + 356] = mem[_2463 + 160]
                                    require ext_code.size(stor3)
                                    staticcall stor3.0x6fbc9807 with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4 len 384]
                                    mem[mem[64] len 64] = ext_call.return_data[0 len 64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _3126 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 64
                                    require mem[_3126] == bool(mem[_3126])
                                    _3206 = mem[_3126 + 32]
                                    require mem[_3126 + 32] == mem[_3126 + 32]
                                    if not mem[_3126]:
                                        revert with 0, 'B'
                                    if 0 >= mem[96]:
                                        revert with 'NH{q', 50
                                    _3443 = mem[mem[128]]
                                    mem[mem[64] + 4] = 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                                    require ext_code.size(address(_3443))
                                    staticcall address(_3443).0x70a08231 with:
                                            gas gas_remaining wei
                                           args 0x85a92368ab710a85f57b9872c0fe4361a405e5d
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _3605 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_3605] == mem[_3605]
                                    if _3206 < mem[_3605]:
                                        if _3206:
                                            return _3206
                                        return cd[4]
                                    if not mem[_3605]:
                                        return cd[4]
                                    mem[mem[64]] = mem[_3605]
    return memory
      from mem[64]
       len 32
}

function sub_407045a8(?) {
    require calldata.size - 4 >= 64
    require cd[4] == cd[4]
    require cd[36] <= test266151307()
    require cd[36] + 35 < calldata.size
    if ('cd', 36).length > test266151307():
        revert with 'NH{q', 65
    if floor32(('cd', 36).length) + 97 > test266151307() or floor32(('cd', 36).length) + 97 < 96:
        revert with 'NH{q', 65
    mem[64] = floor32(('cd', 36).length) + 97
    mem[96] = ('cd', 36).length
    require cd[36] + (192 * ('cd', 36).length) + 36 <= calldata.size
    idx = 0
    s = cd[36] + 36
    t = 128
    while idx < ('cd', 36).length:
        require calldata.size - s >= 192
        _4132 = mem[64]
        if mem[64] + 192 > test266151307() or mem[64] + 192 < mem[64]:
            revert with 'NH{q', 65
        mem[64] = mem[64] + 192
        require cd[s] == address(cd[s])
        mem[_4132] = cd[s]
        require cd[(s + 32)] == address(cd[(s + 32)])
        mem[_4132 + 32] = cd[(s + 32)]
        require cd[(s + 64)] == address(cd[(s + 64)])
        mem[_4132 + 64] = cd[(s + 64)]
        require cd[(s + 96)] == address(cd[(s + 96)])
        mem[_4132 + 96] = cd[(s + 96)]
        require cd[(s + 128)] == cd[(s + 128)]
        mem[_4132 + 128] = cd[(s + 128)]
        require cd[(s + 160)] == cd[(s + 160)]
        mem[_4132 + 160] = cd[(s + 160)]
        mem[t] = _4132
        idx = idx + 1
        s = s + 192
        t = t + 32
        continue 
    _4131 = mem[96]
    if mem[96] > -2:
        revert with 'NH{q', 17
    if mem[96] + 1 > test266151307():
        revert with 'NH{q', 65
    _4133 = mem[64]
    mem[mem[64]] = mem[96] + 1
    mem[64] = mem[64] + (32 * _4131 + 1) + 32
    if not _4131 + 1:
        if 0 >= mem[_4133]:
            revert with 'NH{q', 50
        mem[_4133 + 32] = cd[4]
        _8260 = mem[96]
        idx = 0
        while idx < _8260:
            if idx >= mem[96]:
                revert with 'NH{q', 50
            _8265 = mem[(32 * idx) + 128]
            if mem[mem[(32 * idx) + 128] + 160] == 1:
                _8272 = mem[mem[(32 * idx) + 128]]
                _8273 = mem[mem[(32 * idx) + 128] + 32]
                if mem[mem[(32 * idx) + 128] + 12 len 20] < mem[mem[(32 * idx) + 128] + 44 len 20]:
                    _8278 = mem[mem[(32 * idx) + 128] + 64]
                    _8282 = mem[64]
                    _8283 = mem[64]
                    mem[mem[64]] = 4
                    mem[64] = mem[64] + 36
                    mem[_8283 + 32] = mem[_8283 + 36 len 28] or 0x902f1ac00000000000000000000000000000000000000000000000000000000
                    _8319 = mem[_8283]
                    s = 0
                    while s < _8319:
                        mem[_8282 + s + 36] = mem[_8283 + s + 32]
                        _8260 = mem[96]
                        s = s + 32
                        continue 
                    if ceil32(_8319) <= _8319:
                        staticcall address(_8278).mem[mem[64] len 4] with:
                                gas gas_remaining wei
                               args mem[mem[64] + 4 len _8282 + _8319 + -mem[64] + 32]
                        if not return_data.size:
                            if idx >= mem[_4133]:
                                revert with 'NH{q', 50
                            if mem[(32 * idx) + _4133 + 32] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                            if mem[_8265 + 12 len 20] == address(_8272):
                                if mem[128] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[160] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 10000 < mem[_8265 + 128]:
                                    revert with 'NH{q', 17
                                if not -mem[_8265 + 128] + 10000:
                                    if mem[160]:
                                        if False and mem[160] > 0:
                                            revert with 'NH{q', 17
                                        if not mem[160]:
                                            revert with 'NH{q', 18
                                        if 0 / mem[160]:
                                            revert with 0, 'ds-math-mul-overflow'
                                    if mem[128] and 10000 > -1 / mem[128]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[128] / 10000 != mem[128]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[128] > -1:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[128] < 10000 * mem[128]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not 10000 * mem[128]:
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4133]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4133 + 32] = 0 / 10000 * mem[128]
                                else:
                                    if mem[(32 * idx) + _4133 + 32] and -mem[_8265 + 128] + 10000 > -1 / mem[(32 * idx) + _4133 + 32]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8265 + 128] + 10000:
                                        revert with 'NH{q', 18
                                    if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) / -mem[_8265 + 128] + 10000 != mem[(32 * idx) + _4133 + 32]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if not mem[160]:
                                        if mem[128] and 10000 > -1 / mem[128]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[128] / 10000 != mem[128]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[128] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[128]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4133]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4133 + 32] = 0 / (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32])
                                    else:
                                        if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) and mem[160] > -1 / (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 'NH{q', 17
                                        if not mem[160]:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4133 + 32] * mem[160]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32] * mem[160]) / mem[160] != (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 0, 'ds-math-mul-overflow'
                                        if mem[128] and 10000 > -1 / mem[128]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[128] / 10000 != mem[128]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[128] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[128]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4133]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4133 + 32] = (10000 * mem[(32 * idx) + _4133 + 32] * mem[160]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32] * mem[160]) / (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32])
                            else:
                                if mem[160] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[128] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 10000 < mem[_8265 + 128]:
                                    revert with 'NH{q', 17
                                if not -mem[_8265 + 128] + 10000:
                                    if mem[128]:
                                        if False and mem[128] > 0:
                                            revert with 'NH{q', 17
                                        if not mem[128]:
                                            revert with 'NH{q', 18
                                        if 0 / mem[128]:
                                            revert with 0, 'ds-math-mul-overflow'
                                    if mem[160] and 10000 > -1 / mem[160]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[160] / 10000 != mem[160]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[160] > -1:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[160] < 10000 * mem[160]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not 10000 * mem[160]:
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4133]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4133 + 32] = 0 / 10000 * mem[160]
                                else:
                                    if mem[(32 * idx) + _4133 + 32] and -mem[_8265 + 128] + 10000 > -1 / mem[(32 * idx) + _4133 + 32]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8265 + 128] + 10000:
                                        revert with 'NH{q', 18
                                    if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) / -mem[_8265 + 128] + 10000 != mem[(32 * idx) + _4133 + 32]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if not mem[128]:
                                        if mem[160] and 10000 > -1 / mem[160]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[160] / 10000 != mem[160]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[160] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[160]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4133]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4133 + 32] = 0 / (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32])
                                    else:
                                        if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) and mem[128] > -1 / (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 'NH{q', 17
                                        if not mem[128]:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4133 + 32] * mem[128]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32] * mem[128]) / mem[128] != (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 0, 'ds-math-mul-overflow'
                                        if mem[160] and 10000 > -1 / mem[160]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[160] / 10000 != mem[160]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[160] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[160]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4133]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4133 + 32] = (10000 * mem[(32 * idx) + _4133 + 32] * mem[128]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32] * mem[128]) / (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32])
                        else:
                            _12418 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                            mem[_12418] = return_data.size
                            mem[_12418 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if idx >= mem[_4133]:
                                revert with 'NH{q', 50
                            if mem[(32 * idx) + _4133 + 32] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                            if mem[_8265 + 12 len 20] == address(_8272):
                                if mem[_12418 + 32] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[_12418 + 64] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 10000 < mem[_8265 + 128]:
                                    revert with 'NH{q', 17
                                if not -mem[_8265 + 128] + 10000:
                                    if mem[_12418 + 64]:
                                        if False and mem[_12418 + 64] > 0:
                                            revert with 'NH{q', 17
                                        if not mem[_12418 + 64]:
                                            revert with 'NH{q', 18
                                        if 0 / mem[_12418 + 64]:
                                            revert with 0, 'ds-math-mul-overflow'
                                    if mem[_12418 + 32] and 10000 > -1 / mem[_12418 + 32]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[_12418 + 32] / 10000 != mem[_12418 + 32]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[_12418 + 32] > -1:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[_12418 + 32] < 10000 * mem[_12418 + 32]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not 10000 * mem[_12418 + 32]:
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4133]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4133 + 32] = 0 / 10000 * mem[_12418 + 32]
                                else:
                                    if mem[(32 * idx) + _4133 + 32] and -mem[_8265 + 128] + 10000 > -1 / mem[(32 * idx) + _4133 + 32]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8265 + 128] + 10000:
                                        revert with 'NH{q', 18
                                    if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) / -mem[_8265 + 128] + 10000 != mem[(32 * idx) + _4133 + 32]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if not mem[_12418 + 64]:
                                        if mem[_12418 + 32] and 10000 > -1 / mem[_12418 + 32]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12418 + 32] / 10000 != mem[_12418 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[_12418 + 32] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[_12418 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[_12418 + 32]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[_12418 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4133]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4133 + 32] = 0 / (10000 * mem[_12418 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32])
                                    else:
                                        if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) and mem[_12418 + 64] > -1 / (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 'NH{q', 17
                                        if not mem[_12418 + 64]:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4133 + 32] * mem[_12418 + 64]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32] * mem[_12418 + 64]) / mem[_12418 + 64] != (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 0, 'ds-math-mul-overflow'
                                        if mem[_12418 + 32] and 10000 > -1 / mem[_12418 + 32]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12418 + 32] / 10000 != mem[_12418 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[_12418 + 32] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[_12418 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[_12418 + 32]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[_12418 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4133]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4133 + 32] = (10000 * mem[(32 * idx) + _4133 + 32] * mem[_12418 + 64]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32] * mem[_12418 + 64]) / (10000 * mem[_12418 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32])
                            else:
                                if mem[_12418 + 64] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[_12418 + 32] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 10000 < mem[_8265 + 128]:
                                    revert with 'NH{q', 17
                                if not -mem[_8265 + 128] + 10000:
                                    if mem[_12418 + 32]:
                                        if False and mem[_12418 + 32] > 0:
                                            revert with 'NH{q', 17
                                        if not mem[_12418 + 32]:
                                            revert with 'NH{q', 18
                                        if 0 / mem[_12418 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                    if mem[_12418 + 64] and 10000 > -1 / mem[_12418 + 64]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[_12418 + 64] / 10000 != mem[_12418 + 64]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[_12418 + 64] > -1:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[_12418 + 64] < 10000 * mem[_12418 + 64]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not 10000 * mem[_12418 + 64]:
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4133]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4133 + 32] = 0 / 10000 * mem[_12418 + 64]
                                else:
                                    if mem[(32 * idx) + _4133 + 32] and -mem[_8265 + 128] + 10000 > -1 / mem[(32 * idx) + _4133 + 32]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8265 + 128] + 10000:
                                        revert with 'NH{q', 18
                                    if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) / -mem[_8265 + 128] + 10000 != mem[(32 * idx) + _4133 + 32]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if not mem[_12418 + 32]:
                                        if mem[_12418 + 64] and 10000 > -1 / mem[_12418 + 64]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12418 + 64] / 10000 != mem[_12418 + 64]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[_12418 + 64] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[_12418 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[_12418 + 64]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[_12418 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4133]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4133 + 32] = 0 / (10000 * mem[_12418 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32])
                                    else:
                                        if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) and mem[_12418 + 32] > -1 / (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 'NH{q', 17
                                        if not mem[_12418 + 32]:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4133 + 32] * mem[_12418 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32] * mem[_12418 + 32]) / mem[_12418 + 32] != (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 0, 'ds-math-mul-overflow'
                                        if mem[_12418 + 64] and 10000 > -1 / mem[_12418 + 64]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12418 + 64] / 10000 != mem[_12418 + 64]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[_12418 + 64] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[_12418 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[_12418 + 64]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[_12418 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4133]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4133 + 32] = (10000 * mem[(32 * idx) + _4133 + 32] * mem[_12418 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32] * mem[_12418 + 32]) / (10000 * mem[_12418 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32])
                    else:
                        mem[_8282 + _8319 + 36] = 0
                        staticcall address(_8278).mem[mem[64] len 4] with:
                                gas gas_remaining wei
                               args mem[mem[64] + 4 len _8282 + _8319 + -mem[64] + 32]
                        if not return_data.size:
                            if idx >= mem[_4133]:
                                revert with 'NH{q', 50
                            if mem[(32 * idx) + _4133 + 32] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                            if mem[_8265 + 12 len 20] == address(_8272):
                                if mem[128] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[160] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 10000 < mem[_8265 + 128]:
                                    revert with 'NH{q', 17
                                if not -mem[_8265 + 128] + 10000:
                                    if mem[160]:
                                        if False and mem[160] > 0:
                                            revert with 'NH{q', 17
                                        if not mem[160]:
                                            revert with 'NH{q', 18
                                        if 0 / mem[160]:
                                            revert with 0, 'ds-math-mul-overflow'
                                    if mem[128] and 10000 > -1 / mem[128]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[128] / 10000 != mem[128]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[128] > -1:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[128] < 10000 * mem[128]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not 10000 * mem[128]:
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4133]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4133 + 32] = 0 / 10000 * mem[128]
                                else:
                                    if mem[(32 * idx) + _4133 + 32] and -mem[_8265 + 128] + 10000 > -1 / mem[(32 * idx) + _4133 + 32]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8265 + 128] + 10000:
                                        revert with 'NH{q', 18
                                    if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) / -mem[_8265 + 128] + 10000 != mem[(32 * idx) + _4133 + 32]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if not mem[160]:
                                        if mem[128] and 10000 > -1 / mem[128]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[128] / 10000 != mem[128]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[128] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[128]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4133]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4133 + 32] = 0 / (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32])
                                    else:
                                        if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) and mem[160] > -1 / (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 'NH{q', 17
                                        if not mem[160]:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4133 + 32] * mem[160]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32] * mem[160]) / mem[160] != (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 0, 'ds-math-mul-overflow'
                                        if mem[128] and 10000 > -1 / mem[128]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[128] / 10000 != mem[128]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[128] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[128]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4133]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4133 + 32] = (10000 * mem[(32 * idx) + _4133 + 32] * mem[160]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32] * mem[160]) / (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32])
                            else:
                                if mem[160] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[128] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 10000 < mem[_8265 + 128]:
                                    revert with 'NH{q', 17
                                if not -mem[_8265 + 128] + 10000:
                                    if mem[128]:
                                        if False and mem[128] > 0:
                                            revert with 'NH{q', 17
                                        if not mem[128]:
                                            revert with 'NH{q', 18
                                        if 0 / mem[128]:
                                            revert with 0, 'ds-math-mul-overflow'
                                    if mem[160] and 10000 > -1 / mem[160]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[160] / 10000 != mem[160]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[160] > -1:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[160] < 10000 * mem[160]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not 10000 * mem[160]:
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4133]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4133 + 32] = 0 / 10000 * mem[160]
                                else:
                                    if mem[(32 * idx) + _4133 + 32] and -mem[_8265 + 128] + 10000 > -1 / mem[(32 * idx) + _4133 + 32]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8265 + 128] + 10000:
                                        revert with 'NH{q', 18
                                    if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) / -mem[_8265 + 128] + 10000 != mem[(32 * idx) + _4133 + 32]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if not mem[128]:
                                        if mem[160] and 10000 > -1 / mem[160]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[160] / 10000 != mem[160]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[160] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[160]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4133]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4133 + 32] = 0 / (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32])
                                    else:
                                        if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) and mem[128] > -1 / (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 'NH{q', 17
                                        if not mem[128]:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4133 + 32] * mem[128]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32] * mem[128]) / mem[128] != (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 0, 'ds-math-mul-overflow'
                                        if mem[160] and 10000 > -1 / mem[160]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[160] / 10000 != mem[160]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[160] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[160]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4133]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4133 + 32] = (10000 * mem[(32 * idx) + _4133 + 32] * mem[128]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32] * mem[128]) / (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32])
                        else:
                            _12446 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                            mem[_12446] = return_data.size
                            mem[_12446 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if idx >= mem[_4133]:
                                revert with 'NH{q', 50
                            if mem[(32 * idx) + _4133 + 32] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                            if mem[_8265 + 12 len 20] == address(_8272):
                                if mem[_12446 + 32] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[_12446 + 64] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 10000 < mem[_8265 + 128]:
                                    revert with 'NH{q', 17
                                if not -mem[_8265 + 128] + 10000:
                                    if mem[_12446 + 64]:
                                        if False and mem[_12446 + 64] > 0:
                                            revert with 'NH{q', 17
                                        if not mem[_12446 + 64]:
                                            revert with 'NH{q', 18
                                        if 0 / mem[_12446 + 64]:
                                            revert with 0, 'ds-math-mul-overflow'
                                    if mem[_12446 + 32] and 10000 > -1 / mem[_12446 + 32]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[_12446 + 32] / 10000 != mem[_12446 + 32]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[_12446 + 32] > -1:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[_12446 + 32] < 10000 * mem[_12446 + 32]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not 10000 * mem[_12446 + 32]:
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4133]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4133 + 32] = 0 / 10000 * mem[_12446 + 32]
                                else:
                                    if mem[(32 * idx) + _4133 + 32] and -mem[_8265 + 128] + 10000 > -1 / mem[(32 * idx) + _4133 + 32]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8265 + 128] + 10000:
                                        revert with 'NH{q', 18
                                    if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) / -mem[_8265 + 128] + 10000 != mem[(32 * idx) + _4133 + 32]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if not mem[_12446 + 64]:
                                        if mem[_12446 + 32] and 10000 > -1 / mem[_12446 + 32]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12446 + 32] / 10000 != mem[_12446 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[_12446 + 32] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[_12446 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[_12446 + 32]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[_12446 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4133]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4133 + 32] = 0 / (10000 * mem[_12446 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32])
                                    else:
                                        if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) and mem[_12446 + 64] > -1 / (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 'NH{q', 17
                                        if not mem[_12446 + 64]:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4133 + 32] * mem[_12446 + 64]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32] * mem[_12446 + 64]) / mem[_12446 + 64] != (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 0, 'ds-math-mul-overflow'
                                        if mem[_12446 + 32] and 10000 > -1 / mem[_12446 + 32]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12446 + 32] / 10000 != mem[_12446 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[_12446 + 32] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[_12446 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[_12446 + 32]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[_12446 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4133]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4133 + 32] = (10000 * mem[(32 * idx) + _4133 + 32] * mem[_12446 + 64]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32] * mem[_12446 + 64]) / (10000 * mem[_12446 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32])
                            else:
                                if mem[_12446 + 64] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[_12446 + 32] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 10000 < mem[_8265 + 128]:
                                    revert with 'NH{q', 17
                                if not -mem[_8265 + 128] + 10000:
                                    if mem[_12446 + 32]:
                                        if False and mem[_12446 + 32] > 0:
                                            revert with 'NH{q', 17
                                        if not mem[_12446 + 32]:
                                            revert with 'NH{q', 18
                                        if 0 / mem[_12446 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                    if mem[_12446 + 64] and 10000 > -1 / mem[_12446 + 64]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[_12446 + 64] / 10000 != mem[_12446 + 64]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[_12446 + 64] > -1:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[_12446 + 64] < 10000 * mem[_12446 + 64]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not 10000 * mem[_12446 + 64]:
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4133]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4133 + 32] = 0 / 10000 * mem[_12446 + 64]
                                else:
                                    if mem[(32 * idx) + _4133 + 32] and -mem[_8265 + 128] + 10000 > -1 / mem[(32 * idx) + _4133 + 32]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8265 + 128] + 10000:
                                        revert with 'NH{q', 18
                                    if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) / -mem[_8265 + 128] + 10000 != mem[(32 * idx) + _4133 + 32]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if not mem[_12446 + 32]:
                                        if mem[_12446 + 64] and 10000 > -1 / mem[_12446 + 64]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12446 + 64] / 10000 != mem[_12446 + 64]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[_12446 + 64] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[_12446 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[_12446 + 64]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[_12446 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4133]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4133 + 32] = 0 / (10000 * mem[_12446 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32])
                                    else:
                                        if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) and mem[_12446 + 32] > -1 / (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 'NH{q', 17
                                        if not mem[_12446 + 32]:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4133 + 32] * mem[_12446 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32] * mem[_12446 + 32]) / mem[_12446 + 32] != (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 0, 'ds-math-mul-overflow'
                                        if mem[_12446 + 64] and 10000 > -1 / mem[_12446 + 64]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12446 + 64] / 10000 != mem[_12446 + 64]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[_12446 + 64] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[_12446 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[_12446 + 64]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[_12446 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4133]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4133 + 32] = (10000 * mem[(32 * idx) + _4133 + 32] * mem[_12446 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32] * mem[_12446 + 32]) / (10000 * mem[_12446 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32])
                else:
                    _8279 = mem[mem[(32 * idx) + 128] + 64]
                    _8286 = mem[64]
                    _8287 = mem[64]
                    mem[mem[64]] = 4
                    mem[64] = mem[64] + 36
                    mem[_8287 + 32] = mem[_8287 + 36 len 28] or 0x902f1ac00000000000000000000000000000000000000000000000000000000
                    _8320 = mem[_8287]
                    s = 0
                    while s < _8320:
                        mem[_8286 + s + 36] = mem[_8287 + s + 32]
                        _8260 = mem[96]
                        s = s + 32
                        continue 
                    if ceil32(_8320) <= _8320:
                        staticcall address(_8279).mem[mem[64] len 4] with:
                                gas gas_remaining wei
                               args mem[mem[64] + 4 len _8286 + _8320 + -mem[64] + 32]
                        if not return_data.size:
                            if idx >= mem[_4133]:
                                revert with 'NH{q', 50
                            if mem[(32 * idx) + _4133 + 32] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                            if mem[_8265 + 12 len 20] == address(_8273):
                                if mem[128] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[160] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 10000 < mem[_8265 + 128]:
                                    revert with 'NH{q', 17
                                if not -mem[_8265 + 128] + 10000:
                                    if mem[160]:
                                        if False and mem[160] > 0:
                                            revert with 'NH{q', 17
                                        if not mem[160]:
                                            revert with 'NH{q', 18
                                        if 0 / mem[160]:
                                            revert with 0, 'ds-math-mul-overflow'
                                    if mem[128] and 10000 > -1 / mem[128]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[128] / 10000 != mem[128]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[128] > -1:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[128] < 10000 * mem[128]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not 10000 * mem[128]:
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4133]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4133 + 32] = 0 / 10000 * mem[128]
                                else:
                                    if mem[(32 * idx) + _4133 + 32] and -mem[_8265 + 128] + 10000 > -1 / mem[(32 * idx) + _4133 + 32]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8265 + 128] + 10000:
                                        revert with 'NH{q', 18
                                    if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) / -mem[_8265 + 128] + 10000 != mem[(32 * idx) + _4133 + 32]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if not mem[160]:
                                        if mem[128] and 10000 > -1 / mem[128]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[128] / 10000 != mem[128]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[128] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[128]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4133]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4133 + 32] = 0 / (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32])
                                    else:
                                        if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) and mem[160] > -1 / (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 'NH{q', 17
                                        if not mem[160]:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4133 + 32] * mem[160]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32] * mem[160]) / mem[160] != (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 0, 'ds-math-mul-overflow'
                                        if mem[128] and 10000 > -1 / mem[128]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[128] / 10000 != mem[128]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[128] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[128]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4133]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4133 + 32] = (10000 * mem[(32 * idx) + _4133 + 32] * mem[160]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32] * mem[160]) / (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32])
                            else:
                                if mem[160] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[128] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 10000 < mem[_8265 + 128]:
                                    revert with 'NH{q', 17
                                if not -mem[_8265 + 128] + 10000:
                                    if mem[128]:
                                        if False and mem[128] > 0:
                                            revert with 'NH{q', 17
                                        if not mem[128]:
                                            revert with 'NH{q', 18
                                        if 0 / mem[128]:
                                            revert with 0, 'ds-math-mul-overflow'
                                    if mem[160] and 10000 > -1 / mem[160]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[160] / 10000 != mem[160]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[160] > -1:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[160] < 10000 * mem[160]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not 10000 * mem[160]:
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4133]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4133 + 32] = 0 / 10000 * mem[160]
                                else:
                                    if mem[(32 * idx) + _4133 + 32] and -mem[_8265 + 128] + 10000 > -1 / mem[(32 * idx) + _4133 + 32]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8265 + 128] + 10000:
                                        revert with 'NH{q', 18
                                    if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) / -mem[_8265 + 128] + 10000 != mem[(32 * idx) + _4133 + 32]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if not mem[128]:
                                        if mem[160] and 10000 > -1 / mem[160]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[160] / 10000 != mem[160]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[160] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[160]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4133]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4133 + 32] = 0 / (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32])
                                    else:
                                        if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) and mem[128] > -1 / (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 'NH{q', 17
                                        if not mem[128]:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4133 + 32] * mem[128]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32] * mem[128]) / mem[128] != (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 0, 'ds-math-mul-overflow'
                                        if mem[160] and 10000 > -1 / mem[160]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[160] / 10000 != mem[160]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[160] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[160]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4133]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4133 + 32] = (10000 * mem[(32 * idx) + _4133 + 32] * mem[128]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32] * mem[128]) / (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32])
                        else:
                            _12420 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                            mem[_12420] = return_data.size
                            mem[_12420 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if idx >= mem[_4133]:
                                revert with 'NH{q', 50
                            if mem[(32 * idx) + _4133 + 32] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                            if mem[_8265 + 12 len 20] == address(_8273):
                                if mem[_12420 + 32] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[_12420 + 64] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 10000 < mem[_8265 + 128]:
                                    revert with 'NH{q', 17
                                if not -mem[_8265 + 128] + 10000:
                                    if mem[_12420 + 64]:
                                        if False and mem[_12420 + 64] > 0:
                                            revert with 'NH{q', 17
                                        if not mem[_12420 + 64]:
                                            revert with 'NH{q', 18
                                        if 0 / mem[_12420 + 64]:
                                            revert with 0, 'ds-math-mul-overflow'
                                    if mem[_12420 + 32] and 10000 > -1 / mem[_12420 + 32]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[_12420 + 32] / 10000 != mem[_12420 + 32]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[_12420 + 32] > -1:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[_12420 + 32] < 10000 * mem[_12420 + 32]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not 10000 * mem[_12420 + 32]:
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4133]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4133 + 32] = 0 / 10000 * mem[_12420 + 32]
                                else:
                                    if mem[(32 * idx) + _4133 + 32] and -mem[_8265 + 128] + 10000 > -1 / mem[(32 * idx) + _4133 + 32]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8265 + 128] + 10000:
                                        revert with 'NH{q', 18
                                    if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) / -mem[_8265 + 128] + 10000 != mem[(32 * idx) + _4133 + 32]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if not mem[_12420 + 64]:
                                        if mem[_12420 + 32] and 10000 > -1 / mem[_12420 + 32]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12420 + 32] / 10000 != mem[_12420 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[_12420 + 32] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[_12420 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[_12420 + 32]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[_12420 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4133]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4133 + 32] = 0 / (10000 * mem[_12420 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32])
                                    else:
                                        if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) and mem[_12420 + 64] > -1 / (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 'NH{q', 17
                                        if not mem[_12420 + 64]:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4133 + 32] * mem[_12420 + 64]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32] * mem[_12420 + 64]) / mem[_12420 + 64] != (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 0, 'ds-math-mul-overflow'
                                        if mem[_12420 + 32] and 10000 > -1 / mem[_12420 + 32]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12420 + 32] / 10000 != mem[_12420 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[_12420 + 32] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[_12420 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[_12420 + 32]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[_12420 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4133]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4133 + 32] = (10000 * mem[(32 * idx) + _4133 + 32] * mem[_12420 + 64]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32] * mem[_12420 + 64]) / (10000 * mem[_12420 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32])
                            else:
                                if mem[_12420 + 64] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[_12420 + 32] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 10000 < mem[_8265 + 128]:
                                    revert with 'NH{q', 17
                                if not -mem[_8265 + 128] + 10000:
                                    if mem[_12420 + 32]:
                                        if False and mem[_12420 + 32] > 0:
                                            revert with 'NH{q', 17
                                        if not mem[_12420 + 32]:
                                            revert with 'NH{q', 18
                                        if 0 / mem[_12420 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                    if mem[_12420 + 64] and 10000 > -1 / mem[_12420 + 64]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[_12420 + 64] / 10000 != mem[_12420 + 64]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[_12420 + 64] > -1:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[_12420 + 64] < 10000 * mem[_12420 + 64]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not 10000 * mem[_12420 + 64]:
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4133]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4133 + 32] = 0 / 10000 * mem[_12420 + 64]
                                else:
                                    if mem[(32 * idx) + _4133 + 32] and -mem[_8265 + 128] + 10000 > -1 / mem[(32 * idx) + _4133 + 32]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8265 + 128] + 10000:
                                        revert with 'NH{q', 18
                                    if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) / -mem[_8265 + 128] + 10000 != mem[(32 * idx) + _4133 + 32]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if not mem[_12420 + 32]:
                                        if mem[_12420 + 64] and 10000 > -1 / mem[_12420 + 64]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12420 + 64] / 10000 != mem[_12420 + 64]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[_12420 + 64] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[_12420 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[_12420 + 64]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[_12420 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4133]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4133 + 32] = 0 / (10000 * mem[_12420 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32])
                                    else:
                                        if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) and mem[_12420 + 32] > -1 / (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 'NH{q', 17
                                        if not mem[_12420 + 32]:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4133 + 32] * mem[_12420 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32] * mem[_12420 + 32]) / mem[_12420 + 32] != (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 0, 'ds-math-mul-overflow'
                                        if mem[_12420 + 64] and 10000 > -1 / mem[_12420 + 64]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12420 + 64] / 10000 != mem[_12420 + 64]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[_12420 + 64] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[_12420 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[_12420 + 64]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[_12420 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4133]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4133 + 32] = (10000 * mem[(32 * idx) + _4133 + 32] * mem[_12420 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32] * mem[_12420 + 32]) / (10000 * mem[_12420 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32])
                    else:
                        mem[_8286 + _8320 + 36] = 0
                        staticcall address(_8279).mem[mem[64] len 4] with:
                                gas gas_remaining wei
                               args mem[mem[64] + 4 len _8286 + _8320 + -mem[64] + 32]
                        if not return_data.size:
                            if idx >= mem[_4133]:
                                revert with 'NH{q', 50
                            if mem[(32 * idx) + _4133 + 32] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                            if mem[_8265 + 12 len 20] == address(_8273):
                                if mem[128] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[160] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 10000 < mem[_8265 + 128]:
                                    revert with 'NH{q', 17
                                if not -mem[_8265 + 128] + 10000:
                                    if mem[160]:
                                        if False and mem[160] > 0:
                                            revert with 'NH{q', 17
                                        if not mem[160]:
                                            revert with 'NH{q', 18
                                        if 0 / mem[160]:
                                            revert with 0, 'ds-math-mul-overflow'
                                    if mem[128] and 10000 > -1 / mem[128]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[128] / 10000 != mem[128]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[128] > -1:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[128] < 10000 * mem[128]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not 10000 * mem[128]:
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4133]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4133 + 32] = 0 / 10000 * mem[128]
                                else:
                                    if mem[(32 * idx) + _4133 + 32] and -mem[_8265 + 128] + 10000 > -1 / mem[(32 * idx) + _4133 + 32]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8265 + 128] + 10000:
                                        revert with 'NH{q', 18
                                    if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) / -mem[_8265 + 128] + 10000 != mem[(32 * idx) + _4133 + 32]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if not mem[160]:
                                        if mem[128] and 10000 > -1 / mem[128]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[128] / 10000 != mem[128]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[128] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[128]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4133]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4133 + 32] = 0 / (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32])
                                    else:
                                        if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) and mem[160] > -1 / (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 'NH{q', 17
                                        if not mem[160]:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4133 + 32] * mem[160]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32] * mem[160]) / mem[160] != (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 0, 'ds-math-mul-overflow'
                                        if mem[128] and 10000 > -1 / mem[128]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[128] / 10000 != mem[128]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[128] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[128]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4133]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4133 + 32] = (10000 * mem[(32 * idx) + _4133 + 32] * mem[160]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32] * mem[160]) / (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32])
                            else:
                                if mem[160] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[128] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 10000 < mem[_8265 + 128]:
                                    revert with 'NH{q', 17
                                if not -mem[_8265 + 128] + 10000:
                                    if mem[128]:
                                        if False and mem[128] > 0:
                                            revert with 'NH{q', 17
                                        if not mem[128]:
                                            revert with 'NH{q', 18
                                        if 0 / mem[128]:
                                            revert with 0, 'ds-math-mul-overflow'
                                    if mem[160] and 10000 > -1 / mem[160]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[160] / 10000 != mem[160]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[160] > -1:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[160] < 10000 * mem[160]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not 10000 * mem[160]:
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4133]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4133 + 32] = 0 / 10000 * mem[160]
                                else:
                                    if mem[(32 * idx) + _4133 + 32] and -mem[_8265 + 128] + 10000 > -1 / mem[(32 * idx) + _4133 + 32]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8265 + 128] + 10000:
                                        revert with 'NH{q', 18
                                    if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) / -mem[_8265 + 128] + 10000 != mem[(32 * idx) + _4133 + 32]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if not mem[128]:
                                        if mem[160] and 10000 > -1 / mem[160]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[160] / 10000 != mem[160]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[160] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[160]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4133]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4133 + 32] = 0 / (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32])
                                    else:
                                        if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) and mem[128] > -1 / (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 'NH{q', 17
                                        if not mem[128]:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4133 + 32] * mem[128]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32] * mem[128]) / mem[128] != (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 0, 'ds-math-mul-overflow'
                                        if mem[160] and 10000 > -1 / mem[160]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[160] / 10000 != mem[160]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[160] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[160]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4133]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4133 + 32] = (10000 * mem[(32 * idx) + _4133 + 32] * mem[128]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32] * mem[128]) / (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32])
                        else:
                            _12451 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                            mem[_12451] = return_data.size
                            mem[_12451 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if idx >= mem[_4133]:
                                revert with 'NH{q', 50
                            if mem[(32 * idx) + _4133 + 32] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                            if mem[_8265 + 12 len 20] == address(_8273):
                                if mem[_12451 + 32] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[_12451 + 64] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 10000 < mem[_8265 + 128]:
                                    revert with 'NH{q', 17
                                if not -mem[_8265 + 128] + 10000:
                                    if mem[_12451 + 64]:
                                        if False and mem[_12451 + 64] > 0:
                                            revert with 'NH{q', 17
                                        if not mem[_12451 + 64]:
                                            revert with 'NH{q', 18
                                        if 0 / mem[_12451 + 64]:
                                            revert with 0, 'ds-math-mul-overflow'
                                    if mem[_12451 + 32] and 10000 > -1 / mem[_12451 + 32]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[_12451 + 32] / 10000 != mem[_12451 + 32]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[_12451 + 32] > -1:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[_12451 + 32] < 10000 * mem[_12451 + 32]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not 10000 * mem[_12451 + 32]:
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4133]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4133 + 32] = 0 / 10000 * mem[_12451 + 32]
                                else:
                                    if mem[(32 * idx) + _4133 + 32] and -mem[_8265 + 128] + 10000 > -1 / mem[(32 * idx) + _4133 + 32]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8265 + 128] + 10000:
                                        revert with 'NH{q', 18
                                    if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) / -mem[_8265 + 128] + 10000 != mem[(32 * idx) + _4133 + 32]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if not mem[_12451 + 64]:
                                        if mem[_12451 + 32] and 10000 > -1 / mem[_12451 + 32]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12451 + 32] / 10000 != mem[_12451 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[_12451 + 32] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[_12451 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[_12451 + 32]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[_12451 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4133]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4133 + 32] = 0 / (10000 * mem[_12451 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32])
                                    else:
                                        if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) and mem[_12451 + 64] > -1 / (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 'NH{q', 17
                                        if not mem[_12451 + 64]:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4133 + 32] * mem[_12451 + 64]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32] * mem[_12451 + 64]) / mem[_12451 + 64] != (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 0, 'ds-math-mul-overflow'
                                        if mem[_12451 + 32] and 10000 > -1 / mem[_12451 + 32]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12451 + 32] / 10000 != mem[_12451 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[_12451 + 32] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[_12451 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[_12451 + 32]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[_12451 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4133]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4133 + 32] = (10000 * mem[(32 * idx) + _4133 + 32] * mem[_12451 + 64]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32] * mem[_12451 + 64]) / (10000 * mem[_12451 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32])
                            else:
                                if mem[_12451 + 64] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[_12451 + 32] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 10000 < mem[_8265 + 128]:
                                    revert with 'NH{q', 17
                                if not -mem[_8265 + 128] + 10000:
                                    if mem[_12451 + 32]:
                                        if False and mem[_12451 + 32] > 0:
                                            revert with 'NH{q', 17
                                        if not mem[_12451 + 32]:
                                            revert with 'NH{q', 18
                                        if 0 / mem[_12451 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                    if mem[_12451 + 64] and 10000 > -1 / mem[_12451 + 64]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[_12451 + 64] / 10000 != mem[_12451 + 64]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[_12451 + 64] > -1:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[_12451 + 64] < 10000 * mem[_12451 + 64]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not 10000 * mem[_12451 + 64]:
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4133]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4133 + 32] = 0 / 10000 * mem[_12451 + 64]
                                else:
                                    if mem[(32 * idx) + _4133 + 32] and -mem[_8265 + 128] + 10000 > -1 / mem[(32 * idx) + _4133 + 32]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8265 + 128] + 10000:
                                        revert with 'NH{q', 18
                                    if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) / -mem[_8265 + 128] + 10000 != mem[(32 * idx) + _4133 + 32]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if not mem[_12451 + 32]:
                                        if mem[_12451 + 64] and 10000 > -1 / mem[_12451 + 64]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12451 + 64] / 10000 != mem[_12451 + 64]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[_12451 + 64] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[_12451 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[_12451 + 64]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[_12451 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4133]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4133 + 32] = 0 / (10000 * mem[_12451 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32])
                                    else:
                                        if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) and mem[_12451 + 32] > -1 / (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 'NH{q', 17
                                        if not mem[_12451 + 32]:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4133 + 32] * mem[_12451 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32] * mem[_12451 + 32]) / mem[_12451 + 32] != (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 0, 'ds-math-mul-overflow'
                                        if mem[_12451 + 64] and 10000 > -1 / mem[_12451 + 64]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12451 + 64] / 10000 != mem[_12451 + 64]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[_12451 + 64] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[_12451 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[_12451 + 64]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[_12451 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4133]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4133 + 32] = (10000 * mem[(32 * idx) + _4133 + 32] * mem[_12451 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32] * mem[_12451 + 32]) / (10000 * mem[_12451 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32])
            else:
                if mem[mem[(32 * idx) + 128] + 108 len 20] == 0xd8aa70f7990dab4a383a0d8a57df7a372916575d:
                    _8290 = mem[mem[(32 * idx) + 128]]
                    _8291 = mem[mem[(32 * idx) + 128] + 32]
                    if mem[mem[(32 * idx) + 128] + 12 len 20] < mem[mem[(32 * idx) + 128] + 44 len 20]:
                        _8332 = mem[mem[(32 * idx) + 128] + 64]
                        _8346 = mem[64]
                        _8347 = mem[64]
                        mem[mem[64]] = 4
                        mem[64] = mem[64] + 36
                        mem[_8347 + 32] = mem[_8347 + 36 len 28] or 0x902f1ac00000000000000000000000000000000000000000000000000000000
                        _8442 = mem[_8347]
                        s = 0
                        while s < _8442:
                            mem[_8346 + s + 36] = mem[_8347 + s + 32]
                            _8260 = mem[96]
                            s = s + 32
                            continue 
                        if ceil32(_8442) <= _8442:
                            staticcall address(_8332).mem[mem[64] len 4] with:
                                    gas gas_remaining wei
                                   args mem[mem[64] + 4 len _8346 + _8442 + -mem[64] + 32]
                            if not return_data.size:
                                if idx >= mem[_4133]:
                                    revert with 'NH{q', 50
                                if mem[(32 * idx) + _4133 + 32] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                if mem[_8265 + 12 len 20] == address(_8290):
                                    if mem[128] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if mem[160] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if 10000 < mem[_8265 + 128]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8265 + 128] + 10000:
                                        if mem[160]:
                                            if False and mem[160] > 0:
                                                revert with 'NH{q', 17
                                            if not mem[160]:
                                                revert with 'NH{q', 18
                                            if 0 / mem[160]:
                                                revert with 0, 'ds-math-mul-overflow'
                                        if mem[128] and 10000 > -1 / mem[128]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[128] / 10000 != mem[128]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[128] > -1:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[128] < 10000 * mem[128]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not 10000 * mem[128]:
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4133]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4133 + 32] = 0 / 10000 * mem[128]
                                    else:
                                        if mem[(32 * idx) + _4133 + 32] and -mem[_8265 + 128] + 10000 > -1 / mem[(32 * idx) + _4133 + 32]:
                                            revert with 'NH{q', 17
                                        if not -mem[_8265 + 128] + 10000:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) / -mem[_8265 + 128] + 10000 != mem[(32 * idx) + _4133 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if not mem[160]:
                                            if mem[128] and 10000 > -1 / mem[128]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[128] / 10000 != mem[128]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[128] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[128]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4133]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4133 + 32] = 0 / (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32])
                                        else:
                                            if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) and mem[160] > -1 / (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 'NH{q', 17
                                            if not mem[160]:
                                                revert with 'NH{q', 18
                                            if (10000 * mem[(32 * idx) + _4133 + 32] * mem[160]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32] * mem[160]) / mem[160] != (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 0, 'ds-math-mul-overflow'
                                            if mem[128] and 10000 > -1 / mem[128]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[128] / 10000 != mem[128]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[128] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[128]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4133]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4133 + 32] = (10000 * mem[(32 * idx) + _4133 + 32] * mem[160]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32] * mem[160]) / (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32])
                                else:
                                    if mem[160] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if mem[128] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if 10000 < mem[_8265 + 128]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8265 + 128] + 10000:
                                        if mem[128]:
                                            if False and mem[128] > 0:
                                                revert with 'NH{q', 17
                                            if not mem[128]:
                                                revert with 'NH{q', 18
                                            if 0 / mem[128]:
                                                revert with 0, 'ds-math-mul-overflow'
                                        if mem[160] and 10000 > -1 / mem[160]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[160] / 10000 != mem[160]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[160] > -1:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[160] < 10000 * mem[160]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not 10000 * mem[160]:
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4133]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4133 + 32] = 0 / 10000 * mem[160]
                                    else:
                                        if mem[(32 * idx) + _4133 + 32] and -mem[_8265 + 128] + 10000 > -1 / mem[(32 * idx) + _4133 + 32]:
                                            revert with 'NH{q', 17
                                        if not -mem[_8265 + 128] + 10000:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) / -mem[_8265 + 128] + 10000 != mem[(32 * idx) + _4133 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if not mem[128]:
                                            if mem[160] and 10000 > -1 / mem[160]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[160] / 10000 != mem[160]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[160] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[160]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4133]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4133 + 32] = 0 / (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32])
                                        else:
                                            if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) and mem[128] > -1 / (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 'NH{q', 17
                                            if not mem[128]:
                                                revert with 'NH{q', 18
                                            if (10000 * mem[(32 * idx) + _4133 + 32] * mem[128]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32] * mem[128]) / mem[128] != (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 0, 'ds-math-mul-overflow'
                                            if mem[160] and 10000 > -1 / mem[160]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[160] / 10000 != mem[160]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[160] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[160]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4133]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4133 + 32] = (10000 * mem[(32 * idx) + _4133 + 32] * mem[128]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32] * mem[128]) / (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32])
                            else:
                                _12426 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size) + 1
                                mem[_12426] = return_data.size
                                mem[_12426 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if idx >= mem[_4133]:
                                    revert with 'NH{q', 50
                                if mem[(32 * idx) + _4133 + 32] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                if mem[_8265 + 12 len 20] == address(_8290):
                                    if mem[_12426 + 32] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if mem[_12426 + 64] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if 10000 < mem[_8265 + 128]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8265 + 128] + 10000:
                                        if mem[_12426 + 64]:
                                            if False and mem[_12426 + 64] > 0:
                                                revert with 'NH{q', 17
                                            if not mem[_12426 + 64]:
                                                revert with 'NH{q', 18
                                            if 0 / mem[_12426 + 64]:
                                                revert with 0, 'ds-math-mul-overflow'
                                        if mem[_12426 + 32] and 10000 > -1 / mem[_12426 + 32]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12426 + 32] / 10000 != mem[_12426 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[_12426 + 32] > -1:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12426 + 32] < 10000 * mem[_12426 + 32]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not 10000 * mem[_12426 + 32]:
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4133]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4133 + 32] = 0 / 10000 * mem[_12426 + 32]
                                    else:
                                        if mem[(32 * idx) + _4133 + 32] and -mem[_8265 + 128] + 10000 > -1 / mem[(32 * idx) + _4133 + 32]:
                                            revert with 'NH{q', 17
                                        if not -mem[_8265 + 128] + 10000:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) / -mem[_8265 + 128] + 10000 != mem[(32 * idx) + _4133 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if not mem[_12426 + 64]:
                                            if mem[_12426 + 32] and 10000 > -1 / mem[_12426 + 32]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[_12426 + 32] / 10000 != mem[_12426 + 32]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[_12426 + 32] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[_12426 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[_12426 + 32]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[_12426 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4133]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4133 + 32] = 0 / (10000 * mem[_12426 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32])
                                        else:
                                            if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) and mem[_12426 + 64] > -1 / (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 'NH{q', 17
                                            if not mem[_12426 + 64]:
                                                revert with 'NH{q', 18
                                            if (10000 * mem[(32 * idx) + _4133 + 32] * mem[_12426 + 64]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32] * mem[_12426 + 64]) / mem[_12426 + 64] != (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 0, 'ds-math-mul-overflow'
                                            if mem[_12426 + 32] and 10000 > -1 / mem[_12426 + 32]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[_12426 + 32] / 10000 != mem[_12426 + 32]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[_12426 + 32] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[_12426 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[_12426 + 32]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[_12426 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4133]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4133 + 32] = (10000 * mem[(32 * idx) + _4133 + 32] * mem[_12426 + 64]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32] * mem[_12426 + 64]) / (10000 * mem[_12426 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32])
                                else:
                                    if mem[_12426 + 64] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if mem[_12426 + 32] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if 10000 < mem[_8265 + 128]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8265 + 128] + 10000:
                                        if mem[_12426 + 32]:
                                            if False and mem[_12426 + 32] > 0:
                                                revert with 'NH{q', 17
                                            if not mem[_12426 + 32]:
                                                revert with 'NH{q', 18
                                            if 0 / mem[_12426 + 32]:
                                                revert with 0, 'ds-math-mul-overflow'
                                        if mem[_12426 + 64] and 10000 > -1 / mem[_12426 + 64]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12426 + 64] / 10000 != mem[_12426 + 64]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[_12426 + 64] > -1:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12426 + 64] < 10000 * mem[_12426 + 64]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not 10000 * mem[_12426 + 64]:
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4133]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4133 + 32] = 0 / 10000 * mem[_12426 + 64]
                                    else:
                                        if mem[(32 * idx) + _4133 + 32] and -mem[_8265 + 128] + 10000 > -1 / mem[(32 * idx) + _4133 + 32]:
                                            revert with 'NH{q', 17
                                        if not -mem[_8265 + 128] + 10000:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) / -mem[_8265 + 128] + 10000 != mem[(32 * idx) + _4133 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if not mem[_12426 + 32]:
                                            if mem[_12426 + 64] and 10000 > -1 / mem[_12426 + 64]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[_12426 + 64] / 10000 != mem[_12426 + 64]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[_12426 + 64] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[_12426 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[_12426 + 64]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[_12426 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4133]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4133 + 32] = 0 / (10000 * mem[_12426 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32])
                                        else:
                                            if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) and mem[_12426 + 32] > -1 / (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 'NH{q', 17
                                            if not mem[_12426 + 32]:
                                                revert with 'NH{q', 18
                                            if (10000 * mem[(32 * idx) + _4133 + 32] * mem[_12426 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32] * mem[_12426 + 32]) / mem[_12426 + 32] != (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 0, 'ds-math-mul-overflow'
                                            if mem[_12426 + 64] and 10000 > -1 / mem[_12426 + 64]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[_12426 + 64] / 10000 != mem[_12426 + 64]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[_12426 + 64] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[_12426 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[_12426 + 64]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[_12426 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4133]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4133 + 32] = (10000 * mem[(32 * idx) + _4133 + 32] * mem[_12426 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32] * mem[_12426 + 32]) / (10000 * mem[_12426 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32])
                        else:
                            mem[_8346 + _8442 + 36] = 0
                            staticcall address(_8332).mem[mem[64] len 4] with:
                                    gas gas_remaining wei
                                   args mem[mem[64] + 4 len _8346 + _8442 + -mem[64] + 32]
                            if not return_data.size:
                                if idx >= mem[_4133]:
                                    revert with 'NH{q', 50
                                if mem[(32 * idx) + _4133 + 32] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                if mem[_8265 + 12 len 20] == address(_8290):
                                    if mem[128] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if mem[160] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if 10000 < mem[_8265 + 128]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8265 + 128] + 10000:
                                        if mem[160]:
                                            if False and mem[160] > 0:
                                                revert with 'NH{q', 17
                                            if not mem[160]:
                                                revert with 'NH{q', 18
                                            if 0 / mem[160]:
                                                revert with 0, 'ds-math-mul-overflow'
                                        if mem[128] and 10000 > -1 / mem[128]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[128] / 10000 != mem[128]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[128] > -1:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[128] < 10000 * mem[128]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not 10000 * mem[128]:
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4133]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4133 + 32] = 0 / 10000 * mem[128]
                                    else:
                                        if mem[(32 * idx) + _4133 + 32] and -mem[_8265 + 128] + 10000 > -1 / mem[(32 * idx) + _4133 + 32]:
                                            revert with 'NH{q', 17
                                        if not -mem[_8265 + 128] + 10000:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) / -mem[_8265 + 128] + 10000 != mem[(32 * idx) + _4133 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if not mem[160]:
                                            if mem[128] and 10000 > -1 / mem[128]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[128] / 10000 != mem[128]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[128] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[128]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4133]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4133 + 32] = 0 / (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32])
                                        else:
                                            if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) and mem[160] > -1 / (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 'NH{q', 17
                                            if not mem[160]:
                                                revert with 'NH{q', 18
                                            if (10000 * mem[(32 * idx) + _4133 + 32] * mem[160]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32] * mem[160]) / mem[160] != (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 0, 'ds-math-mul-overflow'
                                            if mem[128] and 10000 > -1 / mem[128]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[128] / 10000 != mem[128]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[128] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[128]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4133]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4133 + 32] = (10000 * mem[(32 * idx) + _4133 + 32] * mem[160]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32] * mem[160]) / (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32])
                                else:
                                    if mem[160] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if mem[128] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if 10000 < mem[_8265 + 128]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8265 + 128] + 10000:
                                        if mem[128]:
                                            if False and mem[128] > 0:
                                                revert with 'NH{q', 17
                                            if not mem[128]:
                                                revert with 'NH{q', 18
                                            if 0 / mem[128]:
                                                revert with 0, 'ds-math-mul-overflow'
                                        if mem[160] and 10000 > -1 / mem[160]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[160] / 10000 != mem[160]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[160] > -1:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[160] < 10000 * mem[160]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not 10000 * mem[160]:
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4133]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4133 + 32] = 0 / 10000 * mem[160]
                                    else:
                                        if mem[(32 * idx) + _4133 + 32] and -mem[_8265 + 128] + 10000 > -1 / mem[(32 * idx) + _4133 + 32]:
                                            revert with 'NH{q', 17
                                        if not -mem[_8265 + 128] + 10000:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) / -mem[_8265 + 128] + 10000 != mem[(32 * idx) + _4133 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if not mem[128]:
                                            if mem[160] and 10000 > -1 / mem[160]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[160] / 10000 != mem[160]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[160] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[160]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4133]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4133 + 32] = 0 / (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32])
                                        else:
                                            if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) and mem[128] > -1 / (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 'NH{q', 17
                                            if not mem[128]:
                                                revert with 'NH{q', 18
                                            if (10000 * mem[(32 * idx) + _4133 + 32] * mem[128]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32] * mem[128]) / mem[128] != (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 0, 'ds-math-mul-overflow'
                                            if mem[160] and 10000 > -1 / mem[160]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[160] / 10000 != mem[160]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[160] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[160]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4133]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4133 + 32] = (10000 * mem[(32 * idx) + _4133 + 32] * mem[128]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32] * mem[128]) / (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32])
                            else:
                                _12467 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size) + 1
                                mem[_12467] = return_data.size
                                mem[_12467 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if idx >= mem[_4133]:
                                    revert with 'NH{q', 50
                                if mem[(32 * idx) + _4133 + 32] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                if mem[_8265 + 12 len 20] == address(_8290):
                                    if mem[_12467 + 32] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if mem[_12467 + 64] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if 10000 < mem[_8265 + 128]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8265 + 128] + 10000:
                                        if mem[_12467 + 64]:
                                            if False and mem[_12467 + 64] > 0:
                                                revert with 'NH{q', 17
                                            if not mem[_12467 + 64]:
                                                revert with 'NH{q', 18
                                            if 0 / mem[_12467 + 64]:
                                                revert with 0, 'ds-math-mul-overflow'
                                        if mem[_12467 + 32] and 10000 > -1 / mem[_12467 + 32]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12467 + 32] / 10000 != mem[_12467 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[_12467 + 32] > -1:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12467 + 32] < 10000 * mem[_12467 + 32]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not 10000 * mem[_12467 + 32]:
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4133]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4133 + 32] = 0 / 10000 * mem[_12467 + 32]
                                    else:
                                        if mem[(32 * idx) + _4133 + 32] and -mem[_8265 + 128] + 10000 > -1 / mem[(32 * idx) + _4133 + 32]:
                                            revert with 'NH{q', 17
                                        if not -mem[_8265 + 128] + 10000:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) / -mem[_8265 + 128] + 10000 != mem[(32 * idx) + _4133 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if not mem[_12467 + 64]:
                                            if mem[_12467 + 32] and 10000 > -1 / mem[_12467 + 32]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[_12467 + 32] / 10000 != mem[_12467 + 32]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[_12467 + 32] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[_12467 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[_12467 + 32]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[_12467 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4133]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4133 + 32] = 0 / (10000 * mem[_12467 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32])
                                        else:
                                            if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) and mem[_12467 + 64] > -1 / (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 'NH{q', 17
                                            if not mem[_12467 + 64]:
                                                revert with 'NH{q', 18
                                            if (10000 * mem[(32 * idx) + _4133 + 32] * mem[_12467 + 64]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32] * mem[_12467 + 64]) / mem[_12467 + 64] != (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 0, 'ds-math-mul-overflow'
                                            if mem[_12467 + 32] and 10000 > -1 / mem[_12467 + 32]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[_12467 + 32] / 10000 != mem[_12467 + 32]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[_12467 + 32] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[_12467 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[_12467 + 32]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[_12467 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4133]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4133 + 32] = (10000 * mem[(32 * idx) + _4133 + 32] * mem[_12467 + 64]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32] * mem[_12467 + 64]) / (10000 * mem[_12467 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32])
                                else:
                                    if mem[_12467 + 64] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if mem[_12467 + 32] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if 10000 < mem[_8265 + 128]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8265 + 128] + 10000:
                                        if mem[_12467 + 32]:
                                            if False and mem[_12467 + 32] > 0:
                                                revert with 'NH{q', 17
                                            if not mem[_12467 + 32]:
                                                revert with 'NH{q', 18
                                            if 0 / mem[_12467 + 32]:
                                                revert with 0, 'ds-math-mul-overflow'
                                        if mem[_12467 + 64] and 10000 > -1 / mem[_12467 + 64]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12467 + 64] / 10000 != mem[_12467 + 64]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[_12467 + 64] > -1:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12467 + 64] < 10000 * mem[_12467 + 64]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not 10000 * mem[_12467 + 64]:
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4133]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4133 + 32] = 0 / 10000 * mem[_12467 + 64]
                                    else:
                                        if mem[(32 * idx) + _4133 + 32] and -mem[_8265 + 128] + 10000 > -1 / mem[(32 * idx) + _4133 + 32]:
                                            revert with 'NH{q', 17
                                        if not -mem[_8265 + 128] + 10000:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) / -mem[_8265 + 128] + 10000 != mem[(32 * idx) + _4133 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if not mem[_12467 + 32]:
                                            if mem[_12467 + 64] and 10000 > -1 / mem[_12467 + 64]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[_12467 + 64] / 10000 != mem[_12467 + 64]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[_12467 + 64] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[_12467 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[_12467 + 64]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[_12467 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4133]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4133 + 32] = 0 / (10000 * mem[_12467 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32])
                                        else:
                                            if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) and mem[_12467 + 32] > -1 / (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 'NH{q', 17
                                            if not mem[_12467 + 32]:
                                                revert with 'NH{q', 18
                                            if (10000 * mem[(32 * idx) + _4133 + 32] * mem[_12467 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32] * mem[_12467 + 32]) / mem[_12467 + 32] != (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 0, 'ds-math-mul-overflow'
                                            if mem[_12467 + 64] and 10000 > -1 / mem[_12467 + 64]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[_12467 + 64] / 10000 != mem[_12467 + 64]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[_12467 + 64] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[_12467 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[_12467 + 64]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[_12467 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4133]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4133 + 32] = (10000 * mem[(32 * idx) + _4133 + 32] * mem[_12467 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32] * mem[_12467 + 32]) / (10000 * mem[_12467 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32])
                    else:
                        _8333 = mem[mem[(32 * idx) + 128] + 64]
                        _8350 = mem[64]
                        _8351 = mem[64]
                        mem[mem[64]] = 4
                        mem[64] = mem[64] + 36
                        mem[_8351 + 32] = mem[_8351 + 36 len 28] or 0x902f1ac00000000000000000000000000000000000000000000000000000000
                        _8443 = mem[_8351]
                        s = 0
                        while s < _8443:
                            mem[_8350 + s + 36] = mem[_8351 + s + 32]
                            _8260 = mem[96]
                            s = s + 32
                            continue 
                        if ceil32(_8443) <= _8443:
                            staticcall address(_8333).mem[mem[64] len 4] with:
                                    gas gas_remaining wei
                                   args mem[mem[64] + 4 len _8350 + _8443 + -mem[64] + 32]
                            if not return_data.size:
                                if idx >= mem[_4133]:
                                    revert with 'NH{q', 50
                                if mem[(32 * idx) + _4133 + 32] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                if mem[_8265 + 12 len 20] == address(_8291):
                                    if mem[128] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if mem[160] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if 10000 < mem[_8265 + 128]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8265 + 128] + 10000:
                                        if mem[160]:
                                            if False and mem[160] > 0:
                                                revert with 'NH{q', 17
                                            if not mem[160]:
                                                revert with 'NH{q', 18
                                            if 0 / mem[160]:
                                                revert with 0, 'ds-math-mul-overflow'
                                        if mem[128] and 10000 > -1 / mem[128]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[128] / 10000 != mem[128]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[128] > -1:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[128] < 10000 * mem[128]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not 10000 * mem[128]:
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4133]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4133 + 32] = 0 / 10000 * mem[128]
                                    else:
                                        if mem[(32 * idx) + _4133 + 32] and -mem[_8265 + 128] + 10000 > -1 / mem[(32 * idx) + _4133 + 32]:
                                            revert with 'NH{q', 17
                                        if not -mem[_8265 + 128] + 10000:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) / -mem[_8265 + 128] + 10000 != mem[(32 * idx) + _4133 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if not mem[160]:
                                            if mem[128] and 10000 > -1 / mem[128]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[128] / 10000 != mem[128]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[128] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[128]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4133]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4133 + 32] = 0 / (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32])
                                        else:
                                            if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) and mem[160] > -1 / (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 'NH{q', 17
                                            if not mem[160]:
                                                revert with 'NH{q', 18
                                            if (10000 * mem[(32 * idx) + _4133 + 32] * mem[160]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32] * mem[160]) / mem[160] != (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 0, 'ds-math-mul-overflow'
                                            if mem[128] and 10000 > -1 / mem[128]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[128] / 10000 != mem[128]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[128] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[128]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4133]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4133 + 32] = (10000 * mem[(32 * idx) + _4133 + 32] * mem[160]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32] * mem[160]) / (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32])
                                else:
                                    if mem[160] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if mem[128] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if 10000 < mem[_8265 + 128]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8265 + 128] + 10000:
                                        if mem[128]:
                                            if False and mem[128] > 0:
                                                revert with 'NH{q', 17
                                            if not mem[128]:
                                                revert with 'NH{q', 18
                                            if 0 / mem[128]:
                                                revert with 0, 'ds-math-mul-overflow'
                                        if mem[160] and 10000 > -1 / mem[160]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[160] / 10000 != mem[160]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[160] > -1:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[160] < 10000 * mem[160]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not 10000 * mem[160]:
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4133]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4133 + 32] = 0 / 10000 * mem[160]
                                    else:
                                        if mem[(32 * idx) + _4133 + 32] and -mem[_8265 + 128] + 10000 > -1 / mem[(32 * idx) + _4133 + 32]:
                                            revert with 'NH{q', 17
                                        if not -mem[_8265 + 128] + 10000:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) / -mem[_8265 + 128] + 10000 != mem[(32 * idx) + _4133 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if not mem[128]:
                                            if mem[160] and 10000 > -1 / mem[160]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[160] / 10000 != mem[160]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[160] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[160]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4133]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4133 + 32] = 0 / (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32])
                                        else:
                                            if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) and mem[128] > -1 / (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 'NH{q', 17
                                            if not mem[128]:
                                                revert with 'NH{q', 18
                                            if (10000 * mem[(32 * idx) + _4133 + 32] * mem[128]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32] * mem[128]) / mem[128] != (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 0, 'ds-math-mul-overflow'
                                            if mem[160] and 10000 > -1 / mem[160]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[160] / 10000 != mem[160]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[160] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[160]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4133]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4133 + 32] = (10000 * mem[(32 * idx) + _4133 + 32] * mem[128]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32] * mem[128]) / (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32])
                            else:
                                _12428 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size) + 1
                                mem[_12428] = return_data.size
                                mem[_12428 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if idx >= mem[_4133]:
                                    revert with 'NH{q', 50
                                if mem[(32 * idx) + _4133 + 32] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                if mem[_8265 + 12 len 20] == address(_8291):
                                    if mem[_12428 + 32] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if mem[_12428 + 64] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if 10000 < mem[_8265 + 128]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8265 + 128] + 10000:
                                        if mem[_12428 + 64]:
                                            if False and mem[_12428 + 64] > 0:
                                                revert with 'NH{q', 17
                                            if not mem[_12428 + 64]:
                                                revert with 'NH{q', 18
                                            if 0 / mem[_12428 + 64]:
                                                revert with 0, 'ds-math-mul-overflow'
                                        if mem[_12428 + 32] and 10000 > -1 / mem[_12428 + 32]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12428 + 32] / 10000 != mem[_12428 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[_12428 + 32] > -1:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12428 + 32] < 10000 * mem[_12428 + 32]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not 10000 * mem[_12428 + 32]:
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4133]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4133 + 32] = 0 / 10000 * mem[_12428 + 32]
                                    else:
                                        if mem[(32 * idx) + _4133 + 32] and -mem[_8265 + 128] + 10000 > -1 / mem[(32 * idx) + _4133 + 32]:
                                            revert with 'NH{q', 17
                                        if not -mem[_8265 + 128] + 10000:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) / -mem[_8265 + 128] + 10000 != mem[(32 * idx) + _4133 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if not mem[_12428 + 64]:
                                            if mem[_12428 + 32] and 10000 > -1 / mem[_12428 + 32]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[_12428 + 32] / 10000 != mem[_12428 + 32]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[_12428 + 32] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[_12428 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[_12428 + 32]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[_12428 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4133]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4133 + 32] = 0 / (10000 * mem[_12428 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32])
                                        else:
                                            if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) and mem[_12428 + 64] > -1 / (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 'NH{q', 17
                                            if not mem[_12428 + 64]:
                                                revert with 'NH{q', 18
                                            if (10000 * mem[(32 * idx) + _4133 + 32] * mem[_12428 + 64]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32] * mem[_12428 + 64]) / mem[_12428 + 64] != (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 0, 'ds-math-mul-overflow'
                                            if mem[_12428 + 32] and 10000 > -1 / mem[_12428 + 32]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[_12428 + 32] / 10000 != mem[_12428 + 32]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[_12428 + 32] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[_12428 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[_12428 + 32]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[_12428 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4133]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4133 + 32] = (10000 * mem[(32 * idx) + _4133 + 32] * mem[_12428 + 64]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32] * mem[_12428 + 64]) / (10000 * mem[_12428 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32])
                                else:
                                    if mem[_12428 + 64] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if mem[_12428 + 32] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if 10000 < mem[_8265 + 128]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8265 + 128] + 10000:
                                        if mem[_12428 + 32]:
                                            if False and mem[_12428 + 32] > 0:
                                                revert with 'NH{q', 17
                                            if not mem[_12428 + 32]:
                                                revert with 'NH{q', 18
                                            if 0 / mem[_12428 + 32]:
                                                revert with 0, 'ds-math-mul-overflow'
                                        if mem[_12428 + 64] and 10000 > -1 / mem[_12428 + 64]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12428 + 64] / 10000 != mem[_12428 + 64]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[_12428 + 64] > -1:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12428 + 64] < 10000 * mem[_12428 + 64]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not 10000 * mem[_12428 + 64]:
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4133]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4133 + 32] = 0 / 10000 * mem[_12428 + 64]
                                    else:
                                        if mem[(32 * idx) + _4133 + 32] and -mem[_8265 + 128] + 10000 > -1 / mem[(32 * idx) + _4133 + 32]:
                                            revert with 'NH{q', 17
                                        if not -mem[_8265 + 128] + 10000:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) / -mem[_8265 + 128] + 10000 != mem[(32 * idx) + _4133 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if not mem[_12428 + 32]:
                                            if mem[_12428 + 64] and 10000 > -1 / mem[_12428 + 64]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[_12428 + 64] / 10000 != mem[_12428 + 64]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[_12428 + 64] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[_12428 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[_12428 + 64]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[_12428 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4133]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4133 + 32] = 0 / (10000 * mem[_12428 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32])
                                        else:
                                            if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) and mem[_12428 + 32] > -1 / (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 'NH{q', 17
                                            if not mem[_12428 + 32]:
                                                revert with 'NH{q', 18
                                            if (10000 * mem[(32 * idx) + _4133 + 32] * mem[_12428 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32] * mem[_12428 + 32]) / mem[_12428 + 32] != (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 0, 'ds-math-mul-overflow'
                                            if mem[_12428 + 64] and 10000 > -1 / mem[_12428 + 64]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[_12428 + 64] / 10000 != mem[_12428 + 64]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[_12428 + 64] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[_12428 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[_12428 + 64]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[_12428 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4133]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4133 + 32] = (10000 * mem[(32 * idx) + _4133 + 32] * mem[_12428 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32] * mem[_12428 + 32]) / (10000 * mem[_12428 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32])
                        else:
                            mem[_8350 + _8443 + 36] = 0
                            staticcall address(_8333).mem[mem[64] len 4] with:
                                    gas gas_remaining wei
                                   args mem[mem[64] + 4 len _8350 + _8443 + -mem[64] + 32]
                            if not return_data.size:
                                if idx >= mem[_4133]:
                                    revert with 'NH{q', 50
                                if mem[(32 * idx) + _4133 + 32] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                if mem[_8265 + 12 len 20] == address(_8291):
                                    if mem[128] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if mem[160] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if 10000 < mem[_8265 + 128]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8265 + 128] + 10000:
                                        if mem[160]:
                                            if False and mem[160] > 0:
                                                revert with 'NH{q', 17
                                            if not mem[160]:
                                                revert with 'NH{q', 18
                                            if 0 / mem[160]:
                                                revert with 0, 'ds-math-mul-overflow'
                                        if mem[128] and 10000 > -1 / mem[128]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[128] / 10000 != mem[128]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[128] > -1:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[128] < 10000 * mem[128]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not 10000 * mem[128]:
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4133]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4133 + 32] = 0 / 10000 * mem[128]
                                    else:
                                        if mem[(32 * idx) + _4133 + 32] and -mem[_8265 + 128] + 10000 > -1 / mem[(32 * idx) + _4133 + 32]:
                                            revert with 'NH{q', 17
                                        if not -mem[_8265 + 128] + 10000:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) / -mem[_8265 + 128] + 10000 != mem[(32 * idx) + _4133 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if not mem[160]:
                                            if mem[128] and 10000 > -1 / mem[128]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[128] / 10000 != mem[128]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[128] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[128]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4133]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4133 + 32] = 0 / (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32])
                                        else:
                                            if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) and mem[160] > -1 / (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 'NH{q', 17
                                            if not mem[160]:
                                                revert with 'NH{q', 18
                                            if (10000 * mem[(32 * idx) + _4133 + 32] * mem[160]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32] * mem[160]) / mem[160] != (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 0, 'ds-math-mul-overflow'
                                            if mem[128] and 10000 > -1 / mem[128]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[128] / 10000 != mem[128]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[128] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[128]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4133]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4133 + 32] = (10000 * mem[(32 * idx) + _4133 + 32] * mem[160]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32] * mem[160]) / (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32])
                                else:
                                    if mem[160] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if mem[128] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if 10000 < mem[_8265 + 128]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8265 + 128] + 10000:
                                        if mem[128]:
                                            if False and mem[128] > 0:
                                                revert with 'NH{q', 17
                                            if not mem[128]:
                                                revert with 'NH{q', 18
                                            if 0 / mem[128]:
                                                revert with 0, 'ds-math-mul-overflow'
                                        if mem[160] and 10000 > -1 / mem[160]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[160] / 10000 != mem[160]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[160] > -1:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[160] < 10000 * mem[160]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not 10000 * mem[160]:
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4133]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4133 + 32] = 0 / 10000 * mem[160]
                                    else:
                                        if mem[(32 * idx) + _4133 + 32] and -mem[_8265 + 128] + 10000 > -1 / mem[(32 * idx) + _4133 + 32]:
                                            revert with 'NH{q', 17
                                        if not -mem[_8265 + 128] + 10000:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) / -mem[_8265 + 128] + 10000 != mem[(32 * idx) + _4133 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if not mem[128]:
                                            if mem[160] and 10000 > -1 / mem[160]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[160] / 10000 != mem[160]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[160] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[160]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4133]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4133 + 32] = 0 / (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32])
                                        else:
                                            if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) and mem[128] > -1 / (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 'NH{q', 17
                                            if not mem[128]:
                                                revert with 'NH{q', 18
                                            if (10000 * mem[(32 * idx) + _4133 + 32] * mem[128]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32] * mem[128]) / mem[128] != (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 0, 'ds-math-mul-overflow'
                                            if mem[160] and 10000 > -1 / mem[160]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[160] / 10000 != mem[160]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[160] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[160]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4133]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4133 + 32] = (10000 * mem[(32 * idx) + _4133 + 32] * mem[128]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32] * mem[128]) / (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32])
                            else:
                                _12472 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size) + 1
                                mem[_12472] = return_data.size
                                mem[_12472 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if idx >= mem[_4133]:
                                    revert with 'NH{q', 50
                                if mem[(32 * idx) + _4133 + 32] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                if mem[_8265 + 12 len 20] == address(_8291):
                                    if mem[_12472 + 32] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if mem[_12472 + 64] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if 10000 < mem[_8265 + 128]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8265 + 128] + 10000:
                                        if mem[_12472 + 64]:
                                            if False and mem[_12472 + 64] > 0:
                                                revert with 'NH{q', 17
                                            if not mem[_12472 + 64]:
                                                revert with 'NH{q', 18
                                            if 0 / mem[_12472 + 64]:
                                                revert with 0, 'ds-math-mul-overflow'
                                        if mem[_12472 + 32] and 10000 > -1 / mem[_12472 + 32]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12472 + 32] / 10000 != mem[_12472 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[_12472 + 32] > -1:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12472 + 32] < 10000 * mem[_12472 + 32]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not 10000 * mem[_12472 + 32]:
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4133]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4133 + 32] = 0 / 10000 * mem[_12472 + 32]
                                    else:
                                        if mem[(32 * idx) + _4133 + 32] and -mem[_8265 + 128] + 10000 > -1 / mem[(32 * idx) + _4133 + 32]:
                                            revert with 'NH{q', 17
                                        if not -mem[_8265 + 128] + 10000:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) / -mem[_8265 + 128] + 10000 != mem[(32 * idx) + _4133 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if not mem[_12472 + 64]:
                                            if mem[_12472 + 32] and 10000 > -1 / mem[_12472 + 32]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[_12472 + 32] / 10000 != mem[_12472 + 32]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[_12472 + 32] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[_12472 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[_12472 + 32]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[_12472 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4133]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4133 + 32] = 0 / (10000 * mem[_12472 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32])
                                        else:
                                            if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) and mem[_12472 + 64] > -1 / (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 'NH{q', 17
                                            if not mem[_12472 + 64]:
                                                revert with 'NH{q', 18
                                            if (10000 * mem[(32 * idx) + _4133 + 32] * mem[_12472 + 64]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32] * mem[_12472 + 64]) / mem[_12472 + 64] != (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 0, 'ds-math-mul-overflow'
                                            if mem[_12472 + 32] and 10000 > -1 / mem[_12472 + 32]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[_12472 + 32] / 10000 != mem[_12472 + 32]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[_12472 + 32] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[_12472 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[_12472 + 32]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[_12472 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4133]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4133 + 32] = (10000 * mem[(32 * idx) + _4133 + 32] * mem[_12472 + 64]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32] * mem[_12472 + 64]) / (10000 * mem[_12472 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32])
                                else:
                                    if mem[_12472 + 64] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if mem[_12472 + 32] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if 10000 < mem[_8265 + 128]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8265 + 128] + 10000:
                                        if mem[_12472 + 32]:
                                            if False and mem[_12472 + 32] > 0:
                                                revert with 'NH{q', 17
                                            if not mem[_12472 + 32]:
                                                revert with 'NH{q', 18
                                            if 0 / mem[_12472 + 32]:
                                                revert with 0, 'ds-math-mul-overflow'
                                        if mem[_12472 + 64] and 10000 > -1 / mem[_12472 + 64]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12472 + 64] / 10000 != mem[_12472 + 64]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[_12472 + 64] > -1:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12472 + 64] < 10000 * mem[_12472 + 64]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not 10000 * mem[_12472 + 64]:
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4133]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4133 + 32] = 0 / 10000 * mem[_12472 + 64]
                                    else:
                                        if mem[(32 * idx) + _4133 + 32] and -mem[_8265 + 128] + 10000 > -1 / mem[(32 * idx) + _4133 + 32]:
                                            revert with 'NH{q', 17
                                        if not -mem[_8265 + 128] + 10000:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) / -mem[_8265 + 128] + 10000 != mem[(32 * idx) + _4133 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if not mem[_12472 + 32]:
                                            if mem[_12472 + 64] and 10000 > -1 / mem[_12472 + 64]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[_12472 + 64] / 10000 != mem[_12472 + 64]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[_12472 + 64] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[_12472 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[_12472 + 64]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[_12472 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4133]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4133 + 32] = 0 / (10000 * mem[_12472 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32])
                                        else:
                                            if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) and mem[_12472 + 32] > -1 / (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 'NH{q', 17
                                            if not mem[_12472 + 32]:
                                                revert with 'NH{q', 18
                                            if (10000 * mem[(32 * idx) + _4133 + 32] * mem[_12472 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32] * mem[_12472 + 32]) / mem[_12472 + 32] != (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 0, 'ds-math-mul-overflow'
                                            if mem[_12472 + 64] and 10000 > -1 / mem[_12472 + 64]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[_12472 + 64] / 10000 != mem[_12472 + 64]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[_12472 + 64] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[_12472 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[_12472 + 64]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[_12472 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4133]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4133 + 32] = (10000 * mem[(32 * idx) + _4133 + 32] * mem[_12472 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32] * mem[_12472 + 32]) / (10000 * mem[_12472 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32])
                else:
                    if mem[mem[(32 * idx) + 128] + 108 len 20] == 0xb9a9bb6cc39387548baa7185fbff51d47eef8771:
                        _8303 = mem[mem[(32 * idx) + 128]]
                        _8304 = mem[mem[(32 * idx) + 128] + 32]
                        if mem[mem[(32 * idx) + 128] + 12 len 20] < mem[mem[(32 * idx) + 128] + 44 len 20]:
                            _8344 = mem[mem[(32 * idx) + 128] + 64]
                            _8378 = mem[64]
                            _8379 = mem[64]
                            mem[mem[64]] = 4
                            mem[64] = mem[64] + 36
                            mem[_8379 + 32] = mem[_8379 + 36 len 28] or 0x902f1ac00000000000000000000000000000000000000000000000000000000
                            _8461 = mem[_8379]
                            s = 0
                            while s < _8461:
                                mem[_8378 + s + 36] = mem[_8379 + s + 32]
                                _8260 = mem[96]
                                s = s + 32
                                continue 
                            if ceil32(_8461) <= _8461:
                                staticcall address(_8344).mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _8378 + _8461 + -mem[64] + 32]
                                if not return_data.size:
                                    if idx >= mem[_4133]:
                                        revert with 'NH{q', 50
                                    if mem[(32 * idx) + _4133 + 32] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                    if mem[_8265 + 12 len 20] == address(_8303):
                                        if mem[128] <= 0:
                                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                        if mem[160] <= 0:
                                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                        if 10000 < mem[_8265 + 128]:
                                            revert with 'NH{q', 17
                                        if not -mem[_8265 + 128] + 10000:
                                            if mem[160]:
                                                if False and mem[160] > 0:
                                                    revert with 'NH{q', 17
                                                if not mem[160]:
                                                    revert with 'NH{q', 18
                                                if 0 / mem[160]:
                                                    revert with 0, 'ds-math-mul-overflow'
                                            if mem[128] and 10000 > -1 / mem[128]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[128] / 10000 != mem[128]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[128] > -1:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[128] < 10000 * mem[128]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not 10000 * mem[128]:
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4133]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4133 + 32] = 0 / 10000 * mem[128]
                                        else:
                                            if mem[(32 * idx) + _4133 + 32] and -mem[_8265 + 128] + 10000 > -1 / mem[(32 * idx) + _4133 + 32]:
                                                revert with 'NH{q', 17
                                            if not -mem[_8265 + 128] + 10000:
                                                revert with 'NH{q', 18
                                            if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) / -mem[_8265 + 128] + 10000 != mem[(32 * idx) + _4133 + 32]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if not mem[160]:
                                                if mem[128] and 10000 > -1 / mem[128]:
                                                    revert with 'NH{q', 17
                                                if 10000 * mem[128] / 10000 != mem[128]:
                                                    revert with 0, 'ds-math-mul-overflow'
                                                if 10000 * mem[128] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                                    revert with 'NH{q', 17
                                                if (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[128]:
                                                    revert with 0, 'ds-math-add-overflow'
                                                if not (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                    revert with 'NH{q', 18
                                                if idx > -2:
                                                    revert with 'NH{q', 17
                                                if idx + 1 >= mem[_4133]:
                                                    revert with 'NH{q', 50
                                                mem[(32 * idx + 1) + _4133 + 32] = 0 / (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32])
                                            else:
                                                if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) and mem[160] > -1 / (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                    revert with 'NH{q', 17
                                                if not mem[160]:
                                                    revert with 'NH{q', 18
                                                if (10000 * mem[(32 * idx) + _4133 + 32] * mem[160]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32] * mem[160]) / mem[160] != (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                    revert with 0, 'ds-math-mul-overflow'
                                                if mem[128] and 10000 > -1 / mem[128]:
                                                    revert with 'NH{q', 17
                                                if 10000 * mem[128] / 10000 != mem[128]:
                                                    revert with 0, 'ds-math-mul-overflow'
                                                if 10000 * mem[128] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                                    revert with 'NH{q', 17
                                                if (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[128]:
                                                    revert with 0, 'ds-math-add-overflow'
                                                if not (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                    revert with 'NH{q', 18
                                                if idx > -2:
                                                    revert with 'NH{q', 17
                                                if idx + 1 >= mem[_4133]:
                                                    revert with 'NH{q', 50
                                                mem[(32 * idx + 1) + _4133 + 32] = (10000 * mem[(32 * idx) + _4133 + 32] * mem[160]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32] * mem[160]) / (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32])
                                    else:
                                        if mem[160] <= 0:
                                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                        if mem[128] <= 0:
                                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                        if 10000 < mem[_8265 + 128]:
                                            revert with 'NH{q', 17
                                        if not -mem[_8265 + 128] + 10000:
                                            if mem[128]:
                                                if False and mem[128] > 0:
                                                    revert with 'NH{q', 17
                                                if not mem[128]:
                                                    revert with 'NH{q', 18
                                                if 0 / mem[128]:
                                                    revert with 0, 'ds-math-mul-overflow'
                                            if mem[160] and 10000 > -1 / mem[160]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[160] / 10000 != mem[160]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[160] > -1:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[160] < 10000 * mem[160]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not 10000 * mem[160]:
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4133]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4133 + 32] = 0 / 10000 * mem[160]
                                        else:
                                            if mem[(32 * idx) + _4133 + 32] and -mem[_8265 + 128] + 10000 > -1 / mem[(32 * idx) + _4133 + 32]:
                                                revert with 'NH{q', 17
                                            if not -mem[_8265 + 128] + 10000:
                                                revert with 'NH{q', 18
                                            if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) / -mem[_8265 + 128] + 10000 != mem[(32 * idx) + _4133 + 32]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if not mem[128]:
                                                if mem[160] and 10000 > -1 / mem[160]:
                                                    revert with 'NH{q', 17
                                                if 10000 * mem[160] / 10000 != mem[160]:
                                                    revert with 0, 'ds-math-mul-overflow'
                                                if 10000 * mem[160] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                                    revert with 'NH{q', 17
                                                if (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[160]:
                                                    revert with 0, 'ds-math-add-overflow'
                                                if not (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                    revert with 'NH{q', 18
                                                if idx > -2:
                                                    revert with 'NH{q', 17
                                                if idx + 1 >= mem[_4133]:
                                                    revert with 'NH{q', 50
                                                mem[(32 * idx + 1) + _4133 + 32] = 0 / (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32])
                                            else:
                                                if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) and mem[128] > -1 / (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                    revert with 'NH{q', 17
                                                if not mem[128]:
                                                    revert with 'NH{q', 18
                                                if (10000 * mem[(32 * idx) + _4133 + 32] * mem[128]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32] * mem[128]) / mem[128] != (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                    revert with 0, 'ds-math-mul-overflow'
                                                if mem[160] and 10000 > -1 / mem[160]:
                                                    revert with 'NH{q', 17
                                                if 10000 * mem[160] / 10000 != mem[160]:
                                                    revert with 0, 'ds-math-mul-overflow'
                                                if 10000 * mem[160] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                                    revert with 'NH{q', 17
                                                if (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[160]:
                                                    revert with 0, 'ds-math-add-overflow'
                                                if not (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                    revert with 'NH{q', 18
                                                if idx > -2:
                                                    revert with 'NH{q', 17
                                                if idx + 1 >= mem[_4133]:
                                                    revert with 'NH{q', 50
                                                mem[(32 * idx + 1) + _4133 + 32] = (10000 * mem[(32 * idx) + _4133 + 32] * mem[128]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32] * mem[128]) / (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32])
                                else:
                                    _12422 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size) + 1
                                    mem[_12422] = return_data.size
                                    mem[_12422 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    if idx >= mem[_4133]:
                                        revert with 'NH{q', 50
                                    if mem[(32 * idx) + _4133 + 32] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                    if mem[_8265 + 12 len 20] == address(_8303):
                                        if mem[_12422 + 32] <= 0:
                                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                        if mem[_12422 + 64] <= 0:
                                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                        if 10000 < mem[_8265 + 128]:
                                            revert with 'NH{q', 17
                                        if not -mem[_8265 + 128] + 10000:
                                            if mem[_12422 + 64]:
                                                if False and mem[_12422 + 64] > 0:
                                                    revert with 'NH{q', 17
                                                if not mem[_12422 + 64]:
                                                    revert with 'NH{q', 18
                                                if 0 / mem[_12422 + 64]:
                                                    revert with 0, 'ds-math-mul-overflow'
                                            if mem[_12422 + 32] and 10000 > -1 / mem[_12422 + 32]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[_12422 + 32] / 10000 != mem[_12422 + 32]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[_12422 + 32] > -1:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[_12422 + 32] < 10000 * mem[_12422 + 32]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not 10000 * mem[_12422 + 32]:
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4133]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4133 + 32] = 0 / 10000 * mem[_12422 + 32]
                                        else:
                                            if mem[(32 * idx) + _4133 + 32] and -mem[_8265 + 128] + 10000 > -1 / mem[(32 * idx) + _4133 + 32]:
                                                revert with 'NH{q', 17
                                            if not -mem[_8265 + 128] + 10000:
                                                revert with 'NH{q', 18
                                            if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) / -mem[_8265 + 128] + 10000 != mem[(32 * idx) + _4133 + 32]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if not mem[_12422 + 64]:
                                                if mem[_12422 + 32] and 10000 > -1 / mem[_12422 + 32]:
                                                    revert with 'NH{q', 17
                                                if 10000 * mem[_12422 + 32] / 10000 != mem[_12422 + 32]:
                                                    revert with 0, 'ds-math-mul-overflow'
                                                if 10000 * mem[_12422 + 32] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                                    revert with 'NH{q', 17
                                                if (10000 * mem[_12422 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[_12422 + 32]:
                                                    revert with 0, 'ds-math-add-overflow'
                                                if not (10000 * mem[_12422 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                    revert with 'NH{q', 18
                                                if idx > -2:
                                                    revert with 'NH{q', 17
                                                if idx + 1 >= mem[_4133]:
                                                    revert with 'NH{q', 50
                                                mem[(32 * idx + 1) + _4133 + 32] = 0 / (10000 * mem[_12422 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32])
                                            else:
                                                if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) and mem[_12422 + 64] > -1 / (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                    revert with 'NH{q', 17
                                                if not mem[_12422 + 64]:
                                                    revert with 'NH{q', 18
                                                if (10000 * mem[(32 * idx) + _4133 + 32] * mem[_12422 + 64]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32] * mem[_12422 + 64]) / mem[_12422 + 64] != (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                    revert with 0, 'ds-math-mul-overflow'
                                                if mem[_12422 + 32] and 10000 > -1 / mem[_12422 + 32]:
                                                    revert with 'NH{q', 17
                                                if 10000 * mem[_12422 + 32] / 10000 != mem[_12422 + 32]:
                                                    revert with 0, 'ds-math-mul-overflow'
                                                if 10000 * mem[_12422 + 32] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                                    revert with 'NH{q', 17
                                                if (10000 * mem[_12422 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[_12422 + 32]:
                                                    revert with 0, 'ds-math-add-overflow'
                                                if not (10000 * mem[_12422 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                    revert with 'NH{q', 18
                                                if idx > -2:
                                                    revert with 'NH{q', 17
                                                if idx + 1 >= mem[_4133]:
                                                    revert with 'NH{q', 50
                                                mem[(32 * idx + 1) + _4133 + 32] = (10000 * mem[(32 * idx) + _4133 + 32] * mem[_12422 + 64]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32] * mem[_12422 + 64]) / (10000 * mem[_12422 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32])
                                    else:
                                        if mem[_12422 + 64] <= 0:
                                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                        if mem[_12422 + 32] <= 0:
                                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                        if 10000 < mem[_8265 + 128]:
                                            revert with 'NH{q', 17
                                        if not -mem[_8265 + 128] + 10000:
                                            if mem[_12422 + 32]:
                                                if False and mem[_12422 + 32] > 0:
                                                    revert with 'NH{q', 17
                                                if not mem[_12422 + 32]:
                                                    revert with 'NH{q', 18
                                                if 0 / mem[_12422 + 32]:
                                                    revert with 0, 'ds-math-mul-overflow'
                                            if mem[_12422 + 64] and 10000 > -1 / mem[_12422 + 64]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[_12422 + 64] / 10000 != mem[_12422 + 64]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[_12422 + 64] > -1:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[_12422 + 64] < 10000 * mem[_12422 + 64]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not 10000 * mem[_12422 + 64]:
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4133]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4133 + 32] = 0 / 10000 * mem[_12422 + 64]
                                        else:
                                            if mem[(32 * idx) + _4133 + 32] and -mem[_8265 + 128] + 10000 > -1 / mem[(32 * idx) + _4133 + 32]:
                                                revert with 'NH{q', 17
                                            if not -mem[_8265 + 128] + 10000:
                                                revert with 'NH{q', 18
                                            if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) / -mem[_8265 + 128] + 10000 != mem[(32 * idx) + _4133 + 32]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if not mem[_12422 + 32]:
                                                if mem[_12422 + 64] and 10000 > -1 / mem[_12422 + 64]:
                                                    revert with 'NH{q', 17
                                                if 10000 * mem[_12422 + 64] / 10000 != mem[_12422 + 64]:
                                                    revert with 0, 'ds-math-mul-overflow'
                                                if 10000 * mem[_12422 + 64] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                                    revert with 'NH{q', 17
                                                if (10000 * mem[_12422 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[_12422 + 64]:
                                                    revert with 0, 'ds-math-add-overflow'
                                                if not (10000 * mem[_12422 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                    revert with 'NH{q', 18
                                                if idx > -2:
                                                    revert with 'NH{q', 17
                                                if idx + 1 >= mem[_4133]:
                                                    revert with 'NH{q', 50
                                                mem[(32 * idx + 1) + _4133 + 32] = 0 / (10000 * mem[_12422 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32])
                                            else:
                                                if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) and mem[_12422 + 32] > -1 / (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                    revert with 'NH{q', 17
                                                if not mem[_12422 + 32]:
                                                    revert with 'NH{q', 18
                                                if (10000 * mem[(32 * idx) + _4133 + 32] * mem[_12422 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32] * mem[_12422 + 32]) / mem[_12422 + 32] != (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                    revert with 0, 'ds-math-mul-overflow'
                                                if mem[_12422 + 64] and 10000 > -1 / mem[_12422 + 64]:
                                                    revert with 'NH{q', 17
                                                if 10000 * mem[_12422 + 64] / 10000 != mem[_12422 + 64]:
                                                    revert with 0, 'ds-math-mul-overflow'
                                                if 10000 * mem[_12422 + 64] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                                    revert with 'NH{q', 17
                                                if (10000 * mem[_12422 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[_12422 + 64]:
                                                    revert with 0, 'ds-math-add-overflow'
                                                if not (10000 * mem[_12422 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                    revert with 'NH{q', 18
                                                if idx > -2:
                                                    revert with 'NH{q', 17
                                                if idx + 1 >= mem[_4133]:
                                                    revert with 'NH{q', 50
                                                mem[(32 * idx + 1) + _4133 + 32] = (10000 * mem[(32 * idx) + _4133 + 32] * mem[_12422 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32] * mem[_12422 + 32]) / (10000 * mem[_12422 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32])
                            else:
                                mem[_8378 + _8461 + 36] = 0
                                staticcall address(_8344).mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _8378 + _8461 + -mem[64] + 32]
                                if not return_data.size:
                                    if idx >= mem[_4133]:
                                        revert with 'NH{q', 50
                                    if mem[(32 * idx) + _4133 + 32] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                    if mem[_8265 + 12 len 20] == address(_8303):
                                        if mem[128] <= 0:
                                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                        if mem[160] <= 0:
                                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                        if 10000 < mem[_8265 + 128]:
                                            revert with 'NH{q', 17
                                        if not -mem[_8265 + 128] + 10000:
                                            if mem[160]:
                                                if False and mem[160] > 0:
                                                    revert with 'NH{q', 17
                                                if not mem[160]:
                                                    revert with 'NH{q', 18
                                                if 0 / mem[160]:
                                                    revert with 0, 'ds-math-mul-overflow'
                                            if mem[128] and 10000 > -1 / mem[128]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[128] / 10000 != mem[128]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[128] > -1:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[128] < 10000 * mem[128]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not 10000 * mem[128]:
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4133]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4133 + 32] = 0 / 10000 * mem[128]
                                        else:
                                            if mem[(32 * idx) + _4133 + 32] and -mem[_8265 + 128] + 10000 > -1 / mem[(32 * idx) + _4133 + 32]:
                                                revert with 'NH{q', 17
                                            if not -mem[_8265 + 128] + 10000:
                                                revert with 'NH{q', 18
                                            if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) / -mem[_8265 + 128] + 10000 != mem[(32 * idx) + _4133 + 32]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if not mem[160]:
                                                if mem[128] and 10000 > -1 / mem[128]:
                                                    revert with 'NH{q', 17
                                                if 10000 * mem[128] / 10000 != mem[128]:
                                                    revert with 0, 'ds-math-mul-overflow'
                                                if 10000 * mem[128] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                                    revert with 'NH{q', 17
                                                if (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[128]:
                                                    revert with 0, 'ds-math-add-overflow'
                                                if not (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                    revert with 'NH{q', 18
                                                if idx > -2:
                                                    revert with 'NH{q', 17
                                                if idx + 1 >= mem[_4133]:
                                                    revert with 'NH{q', 50
                                                mem[(32 * idx + 1) + _4133 + 32] = 0 / (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32])
                                            else:
                                                if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) and mem[160] > -1 / (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                    revert with 'NH{q', 17
                                                if not mem[160]:
                                                    revert with 'NH{q', 18
                                                if (10000 * mem[(32 * idx) + _4133 + 32] * mem[160]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32] * mem[160]) / mem[160] != (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                    revert with 0, 'ds-math-mul-overflow'
                                                if mem[128] and 10000 > -1 / mem[128]:
                                                    revert with 'NH{q', 17
                                                if 10000 * mem[128] / 10000 != mem[128]:
                                                    revert with 0, 'ds-math-mul-overflow'
                                                if 10000 * mem[128] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                                    revert with 'NH{q', 17
                                                if (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[128]:
                                                    revert with 0, 'ds-math-add-overflow'
                                                if not (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                    revert with 'NH{q', 18
                                                if idx > -2:
                                                    revert with 'NH{q', 17
                                                if idx + 1 >= mem[_4133]:
                                                    revert with 'NH{q', 50
                                                mem[(32 * idx + 1) + _4133 + 32] = (10000 * mem[(32 * idx) + _4133 + 32] * mem[160]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32] * mem[160]) / (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32])
                                    else:
                                        if mem[160] <= 0:
                                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                        if mem[128] <= 0:
                                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                        if 10000 < mem[_8265 + 128]:
                                            revert with 'NH{q', 17
                                        if not -mem[_8265 + 128] + 10000:
                                            if mem[128]:
                                                if False and mem[128] > 0:
                                                    revert with 'NH{q', 17
                                                if not mem[128]:
                                                    revert with 'NH{q', 18
                                                if 0 / mem[128]:
                                                    revert with 0, 'ds-math-mul-overflow'
                                            if mem[160] and 10000 > -1 / mem[160]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[160] / 10000 != mem[160]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[160] > -1:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[160] < 10000 * mem[160]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not 10000 * mem[160]:
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4133]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4133 + 32] = 0 / 10000 * mem[160]
                                        else:
                                            if mem[(32 * idx) + _4133 + 32] and -mem[_8265 + 128] + 10000 > -1 / mem[(32 * idx) + _4133 + 32]:
                                                revert with 'NH{q', 17
                                            if not -mem[_8265 + 128] + 10000:
                                                revert with 'NH{q', 18
                                            if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) / -mem[_8265 + 128] + 10000 != mem[(32 * idx) + _4133 + 32]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if not mem[128]:
                                                if mem[160] and 10000 > -1 / mem[160]:
                                                    revert with 'NH{q', 17
                                                if 10000 * mem[160] / 10000 != mem[160]:
                                                    revert with 0, 'ds-math-mul-overflow'
                                                if 10000 * mem[160] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                                    revert with 'NH{q', 17
                                                if (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[160]:
                                                    revert with 0, 'ds-math-add-overflow'
                                                if not (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                    revert with 'NH{q', 18
                                                if idx > -2:
                                                    revert with 'NH{q', 17
                                                if idx + 1 >= mem[_4133]:
                                                    revert with 'NH{q', 50
                                                mem[(32 * idx + 1) + _4133 + 32] = 0 / (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32])
                                            else:
                                                if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) and mem[128] > -1 / (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                    revert with 'NH{q', 17
                                                if not mem[128]:
                                                    revert with 'NH{q', 18
                                                if (10000 * mem[(32 * idx) + _4133 + 32] * mem[128]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32] * mem[128]) / mem[128] != (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                    revert with 0, 'ds-math-mul-overflow'
                                                if mem[160] and 10000 > -1 / mem[160]:
                                                    revert with 'NH{q', 17
                                                if 10000 * mem[160] / 10000 != mem[160]:
                                                    revert with 0, 'ds-math-mul-overflow'
                                                if 10000 * mem[160] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                                    revert with 'NH{q', 17
                                                if (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[160]:
                                                    revert with 0, 'ds-math-add-overflow'
                                                if not (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                    revert with 'NH{q', 18
                                                if idx > -2:
                                                    revert with 'NH{q', 17
                                                if idx + 1 >= mem[_4133]:
                                                    revert with 'NH{q', 50
                                                mem[(32 * idx + 1) + _4133 + 32] = (10000 * mem[(32 * idx) + _4133 + 32] * mem[128]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32] * mem[128]) / (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32])
                                else:
                                    _12457 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size) + 1
                                    mem[_12457] = return_data.size
                                    mem[_12457 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    if idx >= mem[_4133]:
                                        revert with 'NH{q', 50
                                    if mem[(32 * idx) + _4133 + 32] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                    if mem[_8265 + 12 len 20] == address(_8303):
                                        if mem[_12457 + 32] <= 0:
                                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                        if mem[_12457 + 64] <= 0:
                                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                        if 10000 < mem[_8265 + 128]:
                                            revert with 'NH{q', 17
                                        if not -mem[_8265 + 128] + 10000:
                                            if mem[_12457 + 64]:
                                                if False and mem[_12457 + 64] > 0:
                                                    revert with 'NH{q', 17
                                                if not mem[_12457 + 64]:
                                                    revert with 'NH{q', 18
                                                if 0 / mem[_12457 + 64]:
                                                    revert with 0, 'ds-math-mul-overflow'
                                            if mem[_12457 + 32] and 10000 > -1 / mem[_12457 + 32]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[_12457 + 32] / 10000 != mem[_12457 + 32]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[_12457 + 32] > -1:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[_12457 + 32] < 10000 * mem[_12457 + 32]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not 10000 * mem[_12457 + 32]:
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4133]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4133 + 32] = 0 / 10000 * mem[_12457 + 32]
                                        else:
                                            if mem[(32 * idx) + _4133 + 32] and -mem[_8265 + 128] + 10000 > -1 / mem[(32 * idx) + _4133 + 32]:
                                                revert with 'NH{q', 17
                                            if not -mem[_8265 + 128] + 10000:
                                                revert with 'NH{q', 18
                                            if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) / -mem[_8265 + 128] + 10000 != mem[(32 * idx) + _4133 + 32]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if not mem[_12457 + 64]:
                                                if mem[_12457 + 32] and 10000 > -1 / mem[_12457 + 32]:
                                                    revert with 'NH{q', 17
                                                if 10000 * mem[_12457 + 32] / 10000 != mem[_12457 + 32]:
                                                    revert with 0, 'ds-math-mul-overflow'
                                                if 10000 * mem[_12457 + 32] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                                    revert with 'NH{q', 17
                                                if (10000 * mem[_12457 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[_12457 + 32]:
                                                    revert with 0, 'ds-math-add-overflow'
                                                if not (10000 * mem[_12457 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                    revert with 'NH{q', 18
                                                if idx > -2:
                                                    revert with 'NH{q', 17
                                                if idx + 1 >= mem[_4133]:
                                                    revert with 'NH{q', 50
                                                mem[(32 * idx + 1) + _4133 + 32] = 0 / (10000 * mem[_12457 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32])
                                            else:
                                                if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) and mem[_12457 + 64] > -1 / (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                    revert with 'NH{q', 17
                                                if not mem[_12457 + 64]:
                                                    revert with 'NH{q', 18
                                                if (10000 * mem[(32 * idx) + _4133 + 32] * mem[_12457 + 64]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32] * mem[_12457 + 64]) / mem[_12457 + 64] != (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                    revert with 0, 'ds-math-mul-overflow'
                                                if mem[_12457 + 32] and 10000 > -1 / mem[_12457 + 32]:
                                                    revert with 'NH{q', 17
                                                if 10000 * mem[_12457 + 32] / 10000 != mem[_12457 + 32]:
                                                    revert with 0, 'ds-math-mul-overflow'
                                                if 10000 * mem[_12457 + 32] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                                    revert with 'NH{q', 17
                                                if (10000 * mem[_12457 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[_12457 + 32]:
                                                    revert with 0, 'ds-math-add-overflow'
                                                if not (10000 * mem[_12457 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                    revert with 'NH{q', 18
                                                if idx > -2:
                                                    revert with 'NH{q', 17
                                                if idx + 1 >= mem[_4133]:
                                                    revert with 'NH{q', 50
                                                mem[(32 * idx + 1) + _4133 + 32] = (10000 * mem[(32 * idx) + _4133 + 32] * mem[_12457 + 64]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32] * mem[_12457 + 64]) / (10000 * mem[_12457 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32])
                                    else:
                                        if mem[_12457 + 64] <= 0:
                                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                        if mem[_12457 + 32] <= 0:
                                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                        if 10000 < mem[_8265 + 128]:
                                            revert with 'NH{q', 17
                                        if not -mem[_8265 + 128] + 10000:
                                            if mem[_12457 + 32]:
                                                if False and mem[_12457 + 32] > 0:
                                                    revert with 'NH{q', 17
                                                if not mem[_12457 + 32]:
                                                    revert with 'NH{q', 18
                                                if 0 / mem[_12457 + 32]:
                                                    revert with 0, 'ds-math-mul-overflow'
                                            if mem[_12457 + 64] and 10000 > -1 / mem[_12457 + 64]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[_12457 + 64] / 10000 != mem[_12457 + 64]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[_12457 + 64] > -1:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[_12457 + 64] < 10000 * mem[_12457 + 64]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not 10000 * mem[_12457 + 64]:
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4133]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4133 + 32] = 0 / 10000 * mem[_12457 + 64]
                                        else:
                                            if mem[(32 * idx) + _4133 + 32] and -mem[_8265 + 128] + 10000 > -1 / mem[(32 * idx) + _4133 + 32]:
                                                revert with 'NH{q', 17
                                            if not -mem[_8265 + 128] + 10000:
                                                revert with 'NH{q', 18
                                            if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) / -mem[_8265 + 128] + 10000 != mem[(32 * idx) + _4133 + 32]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if not mem[_12457 + 32]:
                                                if mem[_12457 + 64] and 10000 > -1 / mem[_12457 + 64]:
                                                    revert with 'NH{q', 17
                                                if 10000 * mem[_12457 + 64] / 10000 != mem[_12457 + 64]:
                                                    revert with 0, 'ds-math-mul-overflow'
                                                if 10000 * mem[_12457 + 64] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                                    revert with 'NH{q', 17
                                                if (10000 * mem[_12457 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[_12457 + 64]:
                                                    revert with 0, 'ds-math-add-overflow'
                                                if not (10000 * mem[_12457 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                    revert with 'NH{q', 18
                                                if idx > -2:
                                                    revert with 'NH{q', 17
                                                if idx + 1 >= mem[_4133]:
                                                    revert with 'NH{q', 50
                                                mem[(32 * idx + 1) + _4133 + 32] = 0 / (10000 * mem[_12457 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32])
                                            else:
                                                if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) and mem[_12457 + 32] > -1 / (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                    revert with 'NH{q', 17
                                                if not mem[_12457 + 32]:
                                                    revert with 'NH{q', 18
                                                if (10000 * mem[(32 * idx) + _4133 + 32] * mem[_12457 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32] * mem[_12457 + 32]) / mem[_12457 + 32] != (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                    revert with 0, 'ds-math-mul-overflow'
                                                if mem[_12457 + 64] and 10000 > -1 / mem[_12457 + 64]:
                                                    revert with 'NH{q', 17
                                                if 10000 * mem[_12457 + 64] / 10000 != mem[_12457 + 64]:
                                                    revert with 0, 'ds-math-mul-overflow'
                                                if 10000 * mem[_12457 + 64] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                                    revert with 'NH{q', 17
                                                if (10000 * mem[_12457 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[_12457 + 64]:
                                                    revert with 0, 'ds-math-add-overflow'
                                                if not (10000 * mem[_12457 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                    revert with 'NH{q', 18
                                                if idx > -2:
                                                    revert with 'NH{q', 17
                                                if idx + 1 >= mem[_4133]:
                                                    revert with 'NH{q', 50
                                                mem[(32 * idx + 1) + _4133 + 32] = (10000 * mem[(32 * idx) + _4133 + 32] * mem[_12457 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32] * mem[_12457 + 32]) / (10000 * mem[_12457 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32])
                        else:
                            _8345 = mem[mem[(32 * idx) + 128] + 64]
                            _8382 = mem[64]
                            _8383 = mem[64]
                            mem[mem[64]] = 4
                            mem[64] = mem[64] + 36
                            mem[_8383 + 32] = mem[_8383 + 36 len 28] or 0x902f1ac00000000000000000000000000000000000000000000000000000000
                            _8462 = mem[_8383]
                            s = 0
                            while s < _8462:
                                mem[_8382 + s + 36] = mem[_8383 + s + 32]
                                _8260 = mem[96]
                                s = s + 32
                                continue 
                            if ceil32(_8462) <= _8462:
                                staticcall address(_8345).mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _8382 + _8462 + -mem[64] + 32]
                                if not return_data.size:
                                    if idx >= mem[_4133]:
                                        revert with 'NH{q', 50
                                    if mem[(32 * idx) + _4133 + 32] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                    if mem[_8265 + 12 len 20] == address(_8304):
                                        if mem[128] <= 0:
                                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                        if mem[160] <= 0:
                                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                        if 10000 < mem[_8265 + 128]:
                                            revert with 'NH{q', 17
                                        if not -mem[_8265 + 128] + 10000:
                                            if mem[160]:
                                                if False and mem[160] > 0:
                                                    revert with 'NH{q', 17
                                                if not mem[160]:
                                                    revert with 'NH{q', 18
                                                if 0 / mem[160]:
                                                    revert with 0, 'ds-math-mul-overflow'
                                            if mem[128] and 10000 > -1 / mem[128]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[128] / 10000 != mem[128]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[128] > -1:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[128] < 10000 * mem[128]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not 10000 * mem[128]:
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4133]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4133 + 32] = 0 / 10000 * mem[128]
                                        else:
                                            if mem[(32 * idx) + _4133 + 32] and -mem[_8265 + 128] + 10000 > -1 / mem[(32 * idx) + _4133 + 32]:
                                                revert with 'NH{q', 17
                                            if not -mem[_8265 + 128] + 10000:
                                                revert with 'NH{q', 18
                                            if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) / -mem[_8265 + 128] + 10000 != mem[(32 * idx) + _4133 + 32]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if not mem[160]:
                                                if mem[128] and 10000 > -1 / mem[128]:
                                                    revert with 'NH{q', 17
                                                if 10000 * mem[128] / 10000 != mem[128]:
                                                    revert with 0, 'ds-math-mul-overflow'
                                                if 10000 * mem[128] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                                    revert with 'NH{q', 17
                                                if (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[128]:
                                                    revert with 0, 'ds-math-add-overflow'
                                                if not (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                    revert with 'NH{q', 18
                                                if idx > -2:
                                                    revert with 'NH{q', 17
                                                if idx + 1 >= mem[_4133]:
                                                    revert with 'NH{q', 50
                                                mem[(32 * idx + 1) + _4133 + 32] = 0 / (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32])
                                            else:
                                                if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) and mem[160] > -1 / (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                    revert with 'NH{q', 17
                                                if not mem[160]:
                                                    revert with 'NH{q', 18
                                                if (10000 * mem[(32 * idx) + _4133 + 32] * mem[160]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32] * mem[160]) / mem[160] != (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                    revert with 0, 'ds-math-mul-overflow'
                                                if mem[128] and 10000 > -1 / mem[128]:
                                                    revert with 'NH{q', 17
                                                if 10000 * mem[128] / 10000 != mem[128]:
                                                    revert with 0, 'ds-math-mul-overflow'
                                                if 10000 * mem[128] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                                    revert with 'NH{q', 17
                                                if (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[128]:
                                                    revert with 0, 'ds-math-add-overflow'
                                                if not (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                    revert with 'NH{q', 18
                                                if idx > -2:
                                                    revert with 'NH{q', 17
                                                if idx + 1 >= mem[_4133]:
                                                    revert with 'NH{q', 50
                                                mem[(32 * idx + 1) + _4133 + 32] = (10000 * mem[(32 * idx) + _4133 + 32] * mem[160]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32] * mem[160]) / (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32])
                                    else:
                                        if mem[160] <= 0:
                                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                        if mem[128] <= 0:
                                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                        if 10000 < mem[_8265 + 128]:
                                            revert with 'NH{q', 17
                                        if not -mem[_8265 + 128] + 10000:
                                            if mem[128]:
                                                if False and mem[128] > 0:
                                                    revert with 'NH{q', 17
                                                if not mem[128]:
                                                    revert with 'NH{q', 18
                                                if 0 / mem[128]:
                                                    revert with 0, 'ds-math-mul-overflow'
                                            if mem[160] and 10000 > -1 / mem[160]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[160] / 10000 != mem[160]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[160] > -1:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[160] < 10000 * mem[160]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not 10000 * mem[160]:
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4133]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4133 + 32] = 0 / 10000 * mem[160]
                                        else:
                                            if mem[(32 * idx) + _4133 + 32] and -mem[_8265 + 128] + 10000 > -1 / mem[(32 * idx) + _4133 + 32]:
                                                revert with 'NH{q', 17
                                            if not -mem[_8265 + 128] + 10000:
                                                revert with 'NH{q', 18
                                            if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) / -mem[_8265 + 128] + 10000 != mem[(32 * idx) + _4133 + 32]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if not mem[128]:
                                                if mem[160] and 10000 > -1 / mem[160]:
                                                    revert with 'NH{q', 17
                                                if 10000 * mem[160] / 10000 != mem[160]:
                                                    revert with 0, 'ds-math-mul-overflow'
                                                if 10000 * mem[160] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                                    revert with 'NH{q', 17
                                                if (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[160]:
                                                    revert with 0, 'ds-math-add-overflow'
                                                if not (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                    revert with 'NH{q', 18
                                                if idx > -2:
                                                    revert with 'NH{q', 17
                                                if idx + 1 >= mem[_4133]:
                                                    revert with 'NH{q', 50
                                                mem[(32 * idx + 1) + _4133 + 32] = 0 / (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32])
                                            else:
                                                if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) and mem[128] > -1 / (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                    revert with 'NH{q', 17
                                                if not mem[128]:
                                                    revert with 'NH{q', 18
                                                if (10000 * mem[(32 * idx) + _4133 + 32] * mem[128]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32] * mem[128]) / mem[128] != (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                    revert with 0, 'ds-math-mul-overflow'
                                                if mem[160] and 10000 > -1 / mem[160]:
                                                    revert with 'NH{q', 17
                                                if 10000 * mem[160] / 10000 != mem[160]:
                                                    revert with 0, 'ds-math-mul-overflow'
                                                if 10000 * mem[160] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                                    revert with 'NH{q', 17
                                                if (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[160]:
                                                    revert with 0, 'ds-math-add-overflow'
                                                if not (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                    revert with 'NH{q', 18
                                                if idx > -2:
                                                    revert with 'NH{q', 17
                                                if idx + 1 >= mem[_4133]:
                                                    revert with 'NH{q', 50
                                                mem[(32 * idx + 1) + _4133 + 32] = (10000 * mem[(32 * idx) + _4133 + 32] * mem[128]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32] * mem[128]) / (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32])
                                else:
                                    _12424 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size) + 1
                                    mem[_12424] = return_data.size
                                    mem[_12424 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    if idx >= mem[_4133]:
                                        revert with 'NH{q', 50
                                    if mem[(32 * idx) + _4133 + 32] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                    if mem[_8265 + 12 len 20] == address(_8304):
                                        if mem[_12424 + 32] <= 0:
                                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                        if mem[_12424 + 64] <= 0:
                                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                        if 10000 < mem[_8265 + 128]:
                                            revert with 'NH{q', 17
                                        if not -mem[_8265 + 128] + 10000:
                                            if mem[_12424 + 64]:
                                                if False and mem[_12424 + 64] > 0:
                                                    revert with 'NH{q', 17
                                                if not mem[_12424 + 64]:
                                                    revert with 'NH{q', 18
                                                if 0 / mem[_12424 + 64]:
                                                    revert with 0, 'ds-math-mul-overflow'
                                            if mem[_12424 + 32] and 10000 > -1 / mem[_12424 + 32]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[_12424 + 32] / 10000 != mem[_12424 + 32]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[_12424 + 32] > -1:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[_12424 + 32] < 10000 * mem[_12424 + 32]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not 10000 * mem[_12424 + 32]:
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4133]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4133 + 32] = 0 / 10000 * mem[_12424 + 32]
                                        else:
                                            if mem[(32 * idx) + _4133 + 32] and -mem[_8265 + 128] + 10000 > -1 / mem[(32 * idx) + _4133 + 32]:
                                                revert with 'NH{q', 17
                                            if not -mem[_8265 + 128] + 10000:
                                                revert with 'NH{q', 18
                                            if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) / -mem[_8265 + 128] + 10000 != mem[(32 * idx) + _4133 + 32]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if not mem[_12424 + 64]:
                                                if mem[_12424 + 32] and 10000 > -1 / mem[_12424 + 32]:
                                                    revert with 'NH{q', 17
                                                if 10000 * mem[_12424 + 32] / 10000 != mem[_12424 + 32]:
                                                    revert with 0, 'ds-math-mul-overflow'
                                                if 10000 * mem[_12424 + 32] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                                    revert with 'NH{q', 17
                                                if (10000 * mem[_12424 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[_12424 + 32]:
                                                    revert with 0, 'ds-math-add-overflow'
                                                if not (10000 * mem[_12424 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                    revert with 'NH{q', 18
                                                if idx > -2:
                                                    revert with 'NH{q', 17
                                                if idx + 1 >= mem[_4133]:
                                                    revert with 'NH{q', 50
                                                mem[(32 * idx + 1) + _4133 + 32] = 0 / (10000 * mem[_12424 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32])
                                            else:
                                                if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) and mem[_12424 + 64] > -1 / (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                    revert with 'NH{q', 17
                                                if not mem[_12424 + 64]:
                                                    revert with 'NH{q', 18
                                                if (10000 * mem[(32 * idx) + _4133 + 32] * mem[_12424 + 64]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32] * mem[_12424 + 64]) / mem[_12424 + 64] != (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                    revert with 0, 'ds-math-mul-overflow'
                                                if mem[_12424 + 32] and 10000 > -1 / mem[_12424 + 32]:
                                                    revert with 'NH{q', 17
                                                if 10000 * mem[_12424 + 32] / 10000 != mem[_12424 + 32]:
                                                    revert with 0, 'ds-math-mul-overflow'
                                                if 10000 * mem[_12424 + 32] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                                    revert with 'NH{q', 17
                                                if (10000 * mem[_12424 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[_12424 + 32]:
                                                    revert with 0, 'ds-math-add-overflow'
                                                if not (10000 * mem[_12424 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                    revert with 'NH{q', 18
                                                if idx > -2:
                                                    revert with 'NH{q', 17
                                                if idx + 1 >= mem[_4133]:
                                                    revert with 'NH{q', 50
                                                mem[(32 * idx + 1) + _4133 + 32] = (10000 * mem[(32 * idx) + _4133 + 32] * mem[_12424 + 64]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32] * mem[_12424 + 64]) / (10000 * mem[_12424 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32])
                                    else:
                                        if mem[_12424 + 64] <= 0:
                                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                        if mem[_12424 + 32] <= 0:
                                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                        if 10000 < mem[_8265 + 128]:
                                            revert with 'NH{q', 17
                                        if not -mem[_8265 + 128] + 10000:
                                            if mem[_12424 + 32]:
                                                if False and mem[_12424 + 32] > 0:
                                                    revert with 'NH{q', 17
                                                if not mem[_12424 + 32]:
                                                    revert with 'NH{q', 18
                                                if 0 / mem[_12424 + 32]:
                                                    revert with 0, 'ds-math-mul-overflow'
                                            if mem[_12424 + 64] and 10000 > -1 / mem[_12424 + 64]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[_12424 + 64] / 10000 != mem[_12424 + 64]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[_12424 + 64] > -1:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[_12424 + 64] < 10000 * mem[_12424 + 64]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not 10000 * mem[_12424 + 64]:
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4133]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4133 + 32] = 0 / 10000 * mem[_12424 + 64]
                                        else:
                                            if mem[(32 * idx) + _4133 + 32] and -mem[_8265 + 128] + 10000 > -1 / mem[(32 * idx) + _4133 + 32]:
                                                revert with 'NH{q', 17
                                            if not -mem[_8265 + 128] + 10000:
                                                revert with 'NH{q', 18
                                            if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) / -mem[_8265 + 128] + 10000 != mem[(32 * idx) + _4133 + 32]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if not mem[_12424 + 32]:
                                                if mem[_12424 + 64] and 10000 > -1 / mem[_12424 + 64]:
                                                    revert with 'NH{q', 17
                                                if 10000 * mem[_12424 + 64] / 10000 != mem[_12424 + 64]:
                                                    revert with 0, 'ds-math-mul-overflow'
                                                if 10000 * mem[_12424 + 64] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                                    revert with 'NH{q', 17
                                                if (10000 * mem[_12424 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[_12424 + 64]:
                                                    revert with 0, 'ds-math-add-overflow'
                                                if not (10000 * mem[_12424 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                    revert with 'NH{q', 18
                                                if idx > -2:
                                                    revert with 'NH{q', 17
                                                if idx + 1 >= mem[_4133]:
                                                    revert with 'NH{q', 50
                                                mem[(32 * idx + 1) + _4133 + 32] = 0 / (10000 * mem[_12424 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32])
                                            else:
                                                if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) and mem[_12424 + 32] > -1 / (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                    revert with 'NH{q', 17
                                                if not mem[_12424 + 32]:
                                                    revert with 'NH{q', 18
                                                if (10000 * mem[(32 * idx) + _4133 + 32] * mem[_12424 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32] * mem[_12424 + 32]) / mem[_12424 + 32] != (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                    revert with 0, 'ds-math-mul-overflow'
                                                if mem[_12424 + 64] and 10000 > -1 / mem[_12424 + 64]:
                                                    revert with 'NH{q', 17
                                                if 10000 * mem[_12424 + 64] / 10000 != mem[_12424 + 64]:
                                                    revert with 0, 'ds-math-mul-overflow'
                                                if 10000 * mem[_12424 + 64] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                                    revert with 'NH{q', 17
                                                if (10000 * mem[_12424 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[_12424 + 64]:
                                                    revert with 0, 'ds-math-add-overflow'
                                                if not (10000 * mem[_12424 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                    revert with 'NH{q', 18
                                                if idx > -2:
                                                    revert with 'NH{q', 17
                                                if idx + 1 >= mem[_4133]:
                                                    revert with 'NH{q', 50
                                                mem[(32 * idx + 1) + _4133 + 32] = (10000 * mem[(32 * idx) + _4133 + 32] * mem[_12424 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32] * mem[_12424 + 32]) / (10000 * mem[_12424 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32])
                            else:
                                mem[_8382 + _8462 + 36] = 0
                                staticcall address(_8345).mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _8382 + _8462 + -mem[64] + 32]
                                if not return_data.size:
                                    if idx >= mem[_4133]:
                                        revert with 'NH{q', 50
                                    if mem[(32 * idx) + _4133 + 32] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                    if mem[_8265 + 12 len 20] == address(_8304):
                                        if mem[128] <= 0:
                                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                        if mem[160] <= 0:
                                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                        if 10000 < mem[_8265 + 128]:
                                            revert with 'NH{q', 17
                                        if not -mem[_8265 + 128] + 10000:
                                            if mem[160]:
                                                if False and mem[160] > 0:
                                                    revert with 'NH{q', 17
                                                if not mem[160]:
                                                    revert with 'NH{q', 18
                                                if 0 / mem[160]:
                                                    revert with 0, 'ds-math-mul-overflow'
                                            if mem[128] and 10000 > -1 / mem[128]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[128] / 10000 != mem[128]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[128] > -1:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[128] < 10000 * mem[128]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not 10000 * mem[128]:
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4133]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4133 + 32] = 0 / 10000 * mem[128]
                                        else:
                                            if mem[(32 * idx) + _4133 + 32] and -mem[_8265 + 128] + 10000 > -1 / mem[(32 * idx) + _4133 + 32]:
                                                revert with 'NH{q', 17
                                            if not -mem[_8265 + 128] + 10000:
                                                revert with 'NH{q', 18
                                            if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) / -mem[_8265 + 128] + 10000 != mem[(32 * idx) + _4133 + 32]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if not mem[160]:
                                                if mem[128] and 10000 > -1 / mem[128]:
                                                    revert with 'NH{q', 17
                                                if 10000 * mem[128] / 10000 != mem[128]:
                                                    revert with 0, 'ds-math-mul-overflow'
                                                if 10000 * mem[128] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                                    revert with 'NH{q', 17
                                                if (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[128]:
                                                    revert with 0, 'ds-math-add-overflow'
                                                if not (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                    revert with 'NH{q', 18
                                                if idx > -2:
                                                    revert with 'NH{q', 17
                                                if idx + 1 >= mem[_4133]:
                                                    revert with 'NH{q', 50
                                                mem[(32 * idx + 1) + _4133 + 32] = 0 / (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32])
                                            else:
                                                if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) and mem[160] > -1 / (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                    revert with 'NH{q', 17
                                                if not mem[160]:
                                                    revert with 'NH{q', 18
                                                if (10000 * mem[(32 * idx) + _4133 + 32] * mem[160]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32] * mem[160]) / mem[160] != (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                    revert with 0, 'ds-math-mul-overflow'
                                                if mem[128] and 10000 > -1 / mem[128]:
                                                    revert with 'NH{q', 17
                                                if 10000 * mem[128] / 10000 != mem[128]:
                                                    revert with 0, 'ds-math-mul-overflow'
                                                if 10000 * mem[128] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                                    revert with 'NH{q', 17
                                                if (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[128]:
                                                    revert with 0, 'ds-math-add-overflow'
                                                if not (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                    revert with 'NH{q', 18
                                                if idx > -2:
                                                    revert with 'NH{q', 17
                                                if idx + 1 >= mem[_4133]:
                                                    revert with 'NH{q', 50
                                                mem[(32 * idx + 1) + _4133 + 32] = (10000 * mem[(32 * idx) + _4133 + 32] * mem[160]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32] * mem[160]) / (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32])
                                    else:
                                        if mem[160] <= 0:
                                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                        if mem[128] <= 0:
                                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                        if 10000 < mem[_8265 + 128]:
                                            revert with 'NH{q', 17
                                        if not -mem[_8265 + 128] + 10000:
                                            if mem[128]:
                                                if False and mem[128] > 0:
                                                    revert with 'NH{q', 17
                                                if not mem[128]:
                                                    revert with 'NH{q', 18
                                                if 0 / mem[128]:
                                                    revert with 0, 'ds-math-mul-overflow'
                                            if mem[160] and 10000 > -1 / mem[160]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[160] / 10000 != mem[160]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[160] > -1:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[160] < 10000 * mem[160]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not 10000 * mem[160]:
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4133]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4133 + 32] = 0 / 10000 * mem[160]
                                        else:
                                            if mem[(32 * idx) + _4133 + 32] and -mem[_8265 + 128] + 10000 > -1 / mem[(32 * idx) + _4133 + 32]:
                                                revert with 'NH{q', 17
                                            if not -mem[_8265 + 128] + 10000:
                                                revert with 'NH{q', 18
                                            if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) / -mem[_8265 + 128] + 10000 != mem[(32 * idx) + _4133 + 32]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if not mem[128]:
                                                if mem[160] and 10000 > -1 / mem[160]:
                                                    revert with 'NH{q', 17
                                                if 10000 * mem[160] / 10000 != mem[160]:
                                                    revert with 0, 'ds-math-mul-overflow'
                                                if 10000 * mem[160] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                                    revert with 'NH{q', 17
                                                if (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[160]:
                                                    revert with 0, 'ds-math-add-overflow'
                                                if not (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                    revert with 'NH{q', 18
                                                if idx > -2:
                                                    revert with 'NH{q', 17
                                                if idx + 1 >= mem[_4133]:
                                                    revert with 'NH{q', 50
                                                mem[(32 * idx + 1) + _4133 + 32] = 0 / (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32])
                                            else:
                                                if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) and mem[128] > -1 / (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                    revert with 'NH{q', 17
                                                if not mem[128]:
                                                    revert with 'NH{q', 18
                                                if (10000 * mem[(32 * idx) + _4133 + 32] * mem[128]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32] * mem[128]) / mem[128] != (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                    revert with 0, 'ds-math-mul-overflow'
                                                if mem[160] and 10000 > -1 / mem[160]:
                                                    revert with 'NH{q', 17
                                                if 10000 * mem[160] / 10000 != mem[160]:
                                                    revert with 0, 'ds-math-mul-overflow'
                                                if 10000 * mem[160] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                                    revert with 'NH{q', 17
                                                if (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[160]:
                                                    revert with 0, 'ds-math-add-overflow'
                                                if not (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                    revert with 'NH{q', 18
                                                if idx > -2:
                                                    revert with 'NH{q', 17
                                                if idx + 1 >= mem[_4133]:
                                                    revert with 'NH{q', 50
                                                mem[(32 * idx + 1) + _4133 + 32] = (10000 * mem[(32 * idx) + _4133 + 32] * mem[128]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32] * mem[128]) / (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32])
                                else:
                                    _12462 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size) + 1
                                    mem[_12462] = return_data.size
                                    mem[_12462 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    if idx >= mem[_4133]:
                                        revert with 'NH{q', 50
                                    if mem[(32 * idx) + _4133 + 32] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                    if mem[_8265 + 12 len 20] == address(_8304):
                                        if mem[_12462 + 32] <= 0:
                                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                        if mem[_12462 + 64] <= 0:
                                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                        if 10000 < mem[_8265 + 128]:
                                            revert with 'NH{q', 17
                                        if not -mem[_8265 + 128] + 10000:
                                            if mem[_12462 + 64]:
                                                if False and mem[_12462 + 64] > 0:
                                                    revert with 'NH{q', 17
                                                if not mem[_12462 + 64]:
                                                    revert with 'NH{q', 18
                                                if 0 / mem[_12462 + 64]:
                                                    revert with 0, 'ds-math-mul-overflow'
                                            if mem[_12462 + 32] and 10000 > -1 / mem[_12462 + 32]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[_12462 + 32] / 10000 != mem[_12462 + 32]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[_12462 + 32] > -1:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[_12462 + 32] < 10000 * mem[_12462 + 32]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not 10000 * mem[_12462 + 32]:
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4133]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4133 + 32] = 0 / 10000 * mem[_12462 + 32]
                                        else:
                                            if mem[(32 * idx) + _4133 + 32] and -mem[_8265 + 128] + 10000 > -1 / mem[(32 * idx) + _4133 + 32]:
                                                revert with 'NH{q', 17
                                            if not -mem[_8265 + 128] + 10000:
                                                revert with 'NH{q', 18
                                            if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) / -mem[_8265 + 128] + 10000 != mem[(32 * idx) + _4133 + 32]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if not mem[_12462 + 64]:
                                                if mem[_12462 + 32] and 10000 > -1 / mem[_12462 + 32]:
                                                    revert with 'NH{q', 17
                                                if 10000 * mem[_12462 + 32] / 10000 != mem[_12462 + 32]:
                                                    revert with 0, 'ds-math-mul-overflow'
                                                if 10000 * mem[_12462 + 32] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                                    revert with 'NH{q', 17
                                                if (10000 * mem[_12462 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[_12462 + 32]:
                                                    revert with 0, 'ds-math-add-overflow'
                                                if not (10000 * mem[_12462 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                    revert with 'NH{q', 18
                                                if idx > -2:
                                                    revert with 'NH{q', 17
                                                if idx + 1 >= mem[_4133]:
                                                    revert with 'NH{q', 50
                                                mem[(32 * idx + 1) + _4133 + 32] = 0 / (10000 * mem[_12462 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32])
                                            else:
                                                if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) and mem[_12462 + 64] > -1 / (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                    revert with 'NH{q', 17
                                                if not mem[_12462 + 64]:
                                                    revert with 'NH{q', 18
                                                if (10000 * mem[(32 * idx) + _4133 + 32] * mem[_12462 + 64]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32] * mem[_12462 + 64]) / mem[_12462 + 64] != (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                    revert with 0, 'ds-math-mul-overflow'
                                                if mem[_12462 + 32] and 10000 > -1 / mem[_12462 + 32]:
                                                    revert with 'NH{q', 17
                                                if 10000 * mem[_12462 + 32] / 10000 != mem[_12462 + 32]:
                                                    revert with 0, 'ds-math-mul-overflow'
                                                if 10000 * mem[_12462 + 32] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                                    revert with 'NH{q', 17
                                                if (10000 * mem[_12462 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[_12462 + 32]:
                                                    revert with 0, 'ds-math-add-overflow'
                                                if not (10000 * mem[_12462 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                    revert with 'NH{q', 18
                                                if idx > -2:
                                                    revert with 'NH{q', 17
                                                if idx + 1 >= mem[_4133]:
                                                    revert with 'NH{q', 50
                                                mem[(32 * idx + 1) + _4133 + 32] = (10000 * mem[(32 * idx) + _4133 + 32] * mem[_12462 + 64]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32] * mem[_12462 + 64]) / (10000 * mem[_12462 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32])
                                    else:
                                        if mem[_12462 + 64] <= 0:
                                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                        if mem[_12462 + 32] <= 0:
                                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                        if 10000 < mem[_8265 + 128]:
                                            revert with 'NH{q', 17
                                        if not -mem[_8265 + 128] + 10000:
                                            if mem[_12462 + 32]:
                                                if False and mem[_12462 + 32] > 0:
                                                    revert with 'NH{q', 17
                                                if not mem[_12462 + 32]:
                                                    revert with 'NH{q', 18
                                                if 0 / mem[_12462 + 32]:
                                                    revert with 0, 'ds-math-mul-overflow'
                                            if mem[_12462 + 64] and 10000 > -1 / mem[_12462 + 64]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[_12462 + 64] / 10000 != mem[_12462 + 64]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[_12462 + 64] > -1:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[_12462 + 64] < 10000 * mem[_12462 + 64]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not 10000 * mem[_12462 + 64]:
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4133]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4133 + 32] = 0 / 10000 * mem[_12462 + 64]
                                        else:
                                            if mem[(32 * idx) + _4133 + 32] and -mem[_8265 + 128] + 10000 > -1 / mem[(32 * idx) + _4133 + 32]:
                                                revert with 'NH{q', 17
                                            if not -mem[_8265 + 128] + 10000:
                                                revert with 'NH{q', 18
                                            if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) / -mem[_8265 + 128] + 10000 != mem[(32 * idx) + _4133 + 32]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if not mem[_12462 + 32]:
                                                if mem[_12462 + 64] and 10000 > -1 / mem[_12462 + 64]:
                                                    revert with 'NH{q', 17
                                                if 10000 * mem[_12462 + 64] / 10000 != mem[_12462 + 64]:
                                                    revert with 0, 'ds-math-mul-overflow'
                                                if 10000 * mem[_12462 + 64] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                                    revert with 'NH{q', 17
                                                if (10000 * mem[_12462 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[_12462 + 64]:
                                                    revert with 0, 'ds-math-add-overflow'
                                                if not (10000 * mem[_12462 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                    revert with 'NH{q', 18
                                                if idx > -2:
                                                    revert with 'NH{q', 17
                                                if idx + 1 >= mem[_4133]:
                                                    revert with 'NH{q', 50
                                                mem[(32 * idx + 1) + _4133 + 32] = 0 / (10000 * mem[_12462 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32])
                                            else:
                                                if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) and mem[_12462 + 32] > -1 / (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                    revert with 'NH{q', 17
                                                if not mem[_12462 + 32]:
                                                    revert with 'NH{q', 18
                                                if (10000 * mem[(32 * idx) + _4133 + 32] * mem[_12462 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32] * mem[_12462 + 32]) / mem[_12462 + 32] != (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                    revert with 0, 'ds-math-mul-overflow'
                                                if mem[_12462 + 64] and 10000 > -1 / mem[_12462 + 64]:
                                                    revert with 'NH{q', 17
                                                if 10000 * mem[_12462 + 64] / 10000 != mem[_12462 + 64]:
                                                    revert with 0, 'ds-math-mul-overflow'
                                                if 10000 * mem[_12462 + 64] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                                    revert with 'NH{q', 17
                                                if (10000 * mem[_12462 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[_12462 + 64]:
                                                    revert with 0, 'ds-math-add-overflow'
                                                if not (10000 * mem[_12462 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                    revert with 'NH{q', 18
                                                if idx > -2:
                                                    revert with 'NH{q', 17
                                                if idx + 1 >= mem[_4133]:
                                                    revert with 'NH{q', 50
                                                mem[(32 * idx + 1) + _4133 + 32] = (10000 * mem[(32 * idx) + _4133 + 32] * mem[_12462 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32] * mem[_12462 + 32]) / (10000 * mem[_12462 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8265 + 128] * mem[(32 * idx) + _4133 + 32])
                    else:
                        if mem[mem[(32 * idx) + 128] + 160] == 3:
                            _8309 = mem[mem[(32 * idx) + 128] + 64]
                            _8310 = mem[mem[(32 * idx) + 128]]
                            require ext_code.size(mem[mem[(32 * idx) + 128] + 76 len 20])
                            staticcall mem[mem[(32 * idx) + 128] + 76 len 20]._BASE_TOKEN_() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8331 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_8331] == mem[_8331 + 12 len 20]
                            if idx >= mem[_4133]:
                                revert with 'NH{q', 50
                            if mem[_8331 + 12 len 20] != address(_8310):
                                _8592 = mem[(32 * idx) + _4133 + 32]
                                mem[mem[64] + 36] = mem[(32 * idx) + _4133 + 32]
                                require ext_code.size(address(_8309))
                                staticcall address(_8309).querySellQuote(address arg1, uint256 arg2) with:
                                        gas gas_remaining wei
                                       args address(this.address), _8592
                                mem[mem[64] len 64] = ext_call.return_data[0 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _9411 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 64
                                require mem[_9411] == mem[_9411]
                                require mem[_9411 + 32] == mem[_9411 + 32]
                                if idx > -2:
                                    revert with 'NH{q', 17
                                if idx + 1 >= mem[_4133]:
                                    revert with 'NH{q', 50
                                mem[(32 * idx + 1) + _4133 + 32] = mem[_9411]
                            else:
                                _8594 = mem[(32 * idx) + _4133 + 32]
                                mem[mem[64] + 36] = mem[(32 * idx) + _4133 + 32]
                                require ext_code.size(address(_8309))
                                staticcall address(_8309).querySellBase(address arg1, uint256 arg2) with:
                                        gas gas_remaining wei
                                       args address(this.address), _8594
                                mem[mem[64] len 64] = ext_call.return_data[0 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _9412 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 64
                                require mem[_9412] == mem[_9412]
                                require mem[_9412 + 32] == mem[_9412 + 32]
                                if idx > -2:
                                    revert with 'NH{q', 17
                                if idx + 1 >= mem[_4133]:
                                    revert with 'NH{q', 50
                                mem[(32 * idx + 1) + _4133 + 32] = mem[_9412]
                        else:
                            if mem[mem[(32 * idx) + 128] + 160] == 5:
                                _8322 = mem[mem[(32 * idx) + 128] + 96]
                                _8330 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                mem[_8330 + 32 len 64] = call.data[calldata.size len 64]
                                if 0 >= mem[_8330]:
                                    revert with 'NH{q', 50
                                mem[_8330 + 32] = mem[_8265 + 12 len 20]
                                if 1 >= mem[_8330]:
                                    revert with 'NH{q', 50
                                mem[_8330 + 64] = mem[_8265 + 44 len 20]
                                if idx >= mem[_4133]:
                                    revert with 'NH{q', 50
                                _8459 = mem[(32 * idx) + _4133 + 32]
                                mem[_8330 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[_8330 + 100] = _8459
                                mem[_8330 + 132] = 64
                                mem[_8330 + 164] = mem[_8330]
                                s = 0
                                t = _8330 + 32
                                u = _8330 + 196
                                while s < mem[_8330]:
                                    mem[u] = mem[t + 12 len 20]
                                    _8260 = mem[96]
                                    s = s + 1
                                    t = t + 32
                                    u = u + 32
                                    continue 
                                require ext_code.size(address(_8322))
                                staticcall address(_8322).mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _8330 + (32 * mem[_8330]) + -mem[64] + 192]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _12406 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _12452 = mem[_12406]
                                require mem[_12406] <= test266151307()
                                require _12406 + mem[_12406] + 31 < _12406 + return_data.size
                                _12608 = mem[_12406 + mem[_12406]]
                                if mem[_12406 + mem[_12406]] > test266151307():
                                    revert with 'NH{q', 65
                                if _12406 + ceil32(return_data.size) + floor32(mem[_12406 + mem[_12406]]) + 1 > test266151307() or floor32(mem[_12406 + mem[_12406]]) + 1 < 0:
                                    revert with 'NH{q', 65
                                mem[64] = _12406 + ceil32(return_data.size) + floor32(mem[_12406 + mem[_12406]]) + 1
                                mem[_12406 + ceil32(return_data.size)] = _12608
                                require _12452 + (32 * _12608) + 32 <= return_data.size
                                s = 0
                                t = _12406 + _12452 + 32
                                u = _12406 + ceil32(return_data.size) + 32
                                while s < _12608:
                                    require mem[t] == mem[t]
                                    mem[u] = mem[t]
                                    _8260 = mem[96]
                                    s = s + 1
                                    t = t + 32
                                    u = u + 32
                                    continue 
                                if _12608 < 1:
                                    revert with 'NH{q', 17
                                if _12608 - 1 >= _12608:
                                    revert with 'NH{q', 50
                                if idx > -2:
                                    revert with 'NH{q', 17
                                if idx + 1 >= mem[_4133]:
                                    revert with 'NH{q', 50
                                mem[(32 * idx + 1) + _4133 + 32] = mem[(32 * _12608 - 1) + _12406 + ceil32(return_data.size) + 32]
                            else:
                                if mem[mem[(32 * idx) + 128] + 160] == 7:
                                    if idx >= mem[_4133]:
                                        revert with 'NH{q', 50
                                    _8343 = mem[(32 * idx) + _4133 + 32]
                                    _8375 = mem[mem[(32 * idx) + 128] + 32]
                                    _8413 = sha3(address(mem[mem[(32 * idx) + 128]]), sha3(mem[mem[(32 * idx) + 128] + 108 len 20], 0))
                                    mem[0] = mem[mem[(32 * idx) + 128] + 44 len 20]
                                    mem[32] = sha3(address(mem[mem[(32 * idx) + 128] + 96]), 0)
                                    _8415 = sha3(address(_8375), sha3(address(mem[mem[(32 * idx) + 128] + 96]), 0))
                                    if uint256(stor[_8413]) == uint256(sub_f119462d[address(mem[mem[(32 * idx) + 128] + 96])][address(_8375)]):
                                        revert with 0, 'BAD CURVE'
                                    _8457 = mem[mem[(32 * idx) + 128] + 96]
                                    mem[mem[64] + 4] = uint8(stor[_8413])
                                    mem[mem[64] + 36] = uint8(stor[_8415])
                                    mem[mem[64] + 68] = _8343
                                    require ext_code.size(address(_8457))
                                    staticcall address(_8457).calculateSwap(uint8 arg1, uint8 arg2, uint256 arg3) with:
                                            gas gas_remaining wei
                                           args uint8(stor[_8413]), uint8(stor[_8415]), _8343
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _8995 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_8995] == mem[_8995]
                                    if mem[_8995] < 1:
                                        revert with 'NH{q', 17
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4133]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4133 + 32] = mem[_8995] - 1
                                else:
                                    if mem[mem[(32 * idx) + 128] + 160] != 8:
                                        if mem[mem[(32 * idx) + 128] + 160] != 13:
                                            require mem[mem[(32 * idx) + 128] + 160] == 14
                                            _8405 = mem[mem[(32 * idx) + 128] + 32]
                                            if idx >= mem[_4133]:
                                                revert with 'NH{q', 50
                                            _8434 = mem[(32 * idx) + _4133 + 32]
                                            mem[mem[64] + 4] = mem[mem[(32 * idx) + 128] + 12 len 20]
                                            mem[mem[64] + 36] = address(_8405)
                                            mem[mem[64] + 68] = _8434
                                            require ext_code.size(0x66357dcace80431aee0a7507e2e361b7e2402370)
                                            staticcall 0x66357dcace80431aee0a7507e2e361b7e2402370.quotePotentialSwap(address arg1, address arg2, uint256 arg3) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_8405), _8434
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9176 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_9176] == mem[_9176]
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4133]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4133 + 32] = mem[_9176]
                                        else:
                                            _8369 = mem[mem[(32 * idx) + 128]]
                                            _8370 = mem[mem[(32 * idx) + 128] + 32]
                                            if idx >= mem[_4133]:
                                                revert with 'NH{q', 50
                                            _8407 = mem[(32 * idx) + _4133 + 32]
                                            mem[mem[64] + 36] = mem[mem[(32 * idx) + 128] + 12 len 20]
                                            mem[mem[64] + 68] = address(_8370)
                                            mem[mem[64] + 100] = _8407
                                            require ext_code.size(0x9e372b445723e71117b59393aaba05ad3b54ad3f)
                                            staticcall 0x9e372b445723e71117b59393aaba05ad3b54ad3f.0xd7176ca9 with:
                                                    gas gas_remaining wei
                                                   args 0x9ab2de34a33fb459b538c43f251eb825645e8595, address(_8369), address(_8370), _8407
                                            mem[mem[64] len 64] = ext_call.return_data[0 len 64]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9442 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 64
                                            require mem[_9442] == mem[_9442]
                                            require mem[_9442 + 32] == mem[_9442 + 32]
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4133]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4133 + 32] = mem[_9442]
                                    else:
                                        if idx >= mem[_4133]:
                                            revert with 'NH{q', 50
                                        _8372 = mem[(32 * idx) + _4133 + 32]
                                        _8411 = mem[mem[(32 * idx) + 128] + 32]
                                        _8437 = sha3(address(mem[mem[(32 * idx) + 128]]), sha3(mem[mem[(32 * idx) + 128] + 108 len 20], 0))
                                        mem[0] = mem[mem[(32 * idx) + 128] + 44 len 20]
                                        mem[32] = sha3(address(mem[mem[(32 * idx) + 128] + 96]), 0)
                                        _8439 = sha3(address(_8411), sha3(address(mem[mem[(32 * idx) + 128] + 96]), 0))
                                        if uint256(stor[_8437]) == uint256(sub_f119462d[address(mem[mem[(32 * idx) + 128] + 96])][address(_8411)]):
                                            revert with 0, 'BAD CURVE'
                                        if mem[mem[(32 * idx) + 128] + 108 len 20] != 0x58e57ca18b7a47112b877e31929798cd3d703b0f:
                                            if mem[mem[(32 * idx) + 128] + 108 len 20] != 0x7f90122bf0700f9e7e1f688fe926940e8839f353:
                                                if mem[mem[(32 * idx) + 128] + 108 len 20] == 0xaea2e71b631fa93683bcf256a8689dfa0e094fcd:
                                                    _8542 = mem[mem[(32 * idx) + 128] + 96]
                                                    mem[mem[64] + 4] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8437'))))
                                                    mem[mem[64] + 36] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8439'))))
                                                    mem[mem[64] + 68] = _8372
                                                    require ext_code.size(address(_8542))
                                                    staticcall address(_8542).get_dy(int128 arg1, int128 arg2, uint256 arg3) with:
                                                            gas gas_remaining wei
                                                           args ('signextend', 15, ('type', 256, ('stor', ('var', '_8437')))), ('signextend', 15, ('type', 256, ('stor', ('var', '_8439')))), _8372
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _9408 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_9408] == mem[_9408]
                                                    require mem[_9408] > 0
                                                    if mem[_9408] < 1:
                                                        revert with 'NH{q', 17
                                                    if idx > -2:
                                                        revert with 'NH{q', 17
                                                    if idx + 1 >= mem[_4133]:
                                                        revert with 'NH{q', 50
                                                    mem[(32 * idx + 1) + _4133 + 32] = mem[_9408] - 1
                                                else:
                                                    if mem[mem[(32 * idx) + 128] + 108 len 20] == 0x3a43a5851a3e3e0e25a3c1089670269786be1577:
                                                        _8566 = mem[mem[(32 * idx) + 128] + 96]
                                                        mem[mem[64] + 4] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8437'))))
                                                        mem[mem[64] + 36] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8439'))))
                                                        mem[mem[64] + 68] = _8372
                                                        require ext_code.size(address(_8566))
                                                        staticcall address(_8566).get_dy(int128 arg1, int128 arg2, uint256 arg3) with:
                                                                gas gas_remaining wei
                                                               args ('signextend', 15, ('type', 256, ('stor', ('var', '_8437')))), ('signextend', 15, ('type', 256, ('stor', ('var', '_8439')))), _8372
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _9443 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_9443] == mem[_9443]
                                                        require mem[_9443] > 0
                                                        if mem[_9443] < 1:
                                                            revert with 'NH{q', 17
                                                        if idx > -2:
                                                            revert with 'NH{q', 17
                                                        if idx + 1 >= mem[_4133]:
                                                            revert with 'NH{q', 50
                                                        mem[(32 * idx + 1) + _4133 + 32] = mem[_9443] - 1
                                                    else:
                                                        if mem[mem[(32 * idx) + 128] + 108 len 20] == 0x93004d8477f117ea359b71ec02f2706c8175c55c:
                                                            _8590 = mem[mem[(32 * idx) + 128] + 96]
                                                            mem[mem[64] + 4] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8437'))))
                                                            mem[mem[64] + 36] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8439'))))
                                                            mem[mem[64] + 68] = _8372
                                                            require ext_code.size(address(_8590))
                                                            staticcall address(_8590).get_dy(int128 arg1, int128 arg2, uint256 arg3) with:
                                                                    gas gas_remaining wei
                                                                   args ('signextend', 15, ('type', 256, ('stor', ('var', '_8437')))), ('signextend', 15, ('type', 256, ('stor', ('var', '_8439')))), _8372
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _9456 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_9456] == mem[_9456]
                                                            require mem[_9456] > 0
                                                            if mem[_9456] < 1:
                                                                revert with 'NH{q', 17
                                                            if idx > -2:
                                                                revert with 'NH{q', 17
                                                            if idx + 1 >= mem[_4133]:
                                                                revert with 'NH{q', 50
                                                            mem[(32 * idx + 1) + _4133 + 32] = mem[_9456] - 1
                                                        else:
                                                            require mem[mem[(32 * idx) + 128] + 108 len 20] == 0xd79138c49c49200a1afc935171d1bdad084fdc95
                                                            _8638 = mem[mem[(32 * idx) + 128] + 96]
                                                            mem[mem[64] + 4] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8437'))))
                                                            mem[mem[64] + 36] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8439'))))
                                                            mem[mem[64] + 68] = _8372
                                                            require ext_code.size(address(_8638))
                                                            staticcall address(_8638).get_dy(int128 arg1, int128 arg2, uint256 arg3) with:
                                                                    gas gas_remaining wei
                                                                   args ('signextend', 15, ('type', 256, ('stor', ('var', '_8437')))), ('signextend', 15, ('type', 256, ('stor', ('var', '_8439')))), _8372
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _9475 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_9475] == mem[_9475]
                                                            require mem[_9475] > 0
                                                            if mem[_9475] < 1:
                                                                revert with 'NH{q', 17
                                                            if idx > -2:
                                                                revert with 'NH{q', 17
                                                            if idx + 1 >= mem[_4133]:
                                                                revert with 'NH{q', 50
                                                            mem[(32 * idx + 1) + _4133 + 32] = mem[_9475] - 1
                                            else:
                                                _8481 = mem[mem[(32 * idx) + 128] + 96]
                                                mem[mem[64] + 4] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8437'))))
                                                mem[mem[64] + 36] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8439'))))
                                                mem[mem[64] + 68] = _8372
                                                require ext_code.size(address(_8481))
                                                staticcall address(_8481).get_dy_underlying(int128 arg1, int128 arg2, uint256 arg3) with:
                                                        gas gas_remaining wei
                                                       args ('signextend', 15, ('type', 256, ('stor', ('var', '_8437')))), ('signextend', 15, ('type', 256, ('stor', ('var', '_8439')))), _8372
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _9177 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_9177] == mem[_9177]
                                                if mem[_8265 + 108 len 20] == 0xaea2e71b631fa93683bcf256a8689dfa0e094fcd:
                                                    _9679 = mem[_8265 + 96]
                                                    mem[mem[64] + 4] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8437'))))
                                                    mem[mem[64] + 36] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8439'))))
                                                    mem[mem[64] + 68] = _8372
                                                    require ext_code.size(address(_9679))
                                                    staticcall address(_9679).get_dy(int128 arg1, int128 arg2, uint256 arg3) with:
                                                            gas gas_remaining wei
                                                           args ('signextend', 15, ('type', 256, ('stor', ('var', '_8437')))), ('signextend', 15, ('type', 256, ('stor', ('var', '_8439')))), _8372
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _9948 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_9948] == mem[_9948]
                                                    require mem[_9948] > 0
                                                    if mem[_9948] < 1:
                                                        revert with 'NH{q', 17
                                                    if idx > -2:
                                                        revert with 'NH{q', 17
                                                    if idx + 1 >= mem[_4133]:
                                                        revert with 'NH{q', 50
                                                    mem[(32 * idx + 1) + _4133 + 32] = mem[_9948] - 1
                                                else:
                                                    if mem[_8265 + 108 len 20] == 0x3a43a5851a3e3e0e25a3c1089670269786be1577:
                                                        _9684 = mem[_8265 + 96]
                                                        mem[mem[64] + 4] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8437'))))
                                                        mem[mem[64] + 36] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8439'))))
                                                        mem[mem[64] + 68] = _8372
                                                        require ext_code.size(address(_9684))
                                                        staticcall address(_9684).get_dy(int128 arg1, int128 arg2, uint256 arg3) with:
                                                                gas gas_remaining wei
                                                               args ('signextend', 15, ('type', 256, ('stor', ('var', '_8437')))), ('signextend', 15, ('type', 256, ('stor', ('var', '_8439')))), _8372
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _9991 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_9991] == mem[_9991]
                                                        require mem[_9991] > 0
                                                        if mem[_9991] < 1:
                                                            revert with 'NH{q', 17
                                                        if idx > -2:
                                                            revert with 'NH{q', 17
                                                        if idx + 1 >= mem[_4133]:
                                                            revert with 'NH{q', 50
                                                        mem[(32 * idx + 1) + _4133 + 32] = mem[_9991] - 1
                                                    else:
                                                        if mem[_8265 + 108 len 20] == 0x93004d8477f117ea359b71ec02f2706c8175c55c:
                                                            _9691 = mem[_8265 + 96]
                                                            mem[mem[64] + 4] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8437'))))
                                                            mem[mem[64] + 36] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8439'))))
                                                            mem[mem[64] + 68] = _8372
                                                            require ext_code.size(address(_9691))
                                                            staticcall address(_9691).get_dy(int128 arg1, int128 arg2, uint256 arg3) with:
                                                                    gas gas_remaining wei
                                                                   args ('signextend', 15, ('type', 256, ('stor', ('var', '_8437')))), ('signextend', 15, ('type', 256, ('stor', ('var', '_8439')))), _8372
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _10025 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_10025] == mem[_10025]
                                                            require mem[_10025] > 0
                                                            if mem[_10025] < 1:
                                                                revert with 'NH{q', 17
                                                            if idx > -2:
                                                                revert with 'NH{q', 17
                                                            if idx + 1 >= mem[_4133]:
                                                                revert with 'NH{q', 50
                                                            mem[(32 * idx + 1) + _4133 + 32] = mem[_10025] - 1
                                                        else:
                                                            if mem[_8265 + 108 len 20] != 0xd79138c49c49200a1afc935171d1bdad084fdc95:
                                                                require mem[_9177] > 0
                                                                if mem[_9177] < 1:
                                                                    revert with 'NH{q', 17
                                                                if idx > -2:
                                                                    revert with 'NH{q', 17
                                                                if idx + 1 >= mem[_4133]:
                                                                    revert with 'NH{q', 50
                                                                mem[(32 * idx + 1) + _4133 + 32] = mem[_9177] - 1
                                                            else:
                                                                _9696 = mem[_8265 + 96]
                                                                mem[mem[64] + 4] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8437'))))
                                                                mem[mem[64] + 36] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8439'))))
                                                                mem[mem[64] + 68] = _8372
                                                                require ext_code.size(address(_9696))
                                                                staticcall address(_9696).get_dy(int128 arg1, int128 arg2, uint256 arg3) with:
                                                                        gas gas_remaining wei
                                                                       args ('signextend', 15, ('type', 256, ('stor', ('var', '_8437')))), ('signextend', 15, ('type', 256, ('stor', ('var', '_8439')))), _8372
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _10046 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_10046] == mem[_10046]
                                                                require mem[_10046] > 0
                                                                if mem[_10046] < 1:
                                                                    revert with 'NH{q', 17
                                                                if idx > -2:
                                                                    revert with 'NH{q', 17
                                                                if idx + 1 >= mem[_4133]:
                                                                    revert with 'NH{q', 50
                                                                mem[(32 * idx + 1) + _4133 + 32] = mem[_10046] - 1
                                        else:
                                            _8475 = mem[mem[(32 * idx) + 128] + 96]
                                            mem[mem[64] + 4] = uint256(stor[_8437])
                                            mem[mem[64] + 36] = uint256(stor[_8439])
                                            mem[mem[64] + 68] = _8372
                                            require ext_code.size(address(_8475))
                                            staticcall address(_8475).get_dy_underlying(uint256 arg1, uint256 arg2, uint256 arg3) with:
                                                    gas gas_remaining wei
                                                   args uint256(stor[_8437]), uint256(stor[_8439]), _8372
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9140 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_9140] == mem[_9140]
                                            if mem[_9140] and 9996 > -1 / mem[_9140]:
                                                revert with 'NH{q', 17
                                            if mem[_8265 + 108 len 20] != 0x7f90122bf0700f9e7e1f688fe926940e8839f353:
                                                if mem[_8265 + 108 len 20] == 0xaea2e71b631fa93683bcf256a8689dfa0e094fcd:
                                                    _9864 = mem[_8265 + 96]
                                                    mem[mem[64] + 4] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8437'))))
                                                    mem[mem[64] + 36] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8439'))))
                                                    mem[mem[64] + 68] = _8372
                                                    require ext_code.size(address(_9864))
                                                    staticcall address(_9864).get_dy(int128 arg1, int128 arg2, uint256 arg3) with:
                                                            gas gas_remaining wei
                                                           args ('signextend', 15, ('type', 256, ('stor', ('var', '_8437')))), ('signextend', 15, ('type', 256, ('stor', ('var', '_8439')))), _8372
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _10496 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_10496] == mem[_10496]
                                                    require mem[_10496] > 0
                                                    if mem[_10496] < 1:
                                                        revert with 'NH{q', 17
                                                    if idx > -2:
                                                        revert with 'NH{q', 17
                                                    if idx + 1 >= mem[_4133]:
                                                        revert with 'NH{q', 50
                                                    mem[(32 * idx + 1) + _4133 + 32] = mem[_10496] - 1
                                                else:
                                                    if mem[_8265 + 108 len 20] == 0x3a43a5851a3e3e0e25a3c1089670269786be1577:
                                                        _9907 = mem[_8265 + 96]
                                                        mem[mem[64] + 4] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8437'))))
                                                        mem[mem[64] + 36] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8439'))))
                                                        mem[mem[64] + 68] = _8372
                                                        require ext_code.size(address(_9907))
                                                        staticcall address(_9907).get_dy(int128 arg1, int128 arg2, uint256 arg3) with:
                                                                gas gas_remaining wei
                                                               args ('signextend', 15, ('type', 256, ('stor', ('var', '_8437')))), ('signextend', 15, ('type', 256, ('stor', ('var', '_8439')))), _8372
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _10564 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_10564] == mem[_10564]
                                                        require mem[_10564] > 0
                                                        if mem[_10564] < 1:
                                                            revert with 'NH{q', 17
                                                        if idx > -2:
                                                            revert with 'NH{q', 17
                                                        if idx + 1 >= mem[_4133]:
                                                            revert with 'NH{q', 50
                                                        mem[(32 * idx + 1) + _4133 + 32] = mem[_10564] - 1
                                                    else:
                                                        if mem[_8265 + 108 len 20] == 0x93004d8477f117ea359b71ec02f2706c8175c55c:
                                                            _9950 = mem[_8265 + 96]
                                                            mem[mem[64] + 4] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8437'))))
                                                            mem[mem[64] + 36] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8439'))))
                                                            mem[mem[64] + 68] = _8372
                                                            require ext_code.size(address(_9950))
                                                            staticcall address(_9950).get_dy(int128 arg1, int128 arg2, uint256 arg3) with:
                                                                    gas gas_remaining wei
                                                                   args ('signextend', 15, ('type', 256, ('stor', ('var', '_8437')))), ('signextend', 15, ('type', 256, ('stor', ('var', '_8439')))), _8372
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _10624 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_10624] == mem[_10624]
                                                            require mem[_10624] > 0
                                                            if mem[_10624] < 1:
                                                                revert with 'NH{q', 17
                                                            if idx > -2:
                                                                revert with 'NH{q', 17
                                                            if idx + 1 >= mem[_4133]:
                                                                revert with 'NH{q', 50
                                                            mem[(32 * idx + 1) + _4133 + 32] = mem[_10624] - 1
                                                        else:
                                                            if mem[_8265 + 108 len 20] != 0xd79138c49c49200a1afc935171d1bdad084fdc95:
                                                                require 9996 * mem[_9140] / 10000 > 0
                                                                if 9996 * mem[_9140] / 10000 < 1:
                                                                    revert with 'NH{q', 17
                                                                if idx > -2:
                                                                    revert with 'NH{q', 17
                                                                if idx + 1 >= mem[_4133]:
                                                                    revert with 'NH{q', 50
                                                                mem[(32 * idx + 1) + _4133 + 32] = (9996 * mem[_9140] / 10000) - 1
                                                            else:
                                                                _9993 = mem[_8265 + 96]
                                                                mem[mem[64] + 4] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8437'))))
                                                                mem[mem[64] + 36] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8439'))))
                                                                mem[mem[64] + 68] = _8372
                                                                require ext_code.size(address(_9993))
                                                                staticcall address(_9993).get_dy(int128 arg1, int128 arg2, uint256 arg3) with:
                                                                        gas gas_remaining wei
                                                                       args ('signextend', 15, ('type', 256, ('stor', ('var', '_8437')))), ('signextend', 15, ('type', 256, ('stor', ('var', '_8439')))), _8372
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _10667 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_10667] == mem[_10667]
                                                                require mem[_10667] > 0
                                                                if mem[_10667] < 1:
                                                                    revert with 'NH{q', 17
                                                                if idx > -2:
                                                                    revert with 'NH{q', 17
                                                                if idx + 1 >= mem[_4133]:
                                                                    revert with 'NH{q', 50
                                                                mem[(32 * idx + 1) + _4133 + 32] = mem[_10667] - 1
                                            else:
                                                _9749 = mem[_8265 + 96]
                                                mem[mem[64] + 4] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8437'))))
                                                mem[mem[64] + 36] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8439'))))
                                                mem[mem[64] + 68] = _8372
                                                require ext_code.size(address(_9749))
                                                staticcall address(_9749).get_dy_underlying(int128 arg1, int128 arg2, uint256 arg3) with:
                                                        gas gas_remaining wei
                                                       args ('signextend', 15, ('type', 256, ('stor', ('var', '_8437')))), ('signextend', 15, ('type', 256, ('stor', ('var', '_8439')))), _8372
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _10352 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_10352] == mem[_10352]
                                                if mem[_8265 + 108 len 20] == 0xaea2e71b631fa93683bcf256a8689dfa0e094fcd:
                                                    _11124 = mem[_8265 + 96]
                                                    mem[mem[64] + 4] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8437'))))
                                                    mem[mem[64] + 36] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8439'))))
                                                    mem[mem[64] + 68] = _8372
                                                    require ext_code.size(address(_11124))
                                                    staticcall address(_11124).get_dy(int128 arg1, int128 arg2, uint256 arg3) with:
                                                            gas gas_remaining wei
                                                           args ('signextend', 15, ('type', 256, ('stor', ('var', '_8437')))), ('signextend', 15, ('type', 256, ('stor', ('var', '_8439')))), _8372
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _11898 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_11898] == mem[_11898]
                                                    require mem[_11898] > 0
                                                    if mem[_11898] < 1:
                                                        revert with 'NH{q', 17
                                                    if idx > -2:
                                                        revert with 'NH{q', 17
                                                    if idx + 1 >= mem[_4133]:
                                                        revert with 'NH{q', 50
                                                    mem[(32 * idx + 1) + _4133 + 32] = mem[_11898] - 1
                                                else:
                                                    if mem[_8265 + 108 len 20] == 0x3a43a5851a3e3e0e25a3c1089670269786be1577:
                                                        _11136 = mem[_8265 + 96]
                                                        mem[mem[64] + 4] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8437'))))
                                                        mem[mem[64] + 36] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8439'))))
                                                        mem[mem[64] + 68] = _8372
                                                        require ext_code.size(address(_11136))
                                                        staticcall address(_11136).get_dy(int128 arg1, int128 arg2, uint256 arg3) with:
                                                                gas gas_remaining wei
                                                               args ('signextend', 15, ('type', 256, ('stor', ('var', '_8437')))), ('signextend', 15, ('type', 256, ('stor', ('var', '_8439')))), _8372
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _11919 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_11919] == mem[_11919]
                                                        require mem[_11919] > 0
                                                        if mem[_11919] < 1:
                                                            revert with 'NH{q', 17
                                                        if idx > -2:
                                                            revert with 'NH{q', 17
                                                        if idx + 1 >= mem[_4133]:
                                                            revert with 'NH{q', 50
                                                        mem[(32 * idx + 1) + _4133 + 32] = mem[_11919] - 1
                                                    else:
                                                        if mem[_8265 + 108 len 20] == 0x93004d8477f117ea359b71ec02f2706c8175c55c:
                                                            _11174 = mem[_8265 + 96]
                                                            mem[mem[64] + 4] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8437'))))
                                                            mem[mem[64] + 36] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8439'))))
                                                            mem[mem[64] + 68] = _8372
                                                            require ext_code.size(address(_11174))
                                                            staticcall address(_11174).get_dy(int128 arg1, int128 arg2, uint256 arg3) with:
                                                                    gas gas_remaining wei
                                                                   args ('signextend', 15, ('type', 256, ('stor', ('var', '_8437')))), ('signextend', 15, ('type', 256, ('stor', ('var', '_8439')))), _8372
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _11957 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_11957] == mem[_11957]
                                                            require mem[_11957] > 0
                                                            if mem[_11957] < 1:
                                                                revert with 'NH{q', 17
                                                            if idx > -2:
                                                                revert with 'NH{q', 17
                                                            if idx + 1 >= mem[_4133]:
                                                                revert with 'NH{q', 50
                                                            mem[(32 * idx + 1) + _4133 + 32] = mem[_11957] - 1
                                                        else:
                                                            if mem[_8265 + 108 len 20] != 0xd79138c49c49200a1afc935171d1bdad084fdc95:
                                                                require mem[_10352] > 0
                                                                if mem[_10352] < 1:
                                                                    revert with 'NH{q', 17
                                                                if idx > -2:
                                                                    revert with 'NH{q', 17
                                                                if idx + 1 >= mem[_4133]:
                                                                    revert with 'NH{q', 50
                                                                mem[(32 * idx + 1) + _4133 + 32] = mem[_10352] - 1
                                                            else:
                                                                _11251 = mem[_8265 + 96]
                                                                mem[mem[64] + 4] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8437'))))
                                                                mem[mem[64] + 36] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8439'))))
                                                                mem[mem[64] + 68] = _8372
                                                                require ext_code.size(address(_11251))
                                                                staticcall address(_11251).get_dy(int128 arg1, int128 arg2, uint256 arg3) with:
                                                                        gas gas_remaining wei
                                                                       args ('signextend', 15, ('type', 256, ('stor', ('var', '_8437')))), ('signextend', 15, ('type', 256, ('stor', ('var', '_8439')))), _8372
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _11994 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_11994] == mem[_11994]
                                                                require mem[_11994] > 0
                                                                if mem[_11994] < 1:
                                                                    revert with 'NH{q', 17
                                                                if idx > -2:
                                                                    revert with 'NH{q', 17
                                                                if idx + 1 >= mem[_4133]:
                                                                    revert with 'NH{q', 50
                                                                mem[(32 * idx + 1) + _4133 + 32] = mem[_11994] - 1
            if idx == -1:
                revert with 'NH{q', 17
            _8260 = mem[96]
            idx = idx + 1
            continue 
        mem[mem[64]] = 32
        _8276 = mem[_4133]
        mem[mem[64] + 32] = mem[_4133]
        mem[mem[64] + 64 len 32 * _8276] = mem[_4133 + 32 len 32 * _8276]
        return 32, mem[mem[64] + 32 len (32 * _8276) + 32]
    mem[_4133 + 32 len 32 * _4131 + 1] = call.data[calldata.size len 32 * _4131 + 1]
    if 0 >= mem[_4133]:
        revert with 'NH{q', 50
    mem[_4133 + 32] = cd[4]
    _8261 = mem[96]
    idx = 0
    while idx < _8261:
        if idx >= mem[96]:
            revert with 'NH{q', 50
        _8268 = mem[(32 * idx) + 128]
        if mem[mem[(32 * idx) + 128] + 160] == 1:
            _8274 = mem[mem[(32 * idx) + 128]]
            _8275 = mem[mem[(32 * idx) + 128] + 32]
            if mem[mem[(32 * idx) + 128] + 12 len 20] < mem[mem[(32 * idx) + 128] + 44 len 20]:
                _8280 = mem[mem[(32 * idx) + 128] + 64]
                _8292 = mem[64]
                _8293 = mem[64]
                mem[mem[64]] = 4
                mem[64] = mem[64] + 36
                mem[_8293 + 32] = mem[_8293 + 36 len 28] or 0x902f1ac00000000000000000000000000000000000000000000000000000000
                _8324 = mem[_8293]
                s = 0
                while s < _8324:
                    mem[_8292 + s + 36] = mem[_8293 + s + 32]
                    _8261 = mem[96]
                    s = s + 32
                    continue 
                if ceil32(_8324) <= _8324:
                    staticcall address(_8280).mem[mem[64] len 4] with:
                            gas gas_remaining wei
                           args mem[mem[64] + 4 len _8292 + _8324 + -mem[64] + 32]
                    if not return_data.size:
                        if idx >= mem[_4133]:
                            revert with 'NH{q', 50
                        if mem[(32 * idx) + _4133 + 32] <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                        if mem[_8268 + 12 len 20] == address(_8274):
                            if mem[128] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if mem[160] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if 10000 < mem[_8268 + 128]:
                                revert with 'NH{q', 17
                            if not -mem[_8268 + 128] + 10000:
                                if mem[160]:
                                    if False and mem[160] > 0:
                                        revert with 'NH{q', 17
                                    if not mem[160]:
                                        revert with 'NH{q', 18
                                    if 0 / mem[160]:
                                        revert with 0, 'ds-math-mul-overflow'
                                if mem[128] and 10000 > -1 / mem[128]:
                                    revert with 'NH{q', 17
                                if 10000 * mem[128] / 10000 != mem[128]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 10000 * mem[128] > -1:
                                    revert with 'NH{q', 17
                                if 10000 * mem[128] < 10000 * mem[128]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not 10000 * mem[128]:
                                    revert with 'NH{q', 18
                                if idx > -2:
                                    revert with 'NH{q', 17
                                if idx + 1 >= mem[_4133]:
                                    revert with 'NH{q', 50
                                mem[(32 * idx + 1) + _4133 + 32] = 0 / 10000 * mem[128]
                            else:
                                if mem[(32 * idx) + _4133 + 32] and -mem[_8268 + 128] + 10000 > -1 / mem[(32 * idx) + _4133 + 32]:
                                    revert with 'NH{q', 17
                                if not -mem[_8268 + 128] + 10000:
                                    revert with 'NH{q', 18
                                if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) / -mem[_8268 + 128] + 10000 != mem[(32 * idx) + _4133 + 32]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if not mem[160]:
                                    if mem[128] and 10000 > -1 / mem[128]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[128] / 10000 != mem[128]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[128] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                        revert with 'NH{q', 17
                                    if (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[128]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4133]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4133 + 32] = 0 / (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32])
                                else:
                                    if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) and mem[160] > -1 / (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                        revert with 'NH{q', 17
                                    if not mem[160]:
                                        revert with 'NH{q', 18
                                    if (10000 * mem[(32 * idx) + _4133 + 32] * mem[160]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32] * mem[160]) / mem[160] != (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if mem[128] and 10000 > -1 / mem[128]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[128] / 10000 != mem[128]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[128] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                        revert with 'NH{q', 17
                                    if (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[128]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4133]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4133 + 32] = (10000 * mem[(32 * idx) + _4133 + 32] * mem[160]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32] * mem[160]) / (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32])
                        else:
                            if mem[160] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if mem[128] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if 10000 < mem[_8268 + 128]:
                                revert with 'NH{q', 17
                            if not -mem[_8268 + 128] + 10000:
                                if mem[128]:
                                    if False and mem[128] > 0:
                                        revert with 'NH{q', 17
                                    if not mem[128]:
                                        revert with 'NH{q', 18
                                    if 0 / mem[128]:
                                        revert with 0, 'ds-math-mul-overflow'
                                if mem[160] and 10000 > -1 / mem[160]:
                                    revert with 'NH{q', 17
                                if 10000 * mem[160] / 10000 != mem[160]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 10000 * mem[160] > -1:
                                    revert with 'NH{q', 17
                                if 10000 * mem[160] < 10000 * mem[160]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not 10000 * mem[160]:
                                    revert with 'NH{q', 18
                                if idx > -2:
                                    revert with 'NH{q', 17
                                if idx + 1 >= mem[_4133]:
                                    revert with 'NH{q', 50
                                mem[(32 * idx + 1) + _4133 + 32] = 0 / 10000 * mem[160]
                            else:
                                if mem[(32 * idx) + _4133 + 32] and -mem[_8268 + 128] + 10000 > -1 / mem[(32 * idx) + _4133 + 32]:
                                    revert with 'NH{q', 17
                                if not -mem[_8268 + 128] + 10000:
                                    revert with 'NH{q', 18
                                if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) / -mem[_8268 + 128] + 10000 != mem[(32 * idx) + _4133 + 32]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if not mem[128]:
                                    if mem[160] and 10000 > -1 / mem[160]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[160] / 10000 != mem[160]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[160] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                        revert with 'NH{q', 17
                                    if (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[160]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4133]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4133 + 32] = 0 / (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32])
                                else:
                                    if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) and mem[128] > -1 / (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                        revert with 'NH{q', 17
                                    if not mem[128]:
                                        revert with 'NH{q', 18
                                    if (10000 * mem[(32 * idx) + _4133 + 32] * mem[128]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32] * mem[128]) / mem[128] != (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if mem[160] and 10000 > -1 / mem[160]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[160] / 10000 != mem[160]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[160] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                        revert with 'NH{q', 17
                                    if (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[160]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4133]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4133 + 32] = (10000 * mem[(32 * idx) + _4133 + 32] * mem[128]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32] * mem[128]) / (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32])
                    else:
                        _12430 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size) + 1
                        mem[_12430] = return_data.size
                        mem[_12430 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if idx >= mem[_4133]:
                            revert with 'NH{q', 50
                        if mem[(32 * idx) + _4133 + 32] <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                        if mem[_8268 + 12 len 20] == address(_8274):
                            if mem[_12430 + 32] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if mem[_12430 + 64] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if 10000 < mem[_8268 + 128]:
                                revert with 'NH{q', 17
                            if not -mem[_8268 + 128] + 10000:
                                if mem[_12430 + 64]:
                                    if False and mem[_12430 + 64] > 0:
                                        revert with 'NH{q', 17
                                    if not mem[_12430 + 64]:
                                        revert with 'NH{q', 18
                                    if 0 / mem[_12430 + 64]:
                                        revert with 0, 'ds-math-mul-overflow'
                                if mem[_12430 + 32] and 10000 > -1 / mem[_12430 + 32]:
                                    revert with 'NH{q', 17
                                if 10000 * mem[_12430 + 32] / 10000 != mem[_12430 + 32]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 10000 * mem[_12430 + 32] > -1:
                                    revert with 'NH{q', 17
                                if 10000 * mem[_12430 + 32] < 10000 * mem[_12430 + 32]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not 10000 * mem[_12430 + 32]:
                                    revert with 'NH{q', 18
                                if idx > -2:
                                    revert with 'NH{q', 17
                                if idx + 1 >= mem[_4133]:
                                    revert with 'NH{q', 50
                                mem[(32 * idx + 1) + _4133 + 32] = 0 / 10000 * mem[_12430 + 32]
                            else:
                                if mem[(32 * idx) + _4133 + 32] and -mem[_8268 + 128] + 10000 > -1 / mem[(32 * idx) + _4133 + 32]:
                                    revert with 'NH{q', 17
                                if not -mem[_8268 + 128] + 10000:
                                    revert with 'NH{q', 18
                                if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) / -mem[_8268 + 128] + 10000 != mem[(32 * idx) + _4133 + 32]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if not mem[_12430 + 64]:
                                    if mem[_12430 + 32] and 10000 > -1 / mem[_12430 + 32]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[_12430 + 32] / 10000 != mem[_12430 + 32]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[_12430 + 32] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                        revert with 'NH{q', 17
                                    if (10000 * mem[_12430 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[_12430 + 32]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (10000 * mem[_12430 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4133]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4133 + 32] = 0 / (10000 * mem[_12430 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32])
                                else:
                                    if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) and mem[_12430 + 64] > -1 / (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                        revert with 'NH{q', 17
                                    if not mem[_12430 + 64]:
                                        revert with 'NH{q', 18
                                    if (10000 * mem[(32 * idx) + _4133 + 32] * mem[_12430 + 64]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32] * mem[_12430 + 64]) / mem[_12430 + 64] != (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if mem[_12430 + 32] and 10000 > -1 / mem[_12430 + 32]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[_12430 + 32] / 10000 != mem[_12430 + 32]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[_12430 + 32] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                        revert with 'NH{q', 17
                                    if (10000 * mem[_12430 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[_12430 + 32]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (10000 * mem[_12430 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4133]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4133 + 32] = (10000 * mem[(32 * idx) + _4133 + 32] * mem[_12430 + 64]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32] * mem[_12430 + 64]) / (10000 * mem[_12430 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32])
                        else:
                            if mem[_12430 + 64] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if mem[_12430 + 32] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if 10000 < mem[_8268 + 128]:
                                revert with 'NH{q', 17
                            if not -mem[_8268 + 128] + 10000:
                                if mem[_12430 + 32]:
                                    if False and mem[_12430 + 32] > 0:
                                        revert with 'NH{q', 17
                                    if not mem[_12430 + 32]:
                                        revert with 'NH{q', 18
                                    if 0 / mem[_12430 + 32]:
                                        revert with 0, 'ds-math-mul-overflow'
                                if mem[_12430 + 64] and 10000 > -1 / mem[_12430 + 64]:
                                    revert with 'NH{q', 17
                                if 10000 * mem[_12430 + 64] / 10000 != mem[_12430 + 64]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 10000 * mem[_12430 + 64] > -1:
                                    revert with 'NH{q', 17
                                if 10000 * mem[_12430 + 64] < 10000 * mem[_12430 + 64]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not 10000 * mem[_12430 + 64]:
                                    revert with 'NH{q', 18
                                if idx > -2:
                                    revert with 'NH{q', 17
                                if idx + 1 >= mem[_4133]:
                                    revert with 'NH{q', 50
                                mem[(32 * idx + 1) + _4133 + 32] = 0 / 10000 * mem[_12430 + 64]
                            else:
                                if mem[(32 * idx) + _4133 + 32] and -mem[_8268 + 128] + 10000 > -1 / mem[(32 * idx) + _4133 + 32]:
                                    revert with 'NH{q', 17
                                if not -mem[_8268 + 128] + 10000:
                                    revert with 'NH{q', 18
                                if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) / -mem[_8268 + 128] + 10000 != mem[(32 * idx) + _4133 + 32]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if not mem[_12430 + 32]:
                                    if mem[_12430 + 64] and 10000 > -1 / mem[_12430 + 64]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[_12430 + 64] / 10000 != mem[_12430 + 64]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[_12430 + 64] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                        revert with 'NH{q', 17
                                    if (10000 * mem[_12430 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[_12430 + 64]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (10000 * mem[_12430 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4133]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4133 + 32] = 0 / (10000 * mem[_12430 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32])
                                else:
                                    if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) and mem[_12430 + 32] > -1 / (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                        revert with 'NH{q', 17
                                    if not mem[_12430 + 32]:
                                        revert with 'NH{q', 18
                                    if (10000 * mem[(32 * idx) + _4133 + 32] * mem[_12430 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32] * mem[_12430 + 32]) / mem[_12430 + 32] != (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if mem[_12430 + 64] and 10000 > -1 / mem[_12430 + 64]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[_12430 + 64] / 10000 != mem[_12430 + 64]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[_12430 + 64] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                        revert with 'NH{q', 17
                                    if (10000 * mem[_12430 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[_12430 + 64]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (10000 * mem[_12430 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4133]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4133 + 32] = (10000 * mem[(32 * idx) + _4133 + 32] * mem[_12430 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32] * mem[_12430 + 32]) / (10000 * mem[_12430 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32])
                else:
                    mem[_8292 + _8324 + 36] = 0
                    staticcall address(_8280).mem[mem[64] len 4] with:
                            gas gas_remaining wei
                           args mem[mem[64] + 4 len _8292 + _8324 + -mem[64] + 32]
                    if not return_data.size:
                        if idx >= mem[_4133]:
                            revert with 'NH{q', 50
                        if mem[(32 * idx) + _4133 + 32] <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                        if mem[_8268 + 12 len 20] == address(_8274):
                            if mem[128] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if mem[160] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if 10000 < mem[_8268 + 128]:
                                revert with 'NH{q', 17
                            if not -mem[_8268 + 128] + 10000:
                                if mem[160]:
                                    if False and mem[160] > 0:
                                        revert with 'NH{q', 17
                                    if not mem[160]:
                                        revert with 'NH{q', 18
                                    if 0 / mem[160]:
                                        revert with 0, 'ds-math-mul-overflow'
                                if mem[128] and 10000 > -1 / mem[128]:
                                    revert with 'NH{q', 17
                                if 10000 * mem[128] / 10000 != mem[128]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 10000 * mem[128] > -1:
                                    revert with 'NH{q', 17
                                if 10000 * mem[128] < 10000 * mem[128]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not 10000 * mem[128]:
                                    revert with 'NH{q', 18
                                if idx > -2:
                                    revert with 'NH{q', 17
                                if idx + 1 >= mem[_4133]:
                                    revert with 'NH{q', 50
                                mem[(32 * idx + 1) + _4133 + 32] = 0 / 10000 * mem[128]
                            else:
                                if mem[(32 * idx) + _4133 + 32] and -mem[_8268 + 128] + 10000 > -1 / mem[(32 * idx) + _4133 + 32]:
                                    revert with 'NH{q', 17
                                if not -mem[_8268 + 128] + 10000:
                                    revert with 'NH{q', 18
                                if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) / -mem[_8268 + 128] + 10000 != mem[(32 * idx) + _4133 + 32]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if not mem[160]:
                                    if mem[128] and 10000 > -1 / mem[128]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[128] / 10000 != mem[128]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[128] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                        revert with 'NH{q', 17
                                    if (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[128]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4133]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4133 + 32] = 0 / (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32])
                                else:
                                    if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) and mem[160] > -1 / (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                        revert with 'NH{q', 17
                                    if not mem[160]:
                                        revert with 'NH{q', 18
                                    if (10000 * mem[(32 * idx) + _4133 + 32] * mem[160]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32] * mem[160]) / mem[160] != (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if mem[128] and 10000 > -1 / mem[128]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[128] / 10000 != mem[128]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[128] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                        revert with 'NH{q', 17
                                    if (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[128]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4133]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4133 + 32] = (10000 * mem[(32 * idx) + _4133 + 32] * mem[160]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32] * mem[160]) / (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32])
                        else:
                            if mem[160] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if mem[128] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if 10000 < mem[_8268 + 128]:
                                revert with 'NH{q', 17
                            if not -mem[_8268 + 128] + 10000:
                                if mem[128]:
                                    if False and mem[128] > 0:
                                        revert with 'NH{q', 17
                                    if not mem[128]:
                                        revert with 'NH{q', 18
                                    if 0 / mem[128]:
                                        revert with 0, 'ds-math-mul-overflow'
                                if mem[160] and 10000 > -1 / mem[160]:
                                    revert with 'NH{q', 17
                                if 10000 * mem[160] / 10000 != mem[160]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 10000 * mem[160] > -1:
                                    revert with 'NH{q', 17
                                if 10000 * mem[160] < 10000 * mem[160]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not 10000 * mem[160]:
                                    revert with 'NH{q', 18
                                if idx > -2:
                                    revert with 'NH{q', 17
                                if idx + 1 >= mem[_4133]:
                                    revert with 'NH{q', 50
                                mem[(32 * idx + 1) + _4133 + 32] = 0 / 10000 * mem[160]
                            else:
                                if mem[(32 * idx) + _4133 + 32] and -mem[_8268 + 128] + 10000 > -1 / mem[(32 * idx) + _4133 + 32]:
                                    revert with 'NH{q', 17
                                if not -mem[_8268 + 128] + 10000:
                                    revert with 'NH{q', 18
                                if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) / -mem[_8268 + 128] + 10000 != mem[(32 * idx) + _4133 + 32]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if not mem[128]:
                                    if mem[160] and 10000 > -1 / mem[160]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[160] / 10000 != mem[160]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[160] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                        revert with 'NH{q', 17
                                    if (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[160]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4133]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4133 + 32] = 0 / (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32])
                                else:
                                    if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) and mem[128] > -1 / (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                        revert with 'NH{q', 17
                                    if not mem[128]:
                                        revert with 'NH{q', 18
                                    if (10000 * mem[(32 * idx) + _4133 + 32] * mem[128]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32] * mem[128]) / mem[128] != (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if mem[160] and 10000 > -1 / mem[160]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[160] / 10000 != mem[160]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[160] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                        revert with 'NH{q', 17
                                    if (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[160]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4133]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4133 + 32] = (10000 * mem[(32 * idx) + _4133 + 32] * mem[128]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32] * mem[128]) / (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32])
                    else:
                        _12477 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size) + 1
                        mem[_12477] = return_data.size
                        mem[_12477 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if idx >= mem[_4133]:
                            revert with 'NH{q', 50
                        if mem[(32 * idx) + _4133 + 32] <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                        if mem[_8268 + 12 len 20] == address(_8274):
                            if mem[_12477 + 32] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if mem[_12477 + 64] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if 10000 < mem[_8268 + 128]:
                                revert with 'NH{q', 17
                            if not -mem[_8268 + 128] + 10000:
                                if mem[_12477 + 64]:
                                    if False and mem[_12477 + 64] > 0:
                                        revert with 'NH{q', 17
                                    if not mem[_12477 + 64]:
                                        revert with 'NH{q', 18
                                    if 0 / mem[_12477 + 64]:
                                        revert with 0, 'ds-math-mul-overflow'
                                if mem[_12477 + 32] and 10000 > -1 / mem[_12477 + 32]:
                                    revert with 'NH{q', 17
                                if 10000 * mem[_12477 + 32] / 10000 != mem[_12477 + 32]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 10000 * mem[_12477 + 32] > -1:
                                    revert with 'NH{q', 17
                                if 10000 * mem[_12477 + 32] < 10000 * mem[_12477 + 32]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not 10000 * mem[_12477 + 32]:
                                    revert with 'NH{q', 18
                                if idx > -2:
                                    revert with 'NH{q', 17
                                if idx + 1 >= mem[_4133]:
                                    revert with 'NH{q', 50
                                mem[(32 * idx + 1) + _4133 + 32] = 0 / 10000 * mem[_12477 + 32]
                            else:
                                if mem[(32 * idx) + _4133 + 32] and -mem[_8268 + 128] + 10000 > -1 / mem[(32 * idx) + _4133 + 32]:
                                    revert with 'NH{q', 17
                                if not -mem[_8268 + 128] + 10000:
                                    revert with 'NH{q', 18
                                if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) / -mem[_8268 + 128] + 10000 != mem[(32 * idx) + _4133 + 32]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if not mem[_12477 + 64]:
                                    if mem[_12477 + 32] and 10000 > -1 / mem[_12477 + 32]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[_12477 + 32] / 10000 != mem[_12477 + 32]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[_12477 + 32] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                        revert with 'NH{q', 17
                                    if (10000 * mem[_12477 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[_12477 + 32]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (10000 * mem[_12477 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4133]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4133 + 32] = 0 / (10000 * mem[_12477 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32])
                                else:
                                    if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) and mem[_12477 + 64] > -1 / (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                        revert with 'NH{q', 17
                                    if not mem[_12477 + 64]:
                                        revert with 'NH{q', 18
                                    if (10000 * mem[(32 * idx) + _4133 + 32] * mem[_12477 + 64]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32] * mem[_12477 + 64]) / mem[_12477 + 64] != (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if mem[_12477 + 32] and 10000 > -1 / mem[_12477 + 32]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[_12477 + 32] / 10000 != mem[_12477 + 32]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[_12477 + 32] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                        revert with 'NH{q', 17
                                    if (10000 * mem[_12477 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[_12477 + 32]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (10000 * mem[_12477 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4133]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4133 + 32] = (10000 * mem[(32 * idx) + _4133 + 32] * mem[_12477 + 64]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32] * mem[_12477 + 64]) / (10000 * mem[_12477 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32])
                        else:
                            if mem[_12477 + 64] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if mem[_12477 + 32] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if 10000 < mem[_8268 + 128]:
                                revert with 'NH{q', 17
                            if not -mem[_8268 + 128] + 10000:
                                if mem[_12477 + 32]:
                                    if False and mem[_12477 + 32] > 0:
                                        revert with 'NH{q', 17
                                    if not mem[_12477 + 32]:
                                        revert with 'NH{q', 18
                                    if 0 / mem[_12477 + 32]:
                                        revert with 0, 'ds-math-mul-overflow'
                                if mem[_12477 + 64] and 10000 > -1 / mem[_12477 + 64]:
                                    revert with 'NH{q', 17
                                if 10000 * mem[_12477 + 64] / 10000 != mem[_12477 + 64]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 10000 * mem[_12477 + 64] > -1:
                                    revert with 'NH{q', 17
                                if 10000 * mem[_12477 + 64] < 10000 * mem[_12477 + 64]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not 10000 * mem[_12477 + 64]:
                                    revert with 'NH{q', 18
                                if idx > -2:
                                    revert with 'NH{q', 17
                                if idx + 1 >= mem[_4133]:
                                    revert with 'NH{q', 50
                                mem[(32 * idx + 1) + _4133 + 32] = 0 / 10000 * mem[_12477 + 64]
                            else:
                                if mem[(32 * idx) + _4133 + 32] and -mem[_8268 + 128] + 10000 > -1 / mem[(32 * idx) + _4133 + 32]:
                                    revert with 'NH{q', 17
                                if not -mem[_8268 + 128] + 10000:
                                    revert with 'NH{q', 18
                                if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) / -mem[_8268 + 128] + 10000 != mem[(32 * idx) + _4133 + 32]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if not mem[_12477 + 32]:
                                    if mem[_12477 + 64] and 10000 > -1 / mem[_12477 + 64]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[_12477 + 64] / 10000 != mem[_12477 + 64]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[_12477 + 64] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                        revert with 'NH{q', 17
                                    if (10000 * mem[_12477 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[_12477 + 64]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (10000 * mem[_12477 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4133]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4133 + 32] = 0 / (10000 * mem[_12477 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32])
                                else:
                                    if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) and mem[_12477 + 32] > -1 / (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                        revert with 'NH{q', 17
                                    if not mem[_12477 + 32]:
                                        revert with 'NH{q', 18
                                    if (10000 * mem[(32 * idx) + _4133 + 32] * mem[_12477 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32] * mem[_12477 + 32]) / mem[_12477 + 32] != (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if mem[_12477 + 64] and 10000 > -1 / mem[_12477 + 64]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[_12477 + 64] / 10000 != mem[_12477 + 64]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[_12477 + 64] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                        revert with 'NH{q', 17
                                    if (10000 * mem[_12477 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[_12477 + 64]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (10000 * mem[_12477 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4133]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4133 + 32] = (10000 * mem[(32 * idx) + _4133 + 32] * mem[_12477 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32] * mem[_12477 + 32]) / (10000 * mem[_12477 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32])
            else:
                _8281 = mem[mem[(32 * idx) + 128] + 64]
                _8296 = mem[64]
                _8297 = mem[64]
                mem[mem[64]] = 4
                mem[64] = mem[64] + 36
                mem[_8297 + 32] = mem[_8297 + 36 len 28] or 0x902f1ac00000000000000000000000000000000000000000000000000000000
                _8325 = mem[_8297]
                s = 0
                while s < _8325:
                    mem[_8296 + s + 36] = mem[_8297 + s + 32]
                    _8261 = mem[96]
                    s = s + 32
                    continue 
                if ceil32(_8325) <= _8325:
                    staticcall address(_8281).mem[mem[64] len 4] with:
                            gas gas_remaining wei
                           args mem[mem[64] + 4 len _8296 + _8325 + -mem[64] + 32]
                    if not return_data.size:
                        if idx >= mem[_4133]:
                            revert with 'NH{q', 50
                        if mem[(32 * idx) + _4133 + 32] <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                        if mem[_8268 + 12 len 20] == address(_8275):
                            if mem[128] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if mem[160] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if 10000 < mem[_8268 + 128]:
                                revert with 'NH{q', 17
                            if not -mem[_8268 + 128] + 10000:
                                if mem[160]:
                                    if False and mem[160] > 0:
                                        revert with 'NH{q', 17
                                    if not mem[160]:
                                        revert with 'NH{q', 18
                                    if 0 / mem[160]:
                                        revert with 0, 'ds-math-mul-overflow'
                                if mem[128] and 10000 > -1 / mem[128]:
                                    revert with 'NH{q', 17
                                if 10000 * mem[128] / 10000 != mem[128]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 10000 * mem[128] > -1:
                                    revert with 'NH{q', 17
                                if 10000 * mem[128] < 10000 * mem[128]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not 10000 * mem[128]:
                                    revert with 'NH{q', 18
                                if idx > -2:
                                    revert with 'NH{q', 17
                                if idx + 1 >= mem[_4133]:
                                    revert with 'NH{q', 50
                                mem[(32 * idx + 1) + _4133 + 32] = 0 / 10000 * mem[128]
                            else:
                                if mem[(32 * idx) + _4133 + 32] and -mem[_8268 + 128] + 10000 > -1 / mem[(32 * idx) + _4133 + 32]:
                                    revert with 'NH{q', 17
                                if not -mem[_8268 + 128] + 10000:
                                    revert with 'NH{q', 18
                                if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) / -mem[_8268 + 128] + 10000 != mem[(32 * idx) + _4133 + 32]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if not mem[160]:
                                    if mem[128] and 10000 > -1 / mem[128]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[128] / 10000 != mem[128]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[128] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                        revert with 'NH{q', 17
                                    if (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[128]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4133]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4133 + 32] = 0 / (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32])
                                else:
                                    if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) and mem[160] > -1 / (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                        revert with 'NH{q', 17
                                    if not mem[160]:
                                        revert with 'NH{q', 18
                                    if (10000 * mem[(32 * idx) + _4133 + 32] * mem[160]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32] * mem[160]) / mem[160] != (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if mem[128] and 10000 > -1 / mem[128]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[128] / 10000 != mem[128]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[128] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                        revert with 'NH{q', 17
                                    if (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[128]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4133]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4133 + 32] = (10000 * mem[(32 * idx) + _4133 + 32] * mem[160]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32] * mem[160]) / (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32])
                        else:
                            if mem[160] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if mem[128] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if 10000 < mem[_8268 + 128]:
                                revert with 'NH{q', 17
                            if not -mem[_8268 + 128] + 10000:
                                if mem[128]:
                                    if False and mem[128] > 0:
                                        revert with 'NH{q', 17
                                    if not mem[128]:
                                        revert with 'NH{q', 18
                                    if 0 / mem[128]:
                                        revert with 0, 'ds-math-mul-overflow'
                                if mem[160] and 10000 > -1 / mem[160]:
                                    revert with 'NH{q', 17
                                if 10000 * mem[160] / 10000 != mem[160]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 10000 * mem[160] > -1:
                                    revert with 'NH{q', 17
                                if 10000 * mem[160] < 10000 * mem[160]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not 10000 * mem[160]:
                                    revert with 'NH{q', 18
                                if idx > -2:
                                    revert with 'NH{q', 17
                                if idx + 1 >= mem[_4133]:
                                    revert with 'NH{q', 50
                                mem[(32 * idx + 1) + _4133 + 32] = 0 / 10000 * mem[160]
                            else:
                                if mem[(32 * idx) + _4133 + 32] and -mem[_8268 + 128] + 10000 > -1 / mem[(32 * idx) + _4133 + 32]:
                                    revert with 'NH{q', 17
                                if not -mem[_8268 + 128] + 10000:
                                    revert with 'NH{q', 18
                                if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) / -mem[_8268 + 128] + 10000 != mem[(32 * idx) + _4133 + 32]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if not mem[128]:
                                    if mem[160] and 10000 > -1 / mem[160]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[160] / 10000 != mem[160]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[160] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                        revert with 'NH{q', 17
                                    if (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[160]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4133]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4133 + 32] = 0 / (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32])
                                else:
                                    if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) and mem[128] > -1 / (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                        revert with 'NH{q', 17
                                    if not mem[128]:
                                        revert with 'NH{q', 18
                                    if (10000 * mem[(32 * idx) + _4133 + 32] * mem[128]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32] * mem[128]) / mem[128] != (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if mem[160] and 10000 > -1 / mem[160]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[160] / 10000 != mem[160]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[160] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                        revert with 'NH{q', 17
                                    if (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[160]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4133]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4133 + 32] = (10000 * mem[(32 * idx) + _4133 + 32] * mem[128]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32] * mem[128]) / (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32])
                    else:
                        _12432 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size) + 1
                        mem[_12432] = return_data.size
                        mem[_12432 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if idx >= mem[_4133]:
                            revert with 'NH{q', 50
                        if mem[(32 * idx) + _4133 + 32] <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                        if mem[_8268 + 12 len 20] == address(_8275):
                            if mem[_12432 + 32] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if mem[_12432 + 64] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if 10000 < mem[_8268 + 128]:
                                revert with 'NH{q', 17
                            if not -mem[_8268 + 128] + 10000:
                                if mem[_12432 + 64]:
                                    if False and mem[_12432 + 64] > 0:
                                        revert with 'NH{q', 17
                                    if not mem[_12432 + 64]:
                                        revert with 'NH{q', 18
                                    if 0 / mem[_12432 + 64]:
                                        revert with 0, 'ds-math-mul-overflow'
                                if mem[_12432 + 32] and 10000 > -1 / mem[_12432 + 32]:
                                    revert with 'NH{q', 17
                                if 10000 * mem[_12432 + 32] / 10000 != mem[_12432 + 32]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 10000 * mem[_12432 + 32] > -1:
                                    revert with 'NH{q', 17
                                if 10000 * mem[_12432 + 32] < 10000 * mem[_12432 + 32]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not 10000 * mem[_12432 + 32]:
                                    revert with 'NH{q', 18
                                if idx > -2:
                                    revert with 'NH{q', 17
                                if idx + 1 >= mem[_4133]:
                                    revert with 'NH{q', 50
                                mem[(32 * idx + 1) + _4133 + 32] = 0 / 10000 * mem[_12432 + 32]
                            else:
                                if mem[(32 * idx) + _4133 + 32] and -mem[_8268 + 128] + 10000 > -1 / mem[(32 * idx) + _4133 + 32]:
                                    revert with 'NH{q', 17
                                if not -mem[_8268 + 128] + 10000:
                                    revert with 'NH{q', 18
                                if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) / -mem[_8268 + 128] + 10000 != mem[(32 * idx) + _4133 + 32]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if not mem[_12432 + 64]:
                                    if mem[_12432 + 32] and 10000 > -1 / mem[_12432 + 32]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[_12432 + 32] / 10000 != mem[_12432 + 32]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[_12432 + 32] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                        revert with 'NH{q', 17
                                    if (10000 * mem[_12432 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[_12432 + 32]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (10000 * mem[_12432 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4133]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4133 + 32] = 0 / (10000 * mem[_12432 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32])
                                else:
                                    if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) and mem[_12432 + 64] > -1 / (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                        revert with 'NH{q', 17
                                    if not mem[_12432 + 64]:
                                        revert with 'NH{q', 18
                                    if (10000 * mem[(32 * idx) + _4133 + 32] * mem[_12432 + 64]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32] * mem[_12432 + 64]) / mem[_12432 + 64] != (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if mem[_12432 + 32] and 10000 > -1 / mem[_12432 + 32]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[_12432 + 32] / 10000 != mem[_12432 + 32]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[_12432 + 32] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                        revert with 'NH{q', 17
                                    if (10000 * mem[_12432 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[_12432 + 32]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (10000 * mem[_12432 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4133]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4133 + 32] = (10000 * mem[(32 * idx) + _4133 + 32] * mem[_12432 + 64]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32] * mem[_12432 + 64]) / (10000 * mem[_12432 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32])
                        else:
                            if mem[_12432 + 64] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if mem[_12432 + 32] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if 10000 < mem[_8268 + 128]:
                                revert with 'NH{q', 17
                            if not -mem[_8268 + 128] + 10000:
                                if mem[_12432 + 32]:
                                    if False and mem[_12432 + 32] > 0:
                                        revert with 'NH{q', 17
                                    if not mem[_12432 + 32]:
                                        revert with 'NH{q', 18
                                    if 0 / mem[_12432 + 32]:
                                        revert with 0, 'ds-math-mul-overflow'
                                if mem[_12432 + 64] and 10000 > -1 / mem[_12432 + 64]:
                                    revert with 'NH{q', 17
                                if 10000 * mem[_12432 + 64] / 10000 != mem[_12432 + 64]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 10000 * mem[_12432 + 64] > -1:
                                    revert with 'NH{q', 17
                                if 10000 * mem[_12432 + 64] < 10000 * mem[_12432 + 64]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not 10000 * mem[_12432 + 64]:
                                    revert with 'NH{q', 18
                                if idx > -2:
                                    revert with 'NH{q', 17
                                if idx + 1 >= mem[_4133]:
                                    revert with 'NH{q', 50
                                mem[(32 * idx + 1) + _4133 + 32] = 0 / 10000 * mem[_12432 + 64]
                            else:
                                if mem[(32 * idx) + _4133 + 32] and -mem[_8268 + 128] + 10000 > -1 / mem[(32 * idx) + _4133 + 32]:
                                    revert with 'NH{q', 17
                                if not -mem[_8268 + 128] + 10000:
                                    revert with 'NH{q', 18
                                if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) / -mem[_8268 + 128] + 10000 != mem[(32 * idx) + _4133 + 32]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if not mem[_12432 + 32]:
                                    if mem[_12432 + 64] and 10000 > -1 / mem[_12432 + 64]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[_12432 + 64] / 10000 != mem[_12432 + 64]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[_12432 + 64] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                        revert with 'NH{q', 17
                                    if (10000 * mem[_12432 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[_12432 + 64]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (10000 * mem[_12432 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4133]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4133 + 32] = 0 / (10000 * mem[_12432 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32])
                                else:
                                    if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) and mem[_12432 + 32] > -1 / (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                        revert with 'NH{q', 17
                                    if not mem[_12432 + 32]:
                                        revert with 'NH{q', 18
                                    if (10000 * mem[(32 * idx) + _4133 + 32] * mem[_12432 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32] * mem[_12432 + 32]) / mem[_12432 + 32] != (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if mem[_12432 + 64] and 10000 > -1 / mem[_12432 + 64]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[_12432 + 64] / 10000 != mem[_12432 + 64]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[_12432 + 64] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                        revert with 'NH{q', 17
                                    if (10000 * mem[_12432 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[_12432 + 64]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (10000 * mem[_12432 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4133]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4133 + 32] = (10000 * mem[(32 * idx) + _4133 + 32] * mem[_12432 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32] * mem[_12432 + 32]) / (10000 * mem[_12432 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32])
                else:
                    mem[_8296 + _8325 + 36] = 0
                    staticcall address(_8281).mem[mem[64] len 4] with:
                            gas gas_remaining wei
                           args mem[mem[64] + 4 len _8296 + _8325 + -mem[64] + 32]
                    if not return_data.size:
                        if idx >= mem[_4133]:
                            revert with 'NH{q', 50
                        if mem[(32 * idx) + _4133 + 32] <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                        if mem[_8268 + 12 len 20] == address(_8275):
                            if mem[128] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if mem[160] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if 10000 < mem[_8268 + 128]:
                                revert with 'NH{q', 17
                            if not -mem[_8268 + 128] + 10000:
                                if mem[160]:
                                    if False and mem[160] > 0:
                                        revert with 'NH{q', 17
                                    if not mem[160]:
                                        revert with 'NH{q', 18
                                    if 0 / mem[160]:
                                        revert with 0, 'ds-math-mul-overflow'
                                if mem[128] and 10000 > -1 / mem[128]:
                                    revert with 'NH{q', 17
                                if 10000 * mem[128] / 10000 != mem[128]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 10000 * mem[128] > -1:
                                    revert with 'NH{q', 17
                                if 10000 * mem[128] < 10000 * mem[128]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not 10000 * mem[128]:
                                    revert with 'NH{q', 18
                                if idx > -2:
                                    revert with 'NH{q', 17
                                if idx + 1 >= mem[_4133]:
                                    revert with 'NH{q', 50
                                mem[(32 * idx + 1) + _4133 + 32] = 0 / 10000 * mem[128]
                            else:
                                if mem[(32 * idx) + _4133 + 32] and -mem[_8268 + 128] + 10000 > -1 / mem[(32 * idx) + _4133 + 32]:
                                    revert with 'NH{q', 17
                                if not -mem[_8268 + 128] + 10000:
                                    revert with 'NH{q', 18
                                if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) / -mem[_8268 + 128] + 10000 != mem[(32 * idx) + _4133 + 32]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if not mem[160]:
                                    if mem[128] and 10000 > -1 / mem[128]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[128] / 10000 != mem[128]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[128] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                        revert with 'NH{q', 17
                                    if (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[128]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4133]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4133 + 32] = 0 / (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32])
                                else:
                                    if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) and mem[160] > -1 / (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                        revert with 'NH{q', 17
                                    if not mem[160]:
                                        revert with 'NH{q', 18
                                    if (10000 * mem[(32 * idx) + _4133 + 32] * mem[160]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32] * mem[160]) / mem[160] != (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if mem[128] and 10000 > -1 / mem[128]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[128] / 10000 != mem[128]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[128] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                        revert with 'NH{q', 17
                                    if (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[128]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4133]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4133 + 32] = (10000 * mem[(32 * idx) + _4133 + 32] * mem[160]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32] * mem[160]) / (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32])
                        else:
                            if mem[160] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if mem[128] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if 10000 < mem[_8268 + 128]:
                                revert with 'NH{q', 17
                            if not -mem[_8268 + 128] + 10000:
                                if mem[128]:
                                    if False and mem[128] > 0:
                                        revert with 'NH{q', 17
                                    if not mem[128]:
                                        revert with 'NH{q', 18
                                    if 0 / mem[128]:
                                        revert with 0, 'ds-math-mul-overflow'
                                if mem[160] and 10000 > -1 / mem[160]:
                                    revert with 'NH{q', 17
                                if 10000 * mem[160] / 10000 != mem[160]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 10000 * mem[160] > -1:
                                    revert with 'NH{q', 17
                                if 10000 * mem[160] < 10000 * mem[160]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not 10000 * mem[160]:
                                    revert with 'NH{q', 18
                                if idx > -2:
                                    revert with 'NH{q', 17
                                if idx + 1 >= mem[_4133]:
                                    revert with 'NH{q', 50
                                mem[(32 * idx + 1) + _4133 + 32] = 0 / 10000 * mem[160]
                            else:
                                if mem[(32 * idx) + _4133 + 32] and -mem[_8268 + 128] + 10000 > -1 / mem[(32 * idx) + _4133 + 32]:
                                    revert with 'NH{q', 17
                                if not -mem[_8268 + 128] + 10000:
                                    revert with 'NH{q', 18
                                if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) / -mem[_8268 + 128] + 10000 != mem[(32 * idx) + _4133 + 32]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if not mem[128]:
                                    if mem[160] and 10000 > -1 / mem[160]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[160] / 10000 != mem[160]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[160] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                        revert with 'NH{q', 17
                                    if (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[160]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4133]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4133 + 32] = 0 / (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32])
                                else:
                                    if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) and mem[128] > -1 / (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                        revert with 'NH{q', 17
                                    if not mem[128]:
                                        revert with 'NH{q', 18
                                    if (10000 * mem[(32 * idx) + _4133 + 32] * mem[128]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32] * mem[128]) / mem[128] != (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if mem[160] and 10000 > -1 / mem[160]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[160] / 10000 != mem[160]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[160] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                        revert with 'NH{q', 17
                                    if (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[160]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4133]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4133 + 32] = (10000 * mem[(32 * idx) + _4133 + 32] * mem[128]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32] * mem[128]) / (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32])
                    else:
                        _12482 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size) + 1
                        mem[_12482] = return_data.size
                        mem[_12482 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if idx >= mem[_4133]:
                            revert with 'NH{q', 50
                        if mem[(32 * idx) + _4133 + 32] <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                        if mem[_8268 + 12 len 20] == address(_8275):
                            if mem[_12482 + 32] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if mem[_12482 + 64] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if 10000 < mem[_8268 + 128]:
                                revert with 'NH{q', 17
                            if not -mem[_8268 + 128] + 10000:
                                if mem[_12482 + 64]:
                                    if False and mem[_12482 + 64] > 0:
                                        revert with 'NH{q', 17
                                    if not mem[_12482 + 64]:
                                        revert with 'NH{q', 18
                                    if 0 / mem[_12482 + 64]:
                                        revert with 0, 'ds-math-mul-overflow'
                                if mem[_12482 + 32] and 10000 > -1 / mem[_12482 + 32]:
                                    revert with 'NH{q', 17
                                if 10000 * mem[_12482 + 32] / 10000 != mem[_12482 + 32]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 10000 * mem[_12482 + 32] > -1:
                                    revert with 'NH{q', 17
                                if 10000 * mem[_12482 + 32] < 10000 * mem[_12482 + 32]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not 10000 * mem[_12482 + 32]:
                                    revert with 'NH{q', 18
                                if idx > -2:
                                    revert with 'NH{q', 17
                                if idx + 1 >= mem[_4133]:
                                    revert with 'NH{q', 50
                                mem[(32 * idx + 1) + _4133 + 32] = 0 / 10000 * mem[_12482 + 32]
                            else:
                                if mem[(32 * idx) + _4133 + 32] and -mem[_8268 + 128] + 10000 > -1 / mem[(32 * idx) + _4133 + 32]:
                                    revert with 'NH{q', 17
                                if not -mem[_8268 + 128] + 10000:
                                    revert with 'NH{q', 18
                                if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) / -mem[_8268 + 128] + 10000 != mem[(32 * idx) + _4133 + 32]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if not mem[_12482 + 64]:
                                    if mem[_12482 + 32] and 10000 > -1 / mem[_12482 + 32]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[_12482 + 32] / 10000 != mem[_12482 + 32]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[_12482 + 32] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                        revert with 'NH{q', 17
                                    if (10000 * mem[_12482 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[_12482 + 32]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (10000 * mem[_12482 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4133]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4133 + 32] = 0 / (10000 * mem[_12482 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32])
                                else:
                                    if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) and mem[_12482 + 64] > -1 / (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                        revert with 'NH{q', 17
                                    if not mem[_12482 + 64]:
                                        revert with 'NH{q', 18
                                    if (10000 * mem[(32 * idx) + _4133 + 32] * mem[_12482 + 64]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32] * mem[_12482 + 64]) / mem[_12482 + 64] != (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if mem[_12482 + 32] and 10000 > -1 / mem[_12482 + 32]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[_12482 + 32] / 10000 != mem[_12482 + 32]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[_12482 + 32] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                        revert with 'NH{q', 17
                                    if (10000 * mem[_12482 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[_12482 + 32]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (10000 * mem[_12482 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4133]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4133 + 32] = (10000 * mem[(32 * idx) + _4133 + 32] * mem[_12482 + 64]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32] * mem[_12482 + 64]) / (10000 * mem[_12482 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32])
                        else:
                            if mem[_12482 + 64] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if mem[_12482 + 32] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if 10000 < mem[_8268 + 128]:
                                revert with 'NH{q', 17
                            if not -mem[_8268 + 128] + 10000:
                                if mem[_12482 + 32]:
                                    if False and mem[_12482 + 32] > 0:
                                        revert with 'NH{q', 17
                                    if not mem[_12482 + 32]:
                                        revert with 'NH{q', 18
                                    if 0 / mem[_12482 + 32]:
                                        revert with 0, 'ds-math-mul-overflow'
                                if mem[_12482 + 64] and 10000 > -1 / mem[_12482 + 64]:
                                    revert with 'NH{q', 17
                                if 10000 * mem[_12482 + 64] / 10000 != mem[_12482 + 64]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 10000 * mem[_12482 + 64] > -1:
                                    revert with 'NH{q', 17
                                if 10000 * mem[_12482 + 64] < 10000 * mem[_12482 + 64]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not 10000 * mem[_12482 + 64]:
                                    revert with 'NH{q', 18
                                if idx > -2:
                                    revert with 'NH{q', 17
                                if idx + 1 >= mem[_4133]:
                                    revert with 'NH{q', 50
                                mem[(32 * idx + 1) + _4133 + 32] = 0 / 10000 * mem[_12482 + 64]
                            else:
                                if mem[(32 * idx) + _4133 + 32] and -mem[_8268 + 128] + 10000 > -1 / mem[(32 * idx) + _4133 + 32]:
                                    revert with 'NH{q', 17
                                if not -mem[_8268 + 128] + 10000:
                                    revert with 'NH{q', 18
                                if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) / -mem[_8268 + 128] + 10000 != mem[(32 * idx) + _4133 + 32]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if not mem[_12482 + 32]:
                                    if mem[_12482 + 64] and 10000 > -1 / mem[_12482 + 64]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[_12482 + 64] / 10000 != mem[_12482 + 64]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[_12482 + 64] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                        revert with 'NH{q', 17
                                    if (10000 * mem[_12482 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[_12482 + 64]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (10000 * mem[_12482 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4133]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4133 + 32] = 0 / (10000 * mem[_12482 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32])
                                else:
                                    if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) and mem[_12482 + 32] > -1 / (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                        revert with 'NH{q', 17
                                    if not mem[_12482 + 32]:
                                        revert with 'NH{q', 18
                                    if (10000 * mem[(32 * idx) + _4133 + 32] * mem[_12482 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32] * mem[_12482 + 32]) / mem[_12482 + 32] != (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if mem[_12482 + 64] and 10000 > -1 / mem[_12482 + 64]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[_12482 + 64] / 10000 != mem[_12482 + 64]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[_12482 + 64] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                        revert with 'NH{q', 17
                                    if (10000 * mem[_12482 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[_12482 + 64]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (10000 * mem[_12482 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4133]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4133 + 32] = (10000 * mem[(32 * idx) + _4133 + 32] * mem[_12482 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32] * mem[_12482 + 32]) / (10000 * mem[_12482 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32])
        else:
            if mem[mem[(32 * idx) + 128] + 108 len 20] == 0xd8aa70f7990dab4a383a0d8a57df7a372916575d:
                _8300 = mem[mem[(32 * idx) + 128]]
                _8301 = mem[mem[(32 * idx) + 128] + 32]
                if mem[mem[(32 * idx) + 128] + 12 len 20] < mem[mem[(32 * idx) + 128] + 44 len 20]:
                    _8338 = mem[mem[(32 * idx) + 128] + 64]
                    _8360 = mem[64]
                    _8361 = mem[64]
                    mem[mem[64]] = 4
                    mem[64] = mem[64] + 36
                    mem[_8361 + 32] = mem[_8361 + 36 len 28] or 0x902f1ac00000000000000000000000000000000000000000000000000000000
                    _8452 = mem[_8361]
                    s = 0
                    while s < _8452:
                        mem[_8360 + s + 36] = mem[_8361 + s + 32]
                        _8261 = mem[96]
                        s = s + 32
                        continue 
                    if ceil32(_8452) <= _8452:
                        staticcall address(_8338).mem[mem[64] len 4] with:
                                gas gas_remaining wei
                               args mem[mem[64] + 4 len _8360 + _8452 + -mem[64] + 32]
                        if not return_data.size:
                            if idx >= mem[_4133]:
                                revert with 'NH{q', 50
                            if mem[(32 * idx) + _4133 + 32] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                            if mem[_8268 + 12 len 20] == address(_8300):
                                if mem[128] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[160] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 10000 < mem[_8268 + 128]:
                                    revert with 'NH{q', 17
                                if not -mem[_8268 + 128] + 10000:
                                    if mem[160]:
                                        if False and mem[160] > 0:
                                            revert with 'NH{q', 17
                                        if not mem[160]:
                                            revert with 'NH{q', 18
                                        if 0 / mem[160]:
                                            revert with 0, 'ds-math-mul-overflow'
                                    if mem[128] and 10000 > -1 / mem[128]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[128] / 10000 != mem[128]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[128] > -1:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[128] < 10000 * mem[128]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not 10000 * mem[128]:
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4133]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4133 + 32] = 0 / 10000 * mem[128]
                                else:
                                    if mem[(32 * idx) + _4133 + 32] and -mem[_8268 + 128] + 10000 > -1 / mem[(32 * idx) + _4133 + 32]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8268 + 128] + 10000:
                                        revert with 'NH{q', 18
                                    if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) / -mem[_8268 + 128] + 10000 != mem[(32 * idx) + _4133 + 32]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if not mem[160]:
                                        if mem[128] and 10000 > -1 / mem[128]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[128] / 10000 != mem[128]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[128] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[128]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4133]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4133 + 32] = 0 / (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32])
                                    else:
                                        if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) and mem[160] > -1 / (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 'NH{q', 17
                                        if not mem[160]:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4133 + 32] * mem[160]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32] * mem[160]) / mem[160] != (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 0, 'ds-math-mul-overflow'
                                        if mem[128] and 10000 > -1 / mem[128]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[128] / 10000 != mem[128]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[128] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[128]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4133]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4133 + 32] = (10000 * mem[(32 * idx) + _4133 + 32] * mem[160]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32] * mem[160]) / (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32])
                            else:
                                if mem[160] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[128] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 10000 < mem[_8268 + 128]:
                                    revert with 'NH{q', 17
                                if not -mem[_8268 + 128] + 10000:
                                    if mem[128]:
                                        if False and mem[128] > 0:
                                            revert with 'NH{q', 17
                                        if not mem[128]:
                                            revert with 'NH{q', 18
                                        if 0 / mem[128]:
                                            revert with 0, 'ds-math-mul-overflow'
                                    if mem[160] and 10000 > -1 / mem[160]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[160] / 10000 != mem[160]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[160] > -1:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[160] < 10000 * mem[160]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not 10000 * mem[160]:
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4133]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4133 + 32] = 0 / 10000 * mem[160]
                                else:
                                    if mem[(32 * idx) + _4133 + 32] and -mem[_8268 + 128] + 10000 > -1 / mem[(32 * idx) + _4133 + 32]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8268 + 128] + 10000:
                                        revert with 'NH{q', 18
                                    if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) / -mem[_8268 + 128] + 10000 != mem[(32 * idx) + _4133 + 32]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if not mem[128]:
                                        if mem[160] and 10000 > -1 / mem[160]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[160] / 10000 != mem[160]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[160] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[160]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4133]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4133 + 32] = 0 / (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32])
                                    else:
                                        if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) and mem[128] > -1 / (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 'NH{q', 17
                                        if not mem[128]:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4133 + 32] * mem[128]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32] * mem[128]) / mem[128] != (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 0, 'ds-math-mul-overflow'
                                        if mem[160] and 10000 > -1 / mem[160]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[160] / 10000 != mem[160]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[160] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[160]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4133]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4133 + 32] = (10000 * mem[(32 * idx) + _4133 + 32] * mem[128]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32] * mem[128]) / (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32])
                        else:
                            _12438 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                            mem[_12438] = return_data.size
                            mem[_12438 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if idx >= mem[_4133]:
                                revert with 'NH{q', 50
                            if mem[(32 * idx) + _4133 + 32] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                            if mem[_8268 + 12 len 20] == address(_8300):
                                if mem[_12438 + 32] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[_12438 + 64] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 10000 < mem[_8268 + 128]:
                                    revert with 'NH{q', 17
                                if not -mem[_8268 + 128] + 10000:
                                    if mem[_12438 + 64]:
                                        if False and mem[_12438 + 64] > 0:
                                            revert with 'NH{q', 17
                                        if not mem[_12438 + 64]:
                                            revert with 'NH{q', 18
                                        if 0 / mem[_12438 + 64]:
                                            revert with 0, 'ds-math-mul-overflow'
                                    if mem[_12438 + 32] and 10000 > -1 / mem[_12438 + 32]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[_12438 + 32] / 10000 != mem[_12438 + 32]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[_12438 + 32] > -1:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[_12438 + 32] < 10000 * mem[_12438 + 32]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not 10000 * mem[_12438 + 32]:
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4133]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4133 + 32] = 0 / 10000 * mem[_12438 + 32]
                                else:
                                    if mem[(32 * idx) + _4133 + 32] and -mem[_8268 + 128] + 10000 > -1 / mem[(32 * idx) + _4133 + 32]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8268 + 128] + 10000:
                                        revert with 'NH{q', 18
                                    if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) / -mem[_8268 + 128] + 10000 != mem[(32 * idx) + _4133 + 32]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if not mem[_12438 + 64]:
                                        if mem[_12438 + 32] and 10000 > -1 / mem[_12438 + 32]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12438 + 32] / 10000 != mem[_12438 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[_12438 + 32] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[_12438 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[_12438 + 32]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[_12438 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4133]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4133 + 32] = 0 / (10000 * mem[_12438 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32])
                                    else:
                                        if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) and mem[_12438 + 64] > -1 / (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 'NH{q', 17
                                        if not mem[_12438 + 64]:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4133 + 32] * mem[_12438 + 64]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32] * mem[_12438 + 64]) / mem[_12438 + 64] != (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 0, 'ds-math-mul-overflow'
                                        if mem[_12438 + 32] and 10000 > -1 / mem[_12438 + 32]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12438 + 32] / 10000 != mem[_12438 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[_12438 + 32] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[_12438 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[_12438 + 32]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[_12438 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4133]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4133 + 32] = (10000 * mem[(32 * idx) + _4133 + 32] * mem[_12438 + 64]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32] * mem[_12438 + 64]) / (10000 * mem[_12438 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32])
                            else:
                                if mem[_12438 + 64] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[_12438 + 32] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 10000 < mem[_8268 + 128]:
                                    revert with 'NH{q', 17
                                if not -mem[_8268 + 128] + 10000:
                                    if mem[_12438 + 32]:
                                        if False and mem[_12438 + 32] > 0:
                                            revert with 'NH{q', 17
                                        if not mem[_12438 + 32]:
                                            revert with 'NH{q', 18
                                        if 0 / mem[_12438 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                    if mem[_12438 + 64] and 10000 > -1 / mem[_12438 + 64]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[_12438 + 64] / 10000 != mem[_12438 + 64]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[_12438 + 64] > -1:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[_12438 + 64] < 10000 * mem[_12438 + 64]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not 10000 * mem[_12438 + 64]:
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4133]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4133 + 32] = 0 / 10000 * mem[_12438 + 64]
                                else:
                                    if mem[(32 * idx) + _4133 + 32] and -mem[_8268 + 128] + 10000 > -1 / mem[(32 * idx) + _4133 + 32]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8268 + 128] + 10000:
                                        revert with 'NH{q', 18
                                    if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) / -mem[_8268 + 128] + 10000 != mem[(32 * idx) + _4133 + 32]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if not mem[_12438 + 32]:
                                        if mem[_12438 + 64] and 10000 > -1 / mem[_12438 + 64]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12438 + 64] / 10000 != mem[_12438 + 64]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[_12438 + 64] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[_12438 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[_12438 + 64]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[_12438 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4133]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4133 + 32] = 0 / (10000 * mem[_12438 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32])
                                    else:
                                        if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) and mem[_12438 + 32] > -1 / (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 'NH{q', 17
                                        if not mem[_12438 + 32]:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4133 + 32] * mem[_12438 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32] * mem[_12438 + 32]) / mem[_12438 + 32] != (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 0, 'ds-math-mul-overflow'
                                        if mem[_12438 + 64] and 10000 > -1 / mem[_12438 + 64]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12438 + 64] / 10000 != mem[_12438 + 64]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[_12438 + 64] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[_12438 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[_12438 + 64]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[_12438 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4133]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4133 + 32] = (10000 * mem[(32 * idx) + _4133 + 32] * mem[_12438 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32] * mem[_12438 + 32]) / (10000 * mem[_12438 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32])
                    else:
                        mem[_8360 + _8452 + 36] = 0
                        staticcall address(_8338).mem[mem[64] len 4] with:
                                gas gas_remaining wei
                               args mem[mem[64] + 4 len _8360 + _8452 + -mem[64] + 32]
                        if not return_data.size:
                            if idx >= mem[_4133]:
                                revert with 'NH{q', 50
                            if mem[(32 * idx) + _4133 + 32] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                            if mem[_8268 + 12 len 20] == address(_8300):
                                if mem[128] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[160] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 10000 < mem[_8268 + 128]:
                                    revert with 'NH{q', 17
                                if not -mem[_8268 + 128] + 10000:
                                    if mem[160]:
                                        if False and mem[160] > 0:
                                            revert with 'NH{q', 17
                                        if not mem[160]:
                                            revert with 'NH{q', 18
                                        if 0 / mem[160]:
                                            revert with 0, 'ds-math-mul-overflow'
                                    if mem[128] and 10000 > -1 / mem[128]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[128] / 10000 != mem[128]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[128] > -1:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[128] < 10000 * mem[128]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not 10000 * mem[128]:
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4133]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4133 + 32] = 0 / 10000 * mem[128]
                                else:
                                    if mem[(32 * idx) + _4133 + 32] and -mem[_8268 + 128] + 10000 > -1 / mem[(32 * idx) + _4133 + 32]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8268 + 128] + 10000:
                                        revert with 'NH{q', 18
                                    if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) / -mem[_8268 + 128] + 10000 != mem[(32 * idx) + _4133 + 32]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if not mem[160]:
                                        if mem[128] and 10000 > -1 / mem[128]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[128] / 10000 != mem[128]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[128] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[128]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4133]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4133 + 32] = 0 / (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32])
                                    else:
                                        if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) and mem[160] > -1 / (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 'NH{q', 17
                                        if not mem[160]:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4133 + 32] * mem[160]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32] * mem[160]) / mem[160] != (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 0, 'ds-math-mul-overflow'
                                        if mem[128] and 10000 > -1 / mem[128]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[128] / 10000 != mem[128]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[128] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[128]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4133]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4133 + 32] = (10000 * mem[(32 * idx) + _4133 + 32] * mem[160]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32] * mem[160]) / (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32])
                            else:
                                if mem[160] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[128] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 10000 < mem[_8268 + 128]:
                                    revert with 'NH{q', 17
                                if not -mem[_8268 + 128] + 10000:
                                    if mem[128]:
                                        if False and mem[128] > 0:
                                            revert with 'NH{q', 17
                                        if not mem[128]:
                                            revert with 'NH{q', 18
                                        if 0 / mem[128]:
                                            revert with 0, 'ds-math-mul-overflow'
                                    if mem[160] and 10000 > -1 / mem[160]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[160] / 10000 != mem[160]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[160] > -1:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[160] < 10000 * mem[160]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not 10000 * mem[160]:
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4133]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4133 + 32] = 0 / 10000 * mem[160]
                                else:
                                    if mem[(32 * idx) + _4133 + 32] and -mem[_8268 + 128] + 10000 > -1 / mem[(32 * idx) + _4133 + 32]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8268 + 128] + 10000:
                                        revert with 'NH{q', 18
                                    if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) / -mem[_8268 + 128] + 10000 != mem[(32 * idx) + _4133 + 32]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if not mem[128]:
                                        if mem[160] and 10000 > -1 / mem[160]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[160] / 10000 != mem[160]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[160] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[160]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4133]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4133 + 32] = 0 / (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32])
                                    else:
                                        if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) and mem[128] > -1 / (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 'NH{q', 17
                                        if not mem[128]:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4133 + 32] * mem[128]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32] * mem[128]) / mem[128] != (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 0, 'ds-math-mul-overflow'
                                        if mem[160] and 10000 > -1 / mem[160]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[160] / 10000 != mem[160]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[160] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[160]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4133]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4133 + 32] = (10000 * mem[(32 * idx) + _4133 + 32] * mem[128]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32] * mem[128]) / (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32])
                        else:
                            _12498 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                            mem[_12498] = return_data.size
                            mem[_12498 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if idx >= mem[_4133]:
                                revert with 'NH{q', 50
                            if mem[(32 * idx) + _4133 + 32] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                            if mem[_8268 + 12 len 20] == address(_8300):
                                if mem[_12498 + 32] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[_12498 + 64] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 10000 < mem[_8268 + 128]:
                                    revert with 'NH{q', 17
                                if not -mem[_8268 + 128] + 10000:
                                    if mem[_12498 + 64]:
                                        if False and mem[_12498 + 64] > 0:
                                            revert with 'NH{q', 17
                                        if not mem[_12498 + 64]:
                                            revert with 'NH{q', 18
                                        if 0 / mem[_12498 + 64]:
                                            revert with 0, 'ds-math-mul-overflow'
                                    if mem[_12498 + 32] and 10000 > -1 / mem[_12498 + 32]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[_12498 + 32] / 10000 != mem[_12498 + 32]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[_12498 + 32] > -1:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[_12498 + 32] < 10000 * mem[_12498 + 32]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not 10000 * mem[_12498 + 32]:
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4133]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4133 + 32] = 0 / 10000 * mem[_12498 + 32]
                                else:
                                    if mem[(32 * idx) + _4133 + 32] and -mem[_8268 + 128] + 10000 > -1 / mem[(32 * idx) + _4133 + 32]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8268 + 128] + 10000:
                                        revert with 'NH{q', 18
                                    if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) / -mem[_8268 + 128] + 10000 != mem[(32 * idx) + _4133 + 32]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if not mem[_12498 + 64]:
                                        if mem[_12498 + 32] and 10000 > -1 / mem[_12498 + 32]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12498 + 32] / 10000 != mem[_12498 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[_12498 + 32] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[_12498 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[_12498 + 32]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[_12498 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4133]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4133 + 32] = 0 / (10000 * mem[_12498 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32])
                                    else:
                                        if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) and mem[_12498 + 64] > -1 / (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 'NH{q', 17
                                        if not mem[_12498 + 64]:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4133 + 32] * mem[_12498 + 64]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32] * mem[_12498 + 64]) / mem[_12498 + 64] != (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 0, 'ds-math-mul-overflow'
                                        if mem[_12498 + 32] and 10000 > -1 / mem[_12498 + 32]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12498 + 32] / 10000 != mem[_12498 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[_12498 + 32] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[_12498 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[_12498 + 32]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[_12498 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4133]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4133 + 32] = (10000 * mem[(32 * idx) + _4133 + 32] * mem[_12498 + 64]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32] * mem[_12498 + 64]) / (10000 * mem[_12498 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32])
                            else:
                                if mem[_12498 + 64] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[_12498 + 32] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 10000 < mem[_8268 + 128]:
                                    revert with 'NH{q', 17
                                if not -mem[_8268 + 128] + 10000:
                                    if mem[_12498 + 32]:
                                        if False and mem[_12498 + 32] > 0:
                                            revert with 'NH{q', 17
                                        if not mem[_12498 + 32]:
                                            revert with 'NH{q', 18
                                        if 0 / mem[_12498 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                    if mem[_12498 + 64] and 10000 > -1 / mem[_12498 + 64]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[_12498 + 64] / 10000 != mem[_12498 + 64]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[_12498 + 64] > -1:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[_12498 + 64] < 10000 * mem[_12498 + 64]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not 10000 * mem[_12498 + 64]:
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4133]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4133 + 32] = 0 / 10000 * mem[_12498 + 64]
                                else:
                                    if mem[(32 * idx) + _4133 + 32] and -mem[_8268 + 128] + 10000 > -1 / mem[(32 * idx) + _4133 + 32]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8268 + 128] + 10000:
                                        revert with 'NH{q', 18
                                    if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) / -mem[_8268 + 128] + 10000 != mem[(32 * idx) + _4133 + 32]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if not mem[_12498 + 32]:
                                        if mem[_12498 + 64] and 10000 > -1 / mem[_12498 + 64]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12498 + 64] / 10000 != mem[_12498 + 64]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[_12498 + 64] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[_12498 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[_12498 + 64]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[_12498 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4133]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4133 + 32] = 0 / (10000 * mem[_12498 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32])
                                    else:
                                        if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) and mem[_12498 + 32] > -1 / (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 'NH{q', 17
                                        if not mem[_12498 + 32]:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4133 + 32] * mem[_12498 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32] * mem[_12498 + 32]) / mem[_12498 + 32] != (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 0, 'ds-math-mul-overflow'
                                        if mem[_12498 + 64] and 10000 > -1 / mem[_12498 + 64]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12498 + 64] / 10000 != mem[_12498 + 64]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[_12498 + 64] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[_12498 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[_12498 + 64]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[_12498 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4133]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4133 + 32] = (10000 * mem[(32 * idx) + _4133 + 32] * mem[_12498 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32] * mem[_12498 + 32]) / (10000 * mem[_12498 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32])
                else:
                    _8339 = mem[mem[(32 * idx) + 128] + 64]
                    _8364 = mem[64]
                    _8365 = mem[64]
                    mem[mem[64]] = 4
                    mem[64] = mem[64] + 36
                    mem[_8365 + 32] = mem[_8365 + 36 len 28] or 0x902f1ac00000000000000000000000000000000000000000000000000000000
                    _8453 = mem[_8365]
                    s = 0
                    while s < _8453:
                        mem[_8364 + s + 36] = mem[_8365 + s + 32]
                        _8261 = mem[96]
                        s = s + 32
                        continue 
                    if ceil32(_8453) <= _8453:
                        staticcall address(_8339).mem[mem[64] len 4] with:
                                gas gas_remaining wei
                               args mem[mem[64] + 4 len _8364 + _8453 + -mem[64] + 32]
                        if not return_data.size:
                            if idx >= mem[_4133]:
                                revert with 'NH{q', 50
                            if mem[(32 * idx) + _4133 + 32] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                            if mem[_8268 + 12 len 20] == address(_8301):
                                if mem[128] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[160] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 10000 < mem[_8268 + 128]:
                                    revert with 'NH{q', 17
                                if not -mem[_8268 + 128] + 10000:
                                    if mem[160]:
                                        if False and mem[160] > 0:
                                            revert with 'NH{q', 17
                                        if not mem[160]:
                                            revert with 'NH{q', 18
                                        if 0 / mem[160]:
                                            revert with 0, 'ds-math-mul-overflow'
                                    if mem[128] and 10000 > -1 / mem[128]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[128] / 10000 != mem[128]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[128] > -1:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[128] < 10000 * mem[128]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not 10000 * mem[128]:
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4133]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4133 + 32] = 0 / 10000 * mem[128]
                                else:
                                    if mem[(32 * idx) + _4133 + 32] and -mem[_8268 + 128] + 10000 > -1 / mem[(32 * idx) + _4133 + 32]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8268 + 128] + 10000:
                                        revert with 'NH{q', 18
                                    if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) / -mem[_8268 + 128] + 10000 != mem[(32 * idx) + _4133 + 32]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if not mem[160]:
                                        if mem[128] and 10000 > -1 / mem[128]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[128] / 10000 != mem[128]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[128] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[128]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4133]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4133 + 32] = 0 / (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32])
                                    else:
                                        if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) and mem[160] > -1 / (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 'NH{q', 17
                                        if not mem[160]:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4133 + 32] * mem[160]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32] * mem[160]) / mem[160] != (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 0, 'ds-math-mul-overflow'
                                        if mem[128] and 10000 > -1 / mem[128]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[128] / 10000 != mem[128]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[128] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[128]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4133]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4133 + 32] = (10000 * mem[(32 * idx) + _4133 + 32] * mem[160]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32] * mem[160]) / (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32])
                            else:
                                if mem[160] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[128] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 10000 < mem[_8268 + 128]:
                                    revert with 'NH{q', 17
                                if not -mem[_8268 + 128] + 10000:
                                    if mem[128]:
                                        if False and mem[128] > 0:
                                            revert with 'NH{q', 17
                                        if not mem[128]:
                                            revert with 'NH{q', 18
                                        if 0 / mem[128]:
                                            revert with 0, 'ds-math-mul-overflow'
                                    if mem[160] and 10000 > -1 / mem[160]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[160] / 10000 != mem[160]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[160] > -1:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[160] < 10000 * mem[160]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not 10000 * mem[160]:
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4133]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4133 + 32] = 0 / 10000 * mem[160]
                                else:
                                    if mem[(32 * idx) + _4133 + 32] and -mem[_8268 + 128] + 10000 > -1 / mem[(32 * idx) + _4133 + 32]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8268 + 128] + 10000:
                                        revert with 'NH{q', 18
                                    if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) / -mem[_8268 + 128] + 10000 != mem[(32 * idx) + _4133 + 32]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if not mem[128]:
                                        if mem[160] and 10000 > -1 / mem[160]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[160] / 10000 != mem[160]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[160] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[160]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4133]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4133 + 32] = 0 / (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32])
                                    else:
                                        if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) and mem[128] > -1 / (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 'NH{q', 17
                                        if not mem[128]:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4133 + 32] * mem[128]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32] * mem[128]) / mem[128] != (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 0, 'ds-math-mul-overflow'
                                        if mem[160] and 10000 > -1 / mem[160]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[160] / 10000 != mem[160]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[160] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[160]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4133]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4133 + 32] = (10000 * mem[(32 * idx) + _4133 + 32] * mem[128]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32] * mem[128]) / (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32])
                        else:
                            _12440 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                            mem[_12440] = return_data.size
                            mem[_12440 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if idx >= mem[_4133]:
                                revert with 'NH{q', 50
                            if mem[(32 * idx) + _4133 + 32] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                            if mem[_8268 + 12 len 20] == address(_8301):
                                if mem[_12440 + 32] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[_12440 + 64] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 10000 < mem[_8268 + 128]:
                                    revert with 'NH{q', 17
                                if not -mem[_8268 + 128] + 10000:
                                    if mem[_12440 + 64]:
                                        if False and mem[_12440 + 64] > 0:
                                            revert with 'NH{q', 17
                                        if not mem[_12440 + 64]:
                                            revert with 'NH{q', 18
                                        if 0 / mem[_12440 + 64]:
                                            revert with 0, 'ds-math-mul-overflow'
                                    if mem[_12440 + 32] and 10000 > -1 / mem[_12440 + 32]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[_12440 + 32] / 10000 != mem[_12440 + 32]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[_12440 + 32] > -1:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[_12440 + 32] < 10000 * mem[_12440 + 32]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not 10000 * mem[_12440 + 32]:
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4133]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4133 + 32] = 0 / 10000 * mem[_12440 + 32]
                                else:
                                    if mem[(32 * idx) + _4133 + 32] and -mem[_8268 + 128] + 10000 > -1 / mem[(32 * idx) + _4133 + 32]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8268 + 128] + 10000:
                                        revert with 'NH{q', 18
                                    if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) / -mem[_8268 + 128] + 10000 != mem[(32 * idx) + _4133 + 32]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if not mem[_12440 + 64]:
                                        if mem[_12440 + 32] and 10000 > -1 / mem[_12440 + 32]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12440 + 32] / 10000 != mem[_12440 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[_12440 + 32] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[_12440 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[_12440 + 32]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[_12440 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4133]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4133 + 32] = 0 / (10000 * mem[_12440 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32])
                                    else:
                                        if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) and mem[_12440 + 64] > -1 / (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 'NH{q', 17
                                        if not mem[_12440 + 64]:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4133 + 32] * mem[_12440 + 64]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32] * mem[_12440 + 64]) / mem[_12440 + 64] != (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 0, 'ds-math-mul-overflow'
                                        if mem[_12440 + 32] and 10000 > -1 / mem[_12440 + 32]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12440 + 32] / 10000 != mem[_12440 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[_12440 + 32] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[_12440 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[_12440 + 32]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[_12440 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4133]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4133 + 32] = (10000 * mem[(32 * idx) + _4133 + 32] * mem[_12440 + 64]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32] * mem[_12440 + 64]) / (10000 * mem[_12440 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32])
                            else:
                                if mem[_12440 + 64] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[_12440 + 32] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 10000 < mem[_8268 + 128]:
                                    revert with 'NH{q', 17
                                if not -mem[_8268 + 128] + 10000:
                                    if mem[_12440 + 32]:
                                        if False and mem[_12440 + 32] > 0:
                                            revert with 'NH{q', 17
                                        if not mem[_12440 + 32]:
                                            revert with 'NH{q', 18
                                        if 0 / mem[_12440 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                    if mem[_12440 + 64] and 10000 > -1 / mem[_12440 + 64]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[_12440 + 64] / 10000 != mem[_12440 + 64]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[_12440 + 64] > -1:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[_12440 + 64] < 10000 * mem[_12440 + 64]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not 10000 * mem[_12440 + 64]:
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4133]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4133 + 32] = 0 / 10000 * mem[_12440 + 64]
                                else:
                                    if mem[(32 * idx) + _4133 + 32] and -mem[_8268 + 128] + 10000 > -1 / mem[(32 * idx) + _4133 + 32]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8268 + 128] + 10000:
                                        revert with 'NH{q', 18
                                    if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) / -mem[_8268 + 128] + 10000 != mem[(32 * idx) + _4133 + 32]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if not mem[_12440 + 32]:
                                        if mem[_12440 + 64] and 10000 > -1 / mem[_12440 + 64]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12440 + 64] / 10000 != mem[_12440 + 64]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[_12440 + 64] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[_12440 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[_12440 + 64]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[_12440 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4133]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4133 + 32] = 0 / (10000 * mem[_12440 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32])
                                    else:
                                        if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) and mem[_12440 + 32] > -1 / (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 'NH{q', 17
                                        if not mem[_12440 + 32]:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4133 + 32] * mem[_12440 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32] * mem[_12440 + 32]) / mem[_12440 + 32] != (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 0, 'ds-math-mul-overflow'
                                        if mem[_12440 + 64] and 10000 > -1 / mem[_12440 + 64]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12440 + 64] / 10000 != mem[_12440 + 64]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[_12440 + 64] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[_12440 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[_12440 + 64]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[_12440 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4133]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4133 + 32] = (10000 * mem[(32 * idx) + _4133 + 32] * mem[_12440 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32] * mem[_12440 + 32]) / (10000 * mem[_12440 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32])
                    else:
                        mem[_8364 + _8453 + 36] = 0
                        staticcall address(_8339).mem[mem[64] len 4] with:
                                gas gas_remaining wei
                               args mem[mem[64] + 4 len _8364 + _8453 + -mem[64] + 32]
                        if not return_data.size:
                            if idx >= mem[_4133]:
                                revert with 'NH{q', 50
                            if mem[(32 * idx) + _4133 + 32] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                            if mem[_8268 + 12 len 20] == address(_8301):
                                if mem[128] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[160] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 10000 < mem[_8268 + 128]:
                                    revert with 'NH{q', 17
                                if not -mem[_8268 + 128] + 10000:
                                    if mem[160]:
                                        if False and mem[160] > 0:
                                            revert with 'NH{q', 17
                                        if not mem[160]:
                                            revert with 'NH{q', 18
                                        if 0 / mem[160]:
                                            revert with 0, 'ds-math-mul-overflow'
                                    if mem[128] and 10000 > -1 / mem[128]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[128] / 10000 != mem[128]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[128] > -1:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[128] < 10000 * mem[128]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not 10000 * mem[128]:
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4133]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4133 + 32] = 0 / 10000 * mem[128]
                                else:
                                    if mem[(32 * idx) + _4133 + 32] and -mem[_8268 + 128] + 10000 > -1 / mem[(32 * idx) + _4133 + 32]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8268 + 128] + 10000:
                                        revert with 'NH{q', 18
                                    if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) / -mem[_8268 + 128] + 10000 != mem[(32 * idx) + _4133 + 32]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if not mem[160]:
                                        if mem[128] and 10000 > -1 / mem[128]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[128] / 10000 != mem[128]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[128] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[128]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4133]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4133 + 32] = 0 / (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32])
                                    else:
                                        if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) and mem[160] > -1 / (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 'NH{q', 17
                                        if not mem[160]:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4133 + 32] * mem[160]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32] * mem[160]) / mem[160] != (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 0, 'ds-math-mul-overflow'
                                        if mem[128] and 10000 > -1 / mem[128]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[128] / 10000 != mem[128]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[128] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[128]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4133]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4133 + 32] = (10000 * mem[(32 * idx) + _4133 + 32] * mem[160]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32] * mem[160]) / (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32])
                            else:
                                if mem[160] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[128] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 10000 < mem[_8268 + 128]:
                                    revert with 'NH{q', 17
                                if not -mem[_8268 + 128] + 10000:
                                    if mem[128]:
                                        if False and mem[128] > 0:
                                            revert with 'NH{q', 17
                                        if not mem[128]:
                                            revert with 'NH{q', 18
                                        if 0 / mem[128]:
                                            revert with 0, 'ds-math-mul-overflow'
                                    if mem[160] and 10000 > -1 / mem[160]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[160] / 10000 != mem[160]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[160] > -1:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[160] < 10000 * mem[160]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not 10000 * mem[160]:
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4133]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4133 + 32] = 0 / 10000 * mem[160]
                                else:
                                    if mem[(32 * idx) + _4133 + 32] and -mem[_8268 + 128] + 10000 > -1 / mem[(32 * idx) + _4133 + 32]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8268 + 128] + 10000:
                                        revert with 'NH{q', 18
                                    if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) / -mem[_8268 + 128] + 10000 != mem[(32 * idx) + _4133 + 32]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if not mem[128]:
                                        if mem[160] and 10000 > -1 / mem[160]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[160] / 10000 != mem[160]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[160] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[160]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4133]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4133 + 32] = 0 / (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32])
                                    else:
                                        if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) and mem[128] > -1 / (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 'NH{q', 17
                                        if not mem[128]:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4133 + 32] * mem[128]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32] * mem[128]) / mem[128] != (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 0, 'ds-math-mul-overflow'
                                        if mem[160] and 10000 > -1 / mem[160]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[160] / 10000 != mem[160]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[160] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[160]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4133]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4133 + 32] = (10000 * mem[(32 * idx) + _4133 + 32] * mem[128]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32] * mem[128]) / (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32])
                        else:
                            _12503 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                            mem[_12503] = return_data.size
                            mem[_12503 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if idx >= mem[_4133]:
                                revert with 'NH{q', 50
                            if mem[(32 * idx) + _4133 + 32] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                            if mem[_8268 + 12 len 20] == address(_8301):
                                if mem[_12503 + 32] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[_12503 + 64] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 10000 < mem[_8268 + 128]:
                                    revert with 'NH{q', 17
                                if not -mem[_8268 + 128] + 10000:
                                    if mem[_12503 + 64]:
                                        if False and mem[_12503 + 64] > 0:
                                            revert with 'NH{q', 17
                                        if not mem[_12503 + 64]:
                                            revert with 'NH{q', 18
                                        if 0 / mem[_12503 + 64]:
                                            revert with 0, 'ds-math-mul-overflow'
                                    if mem[_12503 + 32] and 10000 > -1 / mem[_12503 + 32]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[_12503 + 32] / 10000 != mem[_12503 + 32]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[_12503 + 32] > -1:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[_12503 + 32] < 10000 * mem[_12503 + 32]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not 10000 * mem[_12503 + 32]:
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4133]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4133 + 32] = 0 / 10000 * mem[_12503 + 32]
                                else:
                                    if mem[(32 * idx) + _4133 + 32] and -mem[_8268 + 128] + 10000 > -1 / mem[(32 * idx) + _4133 + 32]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8268 + 128] + 10000:
                                        revert with 'NH{q', 18
                                    if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) / -mem[_8268 + 128] + 10000 != mem[(32 * idx) + _4133 + 32]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if not mem[_12503 + 64]:
                                        if mem[_12503 + 32] and 10000 > -1 / mem[_12503 + 32]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12503 + 32] / 10000 != mem[_12503 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[_12503 + 32] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[_12503 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[_12503 + 32]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[_12503 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4133]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4133 + 32] = 0 / (10000 * mem[_12503 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32])
                                    else:
                                        if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) and mem[_12503 + 64] > -1 / (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 'NH{q', 17
                                        if not mem[_12503 + 64]:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4133 + 32] * mem[_12503 + 64]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32] * mem[_12503 + 64]) / mem[_12503 + 64] != (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 0, 'ds-math-mul-overflow'
                                        if mem[_12503 + 32] and 10000 > -1 / mem[_12503 + 32]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12503 + 32] / 10000 != mem[_12503 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[_12503 + 32] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[_12503 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[_12503 + 32]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[_12503 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4133]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4133 + 32] = (10000 * mem[(32 * idx) + _4133 + 32] * mem[_12503 + 64]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32] * mem[_12503 + 64]) / (10000 * mem[_12503 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32])
                            else:
                                if mem[_12503 + 64] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[_12503 + 32] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 10000 < mem[_8268 + 128]:
                                    revert with 'NH{q', 17
                                if not -mem[_8268 + 128] + 10000:
                                    if mem[_12503 + 32]:
                                        if False and mem[_12503 + 32] > 0:
                                            revert with 'NH{q', 17
                                        if not mem[_12503 + 32]:
                                            revert with 'NH{q', 18
                                        if 0 / mem[_12503 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                    if mem[_12503 + 64] and 10000 > -1 / mem[_12503 + 64]:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[_12503 + 64] / 10000 != mem[_12503 + 64]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 10000 * mem[_12503 + 64] > -1:
                                        revert with 'NH{q', 17
                                    if 10000 * mem[_12503 + 64] < 10000 * mem[_12503 + 64]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not 10000 * mem[_12503 + 64]:
                                        revert with 'NH{q', 18
                                    if idx > -2:
                                        revert with 'NH{q', 17
                                    if idx + 1 >= mem[_4133]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx + 1) + _4133 + 32] = 0 / 10000 * mem[_12503 + 64]
                                else:
                                    if mem[(32 * idx) + _4133 + 32] and -mem[_8268 + 128] + 10000 > -1 / mem[(32 * idx) + _4133 + 32]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8268 + 128] + 10000:
                                        revert with 'NH{q', 18
                                    if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) / -mem[_8268 + 128] + 10000 != mem[(32 * idx) + _4133 + 32]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if not mem[_12503 + 32]:
                                        if mem[_12503 + 64] and 10000 > -1 / mem[_12503 + 64]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12503 + 64] / 10000 != mem[_12503 + 64]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[_12503 + 64] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[_12503 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[_12503 + 64]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[_12503 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4133]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4133 + 32] = 0 / (10000 * mem[_12503 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32])
                                    else:
                                        if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) and mem[_12503 + 32] > -1 / (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 'NH{q', 17
                                        if not mem[_12503 + 32]:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4133 + 32] * mem[_12503 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32] * mem[_12503 + 32]) / mem[_12503 + 32] != (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 0, 'ds-math-mul-overflow'
                                        if mem[_12503 + 64] and 10000 > -1 / mem[_12503 + 64]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12503 + 64] / 10000 != mem[_12503 + 64]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[_12503 + 64] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                            revert with 'NH{q', 17
                                        if (10000 * mem[_12503 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[_12503 + 64]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (10000 * mem[_12503 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4133]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4133 + 32] = (10000 * mem[(32 * idx) + _4133 + 32] * mem[_12503 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32] * mem[_12503 + 32]) / (10000 * mem[_12503 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32])
            else:
                if mem[mem[(32 * idx) + 128] + 108 len 20] == 0xb9a9bb6cc39387548baa7185fbff51d47eef8771:
                    _8306 = mem[mem[(32 * idx) + 128]]
                    _8307 = mem[mem[(32 * idx) + 128] + 32]
                    if mem[mem[(32 * idx) + 128] + 12 len 20] < mem[mem[(32 * idx) + 128] + 44 len 20]:
                        _8358 = mem[mem[(32 * idx) + 128] + 64]
                        _8396 = mem[64]
                        _8397 = mem[64]
                        mem[mem[64]] = 4
                        mem[64] = mem[64] + 36
                        mem[_8397 + 32] = mem[_8397 + 36 len 28] or 0x902f1ac00000000000000000000000000000000000000000000000000000000
                        _8470 = mem[_8397]
                        s = 0
                        while s < _8470:
                            mem[_8396 + s + 36] = mem[_8397 + s + 32]
                            _8261 = mem[96]
                            s = s + 32
                            continue 
                        if ceil32(_8470) <= _8470:
                            staticcall address(_8358).mem[mem[64] len 4] with:
                                    gas gas_remaining wei
                                   args mem[mem[64] + 4 len _8396 + _8470 + -mem[64] + 32]
                            if not return_data.size:
                                if idx >= mem[_4133]:
                                    revert with 'NH{q', 50
                                if mem[(32 * idx) + _4133 + 32] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                if mem[_8268 + 12 len 20] == address(_8306):
                                    if mem[128] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if mem[160] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if 10000 < mem[_8268 + 128]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8268 + 128] + 10000:
                                        if mem[160]:
                                            if False and mem[160] > 0:
                                                revert with 'NH{q', 17
                                            if not mem[160]:
                                                revert with 'NH{q', 18
                                            if 0 / mem[160]:
                                                revert with 0, 'ds-math-mul-overflow'
                                        if mem[128] and 10000 > -1 / mem[128]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[128] / 10000 != mem[128]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[128] > -1:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[128] < 10000 * mem[128]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not 10000 * mem[128]:
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4133]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4133 + 32] = 0 / 10000 * mem[128]
                                    else:
                                        if mem[(32 * idx) + _4133 + 32] and -mem[_8268 + 128] + 10000 > -1 / mem[(32 * idx) + _4133 + 32]:
                                            revert with 'NH{q', 17
                                        if not -mem[_8268 + 128] + 10000:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) / -mem[_8268 + 128] + 10000 != mem[(32 * idx) + _4133 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if not mem[160]:
                                            if mem[128] and 10000 > -1 / mem[128]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[128] / 10000 != mem[128]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[128] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[128]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4133]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4133 + 32] = 0 / (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32])
                                        else:
                                            if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) and mem[160] > -1 / (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 'NH{q', 17
                                            if not mem[160]:
                                                revert with 'NH{q', 18
                                            if (10000 * mem[(32 * idx) + _4133 + 32] * mem[160]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32] * mem[160]) / mem[160] != (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 0, 'ds-math-mul-overflow'
                                            if mem[128] and 10000 > -1 / mem[128]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[128] / 10000 != mem[128]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[128] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[128]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4133]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4133 + 32] = (10000 * mem[(32 * idx) + _4133 + 32] * mem[160]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32] * mem[160]) / (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32])
                                else:
                                    if mem[160] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if mem[128] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if 10000 < mem[_8268 + 128]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8268 + 128] + 10000:
                                        if mem[128]:
                                            if False and mem[128] > 0:
                                                revert with 'NH{q', 17
                                            if not mem[128]:
                                                revert with 'NH{q', 18
                                            if 0 / mem[128]:
                                                revert with 0, 'ds-math-mul-overflow'
                                        if mem[160] and 10000 > -1 / mem[160]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[160] / 10000 != mem[160]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[160] > -1:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[160] < 10000 * mem[160]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not 10000 * mem[160]:
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4133]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4133 + 32] = 0 / 10000 * mem[160]
                                    else:
                                        if mem[(32 * idx) + _4133 + 32] and -mem[_8268 + 128] + 10000 > -1 / mem[(32 * idx) + _4133 + 32]:
                                            revert with 'NH{q', 17
                                        if not -mem[_8268 + 128] + 10000:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) / -mem[_8268 + 128] + 10000 != mem[(32 * idx) + _4133 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if not mem[128]:
                                            if mem[160] and 10000 > -1 / mem[160]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[160] / 10000 != mem[160]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[160] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[160]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4133]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4133 + 32] = 0 / (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32])
                                        else:
                                            if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) and mem[128] > -1 / (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 'NH{q', 17
                                            if not mem[128]:
                                                revert with 'NH{q', 18
                                            if (10000 * mem[(32 * idx) + _4133 + 32] * mem[128]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32] * mem[128]) / mem[128] != (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 0, 'ds-math-mul-overflow'
                                            if mem[160] and 10000 > -1 / mem[160]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[160] / 10000 != mem[160]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[160] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[160]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4133]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4133 + 32] = (10000 * mem[(32 * idx) + _4133 + 32] * mem[128]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32] * mem[128]) / (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32])
                            else:
                                _12434 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size) + 1
                                mem[_12434] = return_data.size
                                mem[_12434 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if idx >= mem[_4133]:
                                    revert with 'NH{q', 50
                                if mem[(32 * idx) + _4133 + 32] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                if mem[_8268 + 12 len 20] == address(_8306):
                                    if mem[_12434 + 32] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if mem[_12434 + 64] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if 10000 < mem[_8268 + 128]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8268 + 128] + 10000:
                                        if mem[_12434 + 64]:
                                            if False and mem[_12434 + 64] > 0:
                                                revert with 'NH{q', 17
                                            if not mem[_12434 + 64]:
                                                revert with 'NH{q', 18
                                            if 0 / mem[_12434 + 64]:
                                                revert with 0, 'ds-math-mul-overflow'
                                        if mem[_12434 + 32] and 10000 > -1 / mem[_12434 + 32]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12434 + 32] / 10000 != mem[_12434 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[_12434 + 32] > -1:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12434 + 32] < 10000 * mem[_12434 + 32]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not 10000 * mem[_12434 + 32]:
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4133]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4133 + 32] = 0 / 10000 * mem[_12434 + 32]
                                    else:
                                        if mem[(32 * idx) + _4133 + 32] and -mem[_8268 + 128] + 10000 > -1 / mem[(32 * idx) + _4133 + 32]:
                                            revert with 'NH{q', 17
                                        if not -mem[_8268 + 128] + 10000:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) / -mem[_8268 + 128] + 10000 != mem[(32 * idx) + _4133 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if not mem[_12434 + 64]:
                                            if mem[_12434 + 32] and 10000 > -1 / mem[_12434 + 32]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[_12434 + 32] / 10000 != mem[_12434 + 32]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[_12434 + 32] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[_12434 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[_12434 + 32]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[_12434 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4133]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4133 + 32] = 0 / (10000 * mem[_12434 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32])
                                        else:
                                            if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) and mem[_12434 + 64] > -1 / (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 'NH{q', 17
                                            if not mem[_12434 + 64]:
                                                revert with 'NH{q', 18
                                            if (10000 * mem[(32 * idx) + _4133 + 32] * mem[_12434 + 64]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32] * mem[_12434 + 64]) / mem[_12434 + 64] != (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 0, 'ds-math-mul-overflow'
                                            if mem[_12434 + 32] and 10000 > -1 / mem[_12434 + 32]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[_12434 + 32] / 10000 != mem[_12434 + 32]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[_12434 + 32] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[_12434 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[_12434 + 32]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[_12434 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4133]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4133 + 32] = (10000 * mem[(32 * idx) + _4133 + 32] * mem[_12434 + 64]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32] * mem[_12434 + 64]) / (10000 * mem[_12434 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32])
                                else:
                                    if mem[_12434 + 64] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if mem[_12434 + 32] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if 10000 < mem[_8268 + 128]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8268 + 128] + 10000:
                                        if mem[_12434 + 32]:
                                            if False and mem[_12434 + 32] > 0:
                                                revert with 'NH{q', 17
                                            if not mem[_12434 + 32]:
                                                revert with 'NH{q', 18
                                            if 0 / mem[_12434 + 32]:
                                                revert with 0, 'ds-math-mul-overflow'
                                        if mem[_12434 + 64] and 10000 > -1 / mem[_12434 + 64]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12434 + 64] / 10000 != mem[_12434 + 64]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[_12434 + 64] > -1:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12434 + 64] < 10000 * mem[_12434 + 64]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not 10000 * mem[_12434 + 64]:
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4133]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4133 + 32] = 0 / 10000 * mem[_12434 + 64]
                                    else:
                                        if mem[(32 * idx) + _4133 + 32] and -mem[_8268 + 128] + 10000 > -1 / mem[(32 * idx) + _4133 + 32]:
                                            revert with 'NH{q', 17
                                        if not -mem[_8268 + 128] + 10000:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) / -mem[_8268 + 128] + 10000 != mem[(32 * idx) + _4133 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if not mem[_12434 + 32]:
                                            if mem[_12434 + 64] and 10000 > -1 / mem[_12434 + 64]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[_12434 + 64] / 10000 != mem[_12434 + 64]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[_12434 + 64] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[_12434 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[_12434 + 64]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[_12434 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4133]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4133 + 32] = 0 / (10000 * mem[_12434 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32])
                                        else:
                                            if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) and mem[_12434 + 32] > -1 / (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 'NH{q', 17
                                            if not mem[_12434 + 32]:
                                                revert with 'NH{q', 18
                                            if (10000 * mem[(32 * idx) + _4133 + 32] * mem[_12434 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32] * mem[_12434 + 32]) / mem[_12434 + 32] != (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 0, 'ds-math-mul-overflow'
                                            if mem[_12434 + 64] and 10000 > -1 / mem[_12434 + 64]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[_12434 + 64] / 10000 != mem[_12434 + 64]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[_12434 + 64] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[_12434 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[_12434 + 64]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[_12434 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4133]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4133 + 32] = (10000 * mem[(32 * idx) + _4133 + 32] * mem[_12434 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32] * mem[_12434 + 32]) / (10000 * mem[_12434 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32])
                        else:
                            mem[_8396 + _8470 + 36] = 0
                            staticcall address(_8358).mem[mem[64] len 4] with:
                                    gas gas_remaining wei
                                   args mem[mem[64] + 4 len _8396 + _8470 + -mem[64] + 32]
                            if not return_data.size:
                                if idx >= mem[_4133]:
                                    revert with 'NH{q', 50
                                if mem[(32 * idx) + _4133 + 32] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                if mem[_8268 + 12 len 20] == address(_8306):
                                    if mem[128] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if mem[160] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if 10000 < mem[_8268 + 128]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8268 + 128] + 10000:
                                        if mem[160]:
                                            if False and mem[160] > 0:
                                                revert with 'NH{q', 17
                                            if not mem[160]:
                                                revert with 'NH{q', 18
                                            if 0 / mem[160]:
                                                revert with 0, 'ds-math-mul-overflow'
                                        if mem[128] and 10000 > -1 / mem[128]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[128] / 10000 != mem[128]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[128] > -1:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[128] < 10000 * mem[128]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not 10000 * mem[128]:
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4133]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4133 + 32] = 0 / 10000 * mem[128]
                                    else:
                                        if mem[(32 * idx) + _4133 + 32] and -mem[_8268 + 128] + 10000 > -1 / mem[(32 * idx) + _4133 + 32]:
                                            revert with 'NH{q', 17
                                        if not -mem[_8268 + 128] + 10000:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) / -mem[_8268 + 128] + 10000 != mem[(32 * idx) + _4133 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if not mem[160]:
                                            if mem[128] and 10000 > -1 / mem[128]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[128] / 10000 != mem[128]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[128] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[128]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4133]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4133 + 32] = 0 / (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32])
                                        else:
                                            if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) and mem[160] > -1 / (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 'NH{q', 17
                                            if not mem[160]:
                                                revert with 'NH{q', 18
                                            if (10000 * mem[(32 * idx) + _4133 + 32] * mem[160]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32] * mem[160]) / mem[160] != (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 0, 'ds-math-mul-overflow'
                                            if mem[128] and 10000 > -1 / mem[128]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[128] / 10000 != mem[128]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[128] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[128]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4133]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4133 + 32] = (10000 * mem[(32 * idx) + _4133 + 32] * mem[160]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32] * mem[160]) / (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32])
                                else:
                                    if mem[160] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if mem[128] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if 10000 < mem[_8268 + 128]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8268 + 128] + 10000:
                                        if mem[128]:
                                            if False and mem[128] > 0:
                                                revert with 'NH{q', 17
                                            if not mem[128]:
                                                revert with 'NH{q', 18
                                            if 0 / mem[128]:
                                                revert with 0, 'ds-math-mul-overflow'
                                        if mem[160] and 10000 > -1 / mem[160]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[160] / 10000 != mem[160]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[160] > -1:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[160] < 10000 * mem[160]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not 10000 * mem[160]:
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4133]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4133 + 32] = 0 / 10000 * mem[160]
                                    else:
                                        if mem[(32 * idx) + _4133 + 32] and -mem[_8268 + 128] + 10000 > -1 / mem[(32 * idx) + _4133 + 32]:
                                            revert with 'NH{q', 17
                                        if not -mem[_8268 + 128] + 10000:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) / -mem[_8268 + 128] + 10000 != mem[(32 * idx) + _4133 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if not mem[128]:
                                            if mem[160] and 10000 > -1 / mem[160]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[160] / 10000 != mem[160]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[160] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[160]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4133]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4133 + 32] = 0 / (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32])
                                        else:
                                            if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) and mem[128] > -1 / (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 'NH{q', 17
                                            if not mem[128]:
                                                revert with 'NH{q', 18
                                            if (10000 * mem[(32 * idx) + _4133 + 32] * mem[128]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32] * mem[128]) / mem[128] != (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 0, 'ds-math-mul-overflow'
                                            if mem[160] and 10000 > -1 / mem[160]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[160] / 10000 != mem[160]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[160] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[160]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4133]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4133 + 32] = (10000 * mem[(32 * idx) + _4133 + 32] * mem[128]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32] * mem[128]) / (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32])
                            else:
                                _12488 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size) + 1
                                mem[_12488] = return_data.size
                                mem[_12488 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if idx >= mem[_4133]:
                                    revert with 'NH{q', 50
                                if mem[(32 * idx) + _4133 + 32] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                if mem[_8268 + 12 len 20] == address(_8306):
                                    if mem[_12488 + 32] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if mem[_12488 + 64] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if 10000 < mem[_8268 + 128]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8268 + 128] + 10000:
                                        if mem[_12488 + 64]:
                                            if False and mem[_12488 + 64] > 0:
                                                revert with 'NH{q', 17
                                            if not mem[_12488 + 64]:
                                                revert with 'NH{q', 18
                                            if 0 / mem[_12488 + 64]:
                                                revert with 0, 'ds-math-mul-overflow'
                                        if mem[_12488 + 32] and 10000 > -1 / mem[_12488 + 32]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12488 + 32] / 10000 != mem[_12488 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[_12488 + 32] > -1:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12488 + 32] < 10000 * mem[_12488 + 32]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not 10000 * mem[_12488 + 32]:
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4133]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4133 + 32] = 0 / 10000 * mem[_12488 + 32]
                                    else:
                                        if mem[(32 * idx) + _4133 + 32] and -mem[_8268 + 128] + 10000 > -1 / mem[(32 * idx) + _4133 + 32]:
                                            revert with 'NH{q', 17
                                        if not -mem[_8268 + 128] + 10000:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) / -mem[_8268 + 128] + 10000 != mem[(32 * idx) + _4133 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if not mem[_12488 + 64]:
                                            if mem[_12488 + 32] and 10000 > -1 / mem[_12488 + 32]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[_12488 + 32] / 10000 != mem[_12488 + 32]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[_12488 + 32] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[_12488 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[_12488 + 32]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[_12488 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4133]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4133 + 32] = 0 / (10000 * mem[_12488 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32])
                                        else:
                                            if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) and mem[_12488 + 64] > -1 / (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 'NH{q', 17
                                            if not mem[_12488 + 64]:
                                                revert with 'NH{q', 18
                                            if (10000 * mem[(32 * idx) + _4133 + 32] * mem[_12488 + 64]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32] * mem[_12488 + 64]) / mem[_12488 + 64] != (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 0, 'ds-math-mul-overflow'
                                            if mem[_12488 + 32] and 10000 > -1 / mem[_12488 + 32]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[_12488 + 32] / 10000 != mem[_12488 + 32]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[_12488 + 32] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[_12488 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[_12488 + 32]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[_12488 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4133]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4133 + 32] = (10000 * mem[(32 * idx) + _4133 + 32] * mem[_12488 + 64]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32] * mem[_12488 + 64]) / (10000 * mem[_12488 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32])
                                else:
                                    if mem[_12488 + 64] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if mem[_12488 + 32] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if 10000 < mem[_8268 + 128]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8268 + 128] + 10000:
                                        if mem[_12488 + 32]:
                                            if False and mem[_12488 + 32] > 0:
                                                revert with 'NH{q', 17
                                            if not mem[_12488 + 32]:
                                                revert with 'NH{q', 18
                                            if 0 / mem[_12488 + 32]:
                                                revert with 0, 'ds-math-mul-overflow'
                                        if mem[_12488 + 64] and 10000 > -1 / mem[_12488 + 64]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12488 + 64] / 10000 != mem[_12488 + 64]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[_12488 + 64] > -1:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12488 + 64] < 10000 * mem[_12488 + 64]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not 10000 * mem[_12488 + 64]:
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4133]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4133 + 32] = 0 / 10000 * mem[_12488 + 64]
                                    else:
                                        if mem[(32 * idx) + _4133 + 32] and -mem[_8268 + 128] + 10000 > -1 / mem[(32 * idx) + _4133 + 32]:
                                            revert with 'NH{q', 17
                                        if not -mem[_8268 + 128] + 10000:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) / -mem[_8268 + 128] + 10000 != mem[(32 * idx) + _4133 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if not mem[_12488 + 32]:
                                            if mem[_12488 + 64] and 10000 > -1 / mem[_12488 + 64]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[_12488 + 64] / 10000 != mem[_12488 + 64]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[_12488 + 64] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[_12488 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[_12488 + 64]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[_12488 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4133]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4133 + 32] = 0 / (10000 * mem[_12488 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32])
                                        else:
                                            if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) and mem[_12488 + 32] > -1 / (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 'NH{q', 17
                                            if not mem[_12488 + 32]:
                                                revert with 'NH{q', 18
                                            if (10000 * mem[(32 * idx) + _4133 + 32] * mem[_12488 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32] * mem[_12488 + 32]) / mem[_12488 + 32] != (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 0, 'ds-math-mul-overflow'
                                            if mem[_12488 + 64] and 10000 > -1 / mem[_12488 + 64]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[_12488 + 64] / 10000 != mem[_12488 + 64]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[_12488 + 64] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[_12488 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[_12488 + 64]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[_12488 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4133]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4133 + 32] = (10000 * mem[(32 * idx) + _4133 + 32] * mem[_12488 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32] * mem[_12488 + 32]) / (10000 * mem[_12488 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32])
                    else:
                        _8359 = mem[mem[(32 * idx) + 128] + 64]
                        _8400 = mem[64]
                        _8401 = mem[64]
                        mem[mem[64]] = 4
                        mem[64] = mem[64] + 36
                        mem[_8401 + 32] = mem[_8401 + 36 len 28] or 0x902f1ac00000000000000000000000000000000000000000000000000000000
                        _8471 = mem[_8401]
                        s = 0
                        while s < _8471:
                            mem[_8400 + s + 36] = mem[_8401 + s + 32]
                            _8261 = mem[96]
                            s = s + 32
                            continue 
                        if ceil32(_8471) <= _8471:
                            staticcall address(_8359).mem[mem[64] len 4] with:
                                    gas gas_remaining wei
                                   args mem[mem[64] + 4 len _8400 + _8471 + -mem[64] + 32]
                            if not return_data.size:
                                if idx >= mem[_4133]:
                                    revert with 'NH{q', 50
                                if mem[(32 * idx) + _4133 + 32] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                if mem[_8268 + 12 len 20] == address(_8307):
                                    if mem[128] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if mem[160] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if 10000 < mem[_8268 + 128]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8268 + 128] + 10000:
                                        if mem[160]:
                                            if False and mem[160] > 0:
                                                revert with 'NH{q', 17
                                            if not mem[160]:
                                                revert with 'NH{q', 18
                                            if 0 / mem[160]:
                                                revert with 0, 'ds-math-mul-overflow'
                                        if mem[128] and 10000 > -1 / mem[128]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[128] / 10000 != mem[128]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[128] > -1:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[128] < 10000 * mem[128]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not 10000 * mem[128]:
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4133]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4133 + 32] = 0 / 10000 * mem[128]
                                    else:
                                        if mem[(32 * idx) + _4133 + 32] and -mem[_8268 + 128] + 10000 > -1 / mem[(32 * idx) + _4133 + 32]:
                                            revert with 'NH{q', 17
                                        if not -mem[_8268 + 128] + 10000:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) / -mem[_8268 + 128] + 10000 != mem[(32 * idx) + _4133 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if not mem[160]:
                                            if mem[128] and 10000 > -1 / mem[128]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[128] / 10000 != mem[128]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[128] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[128]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4133]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4133 + 32] = 0 / (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32])
                                        else:
                                            if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) and mem[160] > -1 / (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 'NH{q', 17
                                            if not mem[160]:
                                                revert with 'NH{q', 18
                                            if (10000 * mem[(32 * idx) + _4133 + 32] * mem[160]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32] * mem[160]) / mem[160] != (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 0, 'ds-math-mul-overflow'
                                            if mem[128] and 10000 > -1 / mem[128]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[128] / 10000 != mem[128]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[128] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[128]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4133]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4133 + 32] = (10000 * mem[(32 * idx) + _4133 + 32] * mem[160]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32] * mem[160]) / (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32])
                                else:
                                    if mem[160] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if mem[128] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if 10000 < mem[_8268 + 128]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8268 + 128] + 10000:
                                        if mem[128]:
                                            if False and mem[128] > 0:
                                                revert with 'NH{q', 17
                                            if not mem[128]:
                                                revert with 'NH{q', 18
                                            if 0 / mem[128]:
                                                revert with 0, 'ds-math-mul-overflow'
                                        if mem[160] and 10000 > -1 / mem[160]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[160] / 10000 != mem[160]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[160] > -1:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[160] < 10000 * mem[160]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not 10000 * mem[160]:
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4133]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4133 + 32] = 0 / 10000 * mem[160]
                                    else:
                                        if mem[(32 * idx) + _4133 + 32] and -mem[_8268 + 128] + 10000 > -1 / mem[(32 * idx) + _4133 + 32]:
                                            revert with 'NH{q', 17
                                        if not -mem[_8268 + 128] + 10000:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) / -mem[_8268 + 128] + 10000 != mem[(32 * idx) + _4133 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if not mem[128]:
                                            if mem[160] and 10000 > -1 / mem[160]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[160] / 10000 != mem[160]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[160] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[160]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4133]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4133 + 32] = 0 / (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32])
                                        else:
                                            if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) and mem[128] > -1 / (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 'NH{q', 17
                                            if not mem[128]:
                                                revert with 'NH{q', 18
                                            if (10000 * mem[(32 * idx) + _4133 + 32] * mem[128]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32] * mem[128]) / mem[128] != (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 0, 'ds-math-mul-overflow'
                                            if mem[160] and 10000 > -1 / mem[160]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[160] / 10000 != mem[160]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[160] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[160]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4133]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4133 + 32] = (10000 * mem[(32 * idx) + _4133 + 32] * mem[128]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32] * mem[128]) / (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32])
                            else:
                                _12436 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size) + 1
                                mem[_12436] = return_data.size
                                mem[_12436 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if idx >= mem[_4133]:
                                    revert with 'NH{q', 50
                                if mem[(32 * idx) + _4133 + 32] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                if mem[_8268 + 12 len 20] == address(_8307):
                                    if mem[_12436 + 32] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if mem[_12436 + 64] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if 10000 < mem[_8268 + 128]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8268 + 128] + 10000:
                                        if mem[_12436 + 64]:
                                            if False and mem[_12436 + 64] > 0:
                                                revert with 'NH{q', 17
                                            if not mem[_12436 + 64]:
                                                revert with 'NH{q', 18
                                            if 0 / mem[_12436 + 64]:
                                                revert with 0, 'ds-math-mul-overflow'
                                        if mem[_12436 + 32] and 10000 > -1 / mem[_12436 + 32]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12436 + 32] / 10000 != mem[_12436 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[_12436 + 32] > -1:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12436 + 32] < 10000 * mem[_12436 + 32]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not 10000 * mem[_12436 + 32]:
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4133]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4133 + 32] = 0 / 10000 * mem[_12436 + 32]
                                    else:
                                        if mem[(32 * idx) + _4133 + 32] and -mem[_8268 + 128] + 10000 > -1 / mem[(32 * idx) + _4133 + 32]:
                                            revert with 'NH{q', 17
                                        if not -mem[_8268 + 128] + 10000:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) / -mem[_8268 + 128] + 10000 != mem[(32 * idx) + _4133 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if not mem[_12436 + 64]:
                                            if mem[_12436 + 32] and 10000 > -1 / mem[_12436 + 32]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[_12436 + 32] / 10000 != mem[_12436 + 32]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[_12436 + 32] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[_12436 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[_12436 + 32]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[_12436 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4133]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4133 + 32] = 0 / (10000 * mem[_12436 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32])
                                        else:
                                            if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) and mem[_12436 + 64] > -1 / (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 'NH{q', 17
                                            if not mem[_12436 + 64]:
                                                revert with 'NH{q', 18
                                            if (10000 * mem[(32 * idx) + _4133 + 32] * mem[_12436 + 64]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32] * mem[_12436 + 64]) / mem[_12436 + 64] != (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 0, 'ds-math-mul-overflow'
                                            if mem[_12436 + 32] and 10000 > -1 / mem[_12436 + 32]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[_12436 + 32] / 10000 != mem[_12436 + 32]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[_12436 + 32] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[_12436 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[_12436 + 32]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[_12436 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4133]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4133 + 32] = (10000 * mem[(32 * idx) + _4133 + 32] * mem[_12436 + 64]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32] * mem[_12436 + 64]) / (10000 * mem[_12436 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32])
                                else:
                                    if mem[_12436 + 64] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if mem[_12436 + 32] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if 10000 < mem[_8268 + 128]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8268 + 128] + 10000:
                                        if mem[_12436 + 32]:
                                            if False and mem[_12436 + 32] > 0:
                                                revert with 'NH{q', 17
                                            if not mem[_12436 + 32]:
                                                revert with 'NH{q', 18
                                            if 0 / mem[_12436 + 32]:
                                                revert with 0, 'ds-math-mul-overflow'
                                        if mem[_12436 + 64] and 10000 > -1 / mem[_12436 + 64]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12436 + 64] / 10000 != mem[_12436 + 64]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[_12436 + 64] > -1:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12436 + 64] < 10000 * mem[_12436 + 64]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not 10000 * mem[_12436 + 64]:
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4133]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4133 + 32] = 0 / 10000 * mem[_12436 + 64]
                                    else:
                                        if mem[(32 * idx) + _4133 + 32] and -mem[_8268 + 128] + 10000 > -1 / mem[(32 * idx) + _4133 + 32]:
                                            revert with 'NH{q', 17
                                        if not -mem[_8268 + 128] + 10000:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) / -mem[_8268 + 128] + 10000 != mem[(32 * idx) + _4133 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if not mem[_12436 + 32]:
                                            if mem[_12436 + 64] and 10000 > -1 / mem[_12436 + 64]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[_12436 + 64] / 10000 != mem[_12436 + 64]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[_12436 + 64] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[_12436 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[_12436 + 64]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[_12436 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4133]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4133 + 32] = 0 / (10000 * mem[_12436 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32])
                                        else:
                                            if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) and mem[_12436 + 32] > -1 / (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 'NH{q', 17
                                            if not mem[_12436 + 32]:
                                                revert with 'NH{q', 18
                                            if (10000 * mem[(32 * idx) + _4133 + 32] * mem[_12436 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32] * mem[_12436 + 32]) / mem[_12436 + 32] != (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 0, 'ds-math-mul-overflow'
                                            if mem[_12436 + 64] and 10000 > -1 / mem[_12436 + 64]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[_12436 + 64] / 10000 != mem[_12436 + 64]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[_12436 + 64] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[_12436 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[_12436 + 64]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[_12436 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4133]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4133 + 32] = (10000 * mem[(32 * idx) + _4133 + 32] * mem[_12436 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32] * mem[_12436 + 32]) / (10000 * mem[_12436 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32])
                        else:
                            mem[_8400 + _8471 + 36] = 0
                            staticcall address(_8359).mem[mem[64] len 4] with:
                                    gas gas_remaining wei
                                   args mem[mem[64] + 4 len _8400 + _8471 + -mem[64] + 32]
                            if not return_data.size:
                                if idx >= mem[_4133]:
                                    revert with 'NH{q', 50
                                if mem[(32 * idx) + _4133 + 32] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                if mem[_8268 + 12 len 20] == address(_8307):
                                    if mem[128] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if mem[160] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if 10000 < mem[_8268 + 128]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8268 + 128] + 10000:
                                        if mem[160]:
                                            if False and mem[160] > 0:
                                                revert with 'NH{q', 17
                                            if not mem[160]:
                                                revert with 'NH{q', 18
                                            if 0 / mem[160]:
                                                revert with 0, 'ds-math-mul-overflow'
                                        if mem[128] and 10000 > -1 / mem[128]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[128] / 10000 != mem[128]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[128] > -1:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[128] < 10000 * mem[128]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not 10000 * mem[128]:
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4133]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4133 + 32] = 0 / 10000 * mem[128]
                                    else:
                                        if mem[(32 * idx) + _4133 + 32] and -mem[_8268 + 128] + 10000 > -1 / mem[(32 * idx) + _4133 + 32]:
                                            revert with 'NH{q', 17
                                        if not -mem[_8268 + 128] + 10000:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) / -mem[_8268 + 128] + 10000 != mem[(32 * idx) + _4133 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if not mem[160]:
                                            if mem[128] and 10000 > -1 / mem[128]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[128] / 10000 != mem[128]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[128] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[128]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4133]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4133 + 32] = 0 / (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32])
                                        else:
                                            if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) and mem[160] > -1 / (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 'NH{q', 17
                                            if not mem[160]:
                                                revert with 'NH{q', 18
                                            if (10000 * mem[(32 * idx) + _4133 + 32] * mem[160]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32] * mem[160]) / mem[160] != (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 0, 'ds-math-mul-overflow'
                                            if mem[128] and 10000 > -1 / mem[128]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[128] / 10000 != mem[128]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[128] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[128]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4133]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4133 + 32] = (10000 * mem[(32 * idx) + _4133 + 32] * mem[160]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32] * mem[160]) / (10000 * mem[128]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32])
                                else:
                                    if mem[160] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if mem[128] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if 10000 < mem[_8268 + 128]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8268 + 128] + 10000:
                                        if mem[128]:
                                            if False and mem[128] > 0:
                                                revert with 'NH{q', 17
                                            if not mem[128]:
                                                revert with 'NH{q', 18
                                            if 0 / mem[128]:
                                                revert with 0, 'ds-math-mul-overflow'
                                        if mem[160] and 10000 > -1 / mem[160]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[160] / 10000 != mem[160]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[160] > -1:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[160] < 10000 * mem[160]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not 10000 * mem[160]:
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4133]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4133 + 32] = 0 / 10000 * mem[160]
                                    else:
                                        if mem[(32 * idx) + _4133 + 32] and -mem[_8268 + 128] + 10000 > -1 / mem[(32 * idx) + _4133 + 32]:
                                            revert with 'NH{q', 17
                                        if not -mem[_8268 + 128] + 10000:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) / -mem[_8268 + 128] + 10000 != mem[(32 * idx) + _4133 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if not mem[128]:
                                            if mem[160] and 10000 > -1 / mem[160]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[160] / 10000 != mem[160]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[160] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[160]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4133]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4133 + 32] = 0 / (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32])
                                        else:
                                            if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) and mem[128] > -1 / (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 'NH{q', 17
                                            if not mem[128]:
                                                revert with 'NH{q', 18
                                            if (10000 * mem[(32 * idx) + _4133 + 32] * mem[128]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32] * mem[128]) / mem[128] != (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 0, 'ds-math-mul-overflow'
                                            if mem[160] and 10000 > -1 / mem[160]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[160] / 10000 != mem[160]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[160] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[160]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4133]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4133 + 32] = (10000 * mem[(32 * idx) + _4133 + 32] * mem[128]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32] * mem[128]) / (10000 * mem[160]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32])
                            else:
                                _12493 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size) + 1
                                mem[_12493] = return_data.size
                                mem[_12493 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if idx >= mem[_4133]:
                                    revert with 'NH{q', 50
                                if mem[(32 * idx) + _4133 + 32] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                if mem[_8268 + 12 len 20] == address(_8307):
                                    if mem[_12493 + 32] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if mem[_12493 + 64] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if 10000 < mem[_8268 + 128]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8268 + 128] + 10000:
                                        if mem[_12493 + 64]:
                                            if False and mem[_12493 + 64] > 0:
                                                revert with 'NH{q', 17
                                            if not mem[_12493 + 64]:
                                                revert with 'NH{q', 18
                                            if 0 / mem[_12493 + 64]:
                                                revert with 0, 'ds-math-mul-overflow'
                                        if mem[_12493 + 32] and 10000 > -1 / mem[_12493 + 32]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12493 + 32] / 10000 != mem[_12493 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[_12493 + 32] > -1:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12493 + 32] < 10000 * mem[_12493 + 32]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not 10000 * mem[_12493 + 32]:
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4133]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4133 + 32] = 0 / 10000 * mem[_12493 + 32]
                                    else:
                                        if mem[(32 * idx) + _4133 + 32] and -mem[_8268 + 128] + 10000 > -1 / mem[(32 * idx) + _4133 + 32]:
                                            revert with 'NH{q', 17
                                        if not -mem[_8268 + 128] + 10000:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) / -mem[_8268 + 128] + 10000 != mem[(32 * idx) + _4133 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if not mem[_12493 + 64]:
                                            if mem[_12493 + 32] and 10000 > -1 / mem[_12493 + 32]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[_12493 + 32] / 10000 != mem[_12493 + 32]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[_12493 + 32] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[_12493 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[_12493 + 32]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[_12493 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4133]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4133 + 32] = 0 / (10000 * mem[_12493 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32])
                                        else:
                                            if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) and mem[_12493 + 64] > -1 / (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 'NH{q', 17
                                            if not mem[_12493 + 64]:
                                                revert with 'NH{q', 18
                                            if (10000 * mem[(32 * idx) + _4133 + 32] * mem[_12493 + 64]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32] * mem[_12493 + 64]) / mem[_12493 + 64] != (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 0, 'ds-math-mul-overflow'
                                            if mem[_12493 + 32] and 10000 > -1 / mem[_12493 + 32]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[_12493 + 32] / 10000 != mem[_12493 + 32]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[_12493 + 32] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[_12493 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[_12493 + 32]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[_12493 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4133]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4133 + 32] = (10000 * mem[(32 * idx) + _4133 + 32] * mem[_12493 + 64]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32] * mem[_12493 + 64]) / (10000 * mem[_12493 + 32]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32])
                                else:
                                    if mem[_12493 + 64] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if mem[_12493 + 32] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if 10000 < mem[_8268 + 128]:
                                        revert with 'NH{q', 17
                                    if not -mem[_8268 + 128] + 10000:
                                        if mem[_12493 + 32]:
                                            if False and mem[_12493 + 32] > 0:
                                                revert with 'NH{q', 17
                                            if not mem[_12493 + 32]:
                                                revert with 'NH{q', 18
                                            if 0 / mem[_12493 + 32]:
                                                revert with 0, 'ds-math-mul-overflow'
                                        if mem[_12493 + 64] and 10000 > -1 / mem[_12493 + 64]:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12493 + 64] / 10000 != mem[_12493 + 64]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 10000 * mem[_12493 + 64] > -1:
                                            revert with 'NH{q', 17
                                        if 10000 * mem[_12493 + 64] < 10000 * mem[_12493 + 64]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not 10000 * mem[_12493 + 64]:
                                            revert with 'NH{q', 18
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4133]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4133 + 32] = 0 / 10000 * mem[_12493 + 64]
                                    else:
                                        if mem[(32 * idx) + _4133 + 32] and -mem[_8268 + 128] + 10000 > -1 / mem[(32 * idx) + _4133 + 32]:
                                            revert with 'NH{q', 17
                                        if not -mem[_8268 + 128] + 10000:
                                            revert with 'NH{q', 18
                                        if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) / -mem[_8268 + 128] + 10000 != mem[(32 * idx) + _4133 + 32]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if not mem[_12493 + 32]:
                                            if mem[_12493 + 64] and 10000 > -1 / mem[_12493 + 64]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[_12493 + 64] / 10000 != mem[_12493 + 64]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[_12493 + 64] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[_12493 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[_12493 + 64]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[_12493 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4133]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4133 + 32] = 0 / (10000 * mem[_12493 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32])
                                        else:
                                            if (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) and mem[_12493 + 32] > -1 / (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 'NH{q', 17
                                            if not mem[_12493 + 32]:
                                                revert with 'NH{q', 18
                                            if (10000 * mem[(32 * idx) + _4133 + 32] * mem[_12493 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32] * mem[_12493 + 32]) / mem[_12493 + 32] != (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 0, 'ds-math-mul-overflow'
                                            if mem[_12493 + 64] and 10000 > -1 / mem[_12493 + 64]:
                                                revert with 'NH{q', 17
                                            if 10000 * mem[_12493 + 64] / 10000 != mem[_12493 + 64]:
                                                revert with 0, 'ds-math-mul-overflow'
                                            if 10000 * mem[_12493 + 64] > (-10000 * mem[(32 * idx) + _4133 + 32]) + (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) - 1:
                                                revert with 'NH{q', 17
                                            if (10000 * mem[_12493 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]) < 10000 * mem[_12493 + 64]:
                                                revert with 0, 'ds-math-add-overflow'
                                            if not (10000 * mem[_12493 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32]):
                                                revert with 'NH{q', 18
                                            if idx > -2:
                                                revert with 'NH{q', 17
                                            if idx + 1 >= mem[_4133]:
                                                revert with 'NH{q', 50
                                            mem[(32 * idx + 1) + _4133 + 32] = (10000 * mem[(32 * idx) + _4133 + 32] * mem[_12493 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32] * mem[_12493 + 32]) / (10000 * mem[_12493 + 64]) + (10000 * mem[(32 * idx) + _4133 + 32]) - (mem[_8268 + 128] * mem[(32 * idx) + _4133 + 32])
                else:
                    if mem[mem[(32 * idx) + 128] + 160] == 3:
                        _8314 = mem[mem[(32 * idx) + 128] + 64]
                        _8315 = mem[mem[(32 * idx) + 128]]
                        require ext_code.size(mem[mem[(32 * idx) + 128] + 76 len 20])
                        staticcall mem[mem[(32 * idx) + 128] + 76 len 20]._BASE_TOKEN_() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _8337 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_8337] == mem[_8337 + 12 len 20]
                        if idx >= mem[_4133]:
                            revert with 'NH{q', 50
                        if mem[_8337 + 12 len 20] != address(_8315):
                            _8608 = mem[(32 * idx) + _4133 + 32]
                            mem[mem[64] + 36] = mem[(32 * idx) + _4133 + 32]
                            require ext_code.size(address(_8314))
                            staticcall address(_8314).querySellQuote(address arg1, uint256 arg2) with:
                                    gas gas_remaining wei
                                   args address(this.address), _8608
                            mem[mem[64] len 64] = ext_call.return_data[0 len 64]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9432 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 64
                            require mem[_9432] == mem[_9432]
                            require mem[_9432 + 32] == mem[_9432 + 32]
                            if idx > -2:
                                revert with 'NH{q', 17
                            if idx + 1 >= mem[_4133]:
                                revert with 'NH{q', 50
                            mem[(32 * idx + 1) + _4133 + 32] = mem[_9432]
                        else:
                            _8610 = mem[(32 * idx) + _4133 + 32]
                            mem[mem[64] + 36] = mem[(32 * idx) + _4133 + 32]
                            require ext_code.size(address(_8314))
                            staticcall address(_8314).querySellBase(address arg1, uint256 arg2) with:
                                    gas gas_remaining wei
                                   args address(this.address), _8610
                            mem[mem[64] len 64] = ext_call.return_data[0 len 64]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9433 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 64
                            require mem[_9433] == mem[_9433]
                            require mem[_9433 + 32] == mem[_9433 + 32]
                            if idx > -2:
                                revert with 'NH{q', 17
                            if idx + 1 >= mem[_4133]:
                                revert with 'NH{q', 50
                            mem[(32 * idx + 1) + _4133 + 32] = mem[_9433]
                    else:
                        if mem[mem[(32 * idx) + 128] + 160] == 5:
                            _8327 = mem[mem[(32 * idx) + 128] + 96]
                            _8336 = mem[64]
                            mem[mem[64]] = 2
                            mem[64] = mem[64] + 96
                            mem[_8336 + 32 len 64] = call.data[calldata.size len 64]
                            if 0 >= mem[_8336]:
                                revert with 'NH{q', 50
                            mem[_8336 + 32] = mem[_8268 + 12 len 20]
                            if 1 >= mem[_8336]:
                                revert with 'NH{q', 50
                            mem[_8336 + 64] = mem[_8268 + 44 len 20]
                            if idx >= mem[_4133]:
                                revert with 'NH{q', 50
                            _8468 = mem[(32 * idx) + _4133 + 32]
                            mem[_8336 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                            mem[_8336 + 100] = _8468
                            mem[_8336 + 132] = 64
                            mem[_8336 + 164] = mem[_8336]
                            s = 0
                            t = _8336 + 32
                            u = _8336 + 196
                            while s < mem[_8336]:
                                mem[u] = mem[t + 12 len 20]
                                _8261 = mem[96]
                                s = s + 1
                                t = t + 32
                                u = u + 32
                                continue 
                            require ext_code.size(address(_8327))
                            staticcall address(_8327).mem[mem[64] len 4] with:
                                    gas gas_remaining wei
                                   args mem[mem[64] + 4 len _8336 + (32 * mem[_8336]) + -mem[64] + 192]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _12413 = mem[64]
                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _12483 = mem[_12413]
                            require mem[_12413] <= test266151307()
                            require _12413 + mem[_12413] + 31 < _12413 + return_data.size
                            _12633 = mem[_12413 + mem[_12413]]
                            if mem[_12413 + mem[_12413]] > test266151307():
                                revert with 'NH{q', 65
                            if _12413 + ceil32(return_data.size) + floor32(mem[_12413 + mem[_12413]]) + 1 > test266151307() or floor32(mem[_12413 + mem[_12413]]) + 1 < 0:
                                revert with 'NH{q', 65
                            mem[64] = _12413 + ceil32(return_data.size) + floor32(mem[_12413 + mem[_12413]]) + 1
                            mem[_12413 + ceil32(return_data.size)] = _12633
                            require _12483 + (32 * _12633) + 32 <= return_data.size
                            s = 0
                            t = _12413 + _12483 + 32
                            u = _12413 + ceil32(return_data.size) + 32
                            while s < _12633:
                                require mem[t] == mem[t]
                                mem[u] = mem[t]
                                _8261 = mem[96]
                                s = s + 1
                                t = t + 32
                                u = u + 32
                                continue 
                            if _12633 < 1:
                                revert with 'NH{q', 17
                            if _12633 - 1 >= _12633:
                                revert with 'NH{q', 50
                            if idx > -2:
                                revert with 'NH{q', 17
                            if idx + 1 >= mem[_4133]:
                                revert with 'NH{q', 50
                            mem[(32 * idx + 1) + _4133 + 32] = mem[(32 * _12633 - 1) + _12413 + ceil32(return_data.size) + 32]
                        else:
                            if mem[mem[(32 * idx) + 128] + 160] == 7:
                                if idx >= mem[_4133]:
                                    revert with 'NH{q', 50
                                _8357 = mem[(32 * idx) + _4133 + 32]
                                _8393 = mem[mem[(32 * idx) + 128] + 32]
                                _8428 = sha3(address(mem[mem[(32 * idx) + 128]]), sha3(mem[mem[(32 * idx) + 128] + 108 len 20], 0))
                                mem[0] = mem[mem[(32 * idx) + 128] + 44 len 20]
                                mem[32] = sha3(address(mem[mem[(32 * idx) + 128] + 96]), 0)
                                _8430 = sha3(address(_8393), sha3(address(mem[mem[(32 * idx) + 128] + 96]), 0))
                                if uint256(stor[_8428]) == uint256(sub_f119462d[address(mem[mem[(32 * idx) + 128] + 96])][address(_8393)]):
                                    revert with 0, 'BAD CURVE'
                                _8466 = mem[mem[(32 * idx) + 128] + 96]
                                mem[mem[64] + 4] = uint8(stor[_8428])
                                mem[mem[64] + 36] = uint8(stor[_8430])
                                mem[mem[64] + 68] = _8357
                                require ext_code.size(address(_8466))
                                staticcall address(_8466).calculateSwap(uint8 arg1, uint8 arg2, uint256 arg3) with:
                                        gas gas_remaining wei
                                       args uint8(stor[_8428]), uint8(stor[_8430]), _8357
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _9046 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_9046] == mem[_9046]
                                if mem[_9046] < 1:
                                    revert with 'NH{q', 17
                                if idx > -2:
                                    revert with 'NH{q', 17
                                if idx + 1 >= mem[_4133]:
                                    revert with 'NH{q', 50
                                mem[(32 * idx + 1) + _4133 + 32] = mem[_9046] - 1
                            else:
                                if mem[mem[(32 * idx) + 128] + 160] != 8:
                                    if mem[mem[(32 * idx) + 128] + 160] != 13:
                                        require mem[mem[(32 * idx) + 128] + 160] == 14
                                        _8420 = mem[mem[(32 * idx) + 128] + 32]
                                        if idx >= mem[_4133]:
                                            revert with 'NH{q', 50
                                        _8444 = mem[(32 * idx) + _4133 + 32]
                                        mem[mem[64] + 4] = mem[mem[(32 * idx) + 128] + 12 len 20]
                                        mem[mem[64] + 36] = address(_8420)
                                        mem[mem[64] + 68] = _8444
                                        require ext_code.size(0x66357dcace80431aee0a7507e2e361b7e2402370)
                                        staticcall 0x66357dcace80431aee0a7507e2e361b7e2402370.quotePotentialSwap(address arg1, address arg2, uint256 arg3) with:
                                                gas gas_remaining wei
                                               args mem[mem[64] + 4], address(_8420), _8444
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9195 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_9195] == mem[_9195]
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4133]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4133 + 32] = mem[_9195]
                                    else:
                                        _8387 = mem[mem[(32 * idx) + 128]]
                                        _8388 = mem[mem[(32 * idx) + 128] + 32]
                                        if idx >= mem[_4133]:
                                            revert with 'NH{q', 50
                                        _8422 = mem[(32 * idx) + _4133 + 32]
                                        mem[mem[64] + 36] = mem[mem[(32 * idx) + 128] + 12 len 20]
                                        mem[mem[64] + 68] = address(_8388)
                                        mem[mem[64] + 100] = _8422
                                        require ext_code.size(0x9e372b445723e71117b59393aaba05ad3b54ad3f)
                                        staticcall 0x9e372b445723e71117b59393aaba05ad3b54ad3f.0xd7176ca9 with:
                                                gas gas_remaining wei
                                               args 0x9ab2de34a33fb459b538c43f251eb825645e8595, address(_8387), address(_8388), _8422
                                        mem[mem[64] len 64] = ext_call.return_data[0 len 64]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9453 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 64
                                        require mem[_9453] == mem[_9453]
                                        require mem[_9453 + 32] == mem[_9453 + 32]
                                        if idx > -2:
                                            revert with 'NH{q', 17
                                        if idx + 1 >= mem[_4133]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx + 1) + _4133 + 32] = mem[_9453]
                                else:
                                    if idx >= mem[_4133]:
                                        revert with 'NH{q', 50
                                    _8390 = mem[(32 * idx) + _4133 + 32]
                                    _8426 = mem[mem[(32 * idx) + 128] + 32]
                                    _8447 = sha3(address(mem[mem[(32 * idx) + 128]]), sha3(mem[mem[(32 * idx) + 128] + 108 len 20], 0))
                                    mem[0] = mem[mem[(32 * idx) + 128] + 44 len 20]
                                    mem[32] = sha3(address(mem[mem[(32 * idx) + 128] + 96]), 0)
                                    _8449 = sha3(address(_8426), sha3(address(mem[mem[(32 * idx) + 128] + 96]), 0))
                                    if uint256(stor[_8447]) == uint256(sub_f119462d[address(mem[mem[(32 * idx) + 128] + 96])][address(_8426)]):
                                        revert with 0, 'BAD CURVE'
                                    if mem[mem[(32 * idx) + 128] + 108 len 20] != 0x58e57ca18b7a47112b877e31929798cd3d703b0f:
                                        if mem[mem[(32 * idx) + 128] + 108 len 20] != 0x7f90122bf0700f9e7e1f688fe926940e8839f353:
                                            if mem[mem[(32 * idx) + 128] + 108 len 20] == 0xaea2e71b631fa93683bcf256a8689dfa0e094fcd:
                                                _8558 = mem[mem[(32 * idx) + 128] + 96]
                                                mem[mem[64] + 4] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8447'))))
                                                mem[mem[64] + 36] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8449'))))
                                                mem[mem[64] + 68] = _8390
                                                require ext_code.size(address(_8558))
                                                staticcall address(_8558).get_dy(int128 arg1, int128 arg2, uint256 arg3) with:
                                                        gas gas_remaining wei
                                                       args ('signextend', 15, ('type', 256, ('stor', ('var', '_8447')))), ('signextend', 15, ('type', 256, ('stor', ('var', '_8449')))), _8390
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _9429 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_9429] == mem[_9429]
                                                require mem[_9429] > 0
                                                if mem[_9429] < 1:
                                                    revert with 'NH{q', 17
                                                if idx > -2:
                                                    revert with 'NH{q', 17
                                                if idx + 1 >= mem[_4133]:
                                                    revert with 'NH{q', 50
                                                mem[(32 * idx + 1) + _4133 + 32] = mem[_9429] - 1
                                            else:
                                                if mem[mem[(32 * idx) + 128] + 108 len 20] == 0x3a43a5851a3e3e0e25a3c1089670269786be1577:
                                                    _8576 = mem[mem[(32 * idx) + 128] + 96]
                                                    mem[mem[64] + 4] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8447'))))
                                                    mem[mem[64] + 36] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8449'))))
                                                    mem[mem[64] + 68] = _8390
                                                    require ext_code.size(address(_8576))
                                                    staticcall address(_8576).get_dy(int128 arg1, int128 arg2, uint256 arg3) with:
                                                            gas gas_remaining wei
                                                           args ('signextend', 15, ('type', 256, ('stor', ('var', '_8447')))), ('signextend', 15, ('type', 256, ('stor', ('var', '_8449')))), _8390
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _9454 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_9454] == mem[_9454]
                                                    require mem[_9454] > 0
                                                    if mem[_9454] < 1:
                                                        revert with 'NH{q', 17
                                                    if idx > -2:
                                                        revert with 'NH{q', 17
                                                    if idx + 1 >= mem[_4133]:
                                                        revert with 'NH{q', 50
                                                    mem[(32 * idx + 1) + _4133 + 32] = mem[_9454] - 1
                                                else:
                                                    if mem[mem[(32 * idx) + 128] + 108 len 20] == 0x93004d8477f117ea359b71ec02f2706c8175c55c:
                                                        _8606 = mem[mem[(32 * idx) + 128] + 96]
                                                        mem[mem[64] + 4] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8447'))))
                                                        mem[mem[64] + 36] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8449'))))
                                                        mem[mem[64] + 68] = _8390
                                                        require ext_code.size(address(_8606))
                                                        staticcall address(_8606).get_dy(int128 arg1, int128 arg2, uint256 arg3) with:
                                                                gas gas_remaining wei
                                                               args ('signextend', 15, ('type', 256, ('stor', ('var', '_8447')))), ('signextend', 15, ('type', 256, ('stor', ('var', '_8449')))), _8390
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _9465 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_9465] == mem[_9465]
                                                        require mem[_9465] > 0
                                                        if mem[_9465] < 1:
                                                            revert with 'NH{q', 17
                                                        if idx > -2:
                                                            revert with 'NH{q', 17
                                                        if idx + 1 >= mem[_4133]:
                                                            revert with 'NH{q', 50
                                                        mem[(32 * idx + 1) + _4133 + 32] = mem[_9465] - 1
                                                    else:
                                                        require mem[mem[(32 * idx) + 128] + 108 len 20] == 0xd79138c49c49200a1afc935171d1bdad084fdc95
                                                        _8670 = mem[mem[(32 * idx) + 128] + 96]
                                                        mem[mem[64] + 4] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8447'))))
                                                        mem[mem[64] + 36] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8449'))))
                                                        mem[mem[64] + 68] = _8390
                                                        require ext_code.size(address(_8670))
                                                        staticcall address(_8670).get_dy(int128 arg1, int128 arg2, uint256 arg3) with:
                                                                gas gas_remaining wei
                                                               args ('signextend', 15, ('type', 256, ('stor', ('var', '_8447')))), ('signextend', 15, ('type', 256, ('stor', ('var', '_8449')))), _8390
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _9495 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_9495] == mem[_9495]
                                                        require mem[_9495] > 0
                                                        if mem[_9495] < 1:
                                                            revert with 'NH{q', 17
                                                        if idx > -2:
                                                            revert with 'NH{q', 17
                                                        if idx + 1 >= mem[_4133]:
                                                            revert with 'NH{q', 50
                                                        mem[(32 * idx + 1) + _4133 + 32] = mem[_9495] - 1
                                        else:
                                            _8484 = mem[mem[(32 * idx) + 128] + 96]
                                            mem[mem[64] + 4] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8447'))))
                                            mem[mem[64] + 36] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8449'))))
                                            mem[mem[64] + 68] = _8390
                                            require ext_code.size(address(_8484))
                                            staticcall address(_8484).get_dy_underlying(int128 arg1, int128 arg2, uint256 arg3) with:
                                                    gas gas_remaining wei
                                                   args ('signextend', 15, ('type', 256, ('stor', ('var', '_8447')))), ('signextend', 15, ('type', 256, ('stor', ('var', '_8449')))), _8390
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9196 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_9196] == mem[_9196]
                                            if mem[_8268 + 108 len 20] == 0xaea2e71b631fa93683bcf256a8689dfa0e094fcd:
                                                _9682 = mem[_8268 + 96]
                                                mem[mem[64] + 4] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8447'))))
                                                mem[mem[64] + 36] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8449'))))
                                                mem[mem[64] + 68] = _8390
                                                require ext_code.size(address(_9682))
                                                staticcall address(_9682).get_dy(int128 arg1, int128 arg2, uint256 arg3) with:
                                                        gas gas_remaining wei
                                                       args ('signextend', 15, ('type', 256, ('stor', ('var', '_8447')))), ('signextend', 15, ('type', 256, ('stor', ('var', '_8449')))), _8390
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _9969 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_9969] == mem[_9969]
                                                require mem[_9969] > 0
                                                if mem[_9969] < 1:
                                                    revert with 'NH{q', 17
                                                if idx > -2:
                                                    revert with 'NH{q', 17
                                                if idx + 1 >= mem[_4133]:
                                                    revert with 'NH{q', 50
                                                mem[(32 * idx + 1) + _4133 + 32] = mem[_9969] - 1
                                            else:
                                                if mem[_8268 + 108 len 20] == 0x3a43a5851a3e3e0e25a3c1089670269786be1577:
                                                    _9687 = mem[_8268 + 96]
                                                    mem[mem[64] + 4] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8447'))))
                                                    mem[mem[64] + 36] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8449'))))
                                                    mem[mem[64] + 68] = _8390
                                                    require ext_code.size(address(_9687))
                                                    staticcall address(_9687).get_dy(int128 arg1, int128 arg2, uint256 arg3) with:
                                                            gas gas_remaining wei
                                                           args ('signextend', 15, ('type', 256, ('stor', ('var', '_8447')))), ('signextend', 15, ('type', 256, ('stor', ('var', '_8449')))), _8390
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _10004 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_10004] == mem[_10004]
                                                    require mem[_10004] > 0
                                                    if mem[_10004] < 1:
                                                        revert with 'NH{q', 17
                                                    if idx > -2:
                                                        revert with 'NH{q', 17
                                                    if idx + 1 >= mem[_4133]:
                                                        revert with 'NH{q', 50
                                                    mem[(32 * idx + 1) + _4133 + 32] = mem[_10004] - 1
                                                else:
                                                    if mem[_8268 + 108 len 20] == 0x93004d8477f117ea359b71ec02f2706c8175c55c:
                                                        _9694 = mem[_8268 + 96]
                                                        mem[mem[64] + 4] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8447'))))
                                                        mem[mem[64] + 36] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8449'))))
                                                        mem[mem[64] + 68] = _8390
                                                        require ext_code.size(address(_9694))
                                                        staticcall address(_9694).get_dy(int128 arg1, int128 arg2, uint256 arg3) with:
                                                                gas gas_remaining wei
                                                               args ('signextend', 15, ('type', 256, ('stor', ('var', '_8447')))), ('signextend', 15, ('type', 256, ('stor', ('var', '_8449')))), _8390
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _10035 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_10035] == mem[_10035]
                                                        require mem[_10035] > 0
                                                        if mem[_10035] < 1:
                                                            revert with 'NH{q', 17
                                                        if idx > -2:
                                                            revert with 'NH{q', 17
                                                        if idx + 1 >= mem[_4133]:
                                                            revert with 'NH{q', 50
                                                        mem[(32 * idx + 1) + _4133 + 32] = mem[_10035] - 1
                                                    else:
                                                        if mem[_8268 + 108 len 20] != 0xd79138c49c49200a1afc935171d1bdad084fdc95:
                                                            require mem[_9196] > 0
                                                            if mem[_9196] < 1:
                                                                revert with 'NH{q', 17
                                                            if idx > -2:
                                                                revert with 'NH{q', 17
                                                            if idx + 1 >= mem[_4133]:
                                                                revert with 'NH{q', 50
                                                            mem[(32 * idx + 1) + _4133 + 32] = mem[_9196] - 1
                                                        else:
                                                            _9698 = mem[_8268 + 96]
                                                            mem[mem[64] + 4] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8447'))))
                                                            mem[mem[64] + 36] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8449'))))
                                                            mem[mem[64] + 68] = _8390
                                                            require ext_code.size(address(_9698))
                                                            staticcall address(_9698).get_dy(int128 arg1, int128 arg2, uint256 arg3) with:
                                                                    gas gas_remaining wei
                                                                   args ('signextend', 15, ('type', 256, ('stor', ('var', '_8447')))), ('signextend', 15, ('type', 256, ('stor', ('var', '_8449')))), _8390
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _10073 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_10073] == mem[_10073]
                                                            require mem[_10073] > 0
                                                            if mem[_10073] < 1:
                                                                revert with 'NH{q', 17
                                                            if idx > -2:
                                                                revert with 'NH{q', 17
                                                            if idx + 1 >= mem[_4133]:
                                                                revert with 'NH{q', 50
                                                            mem[(32 * idx + 1) + _4133 + 32] = mem[_10073] - 1
                                    else:
                                        _8478 = mem[mem[(32 * idx) + 128] + 96]
                                        mem[mem[64] + 4] = uint256(stor[_8447])
                                        mem[mem[64] + 36] = uint256(stor[_8449])
                                        mem[mem[64] + 68] = _8390
                                        require ext_code.size(address(_8478))
                                        staticcall address(_8478).get_dy_underlying(uint256 arg1, uint256 arg2, uint256 arg3) with:
                                                gas gas_remaining wei
                                               args uint256(stor[_8447]), uint256(stor[_8449]), _8390
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9158 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_9158] == mem[_9158]
                                        if mem[_9158] and 9996 > -1 / mem[_9158]:
                                            revert with 'NH{q', 17
                                        if mem[_8268 + 108 len 20] != 0x7f90122bf0700f9e7e1f688fe926940e8839f353:
                                            if mem[_8268 + 108 len 20] == 0xaea2e71b631fa93683bcf256a8689dfa0e094fcd:
                                                _9886 = mem[_8268 + 96]
                                                mem[mem[64] + 4] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8447'))))
                                                mem[mem[64] + 36] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8449'))))
                                                mem[mem[64] + 68] = _8390
                                                require ext_code.size(address(_9886))
                                                staticcall address(_9886).get_dy(int128 arg1, int128 arg2, uint256 arg3) with:
                                                        gas gas_remaining wei
                                                       args ('signextend', 15, ('type', 256, ('stor', ('var', '_8447')))), ('signextend', 15, ('type', 256, ('stor', ('var', '_8449')))), _8390
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _10538 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_10538] == mem[_10538]
                                                require mem[_10538] > 0
                                                if mem[_10538] < 1:
                                                    revert with 'NH{q', 17
                                                if idx > -2:
                                                    revert with 'NH{q', 17
                                                if idx + 1 >= mem[_4133]:
                                                    revert with 'NH{q', 50
                                                mem[(32 * idx + 1) + _4133 + 32] = mem[_10538] - 1
                                            else:
                                                if mem[_8268 + 108 len 20] == 0x3a43a5851a3e3e0e25a3c1089670269786be1577:
                                                    _9936 = mem[_8268 + 96]
                                                    mem[mem[64] + 4] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8447'))))
                                                    mem[mem[64] + 36] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8449'))))
                                                    mem[mem[64] + 68] = _8390
                                                    require ext_code.size(address(_9936))
                                                    staticcall address(_9936).get_dy(int128 arg1, int128 arg2, uint256 arg3) with:
                                                            gas gas_remaining wei
                                                           args ('signextend', 15, ('type', 256, ('stor', ('var', '_8447')))), ('signextend', 15, ('type', 256, ('stor', ('var', '_8449')))), _8390
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _10590 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_10590] == mem[_10590]
                                                    require mem[_10590] > 0
                                                    if mem[_10590] < 1:
                                                        revert with 'NH{q', 17
                                                    if idx > -2:
                                                        revert with 'NH{q', 17
                                                    if idx + 1 >= mem[_4133]:
                                                        revert with 'NH{q', 50
                                                    mem[(32 * idx + 1) + _4133 + 32] = mem[_10590] - 1
                                                else:
                                                    if mem[_8268 + 108 len 20] == 0x93004d8477f117ea359b71ec02f2706c8175c55c:
                                                        _9971 = mem[_8268 + 96]
                                                        mem[mem[64] + 4] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8447'))))
                                                        mem[mem[64] + 36] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8449'))))
                                                        mem[mem[64] + 68] = _8390
                                                        require ext_code.size(address(_9971))
                                                        staticcall address(_9971).get_dy(int128 arg1, int128 arg2, uint256 arg3) with:
                                                                gas gas_remaining wei
                                                               args ('signextend', 15, ('type', 256, ('stor', ('var', '_8447')))), ('signextend', 15, ('type', 256, ('stor', ('var', '_8449')))), _8390
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _10641 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_10641] == mem[_10641]
                                                        require mem[_10641] > 0
                                                        if mem[_10641] < 1:
                                                            revert with 'NH{q', 17
                                                        if idx > -2:
                                                            revert with 'NH{q', 17
                                                        if idx + 1 >= mem[_4133]:
                                                            revert with 'NH{q', 50
                                                        mem[(32 * idx + 1) + _4133 + 32] = mem[_10641] - 1
                                                    else:
                                                        if mem[_8268 + 108 len 20] != 0xd79138c49c49200a1afc935171d1bdad084fdc95:
                                                            require 9996 * mem[_9158] / 10000 > 0
                                                            if 9996 * mem[_9158] / 10000 < 1:
                                                                revert with 'NH{q', 17
                                                            if idx > -2:
                                                                revert with 'NH{q', 17
                                                            if idx + 1 >= mem[_4133]:
                                                                revert with 'NH{q', 50
                                                            mem[(32 * idx + 1) + _4133 + 32] = (9996 * mem[_9158] / 10000) - 1
                                                        else:
                                                            _10006 = mem[_8268 + 96]
                                                            mem[mem[64] + 4] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8447'))))
                                                            mem[mem[64] + 36] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8449'))))
                                                            mem[mem[64] + 68] = _8390
                                                            require ext_code.size(address(_10006))
                                                            staticcall address(_10006).get_dy(int128 arg1, int128 arg2, uint256 arg3) with:
                                                                    gas gas_remaining wei
                                                                   args ('signextend', 15, ('type', 256, ('stor', ('var', '_8447')))), ('signextend', 15, ('type', 256, ('stor', ('var', '_8449')))), _8390
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _10685 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_10685] == mem[_10685]
                                                            require mem[_10685] > 0
                                                            if mem[_10685] < 1:
                                                                revert with 'NH{q', 17
                                                            if idx > -2:
                                                                revert with 'NH{q', 17
                                                            if idx + 1 >= mem[_4133]:
                                                                revert with 'NH{q', 50
                                                            mem[(32 * idx + 1) + _4133 + 32] = mem[_10685] - 1
                                        else:
                                            _9760 = mem[_8268 + 96]
                                            mem[mem[64] + 4] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8447'))))
                                            mem[mem[64] + 36] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8449'))))
                                            mem[mem[64] + 68] = _8390
                                            require ext_code.size(address(_9760))
                                            staticcall address(_9760).get_dy_underlying(int128 arg1, int128 arg2, uint256 arg3) with:
                                                    gas gas_remaining wei
                                                   args ('signextend', 15, ('type', 256, ('stor', ('var', '_8447')))), ('signextend', 15, ('type', 256, ('stor', ('var', '_8449')))), _8390
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _10361 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_10361] == mem[_10361]
                                            if mem[_8268 + 108 len 20] == 0xaea2e71b631fa93683bcf256a8689dfa0e094fcd:
                                                _11134 = mem[_8268 + 96]
                                                mem[mem[64] + 4] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8447'))))
                                                mem[mem[64] + 36] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8449'))))
                                                mem[mem[64] + 68] = _8390
                                                require ext_code.size(address(_11134))
                                                staticcall address(_11134).get_dy(int128 arg1, int128 arg2, uint256 arg3) with:
                                                        gas gas_remaining wei
                                                       args ('signextend', 15, ('type', 256, ('stor', ('var', '_8447')))), ('signextend', 15, ('type', 256, ('stor', ('var', '_8449')))), _8390
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _11908 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_11908] == mem[_11908]
                                                require mem[_11908] > 0
                                                if mem[_11908] < 1:
                                                    revert with 'NH{q', 17
                                                if idx > -2:
                                                    revert with 'NH{q', 17
                                                if idx + 1 >= mem[_4133]:
                                                    revert with 'NH{q', 50
                                                mem[(32 * idx + 1) + _4133 + 32] = mem[_11908] - 1
                                            else:
                                                if mem[_8268 + 108 len 20] == 0x3a43a5851a3e3e0e25a3c1089670269786be1577:
                                                    _11155 = mem[_8268 + 96]
                                                    mem[mem[64] + 4] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8447'))))
                                                    mem[mem[64] + 36] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8449'))))
                                                    mem[mem[64] + 68] = _8390
                                                    require ext_code.size(address(_11155))
                                                    staticcall address(_11155).get_dy(int128 arg1, int128 arg2, uint256 arg3) with:
                                                            gas gas_remaining wei
                                                           args ('signextend', 15, ('type', 256, ('stor', ('var', '_8447')))), ('signextend', 15, ('type', 256, ('stor', ('var', '_8449')))), _8390
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _11938 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_11938] == mem[_11938]
                                                    require mem[_11938] > 0
                                                    if mem[_11938] < 1:
                                                        revert with 'NH{q', 17
                                                    if idx > -2:
                                                        revert with 'NH{q', 17
                                                    if idx + 1 >= mem[_4133]:
                                                        revert with 'NH{q', 50
                                                    mem[(32 * idx + 1) + _4133 + 32] = mem[_11938] - 1
                                                else:
                                                    if mem[_8268 + 108 len 20] == 0x93004d8477f117ea359b71ec02f2706c8175c55c:
                                                        _11208 = mem[_8268 + 96]
                                                        mem[mem[64] + 4] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8447'))))
                                                        mem[mem[64] + 36] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8449'))))
                                                        mem[mem[64] + 68] = _8390
                                                        require ext_code.size(address(_11208))
                                                        staticcall address(_11208).get_dy(int128 arg1, int128 arg2, uint256 arg3) with:
                                                                gas gas_remaining wei
                                                               args ('signextend', 15, ('type', 256, ('stor', ('var', '_8447')))), ('signextend', 15, ('type', 256, ('stor', ('var', '_8449')))), _8390
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _11975 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_11975] == mem[_11975]
                                                        require mem[_11975] > 0
                                                        if mem[_11975] < 1:
                                                            revert with 'NH{q', 17
                                                        if idx > -2:
                                                            revert with 'NH{q', 17
                                                        if idx + 1 >= mem[_4133]:
                                                            revert with 'NH{q', 50
                                                        mem[(32 * idx + 1) + _4133 + 32] = mem[_11975] - 1
                                                    else:
                                                        if mem[_8268 + 108 len 20] != 0xd79138c49c49200a1afc935171d1bdad084fdc95:
                                                            require mem[_10361] > 0
                                                            if mem[_10361] < 1:
                                                                revert with 'NH{q', 17
                                                            if idx > -2:
                                                                revert with 'NH{q', 17
                                                            if idx + 1 >= mem[_4133]:
                                                                revert with 'NH{q', 50
                                                            mem[(32 * idx + 1) + _4133 + 32] = mem[_10361] - 1
                                                        else:
                                                            _11294 = mem[_8268 + 96]
                                                            mem[mem[64] + 4] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8447'))))
                                                            mem[mem[64] + 36] = ('signextend', 15, ('type', 256, ('stor', ('var', '_8449'))))
                                                            mem[mem[64] + 68] = _8390
                                                            require ext_code.size(address(_11294))
                                                            staticcall address(_11294).get_dy(int128 arg1, int128 arg2, uint256 arg3) with:
                                                                    gas gas_remaining wei
                                                                   args ('signextend', 15, ('type', 256, ('stor', ('var', '_8447')))), ('signextend', 15, ('type', 256, ('stor', ('var', '_8449')))), _8390
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _12029 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_12029] == mem[_12029]
                                                            require mem[_12029] > 0
                                                            if mem[_12029] < 1:
                                                                revert with 'NH{q', 17
                                                            if idx > -2:
                                                                revert with 'NH{q', 17
                                                            if idx + 1 >= mem[_4133]:
                                                                revert with 'NH{q', 50
                                                            mem[(32 * idx + 1) + _4133 + 32] = mem[_12029] - 1
        if idx == -1:
            revert with 'NH{q', 17
        _8261 = mem[96]
        idx = idx + 1
        continue 
    mem[mem[64]] = 32
    _8277 = mem[_4133]
    mem[mem[64] + 32] = mem[_4133]
    mem[mem[64] + 64 len 32 * _8277] = mem[_4133 + 32 len 32 * _8277]
    return 32, mem[mem[64] + 32 len (32 * _8277) + 32]
}



}
